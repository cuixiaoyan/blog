<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring面向切面编程</title>
    <link href="/blog/2021/10/22/Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <url>/blog/2021/10/22/Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring面向切面编程-AOP"><a href="#Spring面向切面编程-AOP" class="headerlink" title="Spring面向切面编程(AOP)"></a>Spring面向切面编程(AOP)</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><ul><li>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</li><li>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</li></ul><h3 id="Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><ul><li>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。<ul><li>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</li><li>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</li></ul></li></ul><h3 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h3><ul><li>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：<ul><li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li><li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li></ul></li><li>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</li></ul><blockquote><p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p></blockquote><h3 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h3><ul><li>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</li><li>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</li><li>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</li><li>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</li><li>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</li><li>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</li><li>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：<ul><li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ul></li></ul><h3 id="Spring在运行时通知对象"><a href="#Spring在运行时通知对象" class="headerlink" title="Spring在运行时通知对象"></a>Spring在运行时通知对象</h3><ul><li>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</li><li>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>面向切面编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/2021/10/20/%E5%89%AF%E6%9C%AC/"/>
    <url>/blog/2021/10/20/%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring的事务传播</title>
    <link href="/blog/2021/10/19/spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
    <url>/blog/2021/10/19/spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="说一下Spring的事务传播行为"><a href="#说一下Spring的事务传播行为" class="headerlink" title="说一下Spring的事务传播行为"></a>说一下Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><blockquote><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p></blockquote><h3 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h3><ul><li>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：<ol><li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li><li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li><li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ol></li><li><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li><li><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</li><li><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</li></ul><h3 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h3><ul><li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li><li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li><li>支持声明式事务管理。</li><li>和Spring各种数据访问抽象层很好得集成。</li></ul><h3 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h3><ul><li>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>事务传播</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring注解</title>
    <link href="/blog/2021/10/17/Spring%E6%B3%A8%E8%A7%A3/"/>
    <url>/blog/2021/10/17/Spring%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h3><ul><li><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p></li><li><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p></li><li><p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> StudentBean <span class="hljs-function"><span class="hljs-title">myStudent</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StudentBean();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="怎样开启注解装配？"><a href="#怎样开启注解装配？" class="headerlink" title="怎样开启注解装配？"></a>怎样开启注解装配？</h3></li><li><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>元素。</p></li></ul><h3 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><ul><li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IOC 容器中。</li><li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li><li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IOC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h3 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h3><ul><li>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-meta">@Required</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Autowired-注解有什么作用"><a href="#Autowired-注解有什么作用" class="headerlink" title="@Autowired 注解有什么作用"></a>@Autowired 注解有什么作用</h3><ul><li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h3><ul><li>@Autowired和@Resource可用于：构造函数、成员变量、Setter方法</li><li>@Autowired和@Resource之间的区别在于<ul><li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li><li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li></ul></li></ul><h3 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h3><ul><li>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</li></ul><h3 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h3><ul><li>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：<ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring数据访问</title>
    <link href="/blog/2021/10/17/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"/>
    <url>/blog/2021/10/17/Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring数据访问"><a href="#Spring数据访问" class="headerlink" title="Spring数据访问"></a>Spring数据访问</h2><h3 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h3><ul><li>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 MyBatis，JPA，TopLink，JDO，OJB等待 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</li></ul><h3 id="在Spring框架中如何更有效地使用JDBC？"><a href="#在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="在Spring框架中如何更有效地使用JDBC？"></a>在Spring框架中如何更有效地使用JDBC？</h3><ul><li>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</li></ul><h3 id="解释JDBC抽象和DAO模块"><a href="#解释JDBC抽象和DAO模块" class="headerlink" title="解释JDBC抽象和DAO模块"></a>解释JDBC抽象和DAO模块</h3><ul><li>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</li></ul><h3 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h3><ul><li>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</li></ul><h3 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h3><ul><li>JdbcTemplate</li><li>SimpleJdbcTemplate</li><li>NamedParameterJdbcTemplate</li><li>SimpleJdbcInsert</li><li>SimpleJdbcCall</li></ul><h3 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h3><ul><li>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</li></ul><h3 id="使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h3><ul><li>在Spring中有两种方式访问Hibernate：<ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul></li></ul><h3 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h3><ul><li>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<ul><li>配置the Hibernate SessionFactory</li><li>继承HibernateDaoSupport实现一个DAO</li><li>在AOP支持的事务中装配</li></ul></li></ul><h3 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h3><ul><li>Spring支持两种类型的事务管理：<ul><li><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</li><li><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</li></ul></li></ul><h3 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h3><ul><li>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>数据访问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是bean的自动装配</title>
    <link href="/blog/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <url>/blog/2021/10/14/%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h3><ul><li>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</li></ul><h3 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h3><ul><li>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</li><li>在Spring框架xml配置中共有5种自动装配：<ul><li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li><li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li><li>byType：通过参数的数据类型进行自动装配。</li><li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li><li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li></ul></li></ul><h3 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><ul><li>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</li><li>在启动spring IOC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IOC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：<ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li></ul></li></ul><h3 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h3><ul><li>自动装配的局限性是：<ul><li><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</li><li><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</li><li><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ul></li></ul><h3 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在Spring中注入一个null 和一个空字符串吗？</h3><ul><li>可以。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>什么是bean</tag>
      
      <tag>自动装配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring如何处理线程并发问题</title>
    <link href="/blog/2021/10/13/Spring%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2021/10/13/Spring%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h3><ul><li>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</li><li>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</li><li>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</li></ul><h3 id="解释Spring框架中bean的生命周期"><a href="#解释Spring框架中bean的生命周期" class="headerlink" title="解释Spring框架中bean的生命周期"></a>解释Spring框架中bean的生命周期</h3><ul><li>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717443ebe68c24f~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</li><li>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</li></ul><p><strong>我们对上图进行详细描述：</strong></p><ul><li>Spring对bean进行实例化；</li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</li><li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li><li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</li><li>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">现在你已经了解了如何创建和加载一个<span class="hljs-variable">Spring</span>容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从<span class="hljs-variable">Spring</span>的<span class="hljs-function"><span class="hljs-title">DI</span>(依赖注入)中受益，我们必须将应用对象装配进<span class="hljs-variable">Spring</span>容器中。</span><br></code></pre></td></tr></table></figure><h3 id="哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？</h3><ul><li>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</li><li>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</li></ul><h3 id="什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="什么是Spring的内部bean？什么是Spring inner beans？"></a>什么是Spring的内部bean？什么是Spring inner beans？</h3><ul><li>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</li></ul><h3 id="在-Spring中如何注入一个java集合？"><a href="#在-Spring中如何注入一个java集合？" class="headerlink" title="在 Spring中如何注入一个java集合？"></a>在 Spring中如何注入一个java集合？</h3><ul><li>Spring提供了以下四种集合类的配置元素(配置标签)：</li></ul><table><thead><tr><th></th><th>该标签用来装配可重复的list值。</th></tr></thead><tbody><tr><td></td><td>该标签用来装配没有重复的set值。</td></tr><tr><td></td><td>该标签可用来注入键和值可以为任何类型的键值对。</td></tr><tr><td></td><td>该标签支持注入键和值都是字符串类型的键值对。</td></tr></tbody></table><h3 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是bean装配？</h3><ul><li>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring如何</tag>
      
      <tag>线程并发问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBeans</title>
    <link href="/blog/2021/10/10/SpringBeans/"/>
    <url>/blog/2021/10/10/SpringBeans/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-Beans"><a href="#Spring-Beans" class="headerlink" title="Spring Beans"></a>Spring Beans</h2><h3 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是Spring beans？</h3><ul><li>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</li></ul><h3 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h3><ul><li>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</li></ul><h3 id="如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><ul><li>这里有三种重要的方法给Spring 容器提供配置元数据。<ul><li>XML配置文件。</li><li>基于注解的配置。</li><li>基于java的配置。</li></ul></li></ul><h3 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h3><ul><li>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</li></ul><h3 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h3><ol><li>Set方法注入；</li><li>构造器注入：<ol><li>通过index设置参数的位置；</li><li>通过type设置参数类型；</li></ol></li><li>静态工厂注入；</li><li>实例工厂；</li></ol><h3 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h3><ul><li>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</li></ul><h3 id="解释Spring支持的几种bean的作用域"><a href="#解释Spring支持的几种bean的作用域" class="headerlink" title="解释Spring支持的几种bean的作用域"></a>解释Spring支持的几种bean的作用域</h3><p><strong>Spring框架支持以下五种bean的作用域：</strong></p><ul><li><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</li><li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li><li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p><strong>注意：</strong> 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h3 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h3><ul><li>不是，Spring框架中的单例bean不是线程安全的。</li><li>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</li><li>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。<ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Beans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring如何设计容器</title>
    <link href="/blog/2021/10/09/Spring%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%B9%E5%99%A8/"/>
    <url>/blog/2021/10/09/Spring%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解"><a href="#Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="headerlink" title="Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解"></a>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</h3><ul><li>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。<ul><li>BeanFactory</li><li>ApplicationContext</li></ul></li><li>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 <strong>“低级容器”</strong>。</li><li>ApplicationContext 可以称之为 <strong>“高级容器”</strong>。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</li><li>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</li><li>BeanFactory和ApplicationContext的关系</li><li>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717443eb634549a~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>有点复杂？ 先不要慌，我来解释一下。</li><li>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</li><li>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</li><li>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</li><li>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</li></ul><p><strong>小结</strong></p><ul><li>说了这么多，不知道你有没有理解Spring IOC？ 这里小结一下：IOC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</li></ul><ol><li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li><li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li></ol><ul><li>上面就是 Spring 低级容器（BeanFactory）的 IOC。</li><li>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IOC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</li></ul><h3 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h3><ul><li><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li><li><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li></ul><h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><ul><li>控制反转IOC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找依赖注入：相对于IOC而言，依赖注入(DI)更加准确地描述了IOC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</li></ul><h3 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h3><ul><li>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IOC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IOC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</li></ul><h3 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h3><ul><li>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：<ul><li>查找定位操作与应用代码完全无关。</li><li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li><li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li></ul></li></ul><h3 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h3><ul><li>依赖注入是时下最流行的IOC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</li><li><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li></ul><h3 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h3><blockquote><table><thead><tr><th><strong>构造函数注入</strong></th><th><strong>setter</strong> <strong>注入</strong></th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属性</td><td>会覆盖 setter 属性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table></blockquote><ul><li>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring控制反转</title>
    <link href="/blog/2021/10/08/Spring%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    <url>/blog/2021/10/08/Spring%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring控制反转-IOC"><a href="#Spring控制反转-IOC" class="headerlink" title="Spring控制反转(IOC)"></a>Spring控制反转(IOC)</h2><h3 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h3><ul><li>控制反转即IOC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</li><li>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</li></ul><h3 id="控制反转-IOC-有什么作用"><a href="#控制反转-IOC-有什么作用" class="headerlink" title="控制反转(IOC)有什么作用"></a>控制反转(IOC)有什么作用</h3><ul><li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li><li>解耦，由容器去维护具体的对象</li><li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li></ul><h3 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h3><ul><li>IOC 或 依赖注入把应用的代码量降到最低。</li><li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li><li>最小的代价和最小的侵入性使松散耦合得以实现。</li><li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li></ul><h3 id="Spring-IOC-的实现机制"><a href="#Spring-IOC-的实现机制" class="headerlink" title="Spring IOC 的实现机制"></a>Spring IOC 的实现机制</h3><ul><li>Spring 中的 IOC 的实现原理就是工厂模式加反射机制。</li><li>示例：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Fruit &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">void</span> eat();<br> &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-title">implements</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span> <span class="hljs-title">implements</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Orange&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> ClassName</span>)</span> &#123;<br>        Fruit f=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f=(Fruit)Class.forName(ClassName).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] a</span>)</span> &#123;<br>        Fruit f=Factory.getInstance(<span class="hljs-string">&quot;io.github.dunwu.spring.Apple&quot;</span>);<br>        <span class="hljs-keyword">if</span>(f!=<span class="hljs-literal">null</span>)&#123;<br>            f.eat();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Spring-的-IOC支持哪些功能"><a href="#Spring-的-IOC支持哪些功能" class="headerlink" title="Spring 的 IOC支持哪些功能"></a>Spring 的 IOC支持哪些功能</h3><ul><li>Spring 的 IOC 设计支持以下功能：</li><li>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</li><li>对于 IOC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</li></ul><h3 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h3><ul><li>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</li><li>依赖关系<ul><li>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</li></ul></li><li>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul></li><li>加载方式<ul><li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</li><li>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">相对于基本的<span class="hljs-keyword">BeanFactory，ApplicationContext </span>唯一的不足是占用内存空间。当应用程序配置<span class="hljs-keyword">Bean较多时，程序启动较慢。</span><br></code></pre></td></tr></table></figure><ul><li>创建方式<ul><li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li></ul></li><li>注册方式<ul><li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>控制反转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>核心容器模块</title>
    <link href="/blog/2021/10/07/%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E6%A8%A1%E5%9D%97/"/>
    <url>/blog/2021/10/07/%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="详细讲解一下核心容器（spring context应用上下文) 模块"></a>详细讲解一下核心容器（spring context应用上下文) 模块</h3><ul><li>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</li><li>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</li></ul><h3 id="Spring框架中有哪些不同类型的事件"><a href="#Spring框架中有哪些不同类型的事件" class="headerlink" title="Spring框架中有哪些不同类型的事件"></a>Spring框架中有哪些不同类型的事件</h3><ul><li>Spring 提供了以下5种标准的事件：<ol><li>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li></ol></li></ul><h3 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h3><p><strong>Spring 应用一般有以下组件：</strong></p><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>用户程序 - 它使用接口。</li></ul><h3 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h3><p><strong>使用 Spring 有以下方式：</strong></p><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li><li>用于远程使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>核心容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring概述</title>
    <link href="/blog/2021/10/06/Spring%E6%A6%82%E8%BF%B0/"/>
    <url>/blog/2021/10/06/Spring%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><h3 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring?"></a>什么是spring?</h3><ul><li>Spring是<strong>一个轻量级Java开发框架</strong>，最早有<strong>Rod Johnson</strong>创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</li><li>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发</strong>。</li><li>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI）\</strong>和**面向切面编程（aspect-oriented programming，AOP）**。</li></ul><p><strong>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</strong></p><ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><h3 id="Spring的俩大核心概念"><a href="#Spring的俩大核心概念" class="headerlink" title="Spring的俩大核心概念"></a>Spring的俩大核心概念</h3><ul><li>IOC（控制翻转）：<ul><li>控制翻转，也叫依赖注入，他就是不会直接创建对象，只是把对象声明出来，在代码 中不直接与对象和服务进行连接，但是在配置文件中描述了哪一项组件需要哪一项服 务，容器将他们组件起来。在一般的IOC场景中容器创建了所有的对象，并设置了必 要的属性将他们联系在一起，等到需要使用的时候才把他们声明出来，使用注解就跟 方便了，容器会自动根据注解把对象组合起来</li></ul></li><li>AOP（面对切面编程）<ul><li>面对切面编程，这是一种编程模式，他允许程序员通过自定义的横切点进行模块 化，将那些影响多个类的行为封装到课重用的模块中。 例子：比如日志输出，不使用AOP的话就需要把日志的输出语句放在所有类中，方法 中，但是有了AOP就可以把日志输出语句封装一个可重用模块，在以声明的方式将他 们放在类中，每次使用类就自动完成了日志输出。</li></ul></li></ul><h3 id="Spring框架的设计目标，设计理念，和核心是什么"><a href="#Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="Spring框架的设计目标，设计理念，和核心是什么"></a>Spring框架的设计目标，设计理念，和核心是什么</h3><ul><li><strong>Spring设计目标</strong>：Spring为开发者提供一个一站式轻量级应用开发平台；</li><li><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OOP（面向对象）设计方法；Spring通过IOC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IOC容器，实现解耦；</li><li><strong>Spring框架的核心</strong>：IOC容器和AOP模块。通过IOC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</li><li>IOC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</li></ul><h3 id="Spring的优缺点是什么？"><a href="#Spring的优缺点是什么？" class="headerlink" title="Spring的优缺点是什么？"></a>Spring的优缺点是什么？</h3><p><strong>优点</strong></p><ul><li><p>方便解耦，简化开发</p><p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p></li><li><p>AOP编程的支持</p><p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p></li><li><p>声明式事务的支持</p><p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p></li><li><p>方便程序的测试</p><p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p></li><li><p>方便集成各种优秀框架</p><p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p></li><li><p>降低JavaEE API的使用难度</p><p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p></li></ul><p><strong>缺点</strong></p><ul><li>Spring明明一个很轻量级的框架，却给人感觉大而全</li><li>Spring依赖反射，反射影响性能</li><li>使用门槛升高，入门Spring需要较长时间</li></ul><h3 id="Spring有哪些应用场景"><a href="#Spring有哪些应用场景" class="headerlink" title="Spring有哪些应用场景"></a>Spring有哪些应用场景</h3><ul><li><strong>应用场景</strong>：JavaEE企业应用开发，包括SSH、SSM等</li></ul><p><strong>Spring价值</strong>：</p><ul><li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li><li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li><li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li></ul><h3 id="Spring由哪些模块组成？"><a href="#Spring由哪些模块组成？" class="headerlink" title="Spring由哪些模块组成？"></a>Spring由哪些模块组成？</h3><ul><li><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在<code>核心容器（Core Container）</code> 、 <code>AOP（Aspect Oriented Programming）和设备支持（Instrmentation）</code> 、<code>数据访问与集成（Data Access/Integeration）</code> 、 <code>Web</code>、 <code>消息（Messaging）</code> 、 <code>Test</code>等 6 个模块中。 以下是 Spring 5 的模块结构图： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717443eb25a3d9b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</p></li><li><p>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</p></li><li><p>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</p></li><li><p>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</p></li><li><p>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</p></li><li><p>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</p></li><li><p>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</p></li></ul><h3 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h3><ol><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li><li>单例模式：Bean默认为单例模式。</li><li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>概述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="/blog/2021/10/05/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/blog/2021/10/05/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="简述java类加载机制"><a href="#简述java类加载机制" class="headerlink" title="简述java类加载机制?"></a>简述java类加载机制?</h3><ul><li>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</li></ul><h3 id="类加载的机制及过程"><a href="#类加载的机制及过程" class="headerlink" title="类加载的机制及过程"></a>类加载的机制及过程</h3><ul><li>程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fd24770998~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h5 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h5><ul><li>加载指的是将类的class文件读入到内存，并将这些静态数据转换成方法区中的运行时数据结构，并在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口，这个过程需要类加载器参与。</li><li>Java类加载器由JVM提供，是所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</li><li>类加载器，可以从不同来源加载类的二进制数据，比如：本地Class文件、Jar包Class文件、网络Class文件等等等。</li><li>类加载的最终产物就是位于堆中的Class对象（注意不是目标类对象），该对象封装了类在方法区中的数据结构，并且向用户提供了访问方法区数据结构的接口，即Java反射的接口</li></ul><h5 id="2、连接过程"><a href="#2、连接过程" class="headerlink" title="2、连接过程"></a>2、连接过程</h5><ul><li>当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中（意思就是将java类的二进制代码合并到JVM的运行状态之中）。类连接又可分为如下3个阶段。</li></ul><ol><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题。主要验证是否符合Class文件格式规范，并且是否能被当前的虚拟机加载处理。</li><li>准备：正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配</li><li>解析：虚拟机常量池的符号引用替换为字节引用过程</li></ol><h5 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h5><ul><li>初始化阶段是执行类构造器<code>&lt;clinit&gt;</code>() 方法的过程。类构造器<code>&lt;clinit&gt;</code>()方法是由编译器自动收藏类中的<code>所有类变量的赋值动作和静态语句块(static块)中的语句合并产生，代码从上往下执行。</code></li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;</code>() 方法在多线程环境中被正确加锁和同步</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">初始化的总结就是：初始化是为类的静态变量赋予正确的初始值<br></code></pre></td></tr></table></figure><h3 id="描述一下JVM加载Class文件的原理机制"><a href="#描述一下JVM加载Class文件的原理机制" class="headerlink" title="描述一下JVM加载Class文件的原理机制"></a>描述一下JVM加载Class文件的原理机制</h3><ul><li>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</li><li>类装载方式，有两种 ：<ul><li>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</li><li>2.显式装载， 通过class.forname()等方法，显式加载需要的类</li></ul></li><li>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</li></ul><h3 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fd30195e5b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</li><li>主要有一下四种类加载器:<ol><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ol></li></ul><h3 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h3><ul><li>类装载分为以下 5 个步骤：<ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul></li></ul><h3 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h3><ul><li>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fd30195e5b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>类加载器分类：<ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul></li><li>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</li><li>总结就是：<code>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</code></li></ul><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="JVM-调优的参数可以在那设置参数值"><a href="#JVM-调优的参数可以在那设置参数值" class="headerlink" title="JVM 调优的参数可以在那设置参数值"></a>JVM 调优的参数可以在那设置参数值</h3><ul><li><p>可以在IDEA，Eclipse，工具里设置</p></li><li><p>如果上线了是WAR包的话可以在Tomcat设置</p></li><li><p>如果是Jar包直接 ：java -jar 是直接插入JVM命令就好了</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-Xms1024m -Xmx1024m ...等等等 <span class="hljs-keyword">JVM参数 </span>-<span class="hljs-keyword">jar </span>springboot_app.<span class="hljs-keyword">jar </span>&amp; <br><br></code></pre></td></tr></table></figure><h3 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h3></li><li><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控； <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fd4667d98b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fd4d2a3018~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#常用的设置</span><br>-Xms：初始堆大小，JVM 启动的时候，给定堆空间大小。 <br><br>-Xmx：最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。 <br><br>-Xmn：设置堆中年轻代大小。整个堆大小=年轻代大小+年老代大小+持久代大小。 <br><br>-XX:<span class="hljs-attribute">NewSize</span>=n 设置年轻代初始化大小大小 <br><br>-XX:<span class="hljs-attribute">MaxNewSize</span>=n 设置年轻代最大值<br><br>-XX:<span class="hljs-attribute">NewRatio</span>=n 设置年轻代和年老代的比值。如: -XX:<span class="hljs-attribute">NewRatio</span>=3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代+年老代和的 1/4 <br><br>-XX:<span class="hljs-attribute">SurvivorRatio</span>=n 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。8表示两个Survivor :<span class="hljs-attribute">eden</span>=2:8 ,即一个Survivor占年轻代的1/10，默认就为8<br><br>-Xss：设置每个线程的堆栈大小。JDK5后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。<br><br>-XX:<span class="hljs-attribute">ThreadStackSize</span>=n 线程堆栈大小<br><br>-XX:<span class="hljs-attribute">PermSize</span>=n 设置持久代初始值<br><br>-XX:<span class="hljs-attribute">MaxPermSize</span>=n 设置持久代大小<br> <br>-XX:<span class="hljs-attribute">MaxTenuringThreshold</span>=n 设置年轻带垃圾对象最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。<br><br><span class="hljs-comment">#下面是一些不常用的</span><br><br>-XX:<span class="hljs-attribute">LargePageSizeInBytes</span>=n 设置堆内存的内存页大小<br><br>-XX:+UseFastAccessorMethods 优化原始类型的getter方法性能<br><br>-XX:+DisableExplicitGC 禁止在运行期显式地调用System.gc()，默认启用<br><br>-XX:+AggressiveOpts 是否启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等，jdk6纸之后默认启动<br><br>-XX:+UseBiasedLocking 是否启用偏向锁，JDK6默认启用<br><br>-Xnoclassgc 是否禁用垃圾回收<br><br>-XX:+UseThreadPriorities 使用本地线程的优先级，默认启用<br><br>等等等<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br><br></code></pre></td></tr></table></figure><h3 id="JVM的GC收集器设置"><a href="#JVM的GC收集器设置" class="headerlink" title="JVM的GC收集器设置"></a>JVM的GC收集器设置</h3><ul><li>-xx:+Use  xxx   GC<ul><li>xxx   代表垃圾收集器名称</li></ul></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">-<span class="hljs-attr">XX:</span>+<span class="hljs-attr">UseSerialGC:</span>设置串行收集器，年轻带收集器 <br><br>-<span class="hljs-attr">XX:</span>+<span class="hljs-attr">UseParNewGC:</span>设置年轻代为并行收集。可与 CMS 收集同时使用。JDK5<span class="hljs-number">.0</span> 以上，JVM 会根据系统配置自行设置，所以无需再设置此值。<br><br>-<span class="hljs-attr">XX:</span>+<span class="hljs-attr">UseParallelGC:</span>设置并行收集器，目标是目标是达到可控制的吞吐量<br><br>-<span class="hljs-attr">XX:</span>+<span class="hljs-attr">UseParallelOldGC:</span>设置并行年老代收集器，JDK6<span class="hljs-number">.0</span> 支持对年老代并行收集。 <br><br>-<span class="hljs-attr">XX:</span>+<span class="hljs-attr">UseConcMarkSweepGC:</span>设置年老代并发收集器<br><br>-<span class="hljs-attr">XX:</span>+<span class="hljs-attr">UseG1GC:</span>设置 G1 收集器，JDK1<span class="hljs-number">.9</span>默认垃圾收集器<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机类</tag>
      
      <tag>加载机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>收集器分配</title>
    <link href="/blog/2021/10/04/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E9%85%8D/"/>
    <url>/blog/2021/10/04/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="收集器可以这么分配？（了解就好了）"><a href="#收集器可以这么分配？（了解就好了）" class="headerlink" title="收集器可以这么分配？（了解就好了）"></a>收集器可以这么分配？（了解就好了）</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Serial</span> / <span class="hljs-type">Serial</span> <span class="hljs-built_in">Old</span><br><span class="hljs-type">Serial</span> / CMS<br>ParNew / <span class="hljs-type">Serial</span> <span class="hljs-built_in">Old</span><br>ParNew / CMS<br>Parallel Scavenge / <span class="hljs-type">Serial</span> <span class="hljs-built_in">Old</span><br>Parallel Scavenge / Parallel <span class="hljs-built_in">Old</span><br>G1<br></code></pre></td></tr></table></figure><h3 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h3><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h3 id="简述分代垃圾回收器是怎么工作的？"><a href="#简述分代垃圾回收器是怎么工作的？" class="headerlink" title="简述分代垃圾回收器是怎么工作的？"></a>简述分代垃圾回收器是怎么工作的？</h3><ul><li>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</li><li>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：<ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul></li><li>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</li><li>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="简述java内存分配与回收策率以及Minor GC和Major GC"></a>简述java内存分配与回收策率以及Minor GC和Major GC</h3><ul><li>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</li><li>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</li></ul><h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><ul><li>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。<ul><li>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。</li><li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li><li><strong>Major GC/Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li></ul></li></ul><h4 id="为什么大对象直接进入老年代"><a href="#为什么大对象直接进入老年代" class="headerlink" title="为什么大对象直接进入老年代"></a>为什么大对象直接进入老年代</h4><ul><li>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</li><li>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</li></ul><h4 id="长期存活对象将进入老年代"><a href="#长期存活对象将进入老年代" class="headerlink" title="长期存活对象将进入老年代"></a>长期存活对象将进入老年代</h4><ul><li>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>收集器</tag>
      
      <tag>垃圾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾收集器</title>
    <link href="/blog/2021/10/03/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/blog/2021/10/03/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="垃圾收集器以及新生代、老年代、永久代"><a href="#垃圾收集器以及新生代、老年代、永久代" class="headerlink" title="垃圾收集器以及新生代、老年代、永久代"></a>垃圾收集器以及新生代、老年代、永久代</h2><h3 id="讲一下新生代、老年代、永久代的区别"><a href="#讲一下新生代、老年代、永久代的区别" class="headerlink" title="讲一下新生代、老年代、永久代的区别"></a>讲一下新生代、老年代、永久代的区别</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fd069db773~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。而新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</li><li>新生代中一般保存新出现的对象，所以每次垃圾收集时都发现大批对象死去，只有少量对象存活，便采用了<code>复制算法</code>，只需要付出少量存活对象的复制成本就可以完成收集。</li><li>老年代中一般保存存活了很久的对象，他们存活率高、没有额外空间对它进行分配担保，就必须采用<code>“标记-清理”或者“标记-整理”</code>算法。</li><li>永久代就是JVM的方法区。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收。</li></ul><h3 id="Minor-GC、Major-GC、Full-GC是什么"><a href="#Minor-GC、Major-GC、Full-GC是什么" class="headerlink" title="Minor GC、Major GC、Full GC是什么"></a>Minor GC、Major GC、Full GC是什么</h3><ol><li>Minor GC是新生代GC，指的是发生在新生代的垃圾收集动作。由于java对象大都是朝生夕死的，所以Minor GC非常频繁，一般回收速度也比较快。（一般采用复制算法回收垃圾）</li><li>Major GC是老年代GC，指的是发生在老年代的GC，通常执行Major GC会连着Minor GC一起执行。Major GC的速度要比Minor GC慢的多。（可采用标记清楚法和标记整理法）</li><li>Full GC是清理整个堆空间，包括年轻代和老年代</li></ol><h3 id="Minor-GC、Major-GC、Full-GC区别及触发条件"><a href="#Minor-GC、Major-GC、Full-GC区别及触发条件" class="headerlink" title="Minor GC、Major GC、Full GC区别及触发条件"></a>Minor GC、Major GC、Full GC区别及触发条件</h3><ul><li><strong>Minor GC 触发条件一般为：</strong><ol><li>eden区满时，触发MinorGC。即申请一个对象时，发现eden区不够用，则触发一次MinorGC。</li><li>新创建的对象大小 &gt; Eden所剩空间时触发Minor GC</li></ol></li><li><strong>Major GC和Full  GC 触发条件一般为：</strong> <code>Major GC通常是跟full GC是等价的</code><ol><li>每次晋升到老年代的对象平均大小&gt;老年代剩余空间</li><li>MinorGC后存活的对象超过了老年代剩余空间</li><li>永久代空间不足</li><li>执行System.gc()</li><li>CMS GC异常</li><li>堆内存分配很大的对象</li></ol></li></ul><h3 id="为什么新生代要分Eden和两个-Survivor-区域？"><a href="#为什么新生代要分Eden和两个-Survivor-区域？" class="headerlink" title="为什么新生代要分Eden和两个 Survivor 区域？"></a>为什么新生代要分Eden和两个 Survivor 区域？</h3><ul><li>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。</li><li>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历15次Minor GC还能在新生代中存活的对象，才会被送到老年代。</li><li>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</li></ul><h3 id="Java堆老年代-Old-和新生代-Young-的默认比例？"><a href="#Java堆老年代-Old-和新生代-Young-的默认比例？" class="headerlink" title="Java堆老年代( Old ) 和新生代 ( Young ) 的默认比例？"></a>Java堆老年代( Old ) 和新生代 ( Young ) 的默认比例？</h3><ul><li>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。</li><li>其中，新生代 ( Young ) 被细分为 Eden 和 <strong>两个 Survivor 区域</strong>，Edem 和俩个Survivor 区域比例是 = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，</li><li>但是JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。</li></ul><h3 id="为什么要这样分代："><a href="#为什么要这样分代：" class="headerlink" title="为什么要这样分代："></a>为什么要这样分代：</h3><ul><li>其实主要原因就是可以根据各个年代的特点进行对象分区存储，更便于回收，采用最适当的收集算法：<ul><li>新生代中，每次垃圾收集时都发现大批对象死去，只有少量对象存活，便采用了复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</li><li>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清理”或者“标记-整理”算法。</li></ul></li><li>新生代又分为Eden和Survivor （From与To，这里简称一个区）两个区。加上老年代就这三个区。数据会首先分配到Eden区当中（当然也有特殊情况，如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。当Eden没有足够空间的时候就会触发jvm发起一次Minor GC，。如果对象经过一次Minor-GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空间当中。并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代中了，当然晋升老年代的年龄是可以设置的。</li></ul><h3 id="什么是垃圾回收器他和垃圾算法有什么区别"><a href="#什么是垃圾回收器他和垃圾算法有什么区别" class="headerlink" title="什么是垃圾回收器他和垃圾算法有什么区别"></a>什么是垃圾回收器他和垃圾算法有什么区别</h3><ul><li>垃圾收集器是垃圾回收算法（标记清楚法、标记整理法、复制算法、分代算法）的具体实现，不同垃圾收集器、不同版本的JVM所提供的垃圾收集器可能会有很在差别。</li></ul><h3 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h3><ul><li>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fd022875b5~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><blockquote><table><thead><tr><th>垃圾回收器</th><th>工作区域</th><th>回收算法</th><th>工作线程</th><th>用户线程并行</th><th>描述</th></tr></thead><tbody><tr><td>Serial</td><td>新生带</td><td>复制算法</td><td>单线程</td><td>否</td><td>Client模式下默认新生代收集器。简单高效</td></tr><tr><td>ParNew</td><td>新生带</td><td>复制算法</td><td>多线程</td><td>否</td><td>Serial的多线程版本，Server模式下首选， 可搭配CMS的新生代收集器</td></tr><tr><td>Parallel Scavenge</td><td>新生带</td><td>复制算法</td><td>多线程</td><td>否</td><td>目标是达到可控制的吞吐量</td></tr><tr><td>Serial Old</td><td>老年带</td><td>标记-整理</td><td>单线程</td><td>否</td><td>Serial老年代版本，给Client模式下的虚拟机使用</td></tr><tr><td>Parallel Old</td><td>老年带</td><td>标记-整理</td><td>多线程</td><td>否</td><td>Parallel Scavenge老年代版本，吞吐量优先</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>G1</td><td>新生带 + 老年带</td><td>标记-整理 + 复制算法</td><td>多线程</td><td>是</td><td>JDK1.9默认垃圾收集器</td></tr></tbody></table></blockquote><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 ( <code>标记整理 + 复制算法来回收垃圾</code> )： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>收集器</tag>
      
      <tag>垃圾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象什么时候可以被垃圾器回收</title>
    <link href="/blog/2021/10/02/%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6/"/>
    <url>/blog/2021/10/02/%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="对象什么时候可以被垃圾器回收"><a href="#对象什么时候可以被垃圾器回收" class="headerlink" title="对象什么时候可以被垃圾器回收"></a>对象什么时候可以被垃圾器回收</h3><ul><li>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</li><li>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</li></ul><h3 id="JVM-垃圾回收算法有哪些？"><a href="#JVM-垃圾回收算法有哪些？" class="headerlink" title="JVM 垃圾回收算法有哪些？"></a>JVM 垃圾回收算法有哪些？</h3><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>标记无用对象，然后进行清除回收。</li><li>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：<ul><li>标记阶段：标记出可以回收的对象。</li><li>清除阶段：回收被标记的对象所占用的空间。</li></ul></li><li>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</li><li><strong>优点</strong>：实现简单，不需要对象进行移动。</li><li><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</li><li>标记-清除算法的执行的过程如下图所示</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fce4d05e44~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ul><li>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</li><li><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</li><li><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</li><li>复制算法的执行过程如下图所示</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fcd22194ad~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><ul><li>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</li><li><strong>优点</strong>：解决了标记-清理算法存在的内存碎片问题。</li><li><strong>缺点</strong>：仍需要进行局部对象移动，一定程度上降低了效率。</li><li>标记-整理算法的执行过程如下图所示</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fce7bb60b1~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ul><li>当前商业虚拟机都采用 <code>分代收集</code>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<code>存活周期</code>将内存划分为几块。一般包括<code>年轻代</code>、<code>老年代</code>和 <code>永久代</code>，如图所示：<code>（后面有重点讲解）</code></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fcf6f94e92~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h3 id="JVM中的永久代中会发生垃圾回收吗"><a href="#JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="JVM中的永久代中会发生垃圾回收吗"></a>JVM中的永久代中会发生垃圾回收吗</h3><ul><li>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br> (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象</tag>
      
      <tag>垃圾器回收</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制及算法</title>
    <link href="/blog/2021/10/01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <url>/blog/2021/10/01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收机制及算法"><a href="#垃圾回收机制及算法" class="headerlink" title="垃圾回收机制及算法"></a>垃圾回收机制及算法</h2><h3 id="简述Java垃圾回收机制"><a href="#简述Java垃圾回收机制" class="headerlink" title="简述Java垃圾回收机制"></a>简述Java垃圾回收机制</h3><ul><li>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</li></ul><h3 id="GC是什么？为什么要GC"><a href="#GC是什么？为什么要GC" class="headerlink" title="GC是什么？为什么要GC"></a>GC是什么？为什么要GC</h3><ul><li>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</li></ul><h3 id="垃圾回收的优点和缺点"><a href="#垃圾回收的优点和缺点" class="headerlink" title="垃圾回收的优点和缺点"></a>垃圾回收的优点和缺点</h3><ul><li>优点：JVM的垃圾回收器都不需要我们手动处理无引用的对象了，这个就是最大的优点</li><li>缺点：程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</li></ul><h3 id="垃圾回收器的原理是什么？有什么办法手动进行垃圾回收？"><a href="#垃圾回收器的原理是什么？有什么办法手动进行垃圾回收？" class="headerlink" title="垃圾回收器的原理是什么？有什么办法手动进行垃圾回收？"></a>垃圾回收器的原理是什么？有什么办法手动进行垃圾回收？</h3><ul><li>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</li><li>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</li><li>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</li></ul><h3 id="JVM-中都有哪些引用类型？"><a href="#JVM-中都有哪些引用类型？" class="headerlink" title="JVM 中都有哪些引用类型？"></a>JVM 中都有哪些引用类型？</h3><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ul><h3 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h3><ul><li>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是存活的，是不可以被回收的；哪些对象已经死掉了，需要被回收。</li><li>一般有两种方法来判断：<ul><li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；（这个已经淘汰了）</li><li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。（市场上用的非常非常广泛）</li></ul></li></ul><h3 id="Full-GC是什么"><a href="#Full-GC是什么" class="headerlink" title="Full GC是什么"></a>Full GC是什么</h3><ul><li>清理整个堆空间—包括年轻代和老年代和永久代</li><li>因为Full GC是清理整个堆空间所以Full GC执行速度非常慢，在Java开发中最好保证少触发Full GC</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾回收</tag>
      
      <tag>机制及算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存模型</title>
    <link href="/blog/2021/10/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/blog/2021/10/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="我们开发人员编写的Java代码是怎么让电脑认识的"><a href="#我们开发人员编写的Java代码是怎么让电脑认识的" class="headerlink" title="我们开发人员编写的Java代码是怎么让电脑认识的"></a>我们开发人员编写的Java代码是怎么让电脑认识的</h3><ul><li>首先先了解电脑是二进制的系统，他只认识 01010101</li><li>比如我们经常要编写 HelloWord.java 电脑是怎么认识运行的</li><li>HelloWord.java是我们程序员编写的，我们人可以认识，但是电脑不认识</li></ul><p><strong>Java文件编译的过程</strong></p><ol><li>程序员编写的.java文件</li><li>由javac编译成字节码文件.class：（为什么编译成class文件，因为JVM只认识.class文件）</li><li>在由JVM编译成电脑认识的文件 （对于电脑系统来说  文件代表一切）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">（这是一个大概的观念 抽象画的概念）<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fc7554d11b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h3 id="为什么说java是跨平台语言"><a href="#为什么说java是跨平台语言" class="headerlink" title="为什么说java是跨平台语言"></a>为什么说java是跨平台语言</h3><ul><li>这个夸平台是中间语言（JVM）实现的夸平台</li><li>Java有JVM从软件层面屏蔽了底层硬件、指令层面的细节让他兼容各种系统</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">难道 <span class="hljs-built_in">C</span> 和 <span class="hljs-built_in">C</span><span class="hljs-operator">++</span> 不能夸平台吗 其实也可以<span class="hljs-operator">`</span> <span class="hljs-operator">`</span><span class="hljs-built_in">C</span>和<span class="hljs-built_in">C</span><span class="hljs-operator">++</span>需要在编译器层面去兼容不同操作系统的不同层面，写过<span class="hljs-built_in">C</span>和<span class="hljs-built_in">C</span><span class="hljs-operator">++</span>的就知道不同操作系统的有些代码是不一样<br></code></pre></td></tr></table></figure><h3 id="Jdk和Jre和JVM的区别"><a href="#Jdk和Jre和JVM的区别" class="headerlink" title="Jdk和Jre和JVM的区别"></a>Jdk和Jre和JVM的区别</h3><ul><li><p>Jdk包括了Jre和Jvm，Jre包括了Jvm</p></li><li><p>Jdk是我们编写代码使用的开发工具包</p></li><li><p>Jre 是Java的运行时环境，他大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库</p></li><li><p>Jvm俗称Java虚拟机，他是java运行环境的一部分，它虚构出来的一台计算机，在通过在实际的计算机上仿真模拟各种计算机功能来实现Java应用程序</p></li><li><p>看Java官方的图片，Jdk中包括了Jre，Jre中包括了JVM</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fc8693d47b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><h3 id="说一下-JVM由那些部分组成，运行流程是什么？"><a href="#说一下-JVM由那些部分组成，运行流程是什么？" class="headerlink" title="说一下 JVM由那些部分组成，运行流程是什么？"></a>说一下 JVM由那些部分组成，运行流程是什么？</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fc868d44b7~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>JVM包含两个子系统和两个组件: 两个子系统为Class loader(类装载)、Execution engine(执行引擎)； 两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。<ul><li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li><li>Execution engine（执行引擎）：执行classes中的指令。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li></ul></li><li><strong>流程</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</li></ul><h3 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h3><ul><li>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">简单的说就是我们java运行时的东西是放在那里的<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fc8784541e~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p><p><code>为什么要线程计数器？因为线程是不具备记忆功能</code></p></li><li><p>Java 虚拟机栈（Java Virtual Machine Stacks）：每个方法在执行的同时都会在Java 虚拟机栈中创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p><p><code>栈帧就是Java虚拟机栈中的下一个单位</code></p></li><li><p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p><p><code>Native 关键字修饰的方法是看不到的，Native 方法的源码大部分都是 C和C++ 的代码</code></p></li><li><p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p></li><li><p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">后面有详细的说明<span class="hljs-keyword">JVM </span>运行时数据区<br></code></pre></td></tr></table></figure><h3 id="详细的介绍下程序计数器？（重点理解）"><a href="#详细的介绍下程序计数器？（重点理解）" class="headerlink" title="详细的介绍下程序计数器？（重点理解）"></a>详细的介绍下程序计数器？（重点理解）</h3><ol><li><p>程序计数器是一块较小的内存空间，它可以看作是：保存当前线程所正在执行的字节码指令的地址(行号)</p></li><li><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。称之为“线程私有”的内存。程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。</p><p><code>总结：也可以把它叫做线程计数器</code></p></li></ol><ul><li><strong>例子</strong>：在java中最小的执行单位是线程，线程是要执行指令的，执行的指令最终操作的就是我们的电脑，就是 CPU。在CPU上面去运行，有个非常不稳定的因素，叫做调度策略，这个调度策略是时基于时间片的，也就是当前的这一纳秒是分配给那个指令的。</li><li><strong>假如</strong>：<ul><li>线程A在看直播 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fc9acf8957~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></li><li>突然，线程B来了一个视频电话，就会抢夺线程A的时间片，就会打断了线程A，线程A就会挂起 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fcc70da181~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></li><li>然后，视频电话结束，这时线程A究竟该干什么？ （线程是最小的执行单位，他不具备记忆功能，他只负责去干，那这个记忆就由：<strong>程序计数器来记录</strong>） <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fcc90c8a88~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="详细介绍下Java虚拟机栈-（重点理解）"><a href="#详细介绍下Java虚拟机栈-（重点理解）" class="headerlink" title="详细介绍下Java虚拟机栈?（重点理解）"></a>详细介绍下Java虚拟机栈?（重点理解）</h3><ol><li>Java虚拟机是线程私有的，它的生命周期和线程相同。</li><li>虚拟机栈描述的是Java方法执行的内存模型：<code>每个方法在执行的同时</code>都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li></ol><ul><li><strong>解释</strong>：虚拟机栈中是有单位的，单位就是<strong>栈帧</strong>，一个方法一个<strong>栈帧</strong>。一个<strong>栈帧</strong>中他又要存储，局部变量，操作数栈，动态链接，出口等。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171729fccadd7f8b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p><strong>解析栈帧：</strong></p><ol><li>局部变量表：是用来存储我们临时8个基本数据类型、对象引用地址、returnAddress类型。（returnAddress中保存的是return后要执行的字节码的指令地址。）</li><li>操作数栈：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操作，读取我们的代码，进行计算后再放入局部变量表中去</li><li>动态链接：假如我方法中，有个 service.add()方法，要链接到别的方法中去，这就是动态链接，存储链接的地方。</li><li>出口：出口是什呢，出口正常的话就是return  不正常的话就是抛出异常落</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈指向堆是什么意思</title>
    <link href="/blog/2021/10/01/%E6%A0%88%E6%8C%87%E5%90%91%E5%A0%86%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <url>/blog/2021/10/01/%E6%A0%88%E6%8C%87%E5%90%91%E5%A0%86%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h4 id="一个方法调用另一个方法，会创建很多栈帧吗？"><a href="#一个方法调用另一个方法，会创建很多栈帧吗？" class="headerlink" title="一个方法调用另一个方法，会创建很多栈帧吗？"></a>一个方法调用另一个方法，会创建很多栈帧吗？</h4><ul><li>答：会创建。如果一个栈中有动态链接调用别的方法，就会去创建新的栈帧，栈中是由顺序的，一个栈帧调用另一个栈帧，另一个栈帧就会排在调用者下面</li></ul><h4 id="栈指向堆是什么意思？"><a href="#栈指向堆是什么意思？" class="headerlink" title="栈指向堆是什么意思？"></a>栈指向堆是什么意思？</h4><ul><li>栈指向堆是什么意思，就是栈中要使用成员变量怎么办，栈中不会存储成员变量，只会存储一个应用地址</li></ul><h4 id="递归的调用自己会创建很多栈帧吗？"><a href="#递归的调用自己会创建很多栈帧吗？" class="headerlink" title="递归的调用自己会创建很多栈帧吗？"></a>递归的调用自己会创建很多栈帧吗？</h4><ul><li>答：递归的话也会创建多个栈帧，就是在栈中一直从上往下排下去</li></ul><h3 id="你能给我详细的介绍Java堆吗-（重点理解）"><a href="#你能给我详细的介绍Java堆吗-（重点理解）" class="headerlink" title="你能给我详细的介绍Java堆吗?（重点理解）"></a>你能给我详细的介绍Java堆吗?（重点理解）</h3><ul><li>java堆（Java Heap）是java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。</li><li>在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</li><li>java堆是垃圾收集器管理的主要区域，因此也被成为“GC堆”。</li><li>从内存回收角度来看java堆可分为：新生代和老生代。</li><li>从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。</li><li>无论怎么划分，都与存放内容无关，无论哪个区域，存储的都是对象实例，进一步的划分都是为了更好的回收内存，或者更快的分配内存。</li><li>根据Java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中。当前主流的虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制）。如果堆中没有内存可以完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</li></ul><h3 id="能不能解释一下本地方法栈？"><a href="#能不能解释一下本地方法栈？" class="headerlink" title="能不能解释一下本地方法栈？"></a>能不能解释一下本地方法栈？</h3><ol><li>本地方法栈很好理解，他很栈很像，只不过方法上带了 native 关键字的栈字</li><li>它是虚拟机栈为虚拟机执行Java方法（也就是字节码）的服务方法</li><li>native关键字的方法是看不到的，必须要去oracle官网去下载才可以看的到，而且native关键字修饰的大部分源码都是C和C++的代码。</li><li>同理可得，本地方法栈中就是C和C++的代码</li></ol><h3 id="能不能解释一下方法区（重点理解）"><a href="#能不能解释一下方法区（重点理解）" class="headerlink" title="能不能解释一下方法区（重点理解）"></a>能不能解释一下方法区（重点理解）</h3><ol><li>方法区是所有线程共享的内存区域，它用于存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>它有个别命叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。</li></ol><h3 id="什么是JVM字节码执行引擎"><a href="#什么是JVM字节码执行引擎" class="headerlink" title="什么是JVM字节码执行引擎"></a>什么是JVM字节码执行引擎</h3><ul><li>虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般户先进行编译成机器码后执行。</li><li>“虚拟机”是一个相对于“物理机”的概念，虚拟机的字节码是不能直接在物理机上运行的，需要JVM字节码执行引擎- 编译成机器码后才可在物理机上执行。</li></ul><h3 id="你听过直接内存吗？"><a href="#你听过直接内存吗？" class="headerlink" title="你听过直接内存吗？"></a>你听过直接内存吗？</h3><ul><li>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现，所以我们放到这里一起讲解。</li><li>我的理解就是直接内存是基于物理内存和Java虚拟机内存的中间内存</li></ul><h3 id="知道垃圾收集系统吗？"><a href="#知道垃圾收集系统吗？" class="headerlink" title="知道垃圾收集系统吗？"></a>知道垃圾收集系统吗？</h3><ul><li>程序在运行过程中，会产生大量的内存垃圾（一些没有引用指向的内存对象都属于内存垃圾，因为这些对象已经无法访问，程序用不了它们了，对程序而言它们已经死亡），为了确保程序运行时的性能，java虚拟机在程序运行的过程中不断地进行自动的垃圾回收（GC）。</li><li>垃圾收集系统是Java的核心，也是不可少的，Java有一套自己进行垃圾清理的机制，开发人员无需手工清理</li><li>有一部分原因就是因为Java垃圾回收系统的强大导致Java领先市场</li></ul><h3 id="堆栈的区别是什么？"><a href="#堆栈的区别是什么？" class="headerlink" title="堆栈的区别是什么？"></a>堆栈的区别是什么？</h3><blockquote><table><thead><tr><th>对比</th><th>JVM堆</th><th>JVM栈</th></tr></thead><tbody><tr><td>物理地址</td><td>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</td><td>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</td></tr><tr><td>内存分别</td><td>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</td><td>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</td></tr><tr><td>存放的内容</td><td>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</td><td>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</td></tr><tr><td>程序的可见度</td><td>堆对于整个应用程序都是共享、可见的。</td><td>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</td></tr></tbody></table></blockquote><ul><li>注意：<ul><li>静态变量放在方法区</li><li>静态的对象还是放在堆。</li></ul></li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</li><li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</li><li>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</li><li>深复制：在计算机中开辟一块<strong>新的内存地址</strong>用于存放复制的对象。</li></ul><h3 id="Java会存在内存泄漏吗？请说明为什么？"><a href="#Java会存在内存泄漏吗？请说明为什么？" class="headerlink" title="Java会存在内存泄漏吗？请说明为什么？"></a>Java会存在内存泄漏吗？请说明为什么？</h3><ul><li>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</li><li>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，<code>尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收</code>，这就是java中内存泄露的发生场景。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈指向堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常处理最佳实践</title>
    <link href="/blog/2021/09/28/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/blog/2021/09/28/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="Java异常处理最佳实践"><a href="#Java异常处理最佳实践" class="headerlink" title="Java异常处理最佳实践"></a>Java异常处理最佳实践</h2><ul><li>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。</li><li>本文给出几个被很多团队使用的异常处理最佳实践。</li></ul><h3 id="1-在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#1-在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="1. 在 finally 块中清理资源或者使用 try-with-resource 语句"></a>1. 在 finally 块中清理资源或者使用 try-with-resource 语句</h3><ul><li>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doNotCloseResourceInTry</span><span class="hljs-params">()</span> </span>&#123;<br>    FileInputStream inputStream = null;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">File</span> file = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>        inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>        <span class="hljs-comment">// do NOT do this</span><br>        inputStream.<span class="hljs-built_in">close</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        <span class="hljs-built_in">log</span>.error(e);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-built_in">log</span>.error(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</li></ul><p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p><h4 id="1-1-使用-finally-代码块"><a href="#1-1-使用-finally-代码块" class="headerlink" title="1.1 使用 finally 代码块"></a>1.1 使用 finally 代码块</h4><ul><li>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">closeResourceInFinally</span>(<span class="hljs-params"></span>)</span> &#123;<br>    FileInputStream inputStream = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>        inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                inputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                log.error(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-Java-7-的-try-with-resource-语法"><a href="#1-2-Java-7-的-try-with-resource-语法" class="headerlink" title="1.2 Java 7 的 try-with-resource 语法"></a>1.2 Java 7 的 try-with-resource 语法</h4><ul><li>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">automaticallyCloseResource</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">File</span> file = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span> (FileInputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);) &#123;<br>        <span class="hljs-comment">// use the inputStream to read a file</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        <span class="hljs-built_in">log</span>.error(e);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-built_in">log</span>.error(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-优先明确的异常"><a href="#2-优先明确的异常" class="headerlink" title="2. 优先明确的异常"></a>2. 优先明确的异常</h3><ul><li>你抛出的异常越明确越好，永远记住，你的同事或者几个月之后的你，将会调用你的方法并且处理异常。</li><li>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。</li><li>因此，总是尝试寻找最适合你的异常事件的类，例如，抛出一个 NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doNotDoThis</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doThis</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NumberFormatException </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-对异常进行文档说明"><a href="#3-对异常进行文档说明" class="headerlink" title="3. 对异常进行文档说明"></a>3. 对异常进行文档说明</h3><ul><li>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br> 在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-keyword">String</span> input)</span> throws MyBusinessException </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-使用描述性消息抛出异常"><a href="#4-使用描述性消息抛出异常" class="headerlink" title="4. 使用描述性消息抛出异常"></a>4. 使用描述性消息抛出异常</h3><ul><li>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</li><li>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</li><li>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</li></ul><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">new</span> Long(<span class="hljs-string">&quot;xyz&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-优先捕获最具体的异常"><a href="#5-优先捕获最具体的异常" class="headerlink" title="5. 优先捕获最具体的异常"></a>5. 优先捕获最具体的异常</h3><ul><li>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</li><li>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</li><li>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</li><li>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">catchMostSpecificExceptionFirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        doSomething(<span class="hljs-string">&quot;A message&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        log.error(e);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>        log.error(e)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-不要捕获-Throwable-类"><a href="#6-不要捕获-Throwable-类" class="headerlink" title="6. 不要捕获 Throwable 类"></a>6. 不要捕获 Throwable 类</h3><ul><li>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</li><li>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</li><li>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doNotCatchThrowable</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// don&#x27;t do this!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-不要忽略异常"><a href="#7-不要忽略异常" class="headerlink" title="7. 不要忽略异常"></a>7. 不要忽略异常</h3><ul><li>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doNotIgnoreExceptions</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        <span class="hljs-comment">// this will never happen</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</li><li>合理的做法是至少要记录异常的信息。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">logAnException</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        log.error(<span class="hljs-string">&quot;This should never happen: &quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-不要记录并抛出异常"><a href="#8-不要记录并抛出异常" class="headerlink" title="8. 不要记录并抛出异常"></a>8. 不要记录并抛出异常</h3><ul><li>这可能是本文中最常被忽略的最佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</li></ul><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">new</span> Long(<span class="hljs-string">&quot;xyz&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(e);<br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">17<span class="hljs-selector-pseudo">:44</span><span class="hljs-selector-pseudo">:28</span>,945 <span class="hljs-selector-tag">ERROR</span> <span class="hljs-selector-tag">TestExceptionHandling</span><span class="hljs-selector-pseudo">:65</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NumberFormatException</span>: <span class="hljs-selector-tag">For</span> <span class="hljs-selector-tag">input</span> <span class="hljs-selector-tag">string</span>: &quot;<span class="hljs-selector-tag">xyz</span>&quot;<br><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NumberFormatException</span>: <span class="hljs-selector-tag">For</span> <span class="hljs-selector-tag">input</span> <span class="hljs-selector-tag">string</span>: &quot;<span class="hljs-selector-tag">xyz</span>&quot;<br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NumberFormatException</span><span class="hljs-selector-class">.forInputString</span>(<span class="hljs-selector-tag">NumberFormatException</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:65)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Long</span><span class="hljs-selector-class">.parseLong</span>(<span class="hljs-selector-tag">Long</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:589)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Long</span>.(<span class="hljs-selector-tag">Long</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:965)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.stackify</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.TestExceptionHandling</span><span class="hljs-selector-class">.logAndThrowException</span>(<span class="hljs-selector-tag">TestExceptionHandling</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:63)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.stackify</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.TestExceptionHandling</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">TestExceptionHandling</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:58)</span><br></code></pre></td></tr></table></figure><ul><li>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrapException</span><span class="hljs-params">(<span class="hljs-keyword">String</span> input)</span> throws MyBusinessException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyBusinessException(<span class="hljs-string">&quot;A message that describes the error.&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</li></ul><h3 id="9-包装异常时不要抛弃原始的异常"><a href="#9-包装异常时不要抛弃原始的异常" class="headerlink" title="9. 包装异常时不要抛弃原始的异常"></a>9. 包装异常时不要抛弃原始的异常</h3><ul><li>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br> 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrapException</span><span class="hljs-params">(<span class="hljs-keyword">String</span> input)</span> throws MyBusinessException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyBusinessException(<span class="hljs-string">&quot;A message that describes the error.&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-不要使用异常控制程序的流程"><a href="#10-不要使用异常控制程序的流程" class="headerlink" title="10. 不要使用异常控制程序的流程"></a>10. 不要使用异常控制程序的流程</h3><ul><li>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</li></ul><h3 id="11-使用标准异常"><a href="#11-使用标准异常" class="headerlink" title="11. 使用标准异常"></a>11. 使用标准异常</h3><ul><li>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。</li></ul><h3 id="12-异常会影响性能"><a href="#12-异常会影响性能" class="headerlink" title="12. 异常会影响性能"></a>12. 异常会影响性能</h3><ul><li>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。<ul><li>仅在异常情况下使用异常；</li><li>在可恢复的异常情况下使用异常；</li></ul></li><li>尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</li></ul><h3 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h3><ul><li>综上所述，当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</li><li>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</li></ul><h3 id="异常处理-阿里巴巴Java开发手册"><a href="#异常处理-阿里巴巴Java开发手册" class="headerlink" title="异常处理-阿里巴巴Java开发手册"></a>异常处理-阿里巴巴Java开发手册</h3><ol><li>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj != null) {…} 反例：try { obj.method(); } catch (NullPointerException e) {…}</li><li>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</li><li>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</li><li>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li><li>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</li><li>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</li><li>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checkReturn</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// x等于1，此处不返回</span><br>        <span class="hljs-keyword">return</span> ++x;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 返回的结果是2</span><br>        <span class="hljs-keyword">return</span> ++x;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</li><li>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</li><li>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</li><li>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br> 正例：使用JDK8的Optional类来防止NPE问题。</li><li>【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。</li><li>【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</li><li>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br> private boolean checkParam(DTO dto) {…}</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java异常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java异常处理</tag>
      
      <tag>最佳实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常常见面试题</title>
    <link href="/blog/2021/09/27/Java%E5%BC%82%E5%B8%B8%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/blog/2021/09/27/Java%E5%BC%82%E5%B8%B8%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Java异常常见面试题"><a href="#Java异常常见面试题" class="headerlink" title="Java异常常见面试题"></a>Java异常常见面试题</h2><h3 id="1-Error-和-Exception-区别是什么？"><a href="#1-Error-和-Exception-区别是什么？" class="headerlink" title="1. Error 和 Exception 区别是什么？"></a>1. Error 和 Exception 区别是什么？</h3><ul><li>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</li><li>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</li></ul><h3 id="2-运行时异常和一般异常-受检异常-区别是什么？"><a href="#2-运行时异常和一般异常-受检异常-区别是什么？" class="headerlink" title="2. 运行时异常和一般异常(受检异常)区别是什么？"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h3><ul><li>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</li><li>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</li><li><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</li></ul><h3 id="3-JVM-是如何处理异常的？"><a href="#3-JVM-是如何处理异常的？" class="headerlink" title="3. JVM 是如何处理异常的？"></a>3. JVM 是如何处理异常的？</h3><ul><li>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</li><li>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</li></ul><h3 id="4-throw-和-throws-的区别是什么？"><a href="#4-throw-和-throws-的区别是什么？" class="headerlink" title="4. throw 和 throws 的区别是什么？"></a>4. throw 和 throws 的区别是什么？</h3><ul><li>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</li></ul><p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h3 id="5-final、finally、finalize-有什么区别？"><a href="#5-final、finally、finalize-有什么区别？" class="headerlink" title="5. final、finally、finalize 有什么区别？"></a>5. final、finally、finalize 有什么区别？</h3><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li></ul><h3 id="6-NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#6-NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="6. NoClassDefFoundError 和 ClassNotFoundException 区别？"></a>6. NoClassDefFoundError 和 ClassNotFoundException 区别？</h3><ul><li>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</li><li>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；</li><li>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</li></ul><h3 id="7-try-catch-finally-中哪个部分可以省略？"><a href="#7-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="7. try-catch-finally 中哪个部分可以省略？"></a>7. try-catch-finally 中哪个部分可以省略？</h3><ul><li>答：catch 可以省略</li></ul><p><strong>原因</strong></p><ul><li>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</li><li>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</li><li>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</li></ul><h3 id="8-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#8-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="8. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>8. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><ul><li>答：会执行，在 return 前执行。</li><li><strong>注意</strong>：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。</li></ul><p><strong>代码示例1：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.<span class="hljs-built_in">println</span>(a / <span class="hljs-number">0</span>);<br>        a = <span class="hljs-number">20</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>        a = <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span><br><span class="hljs-comment">         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span><br><span class="hljs-comment">         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span><br><span class="hljs-comment">         */</span><br>    &#125; finally &#123;<br>        a = <span class="hljs-number">40</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>执行结果：30</li></ul><p><strong>代码示例2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.<span class="hljs-built_in">println</span>(a / <span class="hljs-number">0</span>);<br>        a = <span class="hljs-number">20</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>        a = <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125; finally &#123;<br>        a = <span class="hljs-number">40</span>;<br>        <span class="hljs-comment">//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span><br>        <span class="hljs-keyword">return</span> a; <br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>执行结果：40</li></ul><h3 id="9-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。"><a href="#9-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。" class="headerlink" title="9. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。"></a>9. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</h3><ul><li>有如下代码片断：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExampleB(<span class="hljs-string">&quot;b&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span>（ExampleA e）&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;ExampleA&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>（Exception e）&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Exception&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>请问执行此段代码的输出是什么？</li><li><strong>答</strong>：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</li><li>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annoyance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sneeze</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Annoyance</span> </span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>public static void main(<span class="hljs-type">String</span>[] args)<br><span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Sneeze</span>();<br>&#125; <span class="hljs-keyword">catch</span> ( <span class="hljs-type">Annoyance</span> a ) &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Caught Annoyance&quot;</span>);<br><span class="hljs-keyword">throw</span> a;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> ( <span class="hljs-type">Sneeze</span> s ) &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Caught Sneeze&quot;</span>);<br><span class="hljs-keyword">return</span> ;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Caught Annoyance<br>Caught Sneeze<br>Hello World!<br><br></code></pre></td></tr></table></figure><h3 id="10-常见的-RuntimeException-有哪些？"><a href="#10-常见的-RuntimeException-有哪些？" class="headerlink" title="10. 常见的 RuntimeException 有哪些？"></a>10. 常见的 RuntimeException 有哪些？</h3><ul><li>ClassCastException(类转换异常)</li><li>IndexOutOfBoundsException(数组越界)</li><li>NullPointerException(空指针)</li><li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li><li>还有IO操作的BufferOverflowException异常</li></ul><h3 id="11-Java常见异常有哪些"><a href="#11-Java常见异常有哪些" class="headerlink" title="11. Java常见异常有哪些"></a>11. Java常见异常有哪些</h3><ul><li>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</li><li>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</li><li>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</li><li>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</li><li>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</li><li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</li><li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</li><li>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</li><li>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</li><li>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。-</li><li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</li><li>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</li><li>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java异常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java异常</tag>
      
      <tag>常见面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常处理</title>
    <link href="/blog/2021/09/25/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/blog/2021/09/25/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/1717840de2de5ccf~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。</li><li>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</li></ul><h3 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h3><ul><li>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <strong>throws</strong> 关键字声明可能会抛出的异常。</li></ul><p><strong>注意</strong></p><ul><li>非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</li><li>一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误。</li></ul><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><ul><li>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。</li><li>throw关键字作用是在方法内部抛出一个<code>Throwable</code>类型的异常。任何Java代码都可以通过throw语句抛出异常。</li></ul><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul><li>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</li></ul><h3 id="如何选择异常类型"><a href="#如何选择异常类型" class="headerlink" title="如何选择异常类型"></a>如何选择异常类型</h3><ul><li>可以根据下图来选择是捕获异常，声明异常还是抛出异常</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/1717840de32f26f7~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h3 id="常见异常处理方式"><a href="#常见异常处理方式" class="headerlink" title="常见异常处理方式"></a>常见异常处理方式</h3><h4 id="直接抛出异常"><a href="#直接抛出异常" class="headerlink" title="直接抛出异常"></a>直接抛出异常</h4><ul><li>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <strong>throws</strong> 关键字声明可能会抛出的异常。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-keyword">String</span> filePath)</span> throws IOException </span>&#123;<br>    <span class="hljs-built_in">File</span> file = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(filePath);<br>    <span class="hljs-keyword">String</span> result;<br>    BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(file));<br>    <span class="hljs-keyword">while</span>((result = reader.readLine())!=null) &#123;<br>        System.out.<span class="hljs-built_in">println</span>(result);<br>    &#125;<br>    reader.<span class="hljs-built_in">close</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="封装异常再抛出"><a href="#封装异常再抛出" class="headerlink" title="封装异常再抛出"></a>封装异常再抛出</h4><ul><li>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">(<span class="hljs-keyword">String</span> filePath)</span> throws MyException </span>&#123;    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        MyException ex = <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">&quot;read file failed.&quot;</span>);<br>        ex.initCause(e);<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><ul><li>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">readFile</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> filePath</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        <span class="hljs-comment">// handle FileNotFoundException</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        <span class="hljs-comment">// handle IOException</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>同一个 catch 也可以捕获多种类型异常，用 | 隔开</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">readFile</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> filePath</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException | UnknownHostException e) &#123;<br>        <span class="hljs-comment">// handle FileNotFoundException or UnknownHostException</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        <span class="hljs-comment">// handle IOException</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul><li>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>    public <span class="hljs-type">MyException</span>()&#123; &#125;<br>    public <span class="hljs-type">MyException</span>(<span class="hljs-type">String</span> msg)&#123;<br>        <span class="hljs-keyword">super</span>(msg);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul><li>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> readFile(String filePath) <span class="hljs-keyword">throws</span> MyException &#123;<br>    <span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(filePath);<br>    String result;<br>    BufferedReader reader = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-keyword">file</span>));<br>        <span class="hljs-keyword">while</span>((result = reader.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">println</span>(result);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;readFile method catch block.&quot;</span>);<br>        MyException ex = <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">&quot;read file failed.&quot;</span>);<br>        ex.initCause(e);<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;readFile method finally block.&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != reader) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                reader.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入 finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入 finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。</li><li>若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码中的 catch 子句修改如下：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;readFile method catch block.&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是否执行</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">readFile <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">catch</span> <span class="hljs-title">block</span>.</span><br><span class="hljs-function"><span class="hljs-title">readFile</span> <span class="hljs-title">method</span> <span class="hljs-title">finally</span> <span class="hljs-title">block</span>.</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><ul><li>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</li></ul><h4 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h4><ul><li>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">tryWithResourceTest</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">try</span> (Scanner scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br>        <span class="hljs-comment">// code</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        <span class="hljs-comment">// handle exception</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java异常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java异常</tag>
      
      <tag>处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常简介</title>
    <link href="/blog/2021/09/22/Java%E5%BC%82%E5%B8%B8%E7%AE%80%E4%BB%8B/"/>
    <url>/blog/2021/09/22/Java%E5%BC%82%E5%B8%B8%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Java异常架构与异常关键字"><a href="#Java异常架构与异常关键字" class="headerlink" title="Java异常架构与异常关键字"></a>Java异常架构与异常关键字</h2><h3 id="Java异常简介"><a href="#Java异常简介" class="headerlink" title="Java异常简介"></a>Java异常简介</h3><ul><li>Java异常是Java提供的一种识别及响应错误的一致性机制。<br> Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。</li></ul><h3 id="Java异常架构"><a href="#Java异常架构" class="headerlink" title="Java异常架构"></a>Java异常架构</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/1717840de0260d11~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h4 id="1-Throwable"><a href="#1-Throwable" class="headerlink" title="1. Throwable"></a>1. Throwable</h4><ul><li>Throwable 是 Java 语言中所有错误与异常的超类。</li><li>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</li><li>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</li></ul><h4 id="2-Error（错误）"><a href="#2-Error（错误）" class="headerlink" title="2. Error（错误）"></a>2. Error（错误）</h4><ul><li><strong>定义</strong>：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</li><li><strong>特点</strong>：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</li><li>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</li></ul><h4 id="3-Exception（异常）"><a href="#3-Exception（异常）" class="headerlink" title="3. Exception（异常）"></a>3. Exception（异常）</h4><ul><li>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</li></ul><h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><ul><li><strong>定义</strong>：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</li><li><strong>特点</strong>：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</li><li>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（<strong>就算我们没写异常捕获语句运行时也会抛出错误</strong>！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</li></ul><h5 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h5><ul><li><strong>定义</strong>: Exception 中除 RuntimeException 及其子类之外的异常。</li><li><strong>特点</strong>: Java 编译器会检查它。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。<strong>该异常我们必须手动在代码里添加捕获语句来处理该异常</strong>。</li></ul><h4 id="4-受检异常与非受检异常"><a href="#4-受检异常与非受检异常" class="headerlink" title="4. 受检异常与非受检异常"></a>4. 受检异常与非受检异常</h4><ul><li>Java 的所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）。</li></ul><h5 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h5><ul><li>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。<strong>除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</li></ul><h5 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h5><ul><li>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。<strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。</strong></li></ul><h3 id="Java异常关键字"><a href="#Java异常关键字" class="headerlink" title="Java异常关键字"></a>Java异常关键字</h3><ul><li><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li><strong>throw</strong> – 用于抛出异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java异常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java异常</tag>
      
      <tag>简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发工具类</title>
    <link href="/blog/2021/09/21/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/blog/2021/09/21/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h4 id="常用的并发工具类有哪些？"><a href="#常用的并发工具类有哪些？" class="headerlink" title="常用的并发工具类有哪些？"></a>常用的并发工具类有哪些？</h4><ul><li><p>CountDownLatch</p><p>CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他3个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p></li><li><p>CyclicBarrier (回环栅栏) CyclicBarrier它的作用就是会让所有线程都等待完成后才会继续下一步行动。</p><p>CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。</p><p>CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。</p></li><li><p>Semaphore (信号量) Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。</p><p>Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。它的用法如下：</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发队列</title>
    <link href="/blog/2021/09/20/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
    <url>/blog/2021/09/20/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><h4 id="什么是并发队列："><a href="#什么是并发队列：" class="headerlink" title="什么是并发队列："></a>什么是并发队列：</h4><ul><li>消息队列很多人知道：消息队列是分布式系统中重要的组件，是系统与系统直接的通信</li><li>并发队列是什么：并发队列多个线程以有次序共享数据的重要组件</li></ul><h4 id="并发队列和并发集合的区别："><a href="#并发队列和并发集合的区别：" class="headerlink" title="并发队列和并发集合的区别："></a>并发队列和并发集合的区别：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">那就有可能要说了，我们并发集合不是也可以实现多线程之间的数据共享吗，其实也是有区别的：<br></code></pre></td></tr></table></figure><ul><li>队列遵循“先进先出”的规则，可以想象成排队检票，队列一般用来解决大数据量采集处理和显示的。</li><li>并发集合就是在多个线程中共享数据的</li></ul><h4 id="怎么判断并发队列是阻塞队列还是非阻塞队列"><a href="#怎么判断并发队列是阻塞队列还是非阻塞队列" class="headerlink" title="怎么判断并发队列是阻塞队列还是非阻塞队列"></a>怎么判断并发队列是阻塞队列还是非阻塞队列</h4><ul><li>在并发队列上JDK提供了Queue接口，一个是以Queue接口下的BlockingQueue接口为代表的阻塞队列，另一个是高性能（无堵塞）队列。</li></ul><h4 id="阻塞队列和非阻塞队列区别"><a href="#阻塞队列和非阻塞队列区别" class="headerlink" title="阻塞队列和非阻塞队列区别"></a>阻塞队列和非阻塞队列区别</h4><ul><li>当队列阻塞队列为空的时，从队列中获取元素的操作将会被阻塞。</li><li>或者当阻塞队列是满时，往队列里添加元素的操作会被阻塞。</li><li>或者试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。</li><li>试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来</li></ul><h4 id="常用并发列队的介绍："><a href="#常用并发列队的介绍：" class="headerlink" title="常用并发列队的介绍："></a>常用并发列队的介绍：</h4><ol><li><p><strong>非堵塞队列：</strong></p><ol><li><p><strong>ArrayDeque, （数组双端队列）</strong></p><p>ArrayDeque （非堵塞队列）是JDK容器中的一个双端队列实现，内部使用数组进行元素存储，不允许存储null值，可以高效的进行元素查找和尾部插入取出，是用作队列、双端队列、栈的绝佳选择，性能比LinkedList还要好。</p></li><li><p><strong>PriorityQueue, （优先级队列）</strong></p><p>PriorityQueue （非堵塞队列） 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象</p></li><li><p><strong>ConcurrentLinkedQueue, （基于链表的并发队列）</strong></p><p>ConcurrentLinkedQueue （非堵塞队列）: 是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能。ConcurrentLinkedQueue的性能要好于BlockingQueue接口，它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。该队列不允许null元素。</p></li></ol></li><li><p><strong>堵塞队列：</strong></p><ol><li><p><strong>DelayQueue, （基于时间优先级的队列，延期阻塞队列）</strong></p><p>DelayQueue是一个没有边界BlockingQueue实现，加入其中的元素必需实现Delayed接口。当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。</p></li><li><p><strong>ArrayBlockingQueue, （基于数组的并发阻塞队列）</strong></p><p>ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。ArrayBlockingQueue是以先进先出的方式存储数据</p></li><li><p><strong>LinkedBlockingQueue, （基于链表的FIFO阻塞队列）</strong></p><p>LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。</p></li><li><p><strong>LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）</strong></p><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p><p>相比于其他阻塞队列，LinkedBlockingDeque多了addFirst、addLast、peekFirst、peekLast等方法，以first结尾的方法，表示插入、获取获移除双端队列的第一个元素。以last结尾的方法，表示插入、获取获移除双端队列的最后一个元素。</p><p>LinkedBlockingDeque是可选容量的，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE。</p></li><li><p><strong>PriorityBlockingQueue, （带优先级的无界阻塞队列）</strong></p><p>priorityBlockingQueue是一个无界队列，它没有限制，在内存允许的情况下可以无限添加元素；它又是具有优先级的队列，是通过构造函数传入的对象来判断，传入的对象必须实现comparable接口。</p></li><li><p><strong>SynchronousQueue （并发同步阻塞队列）</strong></p><p>SynchronousQueue是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</p><p>将这个类称为队列有点夸大其词。这更像是一个点。</p></li></ol></li></ol><h4 id="并发队列的常用方法"><a href="#并发队列的常用方法" class="headerlink" title="并发队列的常用方法"></a>并发队列的常用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">不管是那种列队，是那个类，当是他们使用的方法都是差不多的<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>在不超出队列长度的情况下插入元素，可以立即执行，成功返回true，如果队列满了就抛出异常。</td></tr><tr><td>offer()</td><td>在不超出队列长度的情况下插入元素的时候则可以立即在队列的尾部插入指定元素,成功时返回true，如果此队列已满，则返回false。</td></tr><tr><td>put()</td><td>插入元素的时候，如果队列满了就进行等待，直到队列可用。</td></tr><tr><td>take()</td><td>从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。</td></tr><tr><td>poll(long timeout, TimeUnit unit)</td><td>在给定的时间里，从队列中获取值，如果没有取到会抛出异常。</td></tr><tr><td>remainingCapacity()</td><td>获取队列中剩余的空间。</td></tr><tr><td>remove(Object o)</td><td>从队列中移除指定的值。</td></tr><tr><td>contains(Object o)</td><td>判断队列中是否拥有该值。</td></tr><tr><td>drainTo(Collection c)</td><td>将队列中值，全部移除，并发设置到给定的集合中。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SynchronizedMap</title>
    <link href="/blog/2021/09/19/SynchronizedMap/"/>
    <url>/blog/2021/09/19/SynchronizedMap/</url>
    
    <content type="html"><![CDATA[<h4 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h4><ul><li>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。</li><li>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。</li><li>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。</li><li>这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。</li><li>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</li></ul><h4 id="CopyOnWriteArrayList-是什么"><a href="#CopyOnWriteArrayList-是什么" class="headerlink" title="CopyOnWriteArrayList 是什么?"></a>CopyOnWriteArrayList 是什么?</h4><ul><li>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。</li><li>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</li></ul><h4 id="CopyOnWriteArrayList-的使用场景"><a href="#CopyOnWriteArrayList-的使用场景" class="headerlink" title="CopyOnWriteArrayList 的使用场景?"></a>CopyOnWriteArrayList 的使用场景?</h4><ul><li>合适读多写少的场景。</li></ul><h4 id="CopyOnWriteArrayList-的缺点"><a href="#CopyOnWriteArrayList-的缺点" class="headerlink" title="CopyOnWriteArrayList 的缺点?"></a>CopyOnWriteArrayList 的缺点?</h4><ul><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li><li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li><li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li></ul><h4 id="CopyOnWriteArrayList-的设计思想"><a href="#CopyOnWriteArrayList-的设计思想" class="headerlink" title="CopyOnWriteArrayList 的设计思想?"></a>CopyOnWriteArrayList 的设计思想?</h4><ul><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路，来解决并发冲突</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Synchronized</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器</title>
    <link href="/blog/2021/09/17/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <url>/blog/2021/09/17/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><h4 id="你经常使用什么并发容器，为什么？"><a href="#你经常使用什么并发容器，为什么？" class="headerlink" title="你经常使用什么并发容器，为什么？"></a>你经常使用什么并发容器，为什么？</h4><ul><li>答：Vector、ConcurrentHashMap、HasTable</li><li>一般软件开发中容器用的最多的就是HashMap、ArrayList，LinkedList ，等等</li><li>但是在多线程开发中就不能乱用容器，如果使用了未加锁（非同步）的的集合，你的数据就会非常的混乱。由此在多线程开发中需要使用的容器必须是加锁（同步）的容器。</li></ul><h4 id="什么是Vector"><a href="#什么是Vector" class="headerlink" title="什么是Vector"></a>什么是Vector</h4><ul><li><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多</p><p>（<code>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。</code>）</p></li></ul><h4 id="ArrayList和Vector有什么不同之处？"><a href="#ArrayList和Vector有什么不同之处？" class="headerlink" title="ArrayList和Vector有什么不同之处？"></a>ArrayList和Vector有什么不同之处？</h4><ul><li>Vector方法带上了synchronized关键字，是线程同步的</li></ul><ol><li><p>ArrayList添加方法源码</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bac57d8b760~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>Vector添加源码（加锁了synchronized关键字）</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bac5bc35f22~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ol><h4 id="为什么HashTable是线程安全的？"><a href="#为什么HashTable是线程安全的？" class="headerlink" title="为什么HashTable是线程安全的？"></a>为什么HashTable是线程安全的？</h4><ul><li>因为HasTable的内部方法都被synchronized修饰了，所以是线程安全的。其他的都和HashMap一样</li></ul><ol><li><p>HashMap添加方法的源码</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bac5c47d65f~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>HashTable添加方法的源码</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bac599568da~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ol><h4 id="用过ConcurrentHashMap，讲一下他和HashTable的不同之处？"><a href="#用过ConcurrentHashMap，讲一下他和HashTable的不同之处？" class="headerlink" title="用过ConcurrentHashMap，讲一下他和HashTable的不同之处？"></a>用过ConcurrentHashMap，讲一下他和HashTable的不同之处？</h4><ul><li>ConcurrentHashMap是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</li><li>看不懂？？？很正常，我也看不懂</li><li>总结：<ol><li>HashTable就是实现了HashMap加上了synchronized，而ConcurrentHashMap底层采用分段的数组+链表实现，线程安全</li><li>ConcurrentHashMap通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li><li>并且读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。</li><li>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术</li><li>扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</li></ol></li></ul><h4 id="Collections-synchronized-是什么？"><a href="#Collections-synchronized-是什么？" class="headerlink" title="Collections.synchronized * 是什么？"></a>Collections.synchronized * 是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">注意：* 号代表后面是还有内容的<br></code></pre></td></tr></table></figure><ul><li>此方法是干什么的呢，他完完全全的可以把List、Map、Set接口底下的集合变成线程安全的集合</li><li>Collections.synchronized *  ：原理是什么，我猜的话是代理模式：<a href="https://link.juejin.cn/?target=https://blog.csdn.net/weixin_43122090/article/details/104883274">Java代理模式理解</a></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bac6e2aff60~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h4 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a>Java 中 ConcurrentHashMap 的并发度是什么？</h4><ul><li>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</li><li>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</li></ul><h4 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h4><ul><li>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。</li><li>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</li></ul><h4 id="Java-中的同步集合与并发集合有什么区别？"><a href="#Java-中的同步集合与并发集合有什么区别？" class="headerlink" title="Java 中的同步集合与并发集合有什么区别？"></a>Java 中的同步集合与并发集合有什么区别？</h4><ul><li>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池都有哪些状态</title>
    <link href="/blog/2021/09/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81/"/>
    <url>/blog/2021/09/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h4 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h4><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h4 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><ul><li>相同点：<ul><li>相同点就是都可以开启线程执行池中的任务。</li></ul></li><li>不同点：<ul><li>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</li><li>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</li><li>异常处理：submit()方便Exception处理</li></ul></li></ul><h4 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h4><ul><li>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</li><li>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</li><li>为什么不推荐使用线程组？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</li></ul><h4 id="ThreadPoolExecutor饱和策略有哪些？"><a href="#ThreadPoolExecutor饱和策略有哪些？" class="headerlink" title="ThreadPoolExecutor饱和策略有哪些？"></a>ThreadPoolExecutor饱和策略有哪些？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:<br></code></pre></td></tr></table></figure><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li></ul><h4 id="如何自定义线程线程池"><a href="#如何自定义线程线程池" class="headerlink" title="如何自定义线程线程池?"></a>如何自定义线程线程池?</h4><ul><li><p>先看ThreadPoolExecutor（线程池）这个类的构造参数</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bab8f7d464b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>构造参数参数介绍：</p></li></ul>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">corePoolSize 核心线程数量<br>maximumPoolSize 最大线程数量<br>keepAliveTime 线程保持时间，N个时间单位<br>unit 时间单位（比如秒，分）<br>workQueue 阻塞队列<br>threadFactory 线程工厂<br><span class="hljs-keyword">handler</span> 线程池拒绝策略<br><br></code></pre></td></tr></table></figure><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test001</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建线程池</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            TaskThred t1 = <span class="hljs-keyword">new</span> TaskThred(<span class="hljs-string">&quot;任务&quot;</span> + i);<br>            <span class="hljs-comment">//executor.execute(t1);是执行线程方法</span><br>            executor.execute(t1);<br>        &#125;<br>        <span class="hljs-comment">//executor.shutdown()不再接受新的任务，并且等待之前提交的任务都执行完再关闭，阻塞队列中的任务不会再执行。</span><br>        executor.shutdown();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskThred</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String taskName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TaskThred</span><span class="hljs-params">(String taskName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.taskName = taskName;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + taskName);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="线程池的执行原理？"><a href="#线程池的执行原理？" class="headerlink" title="线程池的执行原理？"></a>线程池的执行原理？</h4></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bac2446a113~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>提交一个任务到线程池中，线程池的处理流程如下：<ol><li>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol></li></ul><h4 id="如何合理分配线程池大小"><a href="#如何合理分配线程池大小" class="headerlink" title="如何合理分配线程池大小?"></a>如何合理分配线程池大小?</h4><ul><li>要合理的分配线程池的大小要根据实际情况来定，简单的来说的话就是根据CPU密集和IO密集来分配</li></ul><h5 id="什么是CPU密集"><a href="#什么是CPU密集" class="headerlink" title="什么是CPU密集"></a>什么是CPU密集</h5><ul><li>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。</li><li>CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)，而在单核CPU上，无论你开几个模拟的多线程，该任务都不可能得到加速，因为CPU总的运算能力就那样。</li></ul><h5 id="什么是IO密集"><a href="#什么是IO密集" class="headerlink" title="什么是IO密集"></a>什么是IO密集</h5><ul><li>IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</li></ul><h5 id="分配CPU和IO密集："><a href="#分配CPU和IO密集：" class="headerlink" title="分配CPU和IO密集："></a>分配CPU和IO密集：</h5><ol><li>CPU密集型时，任务可以少配置线程数，大概和机器的cpu核数相当，这样可以使得每个线程都在执行任务</li><li>IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数</li></ol><h5 id="精确来说的话的话："><a href="#精确来说的话的话：" class="headerlink" title="精确来说的话的话："></a>精确来说的话的话：</h5><ul><li>从以下几个角度分析任务的特性：<ul><li>任务的性质：CPU密集型任务、IO密集型任务、混合型任务。</li><li>任务的优先级：高、中、低。</li><li>任务的执行时间：长、中、短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接等。</li></ul></li></ul><p><strong>可以得出一个结论：</strong></p><ul><li>线程等待时间比CPU执行时间比例越高，需要越多线程。</li><li>线程CPU执行时间比等待时间比例越高，需要越少线程。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池四种创建方式</title>
    <link href="/blog/2021/09/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9B%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <url>/blog/2021/09/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9B%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="线程池四种创建方式？"><a href="#线程池四种创建方式？" class="headerlink" title="线程池四种创建方式？"></a>线程池四种创建方式？</h4><ul><li>Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：<ol><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol></li></ul><h4 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h4><ul><li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li><li>Executor 接口对象能执行我们的线程任务。</li><li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li><li>使用 ThreadPoolExecutor 可以创建自定义线程池。</li></ul><h4 id="四种构建线程池的区别及特点？"><a href="#四种构建线程池的区别及特点？" class="headerlink" title="四种构建线程池的区别及特点？"></a>四种构建线程池的区别及特点？</h4><h5 id="1-newCachedThreadPool"><a href="#1-newCachedThreadPool" class="headerlink" title="1. newCachedThreadPool"></a>1. newCachedThreadPool</h5><ul><li><p><strong>特点</strong>：newCachedThreadPool创建一个可缓存线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时， 它可以灵活的添加新的线程，而不会对池的长度作任何限制</p></li><li><p><strong>缺点</strong>：他虽然可以无线的新建线程，但是容易造成堆外内存溢出，因为它的最大值是在初始化的时候设置为 Integer.MAX_VALUE，一般来说机器都没那么大内存给它不断使用。当然知道可能出问题的点，就可以去重写一个方法限制一下这个最大值</p></li><li><p><strong>总结</strong>：线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p></li><li><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNewCachedThreadPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建无限大小线程池，由jvm自动回收</span><br>        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> temp = i;<br>            newCachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;,i==&quot;</span> + temp);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2.newFixedThreadPool"></a>2.newFixedThreadPool</h5></li><li><p><strong>特点</strong>：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。</p></li><li><p><strong>缺点</strong>：线程数量是固定的，但是阻塞队列是无界队列。如果有很多请求积压，阻塞队列越来越长，容易导致OOM（超出内存空间）</p></li><li><p><strong>总结</strong>：请求的挤压一定要和分配的线程池大小匹配，定线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>get<span class="hljs-constructor">Runtime()</span>.available<span class="hljs-constructor">Processors()</span>方法是查看电脑CPU核心数量）<br></code></pre></td></tr></table></figure><ul><li><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNewFixedThreadPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> temp = i;<br>            newFixedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;,i==&quot;</span> + temp);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3.newScheduledThreadPool"></a>3.newScheduledThreadPool</h5></li><li><p><strong>特点</strong>：创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行，类似于Timer（Timer是Java的一个定时器类）</p></li><li><p><strong>缺点</strong>：由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务（比如：一个任务出错，以后的任务都无法继续）。</p></li><li><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNewScheduledThreadPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//定义线程池大小为3</span><br>        ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> temp = i;<br>            newScheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;i:&quot;</span> + temp);<br>                &#125;<br>            &#125;, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<span class="hljs-comment">//这里表示延迟3秒执行。</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4.newSingleThreadExecutor"></a>4.newSingleThreadExecutor</h5></li><li><p><strong>特点</strong>：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，他必须保证前一项任务执行完毕才能执行后一项。保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p></li><li><p><strong>缺点</strong>：缺点的话，很明显，他是单线程的，高并发业务下有点无力</p></li><li><p><strong>总结</strong>：保证所有任务按照指定顺序执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它</p></li><li><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNewSingleThreadExecutor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            newSingleThreadExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; index:&quot;</span> + index);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">200</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程池</tag>
      
      <tag>方式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是线程池</title>
    <link href="/blog/2021/09/09/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/blog/2021/09/09/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h4><ul><li>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。<ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用</li></ul></li></ul><h4 id="线程池作用？"><a href="#线程池作用？" class="headerlink" title="线程池作用？"></a>线程池作用？</h4><ul><li>线程池是为突然大量爆发的线程设计的，通过有限的几个固定线程为大量的操作服务，减少了创建和销毁线程所需的时间，从而提高效率。</li><li>如果一个线程所需要执行的时间非常长的话，就没必要用线程池了(不是不能作长时间操作，而是不宜。本来降低线程创建和销毁，结果你那么久我还不好控制还不如直接创建线程)，况且我们还不能控制线程池中线程的开始、挂起、和中止。</li></ul><h4 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h4><ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li><li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><h4 id="什么是ThreadPoolExecutor？"><a href="#什么是ThreadPoolExecutor？" class="headerlink" title="什么是ThreadPoolExecutor？"></a>什么是ThreadPoolExecutor？</h4><ul><li><p><strong>ThreadPoolExecutor就是线程池</strong></p><p>ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）</p></li></ul><p>构造参数图：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172babf4c562f1~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">构造参数参数介绍：<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">corePoolSize 核心线程数量<br>maximumPoolSize 最大线程数量<br>keepAliveTime 线程保持时间，N个时间单位<br>unit 时间单位（比如秒，分）<br>workQueue 阻塞队列<br>threadFactory 线程工厂<br><span class="hljs-keyword">handler</span> 线程池拒绝策略<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="什么是Executors？"><a href="#什么是Executors？" class="headerlink" title="什么是Executors？"></a>什么是Executors？</h4><ul><li><p><strong>Executors框架实现的就是线程池的功能。</strong></p><p>Executors工厂类中提供的newCachedThreadPool、newFixedThreadPool 、newScheduledThreadPool 、newSingleThreadExecutor 等方法其实也只是ThreadPoolExecutor的构造函数参数不同而已。通过传入不同的参数，就可以构造出适用于不同应用场景下的线程池，</p></li></ul><p>Executor工厂类如何创建线程池图：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bab8fc18fd3~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized和volatile的区别</title>
    <link href="/blog/2021/09/08/synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/09/08/synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h4><ul><li>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</li><li>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</li></ul><p><strong>区别</strong></p><ul><li>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li></ul><h4 id="final不可变对象，它对写并发应用有什么帮助？"><a href="#final不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="final不可变对象，它对写并发应用有什么帮助？"></a>final不可变对象，它对写并发应用有什么帮助？</h4><ul><li>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</li><li>不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。</li><li>只有满足如下状态，一个对象才是不可变的；<ul><li>它的状态不能在创建后再被修改；</li><li>所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。<br></code></pre></td></tr></table></figure><h4 id="Lock-接口和synchronized-对比同步它有什么优势？"><a href="#Lock-接口和synchronized-对比同步它有什么优势？" class="headerlink" title="Lock 接口和synchronized 对比同步它有什么优势？"></a>Lock 接口和synchronized 对比同步它有什么优势？</h4><ul><li>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</li><li>它的优势有：<ul><li>（1）可以使锁更公平</li><li>（2）可以使线程在等待锁的时候响应中断</li><li>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li><li>（4）可以在不同的范围，以不同的顺序获取和释放锁</li></ul></li><li>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</li></ul><h4 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><ul><li>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</li><li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</li></ul><h4 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h4><ul><li>CAS 是 compare and swap 的缩写，即我们所说的比较交换。</li><li>cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。</li><li>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.atomic</span> 包下的类大多是使用 <span class="hljs-selector-tag">CAS</span> 操作来实现的(<span class="hljs-selector-tag">AtomicInteger</span>,<span class="hljs-selector-tag">AtomicBoolean</span>,<span class="hljs-selector-tag">AtomicLong</span>)<br></code></pre></td></tr></table></figure><h4 id="CAS-的会产生什么问题？"><a href="#CAS-的会产生什么问题？" class="headerlink" title="CAS 的会产生什么问题？"></a>CAS 的会产生什么问题？</h4><ul><li><p>1、ABA 问题：</p><p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p></li><li><p>2、循环时间长开销大：</p><p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p></li><li><p>3、只能保证一个共享变量的原子操作：</p><p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p></li></ul><h4 id="什么是原子类"><a href="#什么是原子类" class="headerlink" title="什么是原子类"></a>什么是原子类</h4><ul><li>java.util.concurrent.atomic包：是原子类的小工具包，支持在单个变量上解除锁的线程安全编程 原子变量类相当于一种泛化的 volatile 变量，能够支持原子的和有条件的读-改-写操作。</li><li>比如：AtomicInteger 表示一个int类型的值，并提供了 get 和 set 方法，这些 Volatile 类型的int变量在读取和写入上有着相同的内存语义。它还提供了一个原子的 compareAndSet 方法（如果该方法成功执行，那么将实现与读取/写入一个 volatile 变量相同的内存效果），以及原子的添加、递增和递减等方法。AtomicInteger 表面上非常像一个扩展的 Counter 类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">简单来说就是原子类来实现<span class="hljs-built_in">CAS</span>无锁模式的算法<br></code></pre></td></tr></table></figure><h4 id="原子类的常用类"><a href="#原子类的常用类" class="headerlink" title="原子类的常用类"></a>原子类的常用类</h4><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicReference</li></ul><h4 id="说一下-Atomic的原理？"><a href="#说一下-Atomic的原理？" class="headerlink" title="说一下 Atomic的原理？"></a>说一下 Atomic的原理？</h4><ul><li>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</li></ul><h4 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h4><ul><li><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p></li><li><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p></li><li><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p></li><li><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><p>Java 中导致饥饿的原因：</p><ul><li>1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li><li>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li><li>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>synchronized</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是自旋</title>
    <link href="/blog/2021/09/06/%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B/"/>
    <url>/blog/2021/09/06/%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h4><ul><li>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</li><li>忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</li></ul><h4 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h4><ul><li>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 <span class="hljs-keyword">Java </span><span class="hljs-number">6</span> 之后优化 <span class="hljs-keyword">synchronized </span>的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br></code></pre></td></tr></table></figure><ul><li>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</li><li>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，轻量级锁就会升级为重量级锁；</li><li>重量级锁是synchronized ，是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</li></ul><h4 id="线程-B-怎么知道线程-A-修改了变量"><a href="#线程-B-怎么知道线程-A-修改了变量" class="headerlink" title="线程 B 怎么知道线程 A 修改了变量"></a>线程 B 怎么知道线程 A 修改了变量</h4><ul><li>（1）volatile 修饰变量</li><li>（2）synchronized 修饰修改变量的方法</li><li>（3）wait/notify</li><li>（4）while 轮询</li></ul><h4 id="当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h4><ul><li>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</li></ul><h4 id="synchronized、volatile、CAS-比较"><a href="#synchronized、volatile、CAS-比较" class="headerlink" title="synchronized、volatile、CAS 比较"></a>synchronized、volatile、CAS 比较</h4><ul><li>（1）synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。</li><li>（2）volatile 提供多线程共享变量可见性和禁止指令重排序优化。</li><li>（3）CAS 是基于冲突检测的乐观锁（非阻塞）</li></ul><h4 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h4><ul><li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</li><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h4 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h4><ul><li><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p></li><li><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p></li><li><p>相同点：两者都是可重入锁</p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p></li><li><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li><li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li></ul></li><li><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul></li></ul><h4 id="volatile-关键字的作用"><a href="#volatile-关键字的作用" class="headerlink" title="volatile 关键字的作用"></a>volatile 关键字的作用</h4><ul><li>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。</li><li>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</li><li>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</li></ul><h4 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h4><ul><li>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</li></ul><h4 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h4><ul><li>volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</li><li>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li></ul><h4 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h4><ul><li>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</li><li>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。</li></ul><p><strong>所以从Oracle Java Spec里面可以看到：</strong></p><ul><li>对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</li><li>如果使用volatile修饰long和double，那么其读写都是原子操作</li><li>对于64位的引用地址的读写，都是原子操作</li><li>在实现JVM时，可以自由选择是否把读写long和double作为原子操作</li><li>推荐JVM实现为原子操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自旋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重排序实际执行的指令步骤</title>
    <link href="/blog/2021/09/05/%E9%87%8D%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C/"/>
    <url>/blog/2021/09/05/%E9%87%8D%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="重排序实际执行的指令步骤"><a href="#重排序实际执行的指令步骤" class="headerlink" title="重排序实际执行的指令步骤"></a>重排序实际执行的指令步骤</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bab5818fe21~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><ul><li>这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。</li></ul><h4 id="重排序遵守的规则"><a href="#重排序遵守的规则" class="headerlink" title="重排序遵守的规则"></a>重排序遵守的规则</h4><ul><li>as-if-serial：<ol><li>不管怎么排序，结果不能改变</li><li>不存在数据依赖的可以被编译器和处理器重排序</li><li>一个操作依赖两个操作，这两个操作如果不存在依赖可以重排序</li><li>单线程根据此规则不会有问题，但是重排序后多线程会有问题</li></ol></li></ul><h4 id="as-if-serial规则和happens-before规则的区别"><a href="#as-if-serial规则和happens-before规则的区别" class="headerlink" title="as-if-serial规则和happens-before规则的区别"></a>as-if-serial规则和happens-before规则的区别</h4><ul><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ul><h4 id="并发关键字-synchronized-？"><a href="#并发关键字-synchronized-？" class="headerlink" title="并发关键字 synchronized ？"></a>并发关键字 synchronized ？</h4><ul><li>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。</li><li>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li></ul><h4 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h4><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li>修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li><li>修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">总结： synchronized 关键字加到 static 静态方法和 synchronized(<span class="hljs-keyword">class</span>)代码块上都是是给 <span class="hljs-symbol">Class</span> 类上锁。<span class="hljs-symbol">synchronized</span> 关键字加到实例方法上是给对象实例上锁。尽量不要使用 <span class="hljs-symbol">synchronized</span>(<span class="hljs-symbol">String</span> <span class="hljs-symbol">a</span>) 因为<span class="hljs-symbol">JVM</span>中，字符串常量池具有缓存功能！<br></code></pre></td></tr></table></figure><h4 id="单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”"><a href="#单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”" class="headerlink" title="单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”"></a>单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”</h4><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><p><strong>说明：</strong></p><ul><li><p>双锁机制的出现是为了解决前面同步问题和性能问题，看下面的代码，简单分析下确实是解决了多线程并行进来不会出现重复new对象，而且也实现了懒加载</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> volatile <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-function"><span class="hljs-title">getUniqueInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>      <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">//类对象加锁</span><br>          synchronized (Singleton.class) &#123;<br>              <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                  uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> uniqueInstance;<br>  &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>}</p></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">另外，需要注意 uniqueInstance 采用 <span class="hljs-keyword">volatile</span> 关键字修饰也是很有必要。<br></code></pre></td></tr></table></figure><ul><li>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</li></ul><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">但是由于 <span class="hljs-keyword">JVM </span>具有指令重排的特性，执行顺序有可能变成 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 <span class="hljs-built_in">T1</span> 执行了 <span class="hljs-number">1</span> 和 <span class="hljs-number">3</span>，此时 <span class="hljs-built_in">T2</span> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。<br>使用 volatile 可以禁止 <span class="hljs-keyword">JVM </span>的指令重排，保证在多线程环境下也能正常运行。<br></code></pre></td></tr></table></figure><h4 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h4><ul><li><p>Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，</p></li><li><p>每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态并且尝试获取monitor的所有权 ，过程：</p><p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p><p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p><p>3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">synchronized</span>是可以通过 反汇编指令 javap命令，查看相应的字节码文件。<br></code></pre></td></tr></table></figure><h4 id="synchronized可重入的原理"><a href="#synchronized可重入的原理" class="headerlink" title="synchronized可重入的原理"></a>synchronized可重入的原理</h4><ul><li>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>重排序实际</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发理论</title>
    <link href="/blog/2021/09/04/%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA/"/>
    <url>/blog/2021/09/04/%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="并发理论"><a href="#并发理论" class="headerlink" title="并发理论"></a>并发理论</h2><h4 id="Java中垃圾回收有什么目的？什么时候进行垃圾回收？"><a href="#Java中垃圾回收有什么目的？什么时候进行垃圾回收？" class="headerlink" title="Java中垃圾回收有什么目的？什么时候进行垃圾回收？"></a>Java中垃圾回收有什么目的？什么时候进行垃圾回收？</h4><ul><li>垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。</li><li>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</li></ul><h4 id="线程之间如何通信及线程之间如何同步"><a href="#线程之间如何通信及线程之间如何同步" class="headerlink" title="线程之间如何通信及线程之间如何同步"></a>线程之间如何通信及线程之间如何同步</h4><ul><li>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：共享内存和消息传递。</li><li>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</li></ul><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><ul><li>共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bab46986d99~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：<ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ol></li></ul><p><strong>下面通过示意图来说明线程之间的通信</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bab7ff494ac~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>总结：什么是Java内存模型：java内存模型简称jmm，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。</li></ul><h4 id="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h4><ul><li>不会，在下一个垃圾回调周期中，这个对象将是被可回收的。</li><li>也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。</li></ul><h4 id="finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h4><ul><li>1.垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法； finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws Throwable { } 在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间</li><li><ol><li>GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。<ul><li>Finalizetion主要用来释放被对象占用的资源（不是指内存，而是指其他资源，比如文件(File Handle)、端口(ports)、数据库连接(DB Connection)等）。然而，它不能真正有效地工作。</li></ul></li></ol></li></ul><h4 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h4><ul><li>程序执行的顺序按照代码的先后顺序执行。</li><li>一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，进行重新排序（重排序），它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">int <span class="hljs-keyword">a</span> = <span class="hljs-number">5</span>;   <span class="hljs-comment"> //语句1</span><br>int r = <span class="hljs-number">3</span>;   <span class="hljs-comment"> //语句2</span><br><span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span> + <span class="hljs-number">2</span>;   <span class="hljs-comment"> //语句3</span><br>r = <span class="hljs-keyword">a</span>*<span class="hljs-keyword">a</span>;     <span class="hljs-comment"> //语句4</span><br>复制代码<br></code></pre></td></tr></table></figure><ul><li>则因为重排序，他还可能执行顺序为（这里标注的是语句的执行顺序） 2-1-3-4，1-3-2-4 但绝不可能 2-1-4-3，因为这打破了依赖关系。</li><li>显然重排序对单线程运行是不会有任何问题，但是多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程类的构造方法</title>
    <link href="/blog/2021/09/03/%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/09/03/%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h4><ul><li>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</li><li>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：</li></ul><p>（1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的</p><p>（2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的</p><h4 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？"><a href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？" class="headerlink" title="Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</h4><ul><li>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。</li><li>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。</li><li>在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</li></ul><h4 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h4><ul><li>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</li></ul><h4 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h4><ul><li><p>线程的生命周期开销非常高</p></li><li><p>消耗过多的 CPU</p><p>资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</p></li><li><p>降低稳定性JVM</p><p>在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p></li></ul><h4 id="多线程的常用方法"><a href="#多线程的常用方法" class="headerlink" title="多线程的常用方法"></a>多线程的常用方法</h4><table><thead><tr><th>方法 名</th><th>描述</th></tr></thead><tbody><tr><td>sleep()</td><td>强迫一个线程睡眠Ｎ毫秒</td></tr><tr><td>isAlive()</td><td>判断一个线程是否存活。</td></tr><tr><td>join()</td><td>等待线程终止。</td></tr><tr><td>activeCount()</td><td>程序中活跃的线程数。</td></tr><tr><td>enumerate()</td><td>枚举程序中的线程。</td></tr><tr><td>currentThread()</td><td>得到当前线程。</td></tr><tr><td>isDaemon()</td><td>一个线程是否为守护线程。</td></tr><tr><td>setDaemon()</td><td>设置一个线程为守护线程。</td></tr><tr><td>setName()</td><td>为线程设置一个名称。</td></tr><tr><td>wait()</td><td>强迫一个线程等待。</td></tr><tr><td>notify()</td><td>通知一个线程继续运行。</td></tr><tr><td>setPriority()</td><td>设置一个线程的优先级。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>构造方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步方法和同步块</title>
    <link href="/blog/2021/09/01/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E5%9D%97/"/>
    <url>/blog/2021/09/01/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h4 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h4><ul><li>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</li><li>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">请知道一条原则：同步的范围越小越好。<br></code></pre></td></tr></table></figure><h4 id="什么是线程同步和线程互斥，有哪几种实现方式？"><a href="#什么是线程同步和线程互斥，有哪几种实现方式？" class="headerlink" title="什么是线程同步和线程互斥，有哪几种实现方式？"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h4><ul><li>当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。</li><li>在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。</li><li>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</li><li>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</li><li>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</li><li>实现线程同步的方法<ul><li>同步代码方法：sychronized 关键字修饰的方法</li><li>同步代码块：sychronized 关键字修饰的代码块</li><li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li><li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了lock接口的锁他与sychronized方法具有相同的基本行为和语义</li></ul></li></ul><h4 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h4><ul><li>在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</li><li>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</li><li>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</li></ul><h4 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h4><ul><li><p>有俩种可能：</p><p>（1）如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</p><p>（2）如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy</p></li></ul><h4 id="什么叫线程安全？servlet-是线程安全吗"><a href="#什么叫线程安全？servlet-是线程安全吗" class="headerlink" title="什么叫线程安全？servlet 是线程安全吗?"></a>什么叫线程安全？servlet 是线程安全吗?</h4><ul><li>线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</li><li>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</li><li>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。</li><li>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</li><li>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</li></ul><h4 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h4><ul><li><p>方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger</p></li><li><p>方法二：使用自动锁 synchronized。</p></li><li><p>方法三：使用手动锁 Lock。</p></li><li><p>手动锁 Java 示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">lock</span>. <span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    System. <span class="hljs-keyword">out</span>. println(<span class="hljs-string">&quot;获得锁&quot;</span>);<br>&#125; catch (Exception e) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System. <span class="hljs-keyword">out</span>. println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>    <span class="hljs-keyword">lock</span>. unlock();<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h4></li><li><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</p></li><li><p>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p></li><li><p>当然，如果你真的想设置优先级可以通过setPriority()方法设置，但是设置了不一定会该变，这个是不准确的</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的sleep()方法和yield()</title>
    <link href="/blog/2021/08/31/%E7%BA%BF%E7%A8%8B%E7%9A%84%20sleep()%E6%96%B9%E6%B3%95%E5%92%8C%20yield/"/>
    <url>/blog/2021/08/31/%E7%BA%BF%E7%A8%8B%E7%9A%84%20sleep()%E6%96%B9%E6%B3%95%E5%92%8C%20yield/</url>
    
    <content type="html"><![CDATA[<h4 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h4><ul><li>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</li><li>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</li><li>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</li></ul><h4 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h4><ul><li>在java中有以下3种方法可以终止正在运行的线程：<ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li><li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li><li>使用interrupt方法中断线程。</li></ul></li></ul><h4 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h4><ul><li><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p><p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p></li><li><p>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p></li><li><p>isInterrupted：是可以返回当前中断信号是true还是false，与interrupt最大的差别</p></li></ul><h4 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h4><ul><li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</li></ul><h4 id="Java-中你怎样唤醒一个阻塞的线程？"><a href="#Java-中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java 中你怎样唤醒一个阻塞的线程？"></a>Java 中你怎样唤醒一个阻塞的线程？</h4><ul><li>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</li><li>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</li></ul><h4 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h4><ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</li><li>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</li></ul><h4 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h4><ul><li>在两个线程间共享变量即可实现共享。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。<br></code></pre></td></tr></table></figure><h4 id="Java-如何实现多线程之间的通讯和协作？"><a href="#Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="Java 如何实现多线程之间的通讯和协作？"></a>Java 如何实现多线程之间的通讯和协作？</h4><ul><li>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</li><li>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</li><li>Java中线程通信协作的最常见方式：<ul><li>一.syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()</li><li>二.ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</li></ul></li><li>线程间直接的数据交换：<ul><li>三.通过管道进行线程间通信：字节流、字符流</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sleep</tag>
      
      <tag>yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的状态</title>
    <link href="/blog/2021/08/29/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <url>/blog/2021/08/29/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bab4672a149~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>新建(new)：新创建了一个线程对象。</li><li>就绪（可运行状态）(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</li><li>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li><li>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。<ul><li>阻塞的情况分三种：<ul><li>(一). 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；</li><li>(二). 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；</li><li>(三). 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</li></ul></li></ul></li><li>死亡(dead)(结束)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ul><h4 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h4><ul><li>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。（Java是由JVM中的线程计数器来实现线程调度）</li><li>有两种调度模型：分时调度模型和抢占式调度模型。<ul><li>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</li><li>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</li></ul></li></ul><h4 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：<br></code></pre></td></tr></table></figure><ul><li>（1）线程体中调用了 yield 方法让出了对 cpu 的占用权利</li><li>（2）线程体中调用了 sleep 方法使线程进入睡眠状态</li><li>（3）线程由于 IO 操作受到阻塞</li><li>（4）另外一个更高优先级线程出现</li><li>（5）在支持时间片的系统中，该线程的时间片用完</li></ul><h4 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</h4><ul><li>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</li><li>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。</li><li>线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</li></ul><h4 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h4><ul><li>（1） wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</li><li>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li></ul><h4 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">两者都可以暂停线程的执行<br></code></pre></td></tr></table></figure><ul><li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li><li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li></ul><h4 id="你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><ul><li>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</li><li>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">synchronized (monitor) &#123;<br>    <span class="hljs-regexp">//</span>  判断条件谓词是否得到满足<br>    <span class="hljs-keyword">while</span>(!locked) &#123;<br>        <span class="hljs-regexp">//</span>  等待唤醒<br>        monitor.wait();<br>    &#125;<br>    <span class="hljs-regexp">//</span>  处理其他的业务逻辑<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h4><ul><li>因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</li><li>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</li></ul><h4 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h4><ul><li>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</li></ul><h4 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h4><ul><li>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</li><li>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</li></ul><h4 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h4><ul><li>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建线程的四种方式</title>
    <link href="/blog/2021/08/28/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/blog/2021/08/28/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h4><ul><li><p>继承 Thread 类；</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br>public void run() &#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-type">Thread</span>.currentThread().getName() + <span class="hljs-string">&quot; run()方法正在执行...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现 Runnable 接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; run()方法执行中...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现 Callable 接口；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyCallable</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Callable</span>&lt;<span class="hljs-symbol">Integer</span>&gt; &#123;<br>@Override<br><span class="hljs-keyword">public</span> Integer call() &#123;<br>    System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; call()方法执行中...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用匿名内部类方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateRunnable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-comment">//创建多线程创建开始</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;i:&quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="说一下-runnable-和-callable-有什么区别"><a href="#说一下-runnable-和-callable-有什么区别" class="headerlink" title="说一下 runnable 和 callable 有什么区别"></a>说一下 runnable 和 callable 有什么区别</h4></li></ul><p><strong>相同点：</strong></p><ul><li>都是接口</li><li>都可以编写多线程程序</li><li>都采用Thread.start()启动线程</li></ul><p><strong>主要区别：</strong></p><ul><li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息 注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li></ul><h4 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h4><ul><li>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</li><li>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</li><li>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</li><li>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</li></ul><h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><ul><li>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到<code>时间片</code>后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</li><li>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h4 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h4><ul><li>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</li><li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。</li></ul><h4 id="什么是-FutureTask"><a href="#什么是-FutureTask" class="headerlink" title="什么是 FutureTask"></a>什么是 FutureTask</h4><ul><li>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方式</tag>
      
      <tag>创建线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是上下文切换</title>
    <link href="/blog/2021/08/27/%E7%BA%BF%E7%A8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    <url>/blog/2021/08/27/%E7%BA%BF%E7%A8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h4><ul><li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</li><li>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</li><li>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</li><li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li></ul><h4 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h4><ul><li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li></ul><h4 id="如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？"><a href="#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？" class="headerlink" title="如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h4><ul><li>windows上面用任务管理器看，linux下可以用 top 这个工具看。<ul><li>找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p (shift+m是找出消耗内存最高)查找出cpu利用最厉害的pid号</li><li>根据上面第一步拿到的pid号，top -H -p pid 。然后按下shift+p，查找出cpu利用率最厉害的线程号，比如top -H -p 1328</li><li>将获取到的线程号转换成16进制，去百度转换一下就行</li><li>使用jstack工具将进程信息打印输出，jstack pid号 &gt; /tmp/t.dat，比如jstack 31365 &gt; /tmp/t.dat</li><li>编辑/tmp/t.dat文件，查找线程号对应的信息</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">或者直接使用<span class="hljs-keyword">JDK自带的工具查看“jconsole” </span>、“visualVm”，这都是<span class="hljs-keyword">JDK自带的，可以直接在JDK的bin目录下找到直接使用</span><br></code></pre></td></tr></table></figure><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><ul><li>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</li><li>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</li><li>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172bab440e1912~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h4 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h4><ul><li>互斥条件：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等待，直至占有资源的进程用毕释放。</li><li>占有且等待条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。（比如一个进程集合，A在等B，B在等C，C在等A）</li></ul><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><ol><li>避免一个线程同时获得多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络操作IO讲解</title>
    <link href="/blog/2021/08/14/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9CIO%E8%AE%B2%E8%A7%A3/"/>
    <url>/blog/2021/08/14/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9CIO%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="网络操作IO讲解"><a href="#网络操作IO讲解" class="headerlink" title="网络操作IO讲解"></a>网络操作IO讲解</h4><ul><li>我这使用Socket简单的来模拟网络编程IO会带来的问题</li><li>不懂Socket可以看我之前的文章，这个东西很容易懂的，就是基于TCP实现的网络通信，比http要快，很多实现网络通信的框架都是基于Socket来实现 </li></ul><h4 id="网络操作IO编程演变历史"><a href="#网络操作IO编程演变历史" class="headerlink" title="网络操作IO编程演变历史"></a>网络操作IO编程演变历史</h4><h5 id="1-BIO编程会出现什么问题？"><a href="#1-BIO编程会出现什么问题？" class="headerlink" title="1 BIO编程会出现什么问题？"></a>1 BIO编程会出现什么问题？</h5><ul><li><p>BIO是阻塞的</p></li><li><p><strong>例子：</strong> 阻塞IO（blocking I/O） A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c26ae3362~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><ul><li><p>看起来没问题，但是我很多请求一起发送请求资源怎么办：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c5ec173ed~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>那不是要等待第一个人资源完成后后面的人才可以继续？</p><p>因为BIO是阻塞的所以读取写出操作都是非常浪费资源的</p></li></ul><p><strong>BIO代码示例：</strong>（<code>后面有代码，往后移动一点点，认真看，代码学习量很足</code>）</p><ul><li><p>我这有三个类，我模拟启动服务端，然后启动客户端，模拟客户端操作未完成的时候启动第二个客户端</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c715ef960~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><ol><li><p>启动服务端（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">后面有代码，我这是教运行顺序<br></code></pre></td></tr></table></figure><p>）</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c77b5d822~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>启动第一个客户端，发现服务器显示连接成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">先不要在控制台 输入 ，模拟堵塞。（我的代码输入了就代表请求完成了）<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ce080820b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>·</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d10781adf~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>启动第二个客户端，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">发现服务端没效果<br></code></pre></td></tr></table></figure><p>，而客户端连接成功（在堵塞当中）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">我这启动了俩个<span class="hljs-built_in">Client</span>，注意看，(这俩个代码是一样的)<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d22d2cf71~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>·</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d4362ca3f~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>第一个客户控制台输入，输入完后就会关闭第一个客户端， 在看服务端发现第二个客户端连接上来了</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d395b9f07~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>·</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d66ef456c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ol><p><strong>BIO通信代码：</strong></p><ul><li>TCP协议Socket使用BIO进行通信：服务端（先执行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">//TCP协议Socket使用BIO进行通信：服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;<br>    <span class="hljs-comment">// 在main线程中执行下面这些代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//使用Socket进行网络通信</span><br>        ServerSocket server = <span class="hljs-keyword">null</span>;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//基于字节流</span><br>        InputStream in = <span class="hljs-keyword">null</span>;<br>        OutputStream out = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8000</span>);<br>            System.out.println(<span class="hljs-string">&quot;服务端启动成功，监听端口为8000，等待客户端连接...&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                socket = server.accept(); <span class="hljs-comment">//等待客户端连接</span><br>                System.out.println(<span class="hljs-string">&quot;客户连接成功，客户信息为：&quot;</span> + socket.getRemoteSocketAddress());<br>                in = socket.getInputStream();<br>                <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//读取客户端的数据</span><br>                <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(<span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, len));<br>                &#125;<br>                <span class="hljs-comment">//向客户端写数据</span><br>                out = socket.getOutputStream();<br>                out.write(<span class="hljs-string">&quot;hello!&quot;</span>.getBytes());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>TCP协议Socket使用BIO进行通信：客户端（第二执行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//TCP协议Socket使用BIO进行通信：客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建套接字对象socket并封装ip与port</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>);<br>        <span class="hljs-comment">//根据创建的socket对象获得一个输出流</span><br>        <span class="hljs-comment">//基于字节流</span><br>        OutputStream outputStream = socket.getOutputStream();<br>        <span class="hljs-comment">//控制台输入以IO的形式发送到服务器</span><br>        System.out.println(<span class="hljs-string">&quot;TCP连接成功 \n请输入：&quot;</span>);<br>        String str = <span class="hljs-keyword">new</span> Scanner(System.in).nextLine();<br>        <span class="hljs-keyword">byte</span>[] car = str.getBytes();<br>        outputStream.write(car);<br>        System.out.println(<span class="hljs-string">&quot;TCP协议的Socket发送成功&quot;</span>);<br>        <span class="hljs-comment">//刷新缓冲区</span><br>        outputStream.flush();<br>        <span class="hljs-comment">//关闭连接</span><br>        socket.close();<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>TCP协议Socket使用BIO进行通信：客户端（第三执行）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//TCP协议Socket：客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建套接字对象socket并封装ip与port</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>);<br>        <span class="hljs-comment">//根据创建的socket对象获得一个输出流</span><br>        <span class="hljs-comment">//基于字节流</span><br>        OutputStream outputStream = socket.getOutputStream();<br>        <span class="hljs-comment">//控制台输入以IO的形式发送到服务器</span><br>        System.out.println(<span class="hljs-string">&quot;TCP连接成功 \n请输入：&quot;</span>);<br>        String str = <span class="hljs-keyword">new</span> Scanner(System.in).nextLine();<br>        <span class="hljs-keyword">byte</span>[] car = str.getBytes();<br>        outputStream.write(car);<br>        System.out.println(<span class="hljs-string">&quot;TCP协议的Socket发送成功&quot;</span>);<br>        <span class="hljs-comment">//刷新缓冲区</span><br>        outputStream.flush();<br>        <span class="hljs-comment">//关闭连接</span><br>        socket.close();<br>    &#125;<br>&#125;<br>复制代码<br>为了解决堵塞问题，可以使用多线程，请看下面<br></code></pre></td></tr></table></figure><h5 id="2-多线程解决BIO编程会出现的问题"><a href="#2-多线程解决BIO编程会出现的问题" class="headerlink" title="2 多线程解决BIO编程会出现的问题"></a>2 多线程解决BIO编程会出现的问题</h5><p><strong>这时有人就会说，我多线程不就解决了吗?</strong></p><ul><li><p>使用多线程是可以解决堵塞等待时间很长的问题，因为他可以充分发挥CPU</p></li><li><p>然而系统资源是有限的，不能过多的新建线程，线程过多带来线程上下文的切换，从来带来更大的性能损耗</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dd68f7c10~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><p><strong>万一请求越来越多，线程越来越多那我CPU不就炸了？</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d696381b8~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p><strong>多线程BIO代码示例：</strong></p><ul><li><p>四个客户端，这次我多复制了俩个一样客户端类</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d7a9bf162~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">先启动服务端，在启动所有客户端，测试<br></code></pre></td></tr></table></figure><p>，发现连接成功（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">后面有代码<br></code></pre></td></tr></table></figure><p>）</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d94da3441~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>在所有客户端输入消息（</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Clie<span class="hljs-symbol">nt01</span>、Clie<span class="hljs-symbol">nt02</span>这些是我在客户端输入的消息<br></code></pre></td></tr></table></figure><p>）：发现没有问题</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d94251e4b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><p><strong>多线程BIO通信代码：</strong></p><ul><li><code>服务端的代码，客户端的代码还是上面之前的代码</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">//TCP协议Socket使用多线程BIO进行通行：服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOThreadService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8000</span>);<br>            System.out.println(<span class="hljs-string">&quot;服务端启动成功，监听端口为8000，等待客户端连接... &quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = server.accept();<span class="hljs-comment">//等待客户连接</span><br>                System.out.println(<span class="hljs-string">&quot;客户连接成功，客户信息为：&quot;</span> + socket.getRemoteSocketAddress());<br>                <span class="hljs-comment">//针对每个连接创建一个线程， 去处理I0操作</span><br>                <span class="hljs-comment">//创建多线程创建开始</span><br>                Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            InputStream in = socket.getInputStream();<br>                            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>                            <span class="hljs-comment">//读取客户端的数据</span><br>                            <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                                System.out.println(<span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, len));<br>                            &#125;<br>                            <span class="hljs-comment">//向客户端写数据</span><br>                            OutputStream out = socket.getOutputStream();<br>                            out.write(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>                thread.start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br>为了解决线程太多，这时又来了，线程池<br></code></pre></td></tr></table></figure><h5 id="3-线程池解决多线程BIO编程会出现的问题"><a href="#3-线程池解决多线程BIO编程会出现的问题" class="headerlink" title="3 线程池解决多线程BIO编程会出现的问题"></a>3 线程池解决多线程BIO编程会出现的问题</h5><p><strong>这时有人就会说，我TM用线程池?</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dab69e263~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><ul><li>线程池固然可以解决这个问题，万一需求量还不够还要扩大线程池。当是这是我们自己靠着自己的思想完成的IO操作，Socket 上来了就去创建线程去抢夺CPU资源，MD，线程都TM做IO去了，CPU也不舒服呀</li><li>这时呢：Jdk官方坐不住了，兄弟BIO的问题交给我，我来给你解决：<code>NIO的诞生</code></li></ul><p><strong>线程池BIO代码示例：</strong></p><ul><li><p>四个客户端</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2da7389a42~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">先启动服务端，在启动所有客户端，测试<br></code></pre></td></tr></table></figure><p>，（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">后面有代码<br></code></pre></td></tr></table></figure><p>）</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc163e25a~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>在所有客户端输入消息（</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Clie<span class="hljs-symbol">nt01</span>、Clie<span class="hljs-symbol">nt02</span>这些是我在客户端输入的消息<br></code></pre></td></tr></table></figure><p>）：发现没有问题</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc2080d3a~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><p><strong>线程池BIO通信代码：</strong></p><ul><li><code>服务端的代码，客户端的代码还是上面的代码</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-comment">//TCP协议Socket使用线程池BIO进行通行：服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOThreadPoolService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">30</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8000</span>);<br>            System.out.println(<span class="hljs-string">&quot;服务端启动成功，监听端口为8000，等待客户端连接...&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = server.accept();<span class="hljs-comment">//等待客户连接</span><br>                System.out.println(<span class="hljs-string">&quot;客户连接成功，客户信息为：&quot;</span> + socket.getRemoteSocketAddress());<br>                <span class="hljs-comment">//使用线程池中的线程去执行每个对应的任务</span><br>                executorService.execute(<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            InputStream in = socket.getInputStream();<br>                            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>                            <span class="hljs-comment">//读取客户端的数据</span><br>                            <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                                System.out.println(<span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, len));<br>                            &#125;<br>                            <span class="hljs-comment">//向客户端写数据</span><br>                            OutputStream out = socket.getOutputStream();<br>                            out.write(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br>                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>                );<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-使用NIO实现网络通信"><a href="#4-使用NIO实现网络通信" class="headerlink" title="4 使用NIO实现网络通信"></a>4 使用NIO实现网络通信</h5><ul><li>NIO是JDK1.4提供的操作，他的流还是流，没有改变，服务器实现的还是一个连接一个线程，当是：<code>客户端发送的连接请求都会注册到多路复用器上</code>，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4之后开始支持。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc3e76709~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">看不懂介绍可以认真看看代码实例，其实不难<br></code></pre></td></tr></table></figure><h6 id="什么是通道（Channel）"><a href="#什么是通道（Channel）" class="headerlink" title="什么是通道（Channel）"></a>什么是通道（Channel）</h6><ul><li>Channel是一个对象，可以通过它读取和写入数据。 通常我们都是将数据写入包含一个或者多个字节的缓冲区，然后再将缓存区的数据写入到通道中，将数据从通道读入缓冲区，再从缓冲区获取数据。</li><li>Channel 类似于原I/O中的流（Stream），但有所区别：<ul><li>流是单向的，通道是双向的，可读可写。</li><li>流读写是阻塞的，通道可以异步读写。</li></ul></li></ul><h6 id="什么是选择器（Selector）"><a href="#什么是选择器（Selector）" class="headerlink" title="什么是选择器（Selector）"></a>什么是选择器（Selector）</h6><ul><li>Selector可以称他为通道的集合，每次客户端来了之后我们会把Channel注册到Selector中并且我们给他一个状态，在用死循环来环判断(<code>判断是否做完某个操作，完成某个操作后改变不一样的状态</code>)状态是否发生变化，知道IO操作完成后在退出死循环</li></ul><h6 id="什么是Buffer（缓冲区）"><a href="#什么是Buffer（缓冲区）" class="headerlink" title="什么是Buffer（缓冲区）"></a>什么是Buffer（缓冲区）</h6><ul><li>Buffer 是一个缓冲数据的对象， 它包含一些要写入或者刚读出的数据。</li><li>在普通的面向流的 I/O 中，一般将数据直接写入或直接读到 Stream 对象中。当是有了Buffer（缓冲区）后，数据第一步到达的是Buffer（缓冲区）中</li><li>缓冲区实质上是一个数组(<code>底层完全是数组实现的，感兴趣可以去看一下</code>)。通常它是一个字节数组，内部维护几个状态变量，可以实现在同一块缓冲区上反复读写（不用清空数据再写）。</li></ul><h6 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h6><ul><li><p>目录结构</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dd02ee59c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p>运行示例，先运行服务端，在运行所有客户端控制台输入消息就好了。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">我这客户端和服务端代码有些修该变，后面有代码<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2de8321be5~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li><li><p><code>服务端示例，先运行，想要搞定NIO请认真看代码示例，真的很清楚</code></p></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.test.io;<br><br><span class="hljs-keyword">import</span> com.lijie.iob.RequestHandler;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<br><span class="hljs-keyword">import</span> java.nio.channels.Selector;<br><span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;<br>        <span class="hljs-comment">//111111111</span><br>        <span class="hljs-comment">//Service端的Channel，监听端口的</span><br>        ServerSocketChannel serverChannel = ServerSocketChannel.<span class="hljs-built_in">open</span>();<br>        <span class="hljs-comment">//设置为非阻塞</span><br>        serverChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//nio的api规定这样赋值端口</span><br>        serverChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8000</span>));<br>        <span class="hljs-comment">//显示Channel是否已经启动成功，包括绑定在哪个地址上</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;服务端启动成功，监听端口为8000，等待客户端连接...&quot;</span>+ serverChannel.getLocalAddress());<br><br>        <span class="hljs-comment">//22222222</span><br>        <span class="hljs-comment">//声明selector选择器</span><br>        Selector selector = Selector.<span class="hljs-built_in">open</span>();<br>        <span class="hljs-comment">//这句话的含义，是把selector注册到Channel上面，</span><br>        <span class="hljs-comment">//每个客户端来了之后，就把客户端注册到Selector选择器上,默认状态是Accepted</span><br>        serverChannel.<span class="hljs-keyword">register</span>(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-comment">//33333333</span><br>        <span class="hljs-comment">//创建buffer缓冲区，声明大小是1024，底层使用数组来实现的</span><br>        ByteBuffer <span class="hljs-built_in">buffer</span> = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        RequestHandler requestHandler = <span class="hljs-keyword">new</span> RequestHandler();<br><br>        <span class="hljs-comment">//444444444</span><br>        <span class="hljs-comment">//轮询，服务端不断轮询，等待客户端的连接</span><br>        <span class="hljs-comment">//如果有客户端轮询上来就取出对应的Channel，没有就一直轮询</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">int</span> select = selector.select();<br>            <span class="hljs-keyword">if</span> (select == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//有可能有很多，使用Set保存Channel</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-comment">//使用SelectionKey来获取连接了客户端和服务端的Channel</span><br>                SelectionKey key = iterator.next();<br>                <span class="hljs-comment">//判断SelectionKey中的Channel状态如何，如果是OP_ACCEPT就进入</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-comment">//从判断SelectionKey中取出Channel</span><br>                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">//拿到对应客户端的Channel</span><br>                    SocketChannel clientChannel = channel.accept();<br>                    <span class="hljs-comment">//把客户端的Channel打印出来</span><br>                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;客户端通道信息打印：&quot;</span> + clientChannel.getRemoteAddress());<br>                    <span class="hljs-comment">//设置客户端的Channel设置为非阻塞</span><br>                    clientChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">//操作完了改变SelectionKey中的Channel的状态OP_READ</span><br>                    clientChannel.<span class="hljs-keyword">register</span>(selector, SelectionKey.OP_READ);<br>                &#125;<br>                <span class="hljs-comment">//到此轮训到的时候，发现状态是read，开始进行数据交互</span><br>                <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-comment">//以buffer作为数据桥梁</span><br>                    SocketChannel channel = (SocketChannel) key.channel();<br>                    <span class="hljs-comment">//数据要想读要先写，必须先读取到buffer里面进行操作</span><br>                    channel.<span class="hljs-built_in">read</span>(<span class="hljs-built_in">buffer</span>);<br>                    <span class="hljs-comment">//进行读取</span><br>                    <span class="hljs-keyword">String</span> request = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">array</span>()).trim();<br>                    <span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">clear</span>();<br>                    <span class="hljs-comment">//进行打印buffer中的数据</span><br>                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;客户端发来的消息： %s : %s&quot;</span>, channel.getRemoteAddress(), request));<br>                    <span class="hljs-comment">//要返回数据的话也要先返回buffer里面进行返回</span><br>                    <span class="hljs-keyword">String</span> response = requestHandler.handle(request);<br>                    <span class="hljs-comment">//然后返回出去</span><br>                    channel.<span class="hljs-built_in">write</span>(ByteBuffer.wrap(response.getBytes()));<br>                &#125;<br>                iterator.<span class="hljs-built_in">remove</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>客户端示例：（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">我这用的不是之前的了，有修改<br></code></pre></td></tr></table></figure><p>）运行起来客户端控制台输入消息就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">要模拟测试，请复制粘贴改一下，修改客户端的类名就行了，四个客户端代码一样的<br></code></pre></td></tr></table></figure><p>,</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dee3a5661~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//TCP协议Socket：客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建套接字对象socket并封装ip与port</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>);<br>        <span class="hljs-comment">//根据创建的socket对象获得一个输出流</span><br>        OutputStream outputStream = socket.getOutputStream();<br>        <span class="hljs-comment">//控制台输入以IO的形式发送到服务器</span><br>        System.out.println(<span class="hljs-string">&quot;TCP连接成功 \n请输入：&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">byte</span>[] car = <span class="hljs-keyword">new</span> Scanner(System.in).nextLine().getBytes();<br>            outputStream.write(car);<br>            System.out.println(<span class="hljs-string">&quot;TCP协议的Socket发送成功&quot;</span>);<br>            <span class="hljs-comment">//刷新缓冲区</span><br>            outputStream.flush();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-使用Netty实现网络通信"><a href="#5-使用Netty实现网络通信" class="headerlink" title="5 使用Netty实现网络通信"></a>5 使用Netty实现网络通信</h5><ul><li><p>Netty是由JBOSS提供的一个Java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p></li><li><p>Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的Socket服务开发。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e0284e9ca~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>Netty是由NIO演进而来，使用过NIO编程的用户就知道NIO编程非常繁重，Netty是能够能跟好的使用NIO</p></li></ul><ul><li><p>Netty的原里就是NIO，他是基于NIO的一个完美的封装，并且优化了NIO，使用他非常方便，简单快捷</p></li><li><p>我直接上代码：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e0e2ef4ca~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><ul><li>1、先添加依赖：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;dependency&gt;</span><br>          <span class="hljs-section">&lt;groupId&gt;</span><span class="hljs-attribute">io</span>.netty&lt;/groupId&gt;<br>          <span class="hljs-section">&lt;artifactId&gt;</span><span class="hljs-attribute">netty</span>-<span class="hljs-literal">all</span>&lt;/artifactId&gt;<br>          <span class="hljs-section">&lt;version&gt;</span><span class="hljs-attribute">4</span>.<span class="hljs-number">1</span>.<span class="hljs-number">16</span>.Final&lt;/version&gt;<br>      <span class="hljs-section">&lt;/dependency&gt;</span><br></code></pre></td></tr></table></figure><ul><li>2、NettyServer 模板，看起来代码那么多，<code>其实只需要添加一行消息就好了</code></li><li><code>请认真看中间的代码</code></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.lijie.iob;<br><br>import io.netty.bootstrap.ServerBootstrap;<br>import io.netty.channel.*;<br>import io.netty.channel.nio.NioEventLoopGroup;<br>import io.netty.channel.socket.SocketChannel;<br>import io.netty.channel.socket.nio.NioServerSocketChannel;<br>import io.netty.handler.codec.serialization.ClassResolvers;<br>import io.netty.handler.codec.serialization.ObjectEncoder;<br>import io.netty.handler.codec.<span class="hljs-built_in">string</span>.StringDecoder;<br><br>public <span class="hljs-keyword">class</span> NettyServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws InterruptedException &#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span>;<br>            b.group(bossGroup, workerGroup)<br>                    .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                    .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                        @Override<br>                        protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                            ChannelPipeline pipeline = socketChannel.pipeline<span class="hljs-literal">()</span>;<br>                            pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> StringDecoder()</span>);<br>                            pipeline.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-params">new</span> ObjectEncoder()</span>);<br>                            pipeline.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot; decoder&quot;</span>, <span class="hljs-params">new</span> <span class="hljs-params">io</span>.<span class="hljs-params">netty</span>.<span class="hljs-params">handler</span>.<span class="hljs-params">codec</span>.<span class="hljs-params">serialization</span>.ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.<span class="hljs-params">cacheDisabled</span>(<span class="hljs-params">null</span>)</span>));<br><br>                            <span class="hljs-comment">//重点，其他的都是复用的</span><br>                            <span class="hljs-comment">//这是真正的I0的业务代码，把他封装成一个个的个Hand1e类就行了</span><br>                            <span class="hljs-comment">//把他当成 SpringMVC的Controller</span><br>                            pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> NettyServerHandler()</span>);<br><br><br>                        &#125;<br>                    &#125;)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .child<span class="hljs-constructor">Option(ChannelOption.SO_KEEPALIVE, <span class="hljs-params">true</span>)</span>;<br>            ChannelFuture f = b.bind(<span class="hljs-number">8000</span>).sync<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;服务端启动成功，端口号为:&quot;</span> + <span class="hljs-number">8000</span>);<br>            f.channel<span class="hljs-literal">()</span>.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; finally &#123;<br>            workerGroup.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>            bossGroup.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>3、需要做的IO操作，重点是继承ChannelInboundHandlerAdapter类就好了</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.lijie.iob;<br><br><span class="hljs-keyword">import</span> io.netty.channel.Channel;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-title">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> &#123;</span><br>    RequestHandler requestHandler = <span class="hljs-keyword">new</span> RequestHandler();<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> throws Exception </span>&#123;<br>        Channel channel = ctx.channel();<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;客户端信息： %s&quot;</span>, channel.remoteAddress()));<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> throws Exception </span>&#123;<br>        Channel channel = ctx.channel();<br>        <span class="hljs-keyword">String</span> request = (<span class="hljs-keyword">String</span>) msg;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;客户端发送的消息 %s : %s&quot;</span>, channel.remoteAddress(), request));<br>        <span class="hljs-keyword">String</span> response = requestHandler.handle(request);<br>        ctx.<span class="hljs-built_in">write</span>(response);<br>        ctx.<span class="hljs-built_in">flush</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>4 客户的代码还是之前NIO的代码，我在复制下来一下吧</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">//TCP协议Socket：客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建套接字对象socket并封装ip与port</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8000</span>);<br>        <span class="hljs-comment">//根据创建的socket对象获得一个输出流</span><br>        OutputStream outputStream = socket.getOutputStream();<br>        <span class="hljs-comment">//控制台输入以IO的形式发送到服务器</span><br>        System.out.println(<span class="hljs-string">&quot;TCP连接成功 \n请输入：&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">byte</span>[] car = <span class="hljs-keyword">new</span> Scanner(System.in).nextLine().getBytes();<br>            outputStream.write(car);<br>            System.out.println(<span class="hljs-string">&quot;TCP协议的Socket发送成功&quot;</span>);<br>            <span class="hljs-comment">//刷新缓冲区</span><br>            outputStream.flush();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运行测试，还是之前那样，启动服务端，在启动所有客户端控制台输入就好了：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e4e740749~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>网络操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO基本操作讲解</title>
    <link href="/blog/2021/08/13/IO%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AE%B2%E8%A7%A3/"/>
    <url>/blog/2021/08/13/IO%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="IO基本操作讲解"><a href="#IO基本操作讲解" class="headerlink" title="IO基本操作讲解"></a>IO基本操作讲解</h4><ul><li><code>这里的基本操作就是普通的读取操作，如果想要跟深入的了解不同的IO开发场景必须先了解IO的基本操作</code></li></ul><h5 id="1-按字符流读取文件"><a href="#1-按字符流读取文件" class="headerlink" title="1 按字符流读取文件"></a>1 按<code>字符</code>流读取文件</h5><h6 id="1-1-按字符流的·节点流方式读取"><a href="#1-1-按字符流的·节点流方式读取" class="headerlink" title="1.1 按字符流的·节点流方式读取"></a>1.1 按字符流的·节点流方式读取</h6><ul><li>如果我们要取的数据基本单位是字符，那么用（<strong>字符流</strong>）这种方法读取文件就比较适合。比如：读取test.txt文件</li></ul><p><strong>注释：</strong></p><ul><li><code>字符流</code>：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。 (Java代码接收数据为一般为<code>char数组，也可以是别的</code>)</li><li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据，图片、文件、音乐视频等。 (Java代码接收数据只能为<code>byte数组</code>)</li><li><strong>FileReader 类：</strong>（字符输入流） 注意：new FileReader(“D:\test.txt”);//文件必须存在</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFileReader</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//字符流接收使用的char数组</span><br>        <span class="hljs-keyword">char</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//字符流、节点流打开文件类</span><br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>);<span class="hljs-comment">//文件必须存在</span><br>        <span class="hljs-comment">//FileReader.read()：取出字符存到buf数组中,如果读取为-1代表为空即结束读取。</span><br>        <span class="hljs-comment">//FileReader.read()：读取的是一个字符，但是java虚拟机会自动将char类型数据转换为int数据，</span><br>        <span class="hljs-comment">//如果你读取的是字符A，java虚拟机会自动将其转换成97，如果你想看到字符可以在返回的字符数前加（char）强制转换如</span><br>        <span class="hljs-keyword">while</span>((num=fr.read(buf))!=-<span class="hljs-number">1</span>) &#123; &#125;<br>        <span class="hljs-comment">//检测一下是否取到相应的数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;buf.length;i++) &#123;<br>            System.out.print(buf[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运行结果：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bc8b392a2~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>·</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd287ea0e~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><h6 id="1-2-按字符流的·处理流方式读取"><a href="#1-2-按字符流的·处理流方式读取" class="headerlink" title="1.2 按字符流的·处理流方式读取"></a>1.2 按字符流的·处理流方式读取</h6><ul><li>效果是一样，但是给了我们有不同的选择操作。进行了一个小封装，加缓冲功能，避免频繁读写硬盘。我这只是简单演示，处理流其实还有很多操作</li><li><strong>BufferedReader 类：</strong> 字符输入流使用的类，加缓冲功能，避免频繁读写硬盘</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.<span class="hljs-keyword">BufferedReader</span>;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> class TestBufferedReader &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//字符流接收使用的String数组</span><br>        <span class="hljs-keyword">String</span>[] bufstring=<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//字符流、节点流打开文件类</span><br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>);<span class="hljs-comment">//文件必须存在</span><br>        <span class="hljs-comment">//字符流、处理流读取文件类</span><br>        <span class="hljs-keyword">BufferedReader</span> br = <span class="hljs-keyword">new</span> <span class="hljs-keyword">BufferedReader</span>(fr);<br>        <span class="hljs-comment">//临时接收数据使用的变量</span><br>        <span class="hljs-keyword">String</span> <span class="hljs-built_in">line</span>=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//BufferedReader.readLine()：单行读取，读取为空返回null</span><br>        <span class="hljs-keyword">while</span>((<span class="hljs-built_in">line</span>=br.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>            bufstring[num]=<span class="hljs-built_in">line</span>;<br>            num++;<br>        &#125;<br>        br.close();<span class="hljs-comment">//关闭文件</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(bufstring[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>测试效果一样</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd9df6795~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><h5 id="2-按字符流写出文件"><a href="#2-按字符流写出文件" class="headerlink" title="2 按字符流写出文件"></a>2 按<code>字符</code>流写出文件</h5><h6 id="2-1-按字符流的·节点流方式写出"><a href="#2-1-按字符流的·节点流方式写出" class="headerlink" title="2.1 按字符流的·节点流方式写出"></a>2.1 按字符流的·节点流方式写出</h6><ul><li>写出字符，使用（<strong>字符流</strong>）这种方法写出文件比较适合。比如：输出内容添加到test.txt文件</li><li><strong>FileWriter类：</strong>（字符输出流），如果写出文件不存在会自动创建一个相对应的文件。使用FileWriter写出文件默认是覆盖原文件，如果要想在源文件添加内容不覆盖的话，需要构造参数添加true参数：看示例了解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFileWriter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//File是操作文件类</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>);<span class="hljs-comment">//文件必须存在</span><br>        <span class="hljs-comment">//字符流、节点流写出文件类</span><br>        <span class="hljs-comment">//new FileWriter(file,true)，这个true代表追加，不写就代表覆盖文件</span><br>        FileWriter out=<span class="hljs-keyword">new</span> FileWriter(file,<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//写入的字节,\n代表换行</span><br>        String str=<span class="hljs-string">&quot;\nholler&quot;</span>;<br>        <span class="hljs-comment">//写入</span><br>        out.write(str);<br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运行效果</p><p>：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd9e9cea7~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><h6 id="2-2-按字符流的·处理流方式写出"><a href="#2-2-按字符流的·处理流方式写出" class="headerlink" title="2.2 按字符流的·处理流方式写出"></a>2.2 按字符流的·处理流方式写出</h6><ul><li><strong>BufferedWriter ：</strong> 增加缓冲功能，避免频繁读写硬盘。 我这里： //new FileWriter(file)，这里我只给了他文件位置，我没加true代表覆盖源文件</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBufferedWriter</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;<br>        <span class="hljs-comment">//File是操作文件类</span><br>        <span class="hljs-built_in">File</span> file = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>);<span class="hljs-comment">//文件必须存在</span><br>        <span class="hljs-comment">//字符流、节点流写出文件类</span><br>        <span class="hljs-comment">//new FileWriter(file)，这个我没加true代表覆盖文件</span><br>        Writer writer = <span class="hljs-keyword">new</span> FileWriter(file);<br>        <span class="hljs-comment">////字符流、处理流写出文件类</span><br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(writer);<br>        bw.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\n小心&quot;</span>);<br>        bw.<span class="hljs-built_in">close</span>();<br>        writer.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运行效果</p><p>：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bf6b9c467~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><h5 id="3-按字节流写入写出文件"><a href="#3-按字节流写入写出文件" class="headerlink" title="3 按字节流写入写出文件"></a>3 按<code>字节</code>流写入写出文件</h5><h6 id="3-1-按字节流的·节点流写入写出文件"><a href="#3-1-按字节流的·节点流写入写出文件" class="headerlink" title="3.1 按字节流的·节点流写入写出文件"></a>3.1 按字节流的·节点流写入写出文件</h6><ul><li>如果我们要取的数据 图片、文件、音乐视频等类型，就必须使用字节流进行读取写出</li></ul><p><strong>注释：</strong></p><ul><li><code>字符流</code>：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。 (Java代码接收数据为一般为<code>char数组，也可以是别的</code>)</li><li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据，图片、文件、音乐视频等。 (Java代码接收数据只能为<code>byte数组</code>)</li><li><strong>FileInputStream：</strong>（字节输入流）</li><li><strong>FileOutputStream：</strong>（字节输出流）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFileOutputStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//创建字节输入流、节点流方式读取文件</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\Akie秋绘 - Lemon（Cover：米津玄師）.mp3&quot;</span>);<br>        <span class="hljs-comment">//创建字节输入流、节点流方式输出文件</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:\\copy.mp3&quot;</span>);<br><br>        <span class="hljs-comment">//根据文件大小做一个字节数组</span><br>        <span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[fis.available()];<br>        <span class="hljs-comment">//将文件上的所有字节读取到数组中</span><br>        fis.read(arr);<br>        <span class="hljs-comment">//将数组中的所有字节一次写到了文件上</span><br>        fos.write(arr);<br>        fis.close();<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运行之前：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bea43363c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>运行之后：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bf120ce55~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><h6 id="3-2-按字节流的·处理流写入写出文件"><a href="#3-2-按字节流的·处理流写入写出文件" class="headerlink" title="3.2 按字节流的·处理流写入写出文件"></a>3.2 按字节流的·处理流写入写出文件</h6><ul><li><strong>FileInputStream：</strong>（字节输入流）</li><li><strong>FileOutputStream：</strong>（字节输出流）</li><li><strong>BufferedInputStream</strong>：（带缓冲区字节输入流）</li><li><strong>BufferedOutputStream</strong>：（带缓冲区字节输入流） 带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.test.io;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBufferedOutputStream</span> &#123;</span><br>    <span class="hljs-comment">//创建文件输入流对象,关联致青春.mp3</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:\\copy.mp3&quot;</span>);<br>        <span class="hljs-comment">//创建缓冲区对fis装饰</span><br>        BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);<br>        <span class="hljs-comment">//创建输出流对象,关联copy.mp3</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:\\copy2.mp3&quot;</span>);<br>        <span class="hljs-comment">//创建缓冲区对fos装饰</span><br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>        <span class="hljs-comment">//循环直接输出</span><br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">while</span>((i = bis.<span class="hljs-built_in">read</span>()) != <span class="hljs-number">-1</span>) &#123;<br>            bos.<span class="hljs-built_in">write</span>(i);<br>        &#125;<br>        bis.<span class="hljs-built_in">close</span>();<br>        bos.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运行之前：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c07f6fd17~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>运行之后：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c0e8bc804~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>基本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要使用并发编程</title>
    <link href="/blog/2021/08/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/blog/2021/08/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用并发编程"><a href="#为什么要使用并发编程" class="headerlink" title="为什么要使用并发编程"></a>为什么要使用并发编程</h4><ul><li>提升多核CPU的利用率：一般来说一台主机上的会有多个CPU核心，我们可以创建多个线程，理论上讲操作系统可以将多个线程分配给不同的CPU去执行，每个CPU执行一个线程，这样就提高了CPU的使用效率，如果使用单线程就只能有一个CPU核心被使用。</li><li>比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</li><li>简单来说就是：<ul><li>充分利用多核CPU的计算能力；</li><li>方便进行业务拆分，提升应用性能</li></ul></li></ul><h4 id="多线程应用场景"><a href="#多线程应用场景" class="headerlink" title="多线程应用场景"></a>多线程应用场景</h4><ul><li>例如: 迅雷多线程下载、数据库连接池、分批发送短信等。</li></ul><h4 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h4><ul><li>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、线程安全、死锁等问题。</li></ul><h4 id="并发编程三个必要因素是什么？"><a href="#并发编程三个必要因素是什么？" class="headerlink" title="并发编程三个必要因素是什么？"></a>并发编程三个必要因素是什么？</h4><ul><li>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</li><li>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</li></ul><h4 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h4><ul><li>出现线程安全问题的原因一般都是三个原因：<ul><li>线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。</li><li>缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题</li><li>编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题</li></ul></li></ul><h4 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h4><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</li></ul><p><strong>做一个形象的比喻：</strong></p><ul><li>并发 = 俩个人用一台电脑。</li><li>并行 = 俩个人分配了俩台电脑。</li><li>串行 = 俩个人排队使用一台电脑。</li></ul><h4 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h4><ul><li>多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。</li></ul><h4 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h4><ul><li>可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li></ul><h4 id="多线程的劣势："><a href="#多线程的劣势：" class="headerlink" title="多线程的劣势："></a>多线程的劣势：</h4><ul><li>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；</li><li>多线程需要协调和管理，所以需要 CPU 时间跟踪线程；</li><li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</li></ul><h4 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h4><ul><li><p>什么是线程和进程?</p><ul><li><p>进程</p><p>一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程</p></li><li><p>线程</p><p>进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO概念</title>
    <link href="/blog/2021/08/08/IO%E6%A6%82%E5%BF%B5/"/>
    <url>/blog/2021/08/08/IO%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是比特-Bit-什么是字节-Byte-什么是字符-Char-它们长度是多少-各有什么区别"><a href="#什么是比特-Bit-什么是字节-Byte-什么是字符-Char-它们长度是多少-各有什么区别" class="headerlink" title="什么是比特(Bit),什么是字节(Byte),什么是字符(Char),它们长度是多少,各有什么区别"></a>什么是比特(Bit),什么是字节(Byte),什么是字符(Char),它们长度是多少,各有什么区别</h4><ul><li>Bit最小的二进制单位 ，是计算机的操作部分取值0或者1</li><li>Byte是计算机中存储数据的单元，是一个8位的二进制数，（计算机内部，一个字节可表示一个英文字母，两个字节可表示一个汉字。） <code>取值（-128-127）</code></li><li>Char是用户的可读写的最小单位，他只是抽象意义上的一个符号。如‘5’，‘中’，‘￥’ 等等等等。在java里面由16位bit组成Char 取值<code>（0-65535）</code></li><li>Bit 是最小单位 计算机他只能认识0或者1</li><li>Byte是8个字节  是给计算机看的</li><li>字符 是看到的东西  一个字符=二个字节</li></ul><h4 id="什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作"><a href="#什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作" class="headerlink" title="什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作"></a>什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作</h4><ul><li>对象序列化，将对象以二进制的形式保存在硬盘上</li><li>反序列化；将二进制的文件转化为对象读取</li><li>实现serializable接口，不想让字段放在硬盘上就加transient</li></ul><h4 id="在实现序列化接口是时候一般要生成一个serialVersionUID字段-它叫做什么-一般有什么用"><a href="#在实现序列化接口是时候一般要生成一个serialVersionUID字段-它叫做什么-一般有什么用" class="headerlink" title="在实现序列化接口是时候一般要生成一个serialVersionUID字段,它叫做什么,一般有什么用"></a>在实现序列化接口是时候一般要生成一个serialVersionUID字段,它叫做什么,一般有什么用</h4><ul><li>如果用户没有自己声明一个serialVersionUID,接口会默认生成一个serialVersionUID</li><li>但是强烈建议用户自定义一个serialVersionUID,因为默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassException这个异常。</li><li>（比如说先进行序列化，然后在反序列化之前修改了类，那么就会报错。因为修改了类，对应的SerialversionUID也变化了，而序列化和反序列化就是通过对比其SerialversionUID来进行的，一旦SerialversionUID不匹配，反序列化就无法成功。</li></ul><h4 id="怎么生成SerialversionUID"><a href="#怎么生成SerialversionUID" class="headerlink" title="怎么生成SerialversionUID"></a>怎么生成SerialversionUID</h4><ul><li>可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段<strong>必须是静态 (static)、最终 (final) 的 long 型字段</strong>）显式声明其自己的 serialVersionUID</li><li>两种显示的生成方式（当你一个类实现了Serializable接口，如果没有显示的定义serialVersionUID，Eclipse会提供这个提示功能告诉你去定义 。在Eclipse中点击类中warning的图标一下，Eclipse就会自动给定两种生成的方式。</li></ul><h4 id="BufferedReader属于哪种流-它主要是用来做什么的-它里面有那些经典的方法"><a href="#BufferedReader属于哪种流-它主要是用来做什么的-它里面有那些经典的方法" class="headerlink" title="BufferedReader属于哪种流,它主要是用来做什么的,它里面有那些经典的方法"></a>BufferedReader属于哪种流,它主要是用来做什么的,它里面有那些经典的方法</h4><ul><li>属于处理流中的缓冲流，可以将读取的内容存在内存里面，有readLine（）方法</li></ul><h4 id="Java中流类的超类主要有那些？"><a href="#Java中流类的超类主要有那些？" class="headerlink" title="Java中流类的超类主要有那些？"></a>Java中流类的超类主要有那些？</h4><ul><li>超类代表顶端的父类（都是抽象类）</li><li>java.io.InputStream</li><li>java.io.OutputStream</li><li>java.io.Reader</li><li>java.io.Writer</li></ul><h4 id="为什么图片、视频、音乐、文件等-都是要字节流来读取"><a href="#为什么图片、视频、音乐、文件等-都是要字节流来读取" class="headerlink" title="为什么图片、视频、音乐、文件等 都是要字节流来读取"></a>为什么图片、视频、音乐、文件等 都是要字节流来读取</h4><ul><li>这个很基础，你看看你电脑文件的属性就好了，CPU规定了计算机存储文件都是按字节算的</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bae24bd8b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h4 id="IO的常用类和方法，以及如何使用"><a href="#IO的常用类和方法，以及如何使用" class="headerlink" title="IO的常用类和方法，以及如何使用"></a>IO的常用类和方法，以及如何使用</h4><p><a href="#Mark">注意，如果懂IO的普通文件读写操作可以直接点击此处跳过，直接看网络操作IO编程，那个才是重点，点击即会跳转</a></p><p>前面讲了那么多废话，现在我们开始进入主题，后面很长，从开始的文件操作到后面的<strong>网络IO操作</strong>都会有例子：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bb4bd288c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p><a href="#Mark">注意，如果懂IO的普通文件读写操作可以直接点击此处跳过，直接看网络操作IO编程，那个才是重点，点击即会跳转</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaIO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>五种IO模型</title>
    <link href="/blog/2021/08/07/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/blog/2021/08/07/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h4><ul><li><strong>注意：我这里的用户空间就是应用程序空间</strong></li></ul><h5 id="1-阻塞BIO（blocking-I-O）"><a href="#1-阻塞BIO（blocking-I-O）" class="headerlink" title="1.阻塞BIO（blocking I/O）"></a>1.阻塞BIO（blocking I/O）</h5><ul><li><p>A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。</p></li><li><p>在内核将数据准备好之前，系统调用会一直等待所有的套接字，默认的是阻塞方式。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b82fb2f64~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><h5 id="2-非阻塞NIO（noblocking-I-O）"><a href="#2-非阻塞NIO（noblocking-I-O）" class="headerlink" title="2.非阻塞NIO（noblocking I/O）"></a>2.非阻塞NIO（noblocking I/O）</h5><ul><li>B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。 <strong>B在检查鱼竿是否有鱼，是一个轮询的过程。</strong></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b830f1cd3~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><h5 id="3-异步AIO（asynchronous-I-O）"><a href="#3-异步AIO（asynchronous-I-O）" class="headerlink" title="3.异步AIO（asynchronous I/O）"></a>3.异步AIO（asynchronous I/O）</h5><ul><li><p>C也想钓鱼，但C有事情，于是他雇来了D、E、F，让他们帮他等待鱼上钩，一旦有鱼上钩，就打电话给C，C就会将鱼钓上去。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba0e18c2d~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>当应用程序请求数据时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。</p></li></ul><h5 id="4-信号驱动IO（signal-blocking-I-O）"><a href="#4-信号驱动IO（signal-blocking-I-O）" class="headerlink" title="4.信号驱动IO（signal blocking I/O）"></a>4.信号驱动IO（signal blocking I/O）</h5><ul><li><p>G也在河边钓鱼，但与A、B、C不同的是，G比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，G就会将鱼钓上来。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba21e5d95~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p></li></ul><h5 id="5-IO多路转接（I-O-multiplexing）"><a href="#5-IO多路转接（I-O-multiplexing）" class="headerlink" title="5.IO多路转接（I/O multiplexing）"></a>5.IO多路转接（I/O multiplexing）</h5><ul><li><p>H同样也在河边钓鱼，但是H生活水平比较好，H拿了很多的鱼竿，一次性有很多鱼竿在等，H不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba9450627~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。</p></li></ul><ul><li>IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用</tag>
      
      <tag>IO模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是IO</title>
    <link href="/blog/2021/08/06/%E4%BB%80%E4%B9%88%E6%98%AFIO/"/>
    <url>/blog/2021/08/06/%E4%BB%80%E4%B9%88%E6%98%AFIO/</url>
    
    <content type="html"><![CDATA[<ul><li><p>ava中I/O是以流为基础进行数据的输入输出的，所有数据被串行化(所谓串行化就是数据要按顺序进行输入输出)写入输出流。简单来说就是java通过io流方式和外部设备进行交互。</p></li><li><p>在Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛：标准输入输出，文件的操作，<strong>网络上的数据传输流</strong>，字符串流，对象流等等等。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b746125c6~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p></li></ul><ul><li>比如程序从服务器上下载图片，就是通过流的方式从网络上以流的方式到程序中，在到硬盘中</li></ul><h4 id="在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别"><a href="#在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别" class="headerlink" title="在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别"></a>在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别</h4><ul><li>同步，一个任务的完成之前不能做其他操作，必须等待（等于在打电话）</li><li>异步，一个任务的完成之前，可以进行其他操作（等于在聊QQ）</li><li>阻塞，是相对于CPU来说的， 挂起当前线程，不能做其他操作只能等待</li><li>非阻塞,，无须挂起当前线程，可以去执行其他操作</li></ul><h4 id="什么是BIO"><a href="#什么是BIO" class="headerlink" title="什么是BIO"></a>什么是BIO</h4><ul><li>BIO：同步并阻塞，服务器实现一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，没处理完之前此线程不能做其他操作（如果是单线程的情况下，我传输的文件很大呢？），当然可以通过线程池机制改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li></ul><h4 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h4><ul><li>NIO:同步非阻塞，服务器实现一个连接一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4之后开始支持。</li></ul><h4 id="什么是AIO"><a href="#什么是AIO" class="headerlink" title="什么是AIO"></a>什么是AIO</h4><ul><li>AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用操作系统参与并发操作，编程比较复杂，JDK1.7之后开始支持。.</li><li>AIO属于NIO包中的类实现，其实IO主要分为BIO和NIO，AIO只是附加品，解决IO不能异步的实现</li><li>在以前很少有Linux系统支持AIO，Windows的IOCP就是该AIO模型。但是现在的服务器一般都是支持AIO操作</li></ul><h4 id="什么Netty"><a href="#什么Netty" class="headerlink" title="什么Netty"></a>什么Netty</h4><ul><li><p>Netty是由JBOSS提供的一个Java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p></li><li><p>Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b74fff5c8~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p>Netty是由NIO演进而来，使用过NIO编程的用户就知道NIO编程非常繁重，Netty是能够能跟好的使用NIO</p></li></ul><h4 id="BIO和NIO、AIO的区别"><a href="#BIO和NIO、AIO的区别" class="headerlink" title="BIO和NIO、AIO的区别"></a>BIO和NIO、AIO的区别</h4><ul><li>BIO是阻塞的，NIO是非阻塞的.</li><li>BIO是面向流的，只能单向读写，NIO是面向缓冲的, 可以双向读写</li><li>使用BIO做Socket连接时，由于单向读写，当没有数据时，会挂起当前线程，阻塞等待，为防止影响其它连接,，需要为每个连接新建线程处理.，然而系统资源是有限的,，不能过多的新建线程，线程过多带来线程上下文的切换，从来带来更大的性能损耗，因此需要使用NIO进行BIO多路复用，使用一个线程来监听所有Socket连接，使用本线程或者其他线程处理连接</li><li>AIO是非阻塞 以异步方式发起 I/O 操作。当 I/O 操作进行时可以去做其他操作，由操作系统内核空间提醒IO操作已完成（不懂的可以往下看）</li></ul><h4 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b771fca9c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p><strong>按照读写的单位大小来分：</strong></p><ul><li><code>字符流</code>：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。 (Java代码接收数据为一般为<code>char数组，也可以是别的</code>)</li><li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据，图片、文件、音乐视频等。 (Java代码接收数据只能为<code>byte数组</code>)</li></ul><p><strong>按照实际IO操作来分：</strong></p><ul><li>输出流：从内存读出到文件。只能进行写操作。</li><li>输入流：从文件读入到内存。只能进行读操作。</li><li><strong>注意</strong>：输出流可以帮助我们创建文件，而输入流不会。</li></ul><p><strong>按照读写时是否直接与硬盘，内存等节点连接分：</strong></p><ul><li>节点流：直接与数据源相连，读入或读出。</li><li>处理流：也叫包装流，是对一个对于已存在的流的连接进行封装，通过所封装的流的功能调用实现数据读写。如添加个Buffering缓冲区。（意思就是有个缓存区，等于软件和mysql中的redis）</li><li><strong>注意</strong>：为什么要有处理流？主要作用是在读入或写出时，对数据进行缓存，以减少I/O的次数，以便下次更好更快的读写文件，才有了处理流。</li></ul><h4 id="什么是内核空间"><a href="#什么是内核空间" class="headerlink" title="什么是内核空间"></a>什么是内核空间</h4><ul><li>我们的应用程序是不能直接访问硬盘的，我们程序没有权限直接访问，但是操作系统（Windows、Linux……）会给我们一部分权限较高的内存空间，他叫内核空间，和我们的实际硬盘空间是有区别的</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b7790530d~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>JavaIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>初识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>辅助工具类</title>
    <link href="/blog/2021/08/04/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/blog/2021/08/04/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h2><h3 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h3><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。<br></code></pre></td></tr></table></figure><h3 id="如何实现-Array-和-List-之间的转换？"><a href="#如何实现-Array-和-List-之间的转换？" class="headerlink" title="如何实现 Array 和 List 之间的转换？"></a>如何实现 Array 和 List 之间的转换？</h3><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h3 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，</li><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li></ul><p>？</p><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h3 id="Collection-和-Collections-有什么区别？-1"><a href="#Collection-和-Collections-有什么区别？-1" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？-1"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？-1" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，</li><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>辅助</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合容器概述</title>
    <link href="/blog/2021/08/01/%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <url>/blog/2021/08/01/%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="集合容器概述"><a href="#集合容器概述" class="headerlink" title="集合容器概述"></a>集合容器概述</h2><h3 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h3><ul><li>集合就是一个放数据的容器，准确的说是放数据对象引用的容器</li><li>集合类存放的都是对象的引用，而不是对象的本身</li><li>集合类型主要有3种：set(集）、list(列表）和map(映射)。</li></ul><h3 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h3><ul><li>集合的特点主要有如下两点：<ul><li>集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理。</li><li>和数组对比对象的大小不确定。因为集合是可变长度的。数组需要提前定义大小</li></ul></li></ul><h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><h3 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h3><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h3 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h3><ul><li>Map接口和Collection接口是所有集合框架的父接口：</li></ul><ol><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><h3 id="List，Set，Map三者的区别？"><a href="#List，Set，Map三者的区别？" class="headerlink" title="List，Set，Map三者的区别？"></a>List，Set，Map三者的区别？</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/13/17173551e70de4bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</li><li>Collection集合主要有List和Set两大接口<ul><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li></ul></li><li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。<ul><li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul></li></ul><h3 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h3><ul><li>Collection<ol><li>List<ul><li>Arraylist： Object数组</li><li>Vector： Object数组</li><li>LinkedList： 双向循环链表</li></ul></li><li>Set<ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul></li></ol></li><li>Map<ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul></li></ul><h3 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h3><ul><li>Vector：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用。</li><li>hashTable：就比hashMap多了个synchronized (线程安全)，不建议使用。</li><li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）</li><li>…</li></ul><h3 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h3><ul><li>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</li><li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li><li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>解决办法：<ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol></li></ul><h3 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h3><ul><li><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p></li><li><p>示例代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list. <span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;<span class="hljs-keyword">String</span>&gt; clist = Collections. unmodifiableCollection(list);<br>clist. <span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;y&quot;</span>); <span class="hljs-comment">// 运行时此行报错</span><br>System. out. <span class="hljs-built_in">println</span>(list. <span class="hljs-built_in">size</span>());<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map接口</title>
    <link href="/blog/2021/08/01/Map%E6%8E%A5%E5%8F%A3/"/>
    <url>/blog/2021/08/01/Map%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="什么是Hash算法"><a href="#什么是Hash算法" class="headerlink" title="什么是Hash算法"></a>什么是Hash算法</h3><ul><li>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</li></ul><h3 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h3><ul><li><p>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。</p></li><li><p>链表大致分为单链表和双向链表</p><ol><li>单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针</li></ol></li></ul><pre><code> ![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/13/17173551e72891e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</code></pre><ol start="2"><li>双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针</li></ol><pre><code> ![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/13/17173551e73f80b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</code></pre><ul><li><p>链表的优点</p><ul><li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li><li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li><li>大小没有固定，拓展很灵活。</li></ul></li><li><p>链表的缺点</p><ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul></li></ul><h3 id="说一下HashMap的实现原理？"><a href="#说一下HashMap的实现原理？" class="headerlink" title="说一下HashMap的实现原理？"></a>说一下HashMap的实现原理？</h3><ul><li><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></li><li><p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p></li><li><p>HashMap 基于 Hash 算法实现的</p><ol><li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p></li><li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p><p>​    (1)如果key相同，则覆盖原始值；</p><p>​    (2)如果key不同（出现冲突），则将当前的key-value放入链表中</p></li><li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p></li><li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p></li></ol></li><li><p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p></li></ul><h3 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3><ul><li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；\</strong>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**拉链法**的方式可以解决哈希冲突。</li></ul><h4 id="HashMap-JDK1-8之前"><a href="#HashMap-JDK1-8之前" class="headerlink" title="HashMap JDK1.8之前"></a>HashMap JDK1.8之前</h4><ul><li>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/13/17173551e78f59a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h4 id="HashMap-JDK1-8之后"><a href="#HashMap-JDK1-8之后" class="headerlink" title="HashMap JDK1.8之后"></a>HashMap JDK1.8之后</h4><ul><li>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/13/17173551e7c6af15?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h4 id="JDK1-7-VS-JDK1-8-比较"><a href="#JDK1-7-VS-JDK1-8-比较" class="headerlink" title="JDK1.7 VS JDK1.8 比较"></a>JDK1.7 VS JDK1.8 比较</h4><ul><li>JDK1.8主要解决或优化了一下问题：<ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol></li></ul><blockquote><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：<code>inflateTable()</code></td><td>直接集成到了扩容函数<code>resize()</code>中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部/红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table></blockquote><h3 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h3><h4 id="说道红黑树先讲什么是二叉树"><a href="#说道红黑树先讲什么是二叉树" class="headerlink" title="说道红黑树先讲什么是二叉树"></a>说道红黑树先讲什么是二叉树</h4><ul><li><p>二叉树简单来说就是 每一个节上可以关联俩个子节点</p><ul><li><pre><code>大概就是这样子：                       a                    /     \                  b          c                / \         /  \              d    e       f    g            /  \  / \     / \   / \           h   i  j  k   l   m n   o<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">#### 红黑树</span><br><br>- 红黑树是一种特殊的二叉查找树。红黑树的每个结点上都有存储位表示结点的颜色，可以是红(Red)或黑(Black)。 ![img](https:<span class="hljs-regexp">//u</span>ser-gold-cdn.xitu.io<span class="hljs-regexp">/2020/</span><span class="hljs-number">4</span><span class="hljs-regexp">/13/</span><span class="hljs-number">17173552173</span>a8a0c?imageView2<span class="hljs-regexp">/0/</span>w<span class="hljs-regexp">/1280/</span>h<span class="hljs-regexp">/960/</span>format<span class="hljs-regexp">/webp/ig</span>nore-error/<span class="hljs-number">1</span>)<br>- 红黑树的每个结点是黑色或者红色。当是不管怎么样他的根结点是黑色。每个叶子结点（叶子结点代表终结、结尾的节点）也是黑色 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]。<br>- 如果一个结点是红色的，则它的子结点必须是黑色的。<br>- 每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]<br>- 红黑树的基本操作是**添加、删除**。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树的结构就发生了变化，可能不满足上面三条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转和变色，可以使这颗树重新成为红黑树。简单点说，旋转和变色的目的是让树保持红黑树的特性。<br><br><span class="hljs-comment">### HashMap的put方法的具体流程？</span><br><br>- 当我们put的时候，首先计算 `key`的`hash`值，这里调用了 `hash`方法，`hash`方法实际是让`key.hashCode()`与`key.hashCode()&gt;&gt;&gt;<span class="hljs-number">16</span>`进行异或操作，高<span class="hljs-number">16</span>bit补<span class="hljs-number">0</span>，一个数和<span class="hljs-number">0</span>异或不变，所以 hash 函数大概的作用就是：**高<span class="hljs-number">16</span>bit不变，低<span class="hljs-number">16</span>bit和高<span class="hljs-number">16</span>bit做了一个异或，目的是减少碰撞**。按照函数注释，因为bucket数组大小是<span class="hljs-number">2</span>的幂，计算下标`index = (table.length - <span class="hljs-number">1</span>) &amp; hash`，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高<span class="hljs-number">16</span>bit和低<span class="hljs-number">16</span>bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。<br>- putVal方法执行流程图<br><br><br><br>![在这里插入图片描述](https:<span class="hljs-regexp">//u</span>ser-gold-cdn.xitu.io<span class="hljs-regexp">/2020/</span><span class="hljs-number">4</span><span class="hljs-regexp">/13/</span><span class="hljs-number">1717355218</span>a84ee7?imageView2<span class="hljs-regexp">/0/</span>w<span class="hljs-regexp">/1280/</span>h<span class="hljs-regexp">/960/</span>format<span class="hljs-regexp">/webp/ig</span>nore-error/<span class="hljs-number">1</span>)<br><br><br><br></code></pre></td></tr></table></figure>public V put(K key, V value) &#123;return putVal(hash(key), key, value, false, true);&#125;</code></pre></li></ul></li></ul><p>static final int hash(Object key) {<br>    int h;<br>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}</p><p>//实现Map.put和相关方法<br>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>                   boolean evict) {<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;<br>    // 步骤①：tab为空则创建<br>    // table未初始化或者长度为0，进行扩容<br>    if ((tab = table) == null || (n = tab.length) == 0)<br>        n = (tab = resize()).length;<br>    // 步骤②：计算index，并对null做处理<br>    // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)<br>    if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>        tab[i] = newNode(hash, key, value, null);<br>    // 桶中已经存在元素<br>    else {<br>        Node&lt;K,V&gt; e; K k;<br>        // 步骤③：节点key存在，直接覆盖value<br>        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等<br>        if (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                // 将第一个元素赋值给e，用e来记录<br>                e = p;<br>        // 步骤④：判断该链为红黑树<br>        // hash值不相等，即key不相等；为红黑树结点<br>        // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null<br>        else if (p instanceof TreeNode)<br>            // 放入树中<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);<br>        // 步骤⑤：该链为链表<br>        // 为链表结点<br>        else {<br>            // 在链表最末插入结点<br>            for (int binCount = 0; ; ++binCount) {<br>                // 到达链表的尾部</p><pre><code>            //判断该链表尾部指针是不是空的            if ((e = p.next) == null) &#123;                // 在尾部插入新结点                p.next = newNode(hash, key, value, null);                //判断链表的长度是否达到转化红黑树的临界值，临界值为8                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                    //链表结构转树形结构                    treeifyBin(tab, hash);                // 跳出循环                break;            &#125;            // 判断链表中结点的key值与插入的元素的key值是否相等            if (e.hash == hash &amp;&amp;                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                // 相等，跳出循环                break;            // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表            p = e;        &#125;    &#125;    //判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值    if (e != null) &#123;         // 记录e的value        V oldValue = e.value;        // onlyIfAbsent为false或者旧值为null        if (!onlyIfAbsent || oldValue == null)            //用新值替换旧值            e.value = value;        // 访问后回调        afterNodeAccess(e);        // 返回旧值        return oldValue;    &#125;&#125;// 结构性修改++modCount;// 步骤⑥：超过最大容量就扩容 // 实际大小大于阈值则扩容if (++size &gt; threshold)    resize();// 插入后回调afterNodeInsertion(evict);return null;</code></pre><p>}</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gams"><br><span class="hljs-number">1.</span> 判断键值对数组<span class="hljs-keyword">table</span>[i]是否为空或为null，否则执行resize()进行扩容；<br><span class="hljs-number">2.</span> 根据键值key计算hash值得到插入的数组索引i，如果<span class="hljs-keyword">table</span>[i]==null，直接新建节点添加，转向⑥，如果<span class="hljs-keyword">table</span>[i]不为空，转向③；<br><span class="hljs-number">3.</span> 判断<span class="hljs-keyword">table</span>[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；<br><span class="hljs-number">4.</span> 判断<span class="hljs-keyword">table</span>[i] 是否为treeNode，即<span class="hljs-keyword">table</span>[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；<br><span class="hljs-number">5.</span> 遍历<span class="hljs-keyword">table</span>[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；<br><span class="hljs-number">6.</span> 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。<br><br>### HashMap的扩容操作是怎么实现的？<br><br><span class="hljs-number">1.</span> 在jdk1<span class="hljs-number">.8</span>中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；<br><span class="hljs-number">2.</span> 每次扩展的时候，都是扩展<span class="hljs-number">2</span>倍；<br><span class="hljs-number">3.</span> 扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。<br><br>- 在putVal()中，我们看到在这个函数里面使用到了<span class="hljs-number">2</span>次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为<span class="hljs-number">12</span>),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1<span class="hljs-number">.8</span>版本的一个优化的地方，在<span class="hljs-number">1.7</span>中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在<span class="hljs-number">1.8</span>版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为<span class="hljs-number">0</span>，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上<br><br></code></pre></td></tr></table></figure><p>  final Node&lt;K,V&gt;[] resize() {<br>      Node&lt;K,V&gt;[] oldTab = table;//oldTab指向hash桶数组<br>      int oldCap = (oldTab == null) ? 0 : oldTab.length;<br>      int oldThr = threshold;<br>      int newCap, newThr = 0;<br>      if (oldCap &gt; 0) {//如果oldCap不为空的话，就是hash桶数组不为空<br>          if (oldCap &gt;= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值<br>              threshold = Integer.MAX_VALUE;<br>              return oldTab;//返回<br>          }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16<br>          else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>              newThr = oldThr &lt;&lt; 1; // double threshold 双倍扩容阀值threshold<br>      }<br>      // 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂<br>      // 直接将该值赋给新的容量<br>      else if (oldThr &gt; 0) // initial capacity was placed in threshold<br>          newCap = oldThr;<br>      // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75<br>      else {               // zero initial threshold signifies using defaults<br>          newCap = DEFAULT_INITIAL_CAPACITY;<br>          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>      }<br>      // 新的threshold = 新的cap * 0.75<br>      if (newThr == 0) {<br>          float ft = (float)newCap * loadFactor;<br>          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?<br>                    (int)ft : Integer.MAX_VALUE);<br>      }<br>      threshold = newThr;<br>      // 计算出新的数组长度后赋给当前成员变量table<br>      @SuppressWarnings({“rawtypes”,”unchecked”})<br>          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//新建hash桶数组<br>      table = newTab;//将新数组的值复制给旧的hash桶数组<br>      // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散<br>      if (oldTab != null) {<br>          // 遍历新数组的所有桶下标<br>          for (int j = 0; j &lt; oldCap; ++j) {<br>              Node&lt;K,V&gt; e;<br>              if ((e = oldTab[j]) != null) {<br>                  // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收<br>                  oldTab[j] = null;<br>                  // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树<br>                  if (e.next == null)<br>                      // 用同样的hash映射算法把该元素加入新的数组<br>                      newTab[e.hash &amp; (newCap - 1)] = e;<br>                  // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排<br>                  else if (e instanceof TreeNode)<br>                      ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);<br>                  // e是链表的头并且e.next!=null，那么处理链表中元素重排<br>                  else { // preserve order<br>                      // loHead,loTail 代表扩容后不用变换下标，见注1<br>                      Node&lt;K,V&gt; loHead = null, loTail = null;<br>                      // hiHead,hiTail 代表扩容后变换下标，见注1<br>                      Node&lt;K,V&gt; hiHead = null, hiTail = null;<br>                      Node&lt;K,V&gt; next;<br>                      // 遍历链表<br>                      do {<br>                          next = e.next;<br>                          if ((e.hash &amp; oldCap) == 0) {<br>                              if (loTail == null)<br>                                  // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead<br>                                  // 代表下标保持不变的链表的头元素<br>                                  loHead = e;<br>                              else<br>                                  // loTail.next指向当前e<br>                                  loTail.next = e;<br>                              // loTail指向当前的元素e<br>                              // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，<br>                              // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next…..<br>                              // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。<br>                              loTail = e;<br>                          }<br>                          else {<br>                              if (hiTail == null)<br>                                  // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素<br>                                  hiHead = e;<br>                              else<br>                                  hiTail.next = e;<br>                              hiTail = e;<br>                          }<br>                      } while ((e = next) != null);<br>                      // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。<br>                      if (loTail != null) {<br>                          loTail.next = null;<br>                          newTab[j] = loHead;<br>                      }<br>                      if (hiTail != null) {<br>                          hiTail.next = null;<br>                          newTab[j + oldCap] = hiHead;<br>                      }<br>                  }<br>              }<br>          }<br>      }<br>      return newTab;<br>  }</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">### HashMap是怎么解决哈希冲突的？</span><br><br><span class="hljs-bullet">-</span> 答：在解决这个问题之前，我们首先需要知道<span class="hljs-strong">**什么是哈希冲突**</span>，而在了解哈希冲突之前我们还要知道<span class="hljs-strong">**什么是哈希**</span>才行；<br><br><span class="hljs-section">#### 什么是哈希？</span><br><br><span class="hljs-bullet">-</span> Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。<br><br><span class="hljs-section">#### 什么是哈希冲突？</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）**</span>。<br><br><span class="hljs-section">#### HashMap的数据结构</span><br><br><span class="hljs-bullet">-</span> 在Java中，保存数据有两种比较简单的数据结构：数组和链表。<br><span class="hljs-bullet">  -</span> 数组的特点是：寻址容易，插入和删除困难；<br><span class="hljs-bullet">  -</span> 链表的特点是：寻址困难，但插入和删除容易；<br><span class="hljs-bullet">-</span> 所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：<br><br><br><br>![<span class="hljs-string">在这里插入图片描述</span>](<span class="hljs-link">https://user-gold-cdn.xitu.io/2020/4/13/171735521c92dc84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</span>)<br><br><br><br><span class="hljs-bullet">-</span> 链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；<br><span class="hljs-bullet">-</span> 开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**但相比于hashCode返回的int类型，我们HashMap初始的容量大小`DEFAULT<span class="hljs-emphasis">_INITIAL_</span>CAPACITY = 1 &lt;&lt; 4`（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表**</span>，所以我们还需要对hashCode作一定的优化<br><br><span class="hljs-section">#### hash()函数</span><br><br><span class="hljs-bullet">-</span> 上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<span class="hljs-strong">**参与运算的只有hashCode的低位**</span>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<span class="hljs-strong">**扰动**</span>，在<span class="hljs-strong">**JDK 1.8**</span>中的hash()函数如下：<br><br></code></pre></td></tr></table></figure><p>  static final int hash(Object key) {<br>      int h;<br>      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）<br>  }</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 这比在<span class="hljs-strong">**JDK 1.7**</span>中，更为简洁，<span class="hljs-strong">**相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）**</span>；<br><br><span class="hljs-section">#### 总结</span><br><br><span class="hljs-bullet">-</span> 简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：<br><span class="hljs-bullet">  -</span> 链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；<br><span class="hljs-bullet">  -</span> 开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。<br><br><span class="hljs-section">### 能否使用任何类作为 Map 的 key？</span><br><br>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：<br><br><span class="hljs-bullet">-</span> 如果类重写了 equals() 方法，也应该重写 hashCode() 方法。<br><span class="hljs-bullet">-</span> 类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。<br><span class="hljs-bullet">-</span> 如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。<br><span class="hljs-bullet">-</span> 用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。<br><br><span class="hljs-section">### 为什么HashMap中String、Integer这样的包装类适合作为K？</span><br><br><span class="hljs-bullet">-</span> 答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率<br><span class="hljs-bullet">  -</span> 都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况<br><span class="hljs-bullet">  -</span> 内部已重写了<span class="hljs-code">`equals()`</span>、<span class="hljs-code">`hashCode()`</span>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；<br><br><span class="hljs-section">### 如果使用Object作为HashMap的Key，应该怎么办呢？</span><br><br><span class="hljs-bullet">-</span> 答：重写<br><br></code></pre></td></tr></table></figure><p>  hashCode()<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>和<br><br></code></pre></td></tr></table></figure><br>  equals()<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>  方法<br><br><span class="hljs-bullet">  1.</span> <span class="hljs-strong">**重写`hashCode()`是因为需要计算存储数据的存储位置**</span>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；<br><span class="hljs-bullet">  2.</span> <span class="hljs-strong">**重写`equals()`方法**</span>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<span class="hljs-strong">**目的是为了保证key在哈希表中的唯一性**</span>；<br><br><span class="hljs-section">### HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</span><br><br><span class="hljs-bullet">-</span> 答：<span class="hljs-code">`hashCode()`</span>方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<span class="hljs-code">`hashCode()`</span>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**那怎么解决呢？**</span><br><span class="hljs-bullet">  1.</span> HashMap自己实现了自己的<span class="hljs-code">`hash()`</span>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；<br><span class="hljs-bullet">  2.</span> 在保证数组长度为2的幂次方的时候，使用<span class="hljs-code">`hash()`</span>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；<br><br><span class="hljs-section">### HashMap 的长度为什么是2的幂次方</span><br><br><span class="hljs-bullet">-</span> 为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**这个算法应该如何设计呢？**</span><br><span class="hljs-bullet">  -</span> 我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**那为什么是两次扰动呢？**</span><br><span class="hljs-bullet">  -</span> 答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；<br><br><span class="hljs-section">### HashMap 与 HashTable 有什么区别？</span><br><br><span class="hljs-bullet">1.</span> <span class="hljs-strong">**线程安全**</span>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <span class="hljs-code">`synchronized`</span> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；<br><br><span class="hljs-bullet">2.</span> <span class="hljs-strong">**效率**</span>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；<br><br><span class="hljs-bullet">3.</span> <span class="hljs-strong">**对Null key 和Null value的支持**</span>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。<br><br><span class="hljs-bullet">4.</span> 初始容量大小和每次扩充容量大小的不同<br><br><span class="hljs-code">    ：</span><br><span class="hljs-code"></span><br><span class="hljs-code">   1. 创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</span><br><span class="hljs-code">   2. 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</span><br><span class="hljs-code"></span><br><span class="hljs-code">5. **底层数据结构**： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</span><br><span class="hljs-code"></span><br><span class="hljs-code">6. 推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</span><br><span class="hljs-code"></span><br><span class="hljs-code">### 什么是TreeMap 简介</span><br><span class="hljs-code"></span><br><span class="hljs-code">- TreeMap 是一个**有序的key-value集合**，它是通过红黑树实现的。</span><br><span class="hljs-code">- TreeMap基于**红黑树（Red-Black tree）实现**。该映射根据**其键的自然顺序进行排序**，或者根据**创建映射时提供的 Comparator 进行排序**，具体取决于使用的构造方法。</span><br><span class="hljs-code">- TreeMap是线程**非同步**的。</span><br><span class="hljs-code"></span><br><span class="hljs-code">### 如何决定使用 HashMap 还是 TreeMap？</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</span><br><span class="hljs-code"></span><br><span class="hljs-code">### HashMap 和 ConcurrentHashMap 的区别</span><br><span class="hljs-code"></span><br><span class="hljs-code">1. ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</span><br><span class="hljs-code">2. HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</span><br><span class="hljs-code"></span><br><span class="hljs-code">### ConcurrentHashMap 和 Hashtable 的区别？</span><br><span class="hljs-code"></span><br><span class="hljs-code">- ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</span><br><span class="hljs-code"></span><br><span class="hljs-code">  - **底层数据结构**： JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</span><br><span class="hljs-code"></span><br><span class="hljs-code">  - 实现线程安全的方式</span><br><span class="hljs-code"></span><br><span class="hljs-code">    ：</span><br><span class="hljs-code"></span><br><span class="hljs-code">    1. **在JDK1.7的时候，ConcurrentHashMap（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） **到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</span><br><span class="hljs-code">    2. ② **Hashtable(同一把锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</span><br><span class="hljs-code"></span><br><span class="hljs-code">- **两者的对比图**：</span><br><span class="hljs-code"></span><br><span class="hljs-code">##### 1、HashTable:</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/13/171735521ca71b79?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">##### 2、 JDK1.7的ConcurrentHashMap：</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/13/171735521de4886d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">##### 3、JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/13/171735522b19186a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">- 答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</span><br><span class="hljs-code"></span><br><span class="hljs-code">### ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</span><br><span class="hljs-code"></span><br><span class="hljs-code">#### JDK1.7</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</span><br><span class="hljs-code">- 在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</span><br><span class="hljs-code">- 一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/13/171735524c5089b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">1. 该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</span><br><span class="hljs-code">2. Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</span><br><span class="hljs-code"></span><br><span class="hljs-code">#### JDK1.8</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 在**JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现**，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</span><br><span class="hljs-code">- 结构如下：</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/13/17173552564c22be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code">- **附加源码，有需要的可以看看**</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 插入元素过程（建议去看看源码）：</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><br>  else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {<br>      if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))<br>          break;                   // no lock when adding to empty bin<br>  }</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><br>- 如果相应位置的<span class="hljs-keyword">Node</span><span class="hljs-title">不为空，且当前该节点不处于移动状态，则对该节点加synchronized</span>锁，如果该节点的hash不小于<span class="hljs-number">0</span>，则遍历链表更新节点或插入新节点；<br><br></code></pre></td></tr></table></figure><p>  if (fh &gt;= 0) {<br>      binCount = 1;<br>      for (Node&lt;K,V&gt; e = f;; ++binCount) {<br>          K ek;<br>          if (e.hash == hash &amp;&amp;<br>              ((ek = e.key) == key ||<br>               (ek != null &amp;&amp; key.equals(ek)))) {<br>              oldVal = e.val;<br>              if (!onlyIfAbsent)<br>                  e.val = value;<br>              break;<br>          }<br>          Node&lt;K,V&gt; pred = e;<br>          if ((e = e.next) == null) {<br>              pred.next = new Node&lt;K,V&gt;(hash, key, value, null);<br>              break;<br>          }<br>      }<br>  }</p><p>  ```</p><ol><li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li><li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li></ol>]]></content>
    
    
    <categories>
      
      <category>java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection接口</title>
    <link href="/blog/2021/07/31/Collection%E6%8E%A5%E5%8F%A3/"/>
    <url>/blog/2021/07/31/Collection%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><ul><li>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li><li>因为所有Collection接继承了Iterator迭代器</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/13/17173551e6f6342b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h4 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h4><ul><li><p>Iterator 使用代码如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">List&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-literal">it</span> = <span class="hljs-keyword">list</span>. iterator();<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">it</span>. hasNext())&#123;<br>  <span class="hljs-built_in">String</span> obj = <span class="hljs-literal">it</span>. next();<br>  System. out. println(obj);<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p></li></ul><h4 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h4><ul><li><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">Iterator</span>&lt;<span class="hljs-keyword">Integer</span>&gt; it = <span class="hljs-keyword">list</span>.<span class="hljs-built_in">iterator</span>();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>   *<span class="hljs-comment">// do something*</span><br>   it.remove();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一种最常见的<strong>错误</strong>代码如下：</p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span>(Integer <span class="hljs-attribute">i </span>: list)&#123;<br>   <span class="hljs-selector-tag">list</span><span class="hljs-selector-class">.remove</span>(i)<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</li></ul><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h4 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List-遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4><ul><li>遍历方式有以下几种：<ol><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ol></li><li>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。<ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li><li>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</li></ul></li></ul><h4 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h4><ul><li>ArrayList的优点如下：<ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul></li><li>ArrayList 的缺点如下：<ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li></ul></li><li>ArrayList 比较适合顺序添加、随机访问的场景。</li></ul><h4 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h4><ul><li><p>数组转 List：使用 Arrays. asList(array) 进行转换。</p></li><li><p>List 转数组：使用 List 自带的 toArray() 方法。</p></li><li><p>代码示例：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">// list to array<br>List&lt;String&gt; list =<span class="hljs-built_in"> new </span>ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-string">&quot;456&quot;</span>);<br>list.toArray();<br><br>//<span class="hljs-built_in"> array </span>to list<br>String[]<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>String[]&#123;<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>&#125;;<br>Arrays.asList(array);<br><br></code></pre></td></tr></table></figure><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4></li><li><p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p></li><li><p>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li><p>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p></li><li><p>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p></li><li><p>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li><li><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p></li><li><p>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p></li></ul><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><ul><li>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合<ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul></li><li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</li><li>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</li></ul><h4 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h4><ul><li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li><li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li><li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li></ul><h4 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h4><ul><li><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">List&lt;<span class="hljs-keyword">String</span>&gt; synchronizedList = Collections.synchronizedList(list);<br>synchronizedList.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>synchronizedList.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;bbb&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; synchronizedList.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    System.out.<span class="hljs-built_in">println</span>(synchronizedList.<span class="hljs-built_in">get</span>(i));<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4></li><li><p>ArrayList 中的数组定义如下：</p><p>private transient Object[] elementData;</p></li><li><p>再看一下 ArrayList 的定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList&lt;E&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList&lt;E&gt;</span></span><br><span class="hljs-class">     <span class="hljs-title">implements</span> <span class="hljs-title">List&lt;E&gt;</span>, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure></li><li><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void write<span class="hljs-constructor">Object(<span class="hljs-params">java</span>.<span class="hljs-params">io</span>.ObjectOutputStream <span class="hljs-params">s</span>)</span> throws java.io.IOException&#123;<br>    *<span class="hljs-comment">// Write out element count, and any hidden stuff*</span><br>        <span class="hljs-built_in">int</span> expectedModCount = modCount;<br>    s.default<span class="hljs-constructor">WriteObject()</span>;<br>    *<span class="hljs-comment">// Write out array length*</span><br>        s.write<span class="hljs-constructor">Int(<span class="hljs-params">elementData</span>.<span class="hljs-params">length</span>)</span>;<br>    *<span class="hljs-comment">// Write out all elements in the proper order.*</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>            s.write<span class="hljs-constructor">Object(<span class="hljs-params">elementData</span>[<span class="hljs-params">i</span>])</span>;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ConcurrentModificationException()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p></li></ul><h4 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h4><ul><li>List , Set 都是继承自Collection 接口</li><li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li><li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li><li>Set和List对比<ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li></ul></li></ul><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><ul><li>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li></ul><h4 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><ul><li><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p></li><li><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p></li><li><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p></li><li><p>以下是HashSet 部分源码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span> PRESENT = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">HashMap</span>&lt;E,<span class="hljs-keyword">Object</span>&gt; <span class="hljs-built_in">map</span>;<br><br><span class="hljs-keyword">public</span> HashSet() &#123;<br>    <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;<br>    <span class="hljs-comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p><strong>hashCode（）与equals（）的相关规定</strong>：</p><ol><li>如果两个对象相等，则hashcode一定也是相同的<ul><li>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</li></ul></li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间  equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li></ol><h4 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h4><blockquote><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用put（）向map中添加元素</td><td>调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></blockquote>]]></content>
    
    
    <categories>
      
      <category>java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Collection</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java常用API</title>
    <link href="/blog/2021/07/29/%E5%B8%B8%E7%94%A8API/"/>
    <url>/blog/2021/07/29/%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ol><h4 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h4><ul><li>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li></ul><h4 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗"></a>String 是最基本的数据类型吗</h4><ul><li>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">这是很基础的东西，但是很多初学者却容易忽视，Java 的 <span class="hljs-number">8</span> 种基本数据类型中不包括 <span class="hljs-keyword">String</span>，基本数据类型中用来描述文本数据的是 <span class="hljs-keyword">char</span>，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 <span class="hljs-keyword">char</span> 类型的变量，也就是一个 <span class="hljs-keyword">char</span> 类型数组，比如“你好” 就是长度为<span class="hljs-number">2</span>的数组 <span class="hljs-keyword">char</span>\[\] chars = &#123;‘你’,‘好’&#125;;<br>但是使用数组过于麻烦，所以就有了 <span class="hljs-keyword">String</span>，<span class="hljs-keyword">String</span> 底层就是一个 <span class="hljs-keyword">char</span> 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。<br></code></pre></td></tr></table></figure><h4 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h4><ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><h4 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h4><ul><li><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><p>/** The value is used for character storage. */ private final char value[];</p></li></ul><h4 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h4><ul><li>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</li></ul><p><strong>1 String不可变但不代表引用不可以变</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span> + <span class="hljs-string">&quot; World&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;str=&quot;</span> + <span class="hljs-built_in">str</span>);<br>复制代码<br></code></pre></td></tr></table></figure><ul><li><p>结果：</p><p>str=Hello World</p></li><li><p>解析：</p></li><li><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p></li></ul><p><strong>2.通过反射是可以修改所谓的“不可变”对象</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 创建字符串&quot;Hello World&quot;， 并赋给引用s</span><br>String s = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;s = &quot;</span> + s); <span class="hljs-comment">// Hello World</span><br><br><span class="hljs-comment">// 获取String类中的value字段</span><br>Field valueFieldOfString = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;value&quot;</span>)</span>;<br><br><span class="hljs-comment">// 改变value属性的访问权限</span><br>valueFieldOfString.set<span class="hljs-constructor">Accessible(<span class="hljs-params">true</span>)</span>;<br><br><span class="hljs-comment">// 获取s对象上的value属性的值</span><br><span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> value = (<span class="hljs-built_in">char</span><span class="hljs-literal">[]</span>) valueFieldOfString.get(s);<br><br><span class="hljs-comment">// 改变value所引用的数组中的第5个字符</span><br>value<span class="hljs-literal">[<span class="hljs-number">5</span>]</span> = <span class="hljs-character">&#x27;_&#x27;</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;s = &quot;</span> + s); <span class="hljs-comment">// Hello_World</span><br>复制代码<br></code></pre></td></tr></table></figure><ul><li><p>结果：</p><p>s = Hello World s = Hello_World</p></li><li><p>解析：</p></li><li><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p></li></ul><h4 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h4><ul><li>String 类是 final 类，不可以被继承。</li></ul><h4 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h4><ul><li>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</li></ul><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h4><ul><li><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><p>String str1 = “hello”; //str1指向静态区 String str2 = new String(“hello”);  //str2指向堆上的对象 String str3 = “hello”; String str4 = new String(“hello”); System.out.println(str1.equals(str2)); //true System.out.println(str2.equals(str4)); //true System.out.println(str1 == str3); //true System.out.println(str1 == str2); //false System.out.println(str2 == str4); //false System.out.println(str2 == “hello”); //false str2 = str1; System.out.println(str2 == “hello”); //true</p></li></ul><h4 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h4><ul><li><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p></li><li><p>示例代码：</p><p>// StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer. append(“abcdefg”); System. out. println(stringBuffer. reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder. append(“abcdefg”); System. out. println(stringBuilder. reverse()); // gfedcba</p></li></ul><h4 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h4><ul><li>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</li></ul><h4 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h4><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h4 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><ul><li>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</li></ul><h4 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><p><strong>可变性</strong></p><ul><li>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</li></ul><p><strong>线程安全性</strong></p><ul><li>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li></ul><p><strong>性能</strong></p><ul><li>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><p><strong>对于三者使用的总结</strong></p><ul><li>如果要操作少量的数据用 = String</li><li>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</li><li>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</li></ul><h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h3 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h3><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4><ul><li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</li><li>Java 为每个原始类型提供了包装类型：<ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul></li></ul><h4 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="Integer a= 127 与 Integer b = 127相等吗"></a>Integer a= 127 与 Integer b = 127相等吗</h4><ul><li>对于对象引用类型：==比较的是对象的内存地址。</li><li>对于基本数据类型：==比较的是值。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">如果整型字面量的值在<span class="hljs-number">-128</span>到<span class="hljs-number">127</span>之间，那么自动装箱时不会<span class="hljs-built_in">new</span>新的<span class="hljs-type">Integer</span>对象，而是直接引用常量池中的<span class="hljs-type">Integer</span>对象，超过范围 a1==b1的结果是<span class="hljs-keyword">false</span><br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-type">Integer</span> a = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">Integer</span> b = <span class="hljs-number">3</span>;  // 将<span class="hljs-number">3</span>自动装箱成<span class="hljs-type">Integer</span>类型<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a == b); // <span class="hljs-keyword">false</span> 两个引用没有引用同一对象<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a == c); // <span class="hljs-keyword">true</span> a自动拆箱成<span class="hljs-type">int</span>类型再和c比较<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(b == c); // <span class="hljs-keyword">true</span><br><br>    <span class="hljs-type">Integer</span> a1 = <span class="hljs-number">128</span>;<br>    <span class="hljs-type">Integer</span> b1 = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a1 == b1); // <span class="hljs-keyword">false</span><br><br>    <span class="hljs-type">Integer</span> a2 = <span class="hljs-number">127</span>;<br>    <span class="hljs-type">Integer</span> b2 = <span class="hljs-number">127</span>;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a2 == b2); // <span class="hljs-keyword">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>API</tag>
      
      <tag>常用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流和反射</title>
    <link href="/blog/2021/07/28/IO%E6%B5%81%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/blog/2021/07/28/IO%E6%B5%81%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Java</span> Io流共涉及<span class="hljs-number">40</span>多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I<span class="hljs-number">0</span>流的<span class="hljs-number">40</span>多个类都是从如下<span class="hljs-number">4</span>个抽象类基类中派生出来的。<br></code></pre></td></tr></table></figure><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">按操作方式分类结构图：<br></code></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/4/14/171744c4799a7a74?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">按操作对象分类结构图：<br></code></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/4/14/171744c479a04121?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul><li>简答<ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul></li><li>详细回答<ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul></li></ul><h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>静态编译和动态编译<ul><li>静态编译：在编译时确定类型，绑定对象</li><li>动态编译：运行时确定类型，绑定对象</li></ul></li></ul><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li></ul><h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><ul><li>反射是框架设计的灵魂。</li><li>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li><li>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</li></ul><h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Student &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> sex;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> score;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Get &#123;<br>    <span class="hljs-comment">//获取反射机制三种方式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//方式一(通过建立对象)</span><br>        Student stu = <span class="hljs-keyword">new</span> Student();<br>        <span class="hljs-keyword">Class</span> classobj1 = stu.getClass();<br>        System.out.<span class="hljs-keyword">println</span>(classobj1.getName());<br>        <span class="hljs-comment">//方式二（所在通过路径-相对路径）</span><br>        <span class="hljs-keyword">Class</span> classobj2 = <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;fanshe.Student&quot;</span>);<br>        System.out.<span class="hljs-keyword">println</span>(classobj2.getName());<br>        <span class="hljs-comment">//方式三（通过类名）</span><br>        <span class="hljs-keyword">Class</span> classobj3 = Student.<span class="hljs-keyword">class</span>;<br>        System.out.<span class="hljs-keyword">println</span>(classobj3.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/blog/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/blog/2021/07/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><ul><li><strong>面向过程</strong>：<ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul></li><li><strong>面向对象</strong>：<ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。<br>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。<br>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。<br></code></pre></td></tr></table></figure><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h4><p><strong>面向对象的特征主要有以下几个方面</strong>：</p><ul><li><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li><li><strong>封装</strong>把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</li><li><strong>继承</strong>是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。<ul><li>关于继承如下 3 点请记住：<ul><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ul></li></ul></li><li><strong>多态</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</li></ul><h4 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h4><ul><li>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li><li>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</li></ul><p><strong>多态的实现</strong></p><ul><li>Java实现多态有三个必要条件：继承、重写、向上转型。<ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。<br>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。<br></code></pre></td></tr></table></figure><h4 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h4><ul><li>单一职责原则SRP(Single Responsibility Principle)<br> 类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li>开放封闭原则OCP(Open－Close Principle)<br> 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br> 子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br> 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br> 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul><h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><ul><li>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</li><li>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ul><p><strong>相同点</strong></p><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><p><strong>不同点</strong></p><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>抽象类使用abstract关键字声明</td><td>接口使用interface关键字声明</td></tr><tr><td>实现</td><td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中的方法可以是任意访问修饰符</td><td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td></tr><tr><td>多继承</td><td>一个类最多只能继承一个抽象类</td><td>一个类可以实现多个接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段默认都是 static 和 final 的</td></tr></tbody></table><p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。<br></code></pre></td></tr></table></figure><ul><li>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：<ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul></li></ul><h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><ul><li>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</li></ul><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><ul><li>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li></ul><h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h4><ul><li>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li><li>成员变量：方法外部，类内部定义的变量</li><li>局部变量：类的方法中的变量。</li><li>成员变量和局部变量的区别</li></ul><p><strong>作用域</strong></p><ul><li>成员变量：针对整个类有效。</li><li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li></ul><p><strong>存储位置</strong></p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li><li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li></ul><p><strong>生命周期</strong></p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：当方法调用完，或者语句结束后，就自动释放。</li></ul><p><strong>初始值</strong></p><ul><li>成员变量：有默认初始值。</li><li>局部变量：没有默认初始值，使用前必须赋值。</li></ul><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><ul><li>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li></ul><h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><ul><li>帮助子类做初始化工作。</li></ul><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><ul><li>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li></ul><h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><ul><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ul><h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><ul><li>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li><li>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</li></ul><h4 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h4><ul><li>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li><li>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</li></ul><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">静态方法和实例方法的区别主要体现在两个方面：<br></code></pre></td></tr></table></figure><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ul><h4 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h4><ul><li>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</li></ul><h4 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h4><ul><li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h4><ul><li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</li></ul><h4 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">内部类可以分为四种：<span class="hljs-strong">**成员内部类、局部内部类、匿名内部类和静态内部类**</span>。<br></code></pre></td></tr></table></figure><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><ul><li><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> radius = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInner</span> &#123;</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;visit outer static  variable:&quot;</span> + radius);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Outer</span>.StaticInner <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>.StaticInner();<br><span class="hljs-keyword">inner</span>.visit();<br><br></code></pre></td></tr></table></figure><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5></li><li><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">int</span> radius = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count =<span class="hljs-number">2</span>;<br>    <br>     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> &#123;</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;visit outer static  variable:&quot;</span> + radius);<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;visit outer   variable:&quot;</span> + count);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>();<br><span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br><span class="hljs-keyword">inner</span>.visit();<br><br></code></pre></td></tr></table></figure><h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5></li><li><p>定义在方法中的内部类，就是局部内部类。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">Outer</span> &#123;<br><br>    private  <span class="hljs-type">int</span> out_a = <span class="hljs-number">1</span>;<br>    private static <span class="hljs-type">int</span> STATIC_b = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testFunctionClass()&#123;<br>        <span class="hljs-type">int</span> inner_c =<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;<br>            private <span class="hljs-type">void</span> fun()&#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(out_a);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(STATIC_b);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(inner_c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">Inner</span>  <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br>        <span class="hljs-keyword">inner</span>.fun();<br>    &#125;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> testStaticFunctionClass()&#123;<br>        <span class="hljs-type">int</span> d =<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;<br>            private <span class="hljs-type">void</span> fun()&#123;<br>                // <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(STATIC_b);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(d);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">Inner</span>  <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br>        <span class="hljs-keyword">inner</span>.fun();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> testStaticFunctionClass()&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-keyword">Inner</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">Inner</span>  <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br> &#125;<br><br></code></pre></td></tr></table></figure><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5></li><li><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params">final int i</span>)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Service</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span> );<br>                &#125;<br>            &#125;<br>        &#125;.method();<br>    &#125;<br> &#125;<br> <span class="hljs-comment">//匿名内部类必须继承或实现一个已有的接口 </span><br> <span class="hljs-keyword">interface</span> Service&#123;<br>    <span class="hljs-built_in">void</span> method();<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul></li><li><p>匿名内部类创建方式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type"></span>类/接口&#123; <br>  <span class="hljs-comment">//匿名内部类实现部分</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">我们为什么要使用内部类呢？因为它有以下优点：<br></code></pre></td></tr></table></figure><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调。</li></ul><h4 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h4><ol><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ol><h4 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><ul><li><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？先看这段代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Outer</span> &#123;<br><br>    <span class="hljs-built_in">void</span> outMethod()&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> a =<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">class</span> <span class="hljs-symbol">Inner</span> &#123;<br>            <span class="hljs-built_in">void</span> innerMethod()&#123;<br>                System.<span class="hljs-keyword">out</span>.println(a);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>以上例子，为什么要加final呢？是因为<strong>生命周期不一致</strong>， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p></li></ul><h4 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> &#123;</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">13</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> age = <span class="hljs-number">14</span>;<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;局部变量：&quot;</span> + age);<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;内部类变量：&quot;</span> + <span class="hljs-keyword">this</span>.age);<br>            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;外部类变量：&quot;</span> + Outer.<span class="hljs-keyword">this</span>.age);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        Outer.Inner in = <span class="hljs-keyword">new</span> Outer().<span class="hljs-keyword">new</span> Inner();<br>        in.<span class="hljs-built_in">print</span>();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">局部变量：14<br>内部类变量：13<br>外部类变量：12<br></code></pre></td></tr></table></figure><h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h4><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><ul><li>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li><li>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</li><li>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li></ul><h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="== 和 equals 的区别是什么"></a>== 和 equals 的区别是什么</h4><ul><li><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p></li><li><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p></li><li><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p></li><li><p><strong>举个例子：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test1</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// a 为一个引用</span><br>        <span class="hljs-built_in">String</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br>        <span class="hljs-built_in">String</span> aa = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br>        <span class="hljs-built_in">String</span> bb = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>        <span class="hljs-keyword">if</span> (aa == bb) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;aa==bb&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-comment">// false，非同一对象</span><br>            System.out.println(<span class="hljs-string">&quot;a==b&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a.equals(b)) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;aEQb&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>) &#123; <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;true&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>说明：</strong></p><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul></li></ul><h4 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h4><ul><li>HashSet如何检查重复</li><li>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</li><li>hashCode和equals方法的关系</li><li>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</li></ul><p><strong>hashCode()介绍</strong></p><ul><li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</li><li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li></ul><p><strong>为什么要有 hashCode</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：<br></code></pre></td></tr></table></figure><ul><li>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</li></ul><p><strong>hashCode()与equals()的相关规定</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等，对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖<br>hash<span class="hljs-constructor">Code()</span> 的默认行为是对堆上的对象产生独特值。如果没有重写 hash<span class="hljs-constructor">Code()</span>，则该 <span class="hljs-keyword">class</span> 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）<br></code></pre></td></tr></table></figure><h4 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h4><ul><li>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</li></ul><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><ul><li>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</li></ul><h4 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h4><ul><li>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</li><li><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong><ul><li><strong>下面通过 3 个例子来给大家说明</strong></li></ul></li></ul><h5 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-type">int</span> num1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> num2 = <span class="hljs-number">20</span>;<br><br>    swap(num1, num2);<br><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;num1 = &quot; + num1);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;num2 = &quot; + num2);<br>&#125;<br><br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> swap(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = a;<br>    a = b;<br>    b = <span class="hljs-keyword">temp</span>;<br><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;a = &quot; + a);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;b = &quot; + b);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>结果：</p><p>a = 20 b = 10 num1 = 10 num2 = 20</p></li><li><p>解析：</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/14/171744c436af3af1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example.<br></code></pre></td></tr></table></figure><h5 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">0</span>]);<br>    change(arr);<br>    System.out.<span class="hljs-built_in">println</span>(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 将数组的第一个元素变为0</span><br>    <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>结果：</p><p>1 0</p></li><li><p>解析：</p></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1-20210726133058620.jpg" alt="在这里插入图片描述"></p><ul><li>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">通过</span> <span class="hljs-comment">example2</span> <span class="hljs-comment">我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</span><br><span class="hljs-comment">很多程序设计语言（特别是，C</span>++<span class="hljs-comment">和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</span><br></code></pre></td></tr></table></figure><h5 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        // TODO Auto-<span class="hljs-keyword">generated</span> <span class="hljs-keyword">method</span> stub<br>        Student s1 = <span class="hljs-built_in">new</span> Student(&quot;小张&quot;);<br>        Student s2 = <span class="hljs-built_in">new</span> Student(&quot;小李&quot;);<br>        Test.swap(s1, s2);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;s1:&quot; + s1.getName());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;s2:&quot; + s2.getName());<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> swap(Student x, Student y) &#123;<br>        Student <span class="hljs-keyword">temp</span> = x;<br>        x = y;<br>        y = <span class="hljs-keyword">temp</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;x:&quot; + x.getName());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;y:&quot; + y.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>结果：</p><p>x:小李 y:小张 s1:小张 s2:小李</p></li><li><p>解析：</p></li><li><p>交换之前：</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/14/171744c445af6270?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li>交换之后：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/14/171744c45facc688?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li>通过上面两张图可以很清晰的看出：<code>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</code></li><li>总结<ul><li><code>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</code></li></ul></li><li>下面再总结一下Java中方法参数的使用情况：<ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul></li></ul><h4 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h4><ul><li>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li><li>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul><h3 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h3><h4 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h4><ul><li>java.lang：这个是系统的基础类；</li><li>java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li>java.net：这里面是与网络有关的类；</li><li>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h4 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h4><ul><li>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">所以，实际上java和javax没有区别。这都是一个名字。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象</tag>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础语法</title>
    <link href="/blog/2021/07/25/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/blog/2021/07/25/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><p><strong>分类</strong></p><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><p><strong>Java基本数据类型图</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/4/14/171744c434465b69?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><ul><li>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</li></ul><h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><ul><li>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</li></ul><h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><ul><li>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</li></ul><h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h4><ul><li>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</li></ul><h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><ul><li>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</li><li>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</li></ul><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><ul><li>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="什么Java注释"><a href="#什么Java注释" class="headerlink" title="什么Java注释"></a>什么Java注释</h4><p><strong>定义</strong>：用于解释说明程序的文字</p><p><strong>分类</strong></p><ul><li>单行注释<br> 格式： // 注释文字</li><li>多行注释<br> 格式： /* 注释文字 */</li><li>文档注释<br> 格式：/** 注释文字 */</li></ul><p><strong>作用</strong></p><ul><li>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">注意事项：多行和文档注释都不能嵌套使用。<br></code></pre></td></tr></table></figure><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的区别</h4><ul><li><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</li><li><strong>分类</strong><ul><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法</li></ul></li></ul><p><strong>访问修饰符图</strong></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1-20210725093511338.jpg" alt="在这里插入图片描述"></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><ul><li>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</li><li>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">注意：逻辑或运算符（|<span class="hljs-string">）和短路或运算符（</span>||<span class="hljs-string">）的差别也是如此。</span><br></code></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h4><ul><li>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</li></ul><h4 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">用于修饰类、属性和方法；<br></code></pre></td></tr></table></figure><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的 最后判断。</li></ul><h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><ul><li><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p></li><li><p>this的用法在java中大体可以分为3种：</p><ul><li><p>1.普通的直接引用，this相当于是指向当前对象本身。</p></li><li><p>2.形参与成员名字重名，用this来区分：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3.引用本类的构造函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">private</span> int age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span> &#123;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, int age</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>(name);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4></li></ul></li><li><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p></li><li><p>super也有三种用法：</p><ul><li><p>1.普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p></li><li><p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> name;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br> <br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> name1</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.name = name1;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">getInfo</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name);      <span class="hljs-comment">//Child</span><br>        System.out.println(<span class="hljs-built_in">super</span>.name);     <span class="hljs-comment">//Father</span><br>    &#125;<br> <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>       Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Father&quot;</span>,<span class="hljs-string">&quot;Child&quot;</span>);<br>       s1.getInfo();<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3.引用父类构造函数</p><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li><li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li></ul></li></ul></li></ul><h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><ul><li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h4 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h4><ul><li>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</li><li>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li><li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li></ul><h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><ul><li>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</li></ul><blockquote><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p></blockquote><ul><li>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li><li>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li><li>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ul><h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><ul><li>因为static是被类的实例对象所共享，因此如果<strong>某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量</strong>。</li><li>因此比较常见的static应用场景有：</li></ul><blockquote><p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p></blockquote><h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><ul><li>1、静态只能访问静态。</li><li>2、非静态既可以访问非静态的，也可以访问静态的。</li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><ul><li>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li><li>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</li><li>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</li></ul><h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><ul><li><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    ok:<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot;,j=&quot;</span> + j);<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-keyword">break</span> ok;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/blog/2021/07/24/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/24/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="1-什么是观察者模式"><a href="#1-什么是观察者模式" class="headerlink" title="1.什么是观察者模式"></a>1.什么是观察者模式</h3><ul><li>先讲什么是行为性模型，行为型模式关注的是系统中对象之间的相互交互，解决系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。</li><li>观察者模式，是一种行为性模型，又叫发布-订阅模式，他定义对象之间一种一对多的依赖关系，使得当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</li></ul><h3 id="2-模式的职责"><a href="#2-模式的职责" class="headerlink" title="2.模式的职责"></a>2.模式的职责</h3><ul><li>观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。</li></ul><p><strong>实现有两种方式：</strong></p><ol><li>推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。</li><li>拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。</li></ol><h3 id="3-观察者模式应用场景"><a href="#3-观察者模式应用场景" class="headerlink" title="3.观察者模式应用场景"></a>3.观察者模式应用场景</h3><ol><li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。</li><li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li></ol><h3 id="4-代码实现观察者模式"><a href="#4-代码实现观察者模式" class="headerlink" title="4.代码实现观察者模式"></a>4.代码实现观察者模式</h3><ol><li>定义抽象观察者，每一个实现该接口的实现类都是具体观察者。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//观察者的接口，用来存放观察者共有方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-comment">// 观察者方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>定义具体观察者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">// 具体观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br><br>    <span class="hljs-comment">// 具体观察者的属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> myState;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>&#123;<br>        myState=state;<br>        System.out.println(<span class="hljs-string">&quot;收到消息,myState值改为：&quot;</span>+state);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMyState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myState;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>定义主题。主题定义观察者数组，并实现增、删及通知操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.Vector;<br><br><span class="hljs-comment">//定义主题，以及定义观察者数组，并实现增、删及通知操作。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subjecct</span> </span>&#123;<br><span class="hljs-comment">//观察者的存储集合，不推荐ArrayList，线程不安全，</span><br><span class="hljs-keyword">private</span> Vector&lt;Observer&gt; list = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br><br><span class="hljs-comment">// 注册观察者方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer obs)</span> </span>&#123;<br>list.add(obs);<br>&#125;<br>    <span class="hljs-comment">// 删除观察者方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer obs)</span> </span>&#123;<br>list.remove(obs);<br>&#125;<br><br><span class="hljs-comment">// 通知所有的观察者更新</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAllObserver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (Observer observer : list) &#123;<br>observer.update(state);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>定义具体的，他继承继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多。</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pf">package com.lijie;<br><br>//具体主题<br>public class RealObserver extends Subjecct &#123;<br>    //被观察对象的属性<br> private int <span class="hljs-keyword">state</span>;<br> public int getState()&#123;<br> return <span class="hljs-keyword">state</span>;<br> &#125;<br> public void  <span class="hljs-built_in">set</span>State(int <span class="hljs-keyword">state</span>)&#123;<br> this.<span class="hljs-keyword">state</span>=<span class="hljs-keyword">state</span>;<br> //主题对象(目标对象)值发生改变<br> this.notifyAllObserver(<span class="hljs-keyword">state</span>);<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>运行测试</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.lijie;<br><br>public <span class="hljs-keyword">class</span> Client &#123;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br><span class="hljs-comment">// 目标对象</span><br>RealObserver subject = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RealObserver()</span>;<br><span class="hljs-comment">// 创建多个观察者</span><br>ObserverImpl obs1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObserverImpl()</span>;<br>ObserverImpl obs2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObserverImpl()</span>;<br>ObserverImpl obs3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObserverImpl()</span>;<br><span class="hljs-comment">// 注册到观察队列中</span><br>subject.register<span class="hljs-constructor">Observer(<span class="hljs-params">obs1</span>)</span>;<br>subject.register<span class="hljs-constructor">Observer(<span class="hljs-params">obs2</span>)</span>;<br>subject.register<span class="hljs-constructor">Observer(<span class="hljs-params">obs3</span>)</span>;<br><span class="hljs-comment">// 改变State状态</span><br>subject.set<span class="hljs-constructor">State(300)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;obs1观察者的MyState状态值为：&quot;</span>+obs1.get<span class="hljs-constructor">MyState()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;obs2观察者的MyState状态值为：&quot;</span>+obs2.get<span class="hljs-constructor">MyState()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;obs3观察者的MyState状态值为：&quot;</span>+obs3.get<span class="hljs-constructor">MyState()</span>);<br><span class="hljs-comment">// 改变State状态</span><br>subject.set<span class="hljs-constructor">State(400)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;obs1观察者的MyState状态值为：&quot;</span>+obs1.get<span class="hljs-constructor">MyState()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;obs2观察者的MyState状态值为：&quot;</span>+obs2.get<span class="hljs-constructor">MyState()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;obs3观察者的MyState状态值为：&quot;</span>+obs3.get<span class="hljs-constructor">MyState()</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>观察者</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/blog/2021/07/23/%E7%AD%96%E7%95%A5-%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/23/%E7%AD%96%E7%95%A5-%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="1-什么是策略模式"><a href="#1-什么是策略模式" class="headerlink" title="1.什么是策略模式"></a>1.什么是策略模式</h3><ul><li>定义了一系列的算法 或 逻辑 或 相同意义的操作，并将每一个算法、逻辑、操作封装起来，而且使它们还可以相互替换。（其实策略模式Java中用的非常非常广泛）</li><li>我觉得主要是为了 简化 if…else 所带来的复杂和难以维护。</li></ul><h3 id="2-策略模式应用场景"><a href="#2-策略模式应用场景" class="headerlink" title="2.策略模式应用场景"></a>2.策略模式应用场景</h3><ul><li>策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。</li></ul><ol><li>例如：我要做一个不同会员打折力度不同的三种策略，初级会员，中级会员，高级会员（三种不同的计算）。</li><li>例如：我要一个支付模块，我要有微信支付、支付宝支付、银联支付等</li></ol><h3 id="3-策略模式的优点和缺点"><a href="#3-策略模式的优点和缺点" class="headerlink" title="3.策略模式的优点和缺点"></a>3.策略模式的优点和缺点</h3><ul><li>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性非常良好。</li><li>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</li></ul><h3 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><ul><li>模拟支付模块有微信支付、支付宝支付、银联支付</li></ul><ol><li>定义抽象的公共方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//策略模式 定义抽象方法 所有支持公共接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayStrategy</span> </span>&#123;<br><br><span class="hljs-comment">// 支付逻辑方法</span><br><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithmInterface</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>定义实现微信支付</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PayStrategy</span> </span>&#123;<br><br>void algorithmInterface() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;微信支付&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>定义实现支付宝支付</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayStrategyB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PayStrategy</span> </span>&#123;<br><br>void algorithmInterface() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;支付宝支付&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>定义实现银联支付</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayStrategyC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PayStrategy</span> </span>&#123;<br><br>void algorithmInterface() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;银联支付&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>定义下文维护算法策略</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<span class="hljs-comment">// 使用上下文维护算法策略</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br><br>PayStrategy strategy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Context</span>(<span class="hljs-params">PayStrategy strategy</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.strategy = strategy;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">algorithmInterface</span>(<span class="hljs-params"></span>)</span> &#123;<br>strategy.algorithmInterface();<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>运行测试</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTestStrategy</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>Context context;<br><span class="hljs-comment">//使用支付逻辑A</span><br>context = <span class="hljs-keyword">new</span> <span class="hljs-type">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PayStrategyA</span>());<br>context.algorithmInterface();<br><span class="hljs-comment">//使用支付逻辑B</span><br>context = <span class="hljs-keyword">new</span> <span class="hljs-type">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PayStrategyB</span>());<br>context.algorithmInterface();<br><span class="hljs-comment">//使用支付逻辑C</span><br>context = <span class="hljs-keyword">new</span> <span class="hljs-type">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">PayStrategyC</span>());<br>context.algorithmInterface();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/blog/2021/07/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="1-什么是原型模式"><a href="#1-什么是原型模式" class="headerlink" title="1.什么是原型模式"></a>1.什么是原型模式</h3><ul><li>原型设计模式简单来说就是克隆</li><li>原型表明了有一个样板实例，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。</li></ul><h3 id="2-原型模式的应用场景"><a href="#2-原型模式的应用场景" class="headerlink" title="2.原型模式的应用场景"></a>2.原型模式的应用场景</h3><ol><li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。这时我们就可以通过原型拷贝避免这些消耗。</li><li>通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">我们Spring框架中的多例就是使用原型。<br></code></pre></td></tr></table></figure><h3 id="3-原型模式的使用方式"><a href="#3-原型模式的使用方式" class="headerlink" title="3.原型模式的使用方式"></a>3.原型模式的使用方式</h3><ol><li>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</li><li>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此Prototype类需要将clone方法的作用域修改为public类型。</li></ol><h4 id="3-1原型模式分为浅复制和深复制"><a href="#3-1原型模式分为浅复制和深复制" class="headerlink" title="3.1原型模式分为浅复制和深复制"></a>3.1原型模式分为浅复制和深复制</h4><ol><li>（浅复制）只是拷贝了基本类型的数据，而引用类型数据，只是拷贝了一份引用地址。</li><li>（深复制）在计算机中开辟了一块新的内存地址用于存放复制的对象。</li></ol><h3 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h3><ol><li>创建User类</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-title">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> password;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt; phones;<br><br>    <span class="hljs-keyword">protected</span> User <span class="hljs-function"><span class="hljs-title">clone</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            User user = (User) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-comment">//重点，如果要连带引用类型一起复制，需要添加底下一条代码，如果不加就对于是复制了引用地址</span><br>            user.phones = (ArrayList&lt;<span class="hljs-built_in">String</span>&gt;) <span class="hljs-built_in">this</span>.phones.clone();<span class="hljs-comment">//设置深复制</span><br>            <span class="hljs-keyword">return</span> user;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><span class="hljs-comment">//省略所有属性Git Set方法......</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>测试复制</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package com.lijie;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Client &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        //创建<span class="hljs-keyword">User</span>原型对象<br>        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>();<br>        <span class="hljs-keyword">user</span>.setName(&quot;李三&quot;);<br>        <span class="hljs-keyword">user</span>.setPassword(&quot;123456&quot;);<br>        ArrayList&lt;String&gt; phones = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        phones.<span class="hljs-keyword">add</span>(&quot;17674553302&quot;);<br>        <span class="hljs-keyword">user</span>.setPhones(phones);<br><br>        //<span class="hljs-keyword">copy</span>一个<span class="hljs-keyword">user</span>对象,并且对象的属性<br>        <span class="hljs-keyword">User</span> user2 = <span class="hljs-keyword">user</span>.clone();<br>        user2.setPassword(&quot;654321&quot;);<br><br>        //查看俩个对象是否是一个<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span> == user2);<br><br>        //查看属性内容<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>.getName() + &quot; | &quot; + user2.getName());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>.getPassword() + &quot; | &quot; + user2.getPassword());<br>        //查看对于引用类型拷贝<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>.getPhones() == user2.getPhones());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果不需要深复制，需要删除User 中的</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//默认引用类型为浅复制，这是设置了深复制</span><br>user.phones = (ArrayList&lt;<span class="hljs-keyword">String</span>&gt;) <span class="hljs-keyword">this</span>.phones.clone();<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外观模式</title>
    <link href="/blog/2021/07/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="1-什么是外观模式"><a href="#1-什么是外观模式" class="headerlink" title="1.什么是外观模式"></a>1.什么是外观模式</h3><ul><li>外观模式：也叫门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</li><li>它向现有的系统添加一个接口，用这一个接口来隐藏实际的系统的复杂性。</li><li>使用外观模式，他外部看起来就是一个接口，其实他的内部有很多复杂的接口已经被实现</li></ul><h3 id="2-外观模式例子"><a href="#2-外观模式例子" class="headerlink" title="2.外观模式例子"></a>2.外观模式例子</h3><ul><li>用户注册完之后，需要调用阿里短信接口、邮件接口、微信推送接口。</li></ul><ol><li>创建阿里短信接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//阿里短信消息</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AliSmsService</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliSmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AliSmsService</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;阿里短信消息&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建邮件接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//发送邮件消息</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EamilSmsService</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EamilSmsServiceImpl</span> <span class="hljs-keyword">implements</span>   <span class="hljs-title">EamilSmsService</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;发送邮件消息&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建微信推送接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//微信消息推送</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WeiXinSmsService</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeiXinSmsServiceImpl</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">WeiXinSmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发送微信消息推送&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建门面（门面看起来很简单使用，复杂的东西以及被门面给封装好了）</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br>AliSmsService aliSmsService;<br>EamilSmsService eamilSmsService;<br>WeiXinSmsService weiXinSmsService;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Computer</span>(<span class="hljs-params"></span>)</span> &#123;<br>aliSmsService = <span class="hljs-keyword">new</span> AliSmsServiceImpl();<br>eamilSmsService = <span class="hljs-keyword">new</span> EamilSmsServiceImpl();<br>weiXinSmsService = <span class="hljs-keyword">new</span> WeiXinSmsServiceImpl();<br>&#125;<br><br><span class="hljs-comment">//只需要调用它</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sendMsg</span>(<span class="hljs-params"></span>)</span> &#123;<br>aliSmsService.sendSms();<br>eamilSmsService.sendSms();<br>weiXinSmsService.sendSms();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>启动测试</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">//普通模式需要这样</span><br>        AliSmsService aliSmsService = <span class="hljs-keyword">new</span> <span class="hljs-type">AliSmsServiceImpl</span>();<br>        EamilSmsService eamilSmsService = <span class="hljs-keyword">new</span> <span class="hljs-type">EamilSmsServiceImpl</span>();<br>        WeiXinSmsService weiXinSmsService = <span class="hljs-keyword">new</span> <span class="hljs-type">WeiXinSmsServiceImpl</span>();<br>        aliSmsService.sendSms();<br>        eamilSmsService.sendSms();<br>        weiXinSmsService.sendSms();<br><br>        <span class="hljs-comment">//利用外观模式简化方法</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Computer</span>().sendMsg();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>外观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/2021/07/20/Java%E5%B8%B8%E7%94%A8API/"/>
    <url>/blog/2021/07/20/Java%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/blog/2021/07/19/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/19/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="1-什么是模板方法"><a href="#1-什么是模板方法" class="headerlink" title="1.什么是模板方法"></a>1.什么是模板方法</h3><ul><li>模板方法模式：定义一个操作中的算法骨架（父类），而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构来重定义该算法的</li></ul><h3 id="2-什么时候使用模板方法"><a href="#2-什么时候使用模板方法" class="headerlink" title="2.什么时候使用模板方法"></a>2.什么时候使用模板方法</h3><ul><li>实现一些操作时，整体步骤很固定，但是呢。就是其中一小部分需要改变，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li></ul><h3 id="3-实际开发中应用场景哪里用到了模板方法"><a href="#3-实际开发中应用场景哪里用到了模板方法" class="headerlink" title="3.实际开发中应用场景哪里用到了模板方法"></a>3.实际开发中应用场景哪里用到了模板方法</h3><ul><li>其实很多框架中都有用到了模板方法模式</li><li>例如：数据库访问的封装、Junit单元测试、servlet中关于doGet/doPost方法的调用等等</li></ul><h3 id="4-现实生活中的模板方法"><a href="#4-现实生活中的模板方法" class="headerlink" title="4.现实生活中的模板方法"></a>4.现实生活中的模板方法</h3><p><strong>例如：</strong></p><ol><li>去餐厅吃饭，餐厅给我们提供了一个模板就是：看菜单，点菜，吃饭，付款，走人 （这里 “<strong>点菜和付款</strong>” 是不确定的由子类来完成的，其他的则是一个模板。）</li></ol><h3 id="5-代码实现模板方法模式"><a href="#5-代码实现模板方法模式" class="headerlink" title="5.代码实现模板方法模式"></a>5.代码实现模板方法模式</h3><ol><li>先定义一个模板。把模板中的点菜和付款，让子类来实现。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package com.lijie;<br><br><span class="hljs-comment">//模板方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RestaurantTemplate</span> &#123;<br><br><span class="hljs-comment">// 1.看菜单</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">menu</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;看菜单&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 2.点菜业务</span><br><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spotMenu</span>(<span class="hljs-params"></span>)</span>;<br><br><span class="hljs-comment">// 3.吃饭业务</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">havingDinner</span>(<span class="hljs-params"></span>)</span>&#123; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;吃饭&quot;</span>); &#125;<br><br><span class="hljs-comment">// 3.付款业务</span><br><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">payment</span>(<span class="hljs-params"></span>)</span>;<br><br><span class="hljs-comment">// 3.走人</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GoR</span>(<span class="hljs-params"></span>)</span> &#123; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;走人&quot;</span>); &#125;<br><br><span class="hljs-comment">//模板通用结构</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span>(<span class="hljs-params"></span>)</span>&#123;<br>menu();<br>spotMenu();<br>havingDinner();<br>payment();<br>GoR();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>具体的模板方法子类 1</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestaurantGinsengImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RestaurantTemplate</span> </span>&#123;<br><br>    void spotMenu() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;人参&quot;</span>);<br>    &#125;<br><br>    void payment() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;5快&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>具体的模板方法子类 2</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.lijie;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestaurantLobsterImpl</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">RestaurantTemplate</span>  </span>&#123;<br><br>    void spotMenu() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;龙虾&quot;</span>);<br>    &#125;<br><br>    void payment() &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;50块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>客户端测试</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//调用第一个模板实例</span><br>        RestaurantTemplate restaurantTemplate = <span class="hljs-keyword">new</span> RestaurantGinsengImpl();<br>        restaurantTemplate.<span class="hljs-built_in">process</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/blog/2021/07/18/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/18/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="1-什么是建造者模式"><a href="#1-什么是建造者模式" class="headerlink" title="1.什么是建造者模式"></a>1.什么是建造者模式</h3><ul><li>建造者模式：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的方式进行创建。</li><li>工厂类模式是提供的是创建单个类的产品</li><li>而建造者模式则是将各种产品集中起来进行管理，用来具有不同的属性的产品</li></ul><p><strong>建造者模式通常包括下面几个角色：</strong></p><ol><li>uilder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。</li><li>ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。 在建造过程完成后，提供产品的实例。</li><li>Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li><li>Product：要创建的复杂对象。</li></ol><h3 id="2-建造者模式的使用场景"><a href="#2-建造者模式的使用场景" class="headerlink" title="2.建造者模式的使用场景"></a>2.建造者模式的使用场景</h3><p><strong>使用场景：</strong></p><ol><li>需要生成的对象具有复杂的内部结构。</li><li>需要生成的对象内部属性本身相互依赖。</li></ol><ul><li>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</li><li>JAVA 中的 StringBuilder就是建造者模式创建的，他把一个单个字符的char数组组合起来</li><li>Spring不是建造者模式，它提供的操作应该是对于字符串本身的一些操作，而不是创建或改变一个字符串。</li></ul><h3 id="3-代码案例"><a href="#3-代码案例" class="headerlink" title="3.代码案例"></a>3.代码案例</h3><ol><li>建立一个装备对象Arms</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//装备类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arms</span> </span>&#123;<br><span class="hljs-comment">//头盔</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> helmet;<br><span class="hljs-comment">//铠甲</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> armor;<br><span class="hljs-comment">//武器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> weapon;<br><br><span class="hljs-comment">//省略Git和Set方法...........</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建Builder接口（给出一个抽象接口，以规范产品对象的各个组成成分的建造，这个接口只是规范）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">builderHelmetMurder</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">builderArmorMurder</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">builderWeaponMurder</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">builderHelmetYanLong</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">builderArmorYanLong</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">builderWeaponYanLong</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function">Arms <span class="hljs-title">BuilderArms</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//组装</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><ol><li>创建Builder实现类（这个类主要实现复杂对象创建的哪些部分需要什么属性）</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArmsBuilder</span> <span class="hljs-title">implements</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Arms arms;<br><br>    <span class="hljs-comment">//创建一个Arms实例,用于调用set方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">ArmsBuilder</span>(<span class="hljs-params"></span>)</span> &#123;<br>        arms = <span class="hljs-keyword">new</span> Arms();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">builderHelmetMurder</span>(<span class="hljs-params"></span>)</span> &#123;<br>        arms.setHelmet(<span class="hljs-string">&quot;夺命头盔&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">builderArmorMurder</span>(<span class="hljs-params"></span>)</span> &#123;<br>        arms.setArmor(<span class="hljs-string">&quot;夺命铠甲&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">builderWeaponMurder</span>(<span class="hljs-params"></span>)</span> &#123;<br>        arms.setWeapon(<span class="hljs-string">&quot;夺命宝刀&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">builderHelmetYanLong</span>(<span class="hljs-params"></span>)</span> &#123;<br>        arms.setHelmet(<span class="hljs-string">&quot;炎龙头盔&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">builderArmorYanLong</span>(<span class="hljs-params"></span>)</span> &#123;<br>        arms.setArmor(<span class="hljs-string">&quot;炎龙铠甲&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">builderWeaponYanLong</span>(<span class="hljs-params"></span>)</span> &#123;<br>        arms.setWeapon(<span class="hljs-string">&quot;炎龙宝刀&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Arms <span class="hljs-function"><span class="hljs-title">BuilderArms</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> arms;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><ol><li>Director（调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建）</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package com.lijie;<br><br>public <span class="hljs-keyword">class</span> PersonDirector &#123;<br><br><span class="hljs-comment">//组装</span><br>public Arms construct<span class="hljs-constructor">Person(PersonBuilder <span class="hljs-params">pb</span>)</span> &#123;<br>pb.builder<span class="hljs-constructor">HelmetYanLong()</span>;<br>pb.builder<span class="hljs-constructor">ArmorMurder()</span>;<br>pb.builder<span class="hljs-constructor">WeaponMurder()</span>;<br>return pb.<span class="hljs-constructor">BuilderArms()</span>;<br>&#125;<br><br><span class="hljs-comment">//这里进行测试</span><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>PersonDirector pb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PersonDirector()</span>;<br>Arms arms = pb.construct<span class="hljs-constructor">Person(<span class="hljs-params">new</span> ArmsBuilder()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arms.get<span class="hljs-constructor">Helmet()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arms.get<span class="hljs-constructor">Armor()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(arms.get<span class="hljs-constructor">Weapon()</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>建造者</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/blog/2021/07/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="1-什么是代理模式"><a href="#1-什么是代理模式" class="headerlink" title="1.什么是代理模式"></a>1.什么是代理模式</h3><ul><li>通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AO的P微实现)</li><li>代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和Spring的（面向切面编程）很相似</li></ul><h3 id="2-代理模式应用场景"><a href="#2-代理模式应用场景" class="headerlink" title="2.代理模式应用场景"></a>2.代理模式应用场景</h3><ul><li>Spring AOP、日志打印、异常处理、事务控制、权限控制等</li></ul><h3 id="3-代理的分类"><a href="#3-代理的分类" class="headerlink" title="3.代理的分类"></a>3.代理的分类</h3><ul><li>静态代理(静态定义代理类)</li><li>动态代理(动态生成代理类，也称为Jdk自带动态代理)</li><li>Cglib 、javaassist（字节码操作库）</li></ul><h3 id="4-三种代理的区别"><a href="#4-三种代理的区别" class="headerlink" title="4.三种代理的区别"></a>4.三种代理的区别</h3><ol><li>静态代理：简单代理模式，是动态代理的理论基础。常见使用在代理模式</li><li>jdk动态代理：使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。</li><li>cglib动态代理：也是使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。（需要导入jar包）</li></ol><h3 id="5-用代码演示三种代理"><a href="#5-用代码演示三种代理" class="headerlink" title="5.用代码演示三种代理"></a>5.用代码演示三种代理</h3><h4 id="5-1-静态代理"><a href="#5-1-静态代理" class="headerlink" title="5.1.静态代理"></a>5.1.静态代理</h4><p><strong>什么是静态代理</strong></p><ul><li>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</li></ul><p><strong>代码演示：</strong></p><ul><li>我有一段这样的代码：（如何能在不修改UserDao接口类的情况下开事务和关闭事务呢）</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-comment">//接口类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">save</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;保存数据方法&quot;</span>);<br>&#125;<br>&#125;<br><br>package com.lijie;<br><br><span class="hljs-comment">//运行测试类</span><br><span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>UserDao userDao = <span class="hljs-keyword">new</span> UserDao();<br>userDao.save();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>修改代码，添加代理类</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-comment">//代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-keyword">private</span> UserDao userDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">UserDaoProxy</span>(<span class="hljs-params">UserDao userDao</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.userDao = userDao;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">save</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;开启事物...&quot;</span>);<br>userDao.save();<br>System.out.println(<span class="hljs-string">&quot;关闭事物...&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//添加完静态代理的测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>UserDao userDao = <span class="hljs-keyword">new</span> UserDao();<br>UserDaoProxy userDaoProxy = <span class="hljs-keyword">new</span> UserDaoProxy(userDao);<br>userDaoProxy.save();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>缺点：每个需要代理的对象都需要自己重复编写代理，很不舒服，</li><li>优点：但是可以面相实际对象或者是接口的方式实现代理</li></ul><h4 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2.动态代理"></a>2.2.动态代理</h4><p><strong>什么是动态代理</strong></p><ul><li>动态代理也叫做，JDK代理、接口代理。</li><li>动态代理的对象，是利用JDK的API，动态的在内存中构建代理对象（是根据被代理的接口来动态生成代理类的class文件，并加载运行的过程），这就叫动态代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//接口实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;保存数据方法&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>//下面是代理类，可重复使用，不像静态代理那样要自己重复编写代理</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvocationHandlerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br><span class="hljs-comment">// 这其实业务实现类对象，用来调用具体的业务方法</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-keyword">target</span>;<br><br>    <span class="hljs-comment">// 通过构造函数传入目标对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InvocationHandlerImpl</span><span class="hljs-params">(Object <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">target</span> = <span class="hljs-keyword">target</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//动态代理实际运行的代理方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用开始处理&quot;</span>);<br>        <span class="hljs-comment">//下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span><br>Object result = method.invoke(<span class="hljs-keyword">target</span>, args);<br>        System.out.println(<span class="hljs-string">&quot;调用结束处理&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>//利用动态代理使用代理方法</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">// 被代理对象</span><br>        UserDao userDaoImpl = <span class="hljs-keyword">new</span> <span class="hljs-type">UserDaoImpl</span>();<br>        InvocationHandlerImpl invocationHandlerImpl = <span class="hljs-keyword">new</span> <span class="hljs-type">InvocationHandlerImpl</span>(userDaoImpl);<br><br>        <span class="hljs-comment">//类加载器</span><br>        ClassLoader loader = userDaoImpl.getClass().getClassLoader();<br>        Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces();<br><br>        <span class="hljs-comment">// 主要装载器、一组接口及调用处理动态代理实例</span><br>        UserDao <span class="hljs-keyword">new</span><span class="hljs-type">ProxyInstance</span> = (UserDao) Proxy.<span class="hljs-keyword">new</span><span class="hljs-type">ProxyInstance</span>(loader, interfaces, invocationHandlerImpl);<br>        <span class="hljs-keyword">new</span><span class="hljs-type">ProxyInstance</span>.save();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>缺点：必须是面向接口，目标业务类必须实现接口</li><li>优点：不用关心代理类，只需要在运行阶段才指定代理哪一个对象</li></ul><h4 id="5-3-CGLIB动态代理"><a href="#5-3-CGLIB动态代理" class="headerlink" title="5.3.CGLIB动态代理"></a>5.3.CGLIB动态代理</h4><p><strong>CGLIB动态代理原理：</strong></p><ul><li>利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li></ul><p><strong>什么是CGLIB动态代理</strong></p><ul><li>CGLIB动态代理和jdk代理一样，使用反射完成代理，不同的是他可以直接代理类（jdk动态代理不行，他必须目标业务类必须实现接口），CGLIB动态代理底层使用字节码技术，CGLIB动态代理不能对 final类进行继承。（CGLIB动态代理需要导入jar包）</li></ul><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//接口实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;保存数据方法&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodProxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//代理主要类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><span class="hljs-keyword">private</span> Object targetObject;<br><span class="hljs-comment">// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Object target)</span> </span>&#123;<br><span class="hljs-comment">// 设置需要创建子类的类</span><br><span class="hljs-keyword">this</span>.targetObject = target;<br>Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>enhancer.setSuperclass(target.getClass());<br>enhancer.setCallback(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">return</span> enhancer.create();<br>&#125;<br><br><span class="hljs-comment">//代理实际方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;开启事物&quot;</span>);<br>Object result = proxy.invoke(targetObject, args);<br>System.out.println(<span class="hljs-string">&quot;关闭事物&quot;</span>);<br><span class="hljs-comment">// 返回代理对象</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//测试CGLIB动态代理</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        CglibProxy cglibProxy = <span class="hljs-keyword">new</span> CglibProxy();<br>        UserDao userDao = (UserDao) cglibProxy.getInstance(<span class="hljs-keyword">new</span> UserDaoImpl());<br>        userDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/blog/2021/07/16/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/16/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="1-什么是工厂模式"><a href="#1-什么是工厂模式" class="headerlink" title="1.什么是工厂模式"></a>1.什么是工厂模式</h3><ul><li>它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式</li></ul><h3 id="2-工厂模式好处"><a href="#2-工厂模式好处" class="headerlink" title="2.工厂模式好处"></a>2.工厂模式好处</h3><ul><li>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。</li><li>利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。</li><li>将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</li></ul><h3 id="3-为什么要学习工厂设计模式"><a href="#3-为什么要学习工厂设计模式" class="headerlink" title="3.为什么要学习工厂设计模式"></a>3.为什么要学习工厂设计模式</h3><ul><li>不知道你们面试题问到过源码没有，你知道Spring的源码吗，MyBatis的源码吗，等等等 如果你想学习很多框架的源码，或者你想自己开发自己的框架，就必须先掌握设计模式（工厂设计模式用的是非常非常广泛的）</li></ul><h3 id="4-Spring开发中的工厂设计模式"><a href="#4-Spring开发中的工厂设计模式" class="headerlink" title="4.Spring开发中的工厂设计模式"></a>4.Spring开发中的工厂设计模式</h3><p><strong>1.Spring IOC</strong></p><ul><li>看过Spring源码就知道，在Spring IOC容器创建bean的过程是使用了工厂设计模式</li><li>Spring中无论是通过xml配置还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的。</li><li>当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。</li></ul><p><strong>2.为什么Spring IOC要使用工厂设计模式创建Bean呢</strong></p><ul><li>在实际开发中，如果我们A对象调用B，B调用C，C调用D的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。）</li><li>在很久以前的三层架构编程时，都是控制层调用业务层，业务层调用数据访问层时，都是是直接new对象，耦合性大大提升，代码重复量很高，对象满天飞</li><li>为了避免这种情况，Spring使用工厂模式编程，写一个工厂，由工厂创建Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到Map集合中，保证了实例不会重复影响程序效率。</li></ul><h3 id="5-工厂模式分类"><a href="#5-工厂模式分类" class="headerlink" title="5.工厂模式分类"></a>5.工厂模式分类</h3><ul><li>工厂模式分为简单工厂、工厂方法、抽象工厂模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">简单工厂 ：用来生产同一等级结构中的任意产品。（不支持拓展增加产品）<br>工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）   <br>抽象工厂 ：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）<br><br></code></pre></td></tr></table></figure><h4 id="5-1-简单工厂模式"><a href="#5-1-简单工厂模式" class="headerlink" title="5.1 简单工厂模式"></a>5.1 简单工厂模式</h4><p><strong>什么是简单工厂模式</strong></p><ul><li>简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。</li></ul><p><strong>代码演示：</strong></p><ol><li>创建工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建工厂的产品（宝马）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bmw</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我是宝马汽车...&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建工另外一种产品（奥迪）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AoDi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我是奥迪汽车..&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建核心工厂类，由他决定具体调用哪产品</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactory</span> </span>&#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-function"><span class="hljs-title">createCar</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(name)) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(name.equals(<span class="hljs-string">&quot;奥迪&quot;</span>))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AoDi();<br>&#125;<br><span class="hljs-keyword">if</span>(name.equals(<span class="hljs-string">&quot;宝马&quot;</span>))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bmw();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>演示创建工厂的具体实例</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client01</span> &#123;</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>Car aodi  =CarFactory.createCar(<span class="hljs-string">&quot;奥迪&quot;</span>);<br>Car bmw  =CarFactory.createCar(<span class="hljs-string">&quot;宝马&quot;</span>);<br>aodi.<span class="hljs-built_in">run</span>();<br>bmw.<span class="hljs-built_in">run</span>();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>单工厂的优点/缺点</strong></p><ul><li>优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。</li><li>缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则</li></ul><h4 id="5-2-工厂方法模式"><a href="#5-2-工厂方法模式" class="headerlink" title="5.2 工厂方法模式"></a>5.2 工厂方法模式</h4><p><strong>什么是工厂方法模式</strong></p><ul><li>工厂方法模式Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节</li></ul><p><strong>代码演示：</strong></p><ol><li>创建工厂</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建工厂方法调用接口（所有的产品需要new出来必须继承他来实现方法）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> </span>&#123;<br><br><span class="hljs-function">Car <span class="hljs-title">createCar</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建工厂的产品（奥迪）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AoDi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我是奥迪汽车..&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建工厂另外一种产品（宝马）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bmw</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我是宝马汽车...&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建工厂方法调用接口的实例（奥迪）</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AoDiFactory</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">CarFactory</span></span> </span>&#123;<br><br><span class="hljs-keyword">public</span> Car createCar() &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AoDi</span>();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建工厂方法调用接口的实例（宝马）</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BmwFactory</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">CarFactory</span></span> </span>&#123;<br><br><span class="hljs-keyword">public</span> Car createCar() &#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Bmw</span>();<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>演示创建工厂的具体实例</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>Car aodi = <span class="hljs-keyword">new</span> AoDiFactory().createCar();<br>Car jili = <span class="hljs-keyword">new</span> BmwFactory().createCar();<br>aodi.<span class="hljs-built_in">run</span>();<br>jili.<span class="hljs-built_in">run</span>();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="5-3-抽象工厂模式"><a href="#5-3-抽象工厂模式" class="headerlink" title="5.3 抽象工厂模式"></a>5.3 抽象工厂模式</h4><p><strong>什么是抽象工厂模式</strong></p><ul><li><p>抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体工厂，由具体工厂来产生具体产品。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/13/17172acff9e664a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><p>代码演示：</p></li></ul><ol><li>创建第一个子工厂，及实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//汽车</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span></span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;宝马&quot;</span>);<br>&#125;<br><br>&#125;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span></span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;摩拜&quot;</span>);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建第二个子工厂，及实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-comment">//发动机</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Engine</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Engine</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;转的快!&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EngineB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Engine</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;转的慢!&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>创建一个总工厂，及实现类（由总工厂的实现类决定调用那个工厂的那个实例）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TotalFactory</span> </span>&#123;<br><span class="hljs-comment">// 创建汽车</span><br><span class="hljs-function">Car <span class="hljs-title">createChair</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 创建发动机</span><br><span class="hljs-function">Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//总工厂实现类，由他决定调用哪个工厂的那个实例</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TotalFactoryReally</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TotalFactory</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EngineA();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">createChair</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CarA();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>运行测试</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.lijie;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        TotalFactory totalFactory2 = <span class="hljs-keyword">new</span> TotalFactoryReally();<br>        Car car = totalFactory2.createChair();<br>        car.<span class="hljs-built_in">run</span>();<br><br>        TotalFactory totalFactory = <span class="hljs-keyword">new</span> TotalFactoryReally();<br>        Engine engine = totalFactory.createEngine();<br>        engine.<span class="hljs-built_in">run</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工厂模式</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/blog/2021/07/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="1-什么是单例"><a href="#1-什么是单例" class="headerlink" title="1.什么是单例"></a>1.什么是单例</h3><ul><li>保证一个类只有一个实例，并且提供一个访问该全局访问点</li></ul><h3 id="2-那些地方用到了单例模式"><a href="#2-那些地方用到了单例模式" class="headerlink" title="2.那些地方用到了单例模式"></a>2.那些地方用到了单例模式</h3><ol><li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li><li>应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。</li><li>多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制</li><li>Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个</li><li>windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。</li></ol><h3 id="3-单例优缺点"><a href="#3-单例优缺点" class="headerlink" title="3.单例优缺点"></a>3.单例优缺点</h3><p><strong>优点：</strong></p><ol><li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li><li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li><li>提供了对唯一实例的受控访问。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。</li><li>避免对共享资源的多重占用。</li></ol><p><strong>缺点：</strong></p><ol><li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li><li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ol><h3 id="4-单例模式使用注意事项："><a href="#4-单例模式使用注意事项：" class="headerlink" title="4.单例模式使用注意事项："></a>4.单例模式使用注意事项：</h3><ol><li>使用时不能用反射模式创建单例，否则会实例化一个新的对象</li><li>使用懒单例模式时注意线程安全问题</li><li>饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）</li></ol><h3 id="5-单例防止反射漏洞攻击"><a href="#5-单例防止反射漏洞攻击" class="headerlink" title="5.单例防止反射漏洞攻击"></a>5.单例防止反射漏洞攻击</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> flag = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;<br><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>) &#123;<br>flag = !flag;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;单例模式被侵犯！&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如何选择单例创建方式"><a href="#6-如何选择单例创建方式" class="headerlink" title="6.如何选择单例创建方式"></a>6.如何选择单例创建方式</h3><ul><li>如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。 如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒韩式。 最好使用饿汉式</li></ul><h3 id="7-单例创建方式"><a href="#7-单例创建方式" class="headerlink" title="7.单例创建方式"></a>7.单例创建方式</h3><p><strong>（主要使用懒汉和懒汉式）</strong></p><ol><li>饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。</li><li>懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。</li><li>静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</li><li>枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</li><li>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)</li></ol><h4 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h4><ol><li>饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-comment">//饿汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><br>    <span class="hljs-comment">// 类初始化时,会立即加载该对象，线程安全,调用效率高</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo1 demo1 = <span class="hljs-keyword">new</span> Demo1();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Demo1</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;私有Demo1构造参数初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo1 <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> demo1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Demo1 s1 = Demo1.getInstance();<br>        Demo1 s2 = Demo1.getInstance();<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h4><ol><li>懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-comment">//懒汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br><br>    <span class="hljs-comment">//类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo2 demo2;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Demo2</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;私有Demo2构造参数初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> Demo2 <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (demo2 == <span class="hljs-literal">null</span>) &#123;<br>            demo2 = <span class="hljs-keyword">new</span> Demo2();<br>        &#125;<br>        <span class="hljs-keyword">return</span> demo2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Demo2 s1 = Demo2.getInstance();<br>        Demo2 s2 = Demo2.getInstance();<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3.静态内部类"></a>3.静态内部类</h4><ol><li>静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.lijie;<br><br><span class="hljs-comment">// 静态内部类方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> &#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Demo3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;私有Demo3构造参数初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClassInstance</span> &#123;</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Demo3 DEMO_3 = <span class="hljs-keyword">new</span> Demo3();<br>    &#125;<br><br>    <span class="hljs-comment">// 方法没有同步</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo3 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonClassInstance.DEMO_3;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        Demo3 s1 = Demo3.getInstance();<br>        Demo3 s2 = Demo3.getInstance();<br>        System.out.<span class="hljs-built_in">println</span>(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-枚举单例式"><a href="#4-枚举单例式" class="headerlink" title="4.枚举单例式"></a>4.枚举单例式</h4><ol><li>枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-comment">//使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo4 <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> Demo.INSTANCE.getInstance();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        Demo4 s1 = Demo4.getInstance();<br>        Demo4 s2 = Demo4.getInstance();<br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-comment">//定义枚举</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">enum</span> Demo &#123;<br>INSTANCE;<br><span class="hljs-comment">// 枚举元素为单例</span><br><span class="hljs-keyword">private</span> Demo4 demo4;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Demo</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;枚举Demo私有构造参数&quot;</span>);<br>demo4 = <span class="hljs-keyword">new</span> Demo4();<br>&#125;<br><br><span class="hljs-keyword">public</span> Demo4 <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> demo4;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-双重检测锁方式"><a href="#5-双重检测锁方式" class="headerlink" title="5.双重检测锁方式"></a>5.双重检测锁方式</h4><ol><li>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.lijie;<br><br><span class="hljs-comment">//双重检测锁方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Demo5 demo5;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Demo5</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;私有Demo4构造参数初始化&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Demo5 <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">if</span> (demo5 == <span class="hljs-literal">null</span>) &#123;<br>synchronized (Demo5.class) &#123;<br><span class="hljs-keyword">if</span> (demo5 == <span class="hljs-literal">null</span>) &#123;<br>demo5 = <span class="hljs-keyword">new</span> Demo5();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> demo5;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>Demo5 s1 = Demo5.getInstance();<br>Demo5 s2 = Demo5.getInstance();<br>System.out.println(s1 == s2);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>单例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是设计模式</title>
    <link href="/blog/2021/07/13/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/07/13/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul><li>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</li></ul><h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul><li>看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行</li><li>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？</li><li>编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样</li></ul><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/13/17172acfe20b2d2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><ul><li>创建型模式，共五种：<strong>工厂方法模式、抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、<strong>原型模式。</strong></li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1-20210713204600637.jpg" alt="在这里插入图片描述"></p><h4 id="开放封闭原则（Open-Close-Principle）"><a href="#开放封闭原则（Open-Close-Principle）" class="headerlink" title="开放封闭原则（Open Close Principle）"></a>开放封闭原则（Open Close Principle）</h4><ul><li>原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li><li>描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li><li>优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li></ul><h4 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h4><ul><li>原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li><li>大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li><li>优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li></ul><h4 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h4><ul><li>依赖倒置原则的核心思想是面向接口编程.</li><li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，</li><li>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</li></ul><h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><ul><li>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li><li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li></ul><h4 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h4><ul><li>原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦</li><li>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li><li>优点：低耦合，高内聚。</li></ul><h4 id="单一职责原则（Principle-of-single-responsibility）"><a href="#单一职责原则（Principle-of-single-responsibility）" class="headerlink" title="单一职责原则（Principle of single responsibility）"></a>单一职责原则（Principle of single responsibility）</h4><ul><li>原则思想：一个方法只负责一件事情。</li><li>描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。</li><li>优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分类</tag>
      
      <tag>原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>延迟执行与不可变JavaStream</title>
    <link href="/blog/2021/07/12/%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98JavaStream/"/>
    <url>/blog/2021/07/12/%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98JavaStream/</url>
    
    <content type="html"><![CDATA[<p>最近在公司写业务的时候，忽然想不起来<code>Stream</code>中的累加应该怎么写？</p><p>无奈只能面向谷歌编程，花费了我宝贵的三分钟之后，学会了，很简单。</p><p>自从我用上JDK8以后，Stream就是我最常用的特性，各种流式操作用的飞起，然而这次事以后我忽然觉得Stream对我真的很陌生。</p><p>可能大家都一样，<code>对最常用到的东西，也最容易将其忽略</code>，哪怕你要准备面试估计也肯定想不起来要看一下Stream这种东西。</p><p>不过我既然注意到了，就要重新梳理一遍它，也算是对我的整体知识体系的查漏补缺。</p><p>花了很多功夫来写这篇Stream，希望大家和我一块重新认识并学习一下Stream，了解API也好，了解内部特性也罢，<strong>怕什么真理无穷，进一步有进一步的欢喜。</strong></p><p>在本文中我将Stream的内容分为以下几个部分：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8d35884fcdd24d82a438f1a4f399e8e0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>初看这个导图大家可能对转换流操作和终结流操作这两个名词有点蒙，其实这是我将Stream中的所有API分成两类，每一类起了一个对应的名字(参考自Java8相关书籍，见文末)：</p><ul><li><strong>转换流操作</strong> ：例如filter和map方法，将一个Stream转换成另一个Stream，返回值都是Stream。</li><li><strong>终结流操作</strong> ：例如count和collect方法，将一个Stream汇总为我们需要的结果，返回值都不是Stream。</li></ul><p>其中转换流操作的API我也分了两类，文中会有详细例子说明，这里先看一下定义，有一个大概印象：</p><ol><li><strong>无状态</strong> ：即此方法的执行无需依赖前面方法执行的结果集。</li><li><strong>有状态</strong> ：即此方法的执行需要依赖前面方法执行的结果集。</li></ol><p>由于Stream内容过多，所以我将Stream拆成了上下两篇，本篇是第一篇，内容翔实，用例简单且丰富。</p><p>第二篇的主题虽然只有一个终结操作，但是终结操作API比较复杂，所以内容也翔实，用例也简单且丰富，从篇幅上来看两者差不多，敬请期待。</p><hr><p><strong>注</strong> ：由于我本机的电脑是JDK11，而且写的时候忘了切换到JDK8，所以在用例中大量出现的<code>List.of()</code>在JDK8是没有的，它等同于JDK8中的<code>Arrays.asList()</code>。</p><p><strong>注</strong> ：写作过程中翻读了大量Stream源码和Java8书籍(文末)，创作不易，点赞过百，马上出第二篇。</p><h2 id="1-为什么要使用Stream？"><a href="#1-为什么要使用Stream？" class="headerlink" title="1. 为什么要使用Stream？"></a>1. 为什么要使用Stream？</h2><p>一切还要源于JDK8的发布，在那个函数式编程语言如火如荼的时代，Java由于它的臃肿而饱受诟病（强面向对象），社区迫切需要Java能加入函数式语言特点改善这种情况，终于在2014年Java发布了JDK8。</p><p>在JDK8中，我认为最大的新特性就是加入了函数式接口和lambda表达式，这两个特性取自函数式编程。</p><p>这两个特点的加入使Java变得更加简单与优雅，用函数式对抗函数式，巩固Java老大哥的地位，简直是师夷长技以制夷。</p><p>而Stream，就是JDK8又依托于上面的两个特性为集合类库做的 一个类库，它能让我们通过lambda表达式更简明扼要的以流水线的方式去处理集合内的数据，可以很轻松的完成诸如：过滤、分组、收集、归约这类操作，所以我愿将Stream称为函数式接口的最佳实践。</p><h3 id="1-1-更清晰的代码结构"><a href="#1-1-更清晰的代码结构" class="headerlink" title="1.1 更清晰的代码结构"></a>1.1 更清晰的代码结构</h3><p>Stream拥有更清晰的代码结构，为了更好的讲解Stream怎么就让代码变清晰了，这里假设我们有一个非常简单的需求：<strong>在一个集合中找到所有大于2的元素</strong> 。</p><p>先来看看没使用Stream之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>List&lt;Integer&gt; filterList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (Integer i : list) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">2</span>) &#123;<br>        filterList.add(i);<br>    &#125;<br>&#125;<br><br>System.out.println(filterList);<br></code></pre></td></tr></table></figure><p>上面的代码很好理解，我就不过多解释了，其实也还好了，因为我们的需求比较简单，如果需求再多点呢？</p><p>每多一个要求，那么if里面就又要加一个条件了，而我们开发中往往对象上都有很多字段，那么条件可能有四五个，最后可能会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>List&lt;Integer&gt; filterList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (Integer i : list) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">2</span> &amp;&amp; i &lt; <span class="hljs-number">10</span> &amp;&amp; (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)) &#123;<br>        filterList.add(i);<br>    &#125;<br>&#125;<br><br>System.out.println(filterList);<br></code></pre></td></tr></table></figure><p>if里面塞了很多条件，看起来就变得乱糟糟了，其实这也还好，最要命的是项目中往往有很多类似的需求，它们之间的区别只是某个条件不一样，那么你就需要复制一大坨代码，改吧改吧就上线了，这就导致代码里有大量重复的代码。</p><p>如果你Stream，一切都会变得清晰易懂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream()<br>        .filter(i -&gt; i &gt; <span class="hljs-number">2</span>)<br>        .filter(i -&gt; i &lt; <span class="hljs-number">10</span>)<br>        .filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        .collect(toList());<br></code></pre></td></tr></table></figure><p>这段代码你只需要关注我们最关注的东西：筛选条件就够了，filter这个方法名能让你清楚的知道它是个过滤条件，collect这个方法名也能看出来它是一个收集器，将最终结果收集到一个List里面去。</p><p>同时你可能发现了，为什么上面的代码中不用写循环？</p><p>因为Stream会帮助我们进行隐式的循环，这被称为：<code>内部迭代</code>，与之对应的就是我们常见的外部迭代了。</p><p>所以就算你不写循环，它也会进行一遍循环。</p><h3 id="1-2-不必关心变量状态"><a href="#1-2-不必关心变量状态" class="headerlink" title="1.2 不必关心变量状态"></a>1.2 不必关心变量状态</h3><p>Stream在设计之初就被设计为<code>不可变的</code>，它的不可变有两重含义：</p><ol><li>由于每次Stream操作都会生成一个新的Stream，所以Stream是不可变的，就像String。</li><li>在Stream中只保存原集合的引用，所以在进行一些会修改元素的操作时，是通过原元素生成一份新的新元素，所以Stream 的任何操作都不会影响到原对象。</li></ol><p>第一个含义可以帮助我们进行链式调用，实际上我们使用Stream的过程中往往会使用链式调用，而第二个含义则是函数式编程中的一大特点：不修改状态。</p><p>无论对Stream做怎么样的操作，它最终都不会影响到原集合，它的返回值也是在原集合的基础上进行计算得来的。</p><p>所以在Stream中我们不必关心操作原对象集合带来的种种副作用，用就完了。</p><p>关于函数式编程可以查阅<a href="https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2012/04/functional_programming.html">阮一峰的函数式编程初探</a>。</p><h3 id="1-3-延迟执行与优化"><a href="#1-3-延迟执行与优化" class="headerlink" title="1.3 延迟执行与优化"></a>1.3 延迟执行与优化</h3><p>Stream只在遇到<code>终结操作</code>的时候才会执行，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream()<br>        .filter(i -&gt; i &gt; <span class="hljs-number">2</span>)<br>        .peek(System.out::println);<br></code></pre></td></tr></table></figure><p>这么一段代码是不会执行的，peek方法可以看作是forEach，这里我用它来打印Stream中的元素。</p><p>因为filter方法和peek方法都是转换流方法，所以不会触发执行。</p><p>如果我们在后面加入一个count方法就能正常执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream()<br>        .filter(i -&gt; i &gt; <span class="hljs-number">2</span>)<br>        .peek(System.out::println)<br>        .count();<br></code></pre></td></tr></table></figure><p>count方法是一个终结操作，用于计算出Stream中有多少个元素，它的返回值是一个long型。</p><p>Stream的这种没有终结操作就不会执行的特性被称为<code>延迟执行</code>。</p><p>与此同时，Stream还会对API中的无状态方法进行名为<code>循环合并</code>的优化，具体例子详见第三节。</p><h2 id="2-创建Stream"><a href="#2-创建Stream" class="headerlink" title="2. 创建Stream"></a>2. 创建Stream</h2><p>为了文章的完整性，我思来想去还是加上了创建Stream这一节，这一节主要介绍一些创建Stream的常用方式，Stream的创建一般可以分为两种情况：</p><ol><li><strong>使用Steam接口创建</strong></li><li><strong>通过集合类库创建</strong></li></ol><p>同时还会讲一讲Stream的并行流与连接，都是创建Stream，却具有不同的特点。</p><h3 id="2-1-通过Stream接口创建"><a href="#2-1-通过Stream接口创建" class="headerlink" title="2.1 通过Stream接口创建"></a>2.1 通过Stream接口创建</h3><p>Stream作为一个接口，它在接口中定义了定义了几个静态方法为我们提供创建Stream的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T... values)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Arrays.stream(values);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是of方法，它提供了一个泛型可变参数，为我们创建了带有泛型的Stream流，同时在如果你的参数是基本类型的情况下会使用自动包装对基本类型进行包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>Stream&lt;Double&gt; doubleStream = Stream.of(<span class="hljs-number">1.1d</span>, <span class="hljs-number">2.2d</span>, <span class="hljs-number">3.3d</span>);<br><br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然，你也可以直接创建一个空的Stream，只需要调用另一个静态方法——empty()，它的泛型是一个Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Object&gt; empty = Stream.empty();<br></code></pre></td></tr></table></figure><p>以上都是我们让我们易于理解的创建方式，还有一种方式可以创建一个无限制元素数量的Stream——generate()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title">generate</span><span class="hljs-params">(Supplier&lt;? extends T&gt; s)</span> </span>&#123;<br>    Objects.requireNonNull(s);<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(<br>            <span class="hljs-keyword">new</span> StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>从方法参数上来看，它接受一个函数式接口——Supplier作为参数，这个函数式接口是用来创建对象的接口，你可以将其类比为对象的创建工厂，Stream将从此工厂中创建的对象放入Stream中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; generate = Stream.generate(() -&gt; <span class="hljs-string">&quot;Supplier&quot;</span>);<br><br>Stream&lt;Integer&gt; generateInteger = Stream.generate(() -&gt; <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>我这里是为了方便直接使用Lamdba构造了一个Supplier对象，你也可以直接传入一个Supplier对象，它会通过Supplier接口的get() 方法来构造对象。</p><h3 id="2-2-通过集合类库进行创建"><a href="#2-2-通过集合类库进行创建" class="headerlink" title="2.2 通过集合类库进行创建"></a>2.2 通过集合类库进行创建</h3><p>相较于上面一种来说，第二种方式更较为常用，我们常常对集合就行Stream流操作而非手动构建一个Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStreamList = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream();<br><br>Stream&lt;String&gt; stringStreamList = List.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>).stream(); <br></code></pre></td></tr></table></figure><p>在Java8中，集合的顶层接口<code>Collection</code>被加入了一个新的接口默认方法——<code>stream()</code>，通过这个方法我们可以方便的对所有集合子类进行创建Stream的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; listStream = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream();<br><br>Stream&lt;Integer&gt; setStream = Set.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream();<br></code></pre></td></tr></table></figure><p>通过查阅源码，可以发先 <code>stream()</code> 方法本质上还是通过调用一个Stream工具类来创建Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">false</span>);<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="2-3-创建并行流"><a href="#2-3-创建并行流" class="headerlink" title="2.3 创建并行流"></a>2.3 创建并行流</h3><p>在以上的示例中所有的Stream都是串行流，在某些场景下，为了最大化压榨多核CPU的性能，我们可以使用并行流，它通过JDK7中引入的fork/join框架来执行并行操作，我们可以通过如下方式创建并行流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerParallelStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).parallel();<br><br>Stream&lt;String&gt; stringParallelStream = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>).parallel();<br><br>Stream&lt;Integer&gt; integerParallelStreamList = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).parallelStream();<br><br>Stream&lt;String&gt; stringParallelStreamList = List.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>).parallelStream();<br></code></pre></td></tr></table></figure><p>是的，在Stream的静态方法中没有直接创建并行流的方法，我们需要在构造Stream后再调用一次parallel()方法才能创建并行流，因为调用parallel()方法并不会重新创建一个并行流对象，而是在原有的Stream对象上面设置了一个并行参数。</p><p>当然，我们还可以看到，Collection接口中可以直接创建并行流，只需要调用与<code>stream()</code> 对应的<code>parallelStream()</code>方法，就像我刚才讲到的，他们之间其实只有参数的不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">parallelStream</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过一般情况下我们并不需要用到并行流，在Stream中元素不过千的情况下性能并不会有太大提升，因为将元素分散到不同的CPU进行计算也是有成本的。</p><p>并行的好处是充分利用多核CPU的性能，但是使用中往往要对数据进行分割，然后分散到各个CPU上去处理，如果我们使用的数据是数组结构则可以很轻易的进行分割，但是如果是链表结构的数据或者Hash结构的数据则分割起来很明显不如数组结构方便。</p><p>所以只有当Stream中元素过万甚至更大时，选用并行流才能带给你更明显的性能提升。</p><p>最后，当你有一个并行流的时候，你也可以通过<code>sequential()</code> 将其方便的转换成串行流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).parallel().sequential();<br></code></pre></td></tr></table></figure><h3 id="2-4-连接Stream"><a href="#2-4-连接Stream" class="headerlink" title="2.4 连接Stream"></a>2.4 连接Stream</h3><p>如果你在两处构造了两个Stream，在使用的时候希望组合在一起使用，可以使用concat()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; concat = Stream<br>        .concat(Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), Stream.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>));<br></code></pre></td></tr></table></figure><p>如果是两种不同的泛型流进行组合，自动推断会自动的推断出两种类型相同的父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br><br>Stream&lt;? extends Serializable&gt; stream = Stream.concat(integerStream, stringStream);<br></code></pre></td></tr></table></figure><h2 id="3-Stream转换操作之无状态方法"><a href="#3-Stream转换操作之无状态方法" class="headerlink" title="3. Stream转换操作之无状态方法"></a>3. Stream转换操作之无状态方法</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90bd3bad499b4c4886aa100c2af83c4d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><strong>无状态方法：即此方法的执行无需依赖前面方法执行的结果集。</strong></p><p>在Stream中无状态的API我们常用的大概有以下三个：</p><ol><li><code>map()</code>方法：此方法的参数是一个Function对象，它可以使你对集合中的元素做自定义操作，并保留操作后的元素。</li><li><code>filter()</code>方法：此方法的参数是一个Predicate对象，Predicate的执行结果是一个Boolean类型，所以此方法只保留返回值为true的元素，正如其名我们可以使用此方法做一些筛选操作。</li><li><code>flatMap()</code>方法：此方法和map()方法一样参数是一个Function对象，但是此Function的返回值要求是一个Stream，该方法可以将多个Stream中的元素聚合在一起进行返回。</li></ol><p>先来看看一个map()方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStreamList = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream();<br><br>Stream&lt;Integer&gt; mapStream = integerStreamList.map(i -&gt; i * <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>我们拥有一个List，想要对其中的每个元素进行<strong>乘10</strong> 的操作，就可以采用如上写法，其中的<code>i</code>是对List中元素的变量名，<code>→</code> 后面的逻辑则是要对此元素进行的操作，以一种非常简洁明了的方式传入一段代码逻辑执行，这段代码最后会返回一个包含操作结果的新Stream。</p><p>这里为了更好的帮助大家理解，我画了一个简图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2958e563168e4631b2e06a20487e9f7e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><p>接下来是filter()方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStreamList = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream();<br><br>Stream&lt;Integer&gt; filterStream = integerStreamList.filter(i -&gt; i &gt;= <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>在这段代码中会执行<code>i &gt;= 20</code> 这段逻辑，然后将返回值为true的结果保存在一个新的Stream中并返回。</p><p>这里我也有一个简单的图示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8d5acb58a414c7ab4fccc6c08918ead~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><p><code>flatMap()</code> 方法的描述在上文我已经描述过，但是有点过于抽象，我在学习此方法中也是搜索了很多示例才有了较好的理解。</p><p>根据官方文档的说法，此方法是为了进行一对多元素的平展操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Order&gt; orders = List.of(<span class="hljs-keyword">new</span> Order(), <span class="hljs-keyword">new</span> Order());<br><br>Stream&lt;Item&gt; itemStream = orders.stream()<br>        .flatMap(order -&gt; order.getItemList().stream());<br></code></pre></td></tr></table></figure><p>这里我通过一个订单示例来说明此方法，我们的每个订单中都包含了一个商品List，如果我想要将两个订单中所有商品List组成一个新的商品List，就需要用到flatMap()方法。</p><p>在上面的代码示例中可以看到每个订单都返回了一个商品List的Stream，我们在本例中只有两个订单，所以也就是最终会返回两个商品List的Stream，flatMap()方法的作用就是将这两个Stream中元素提取出来然后放到一个新的Stream中。</p><p>老规矩，放一个简单的图示来说明：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327690b17959463d8677f5d333699b12~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>图例中我使用青色代表Stream，在最终的输出中可以看到flatMap()将两个流变成了一个流进行输出，这在某些场景中非常有用，比如我上面的订单例子。</p><hr><p>还有一个很不常用的无状态方法<code>peek()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">peek</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><p>peek方法接受一个Consumer对象做参数，这是一个无返回值的参数，我们可以通过peek方法做些打印元素之类的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; peekStream = integerStreamList.peek(i -&gt; System.out.println(i));<br></code></pre></td></tr></table></figure><p>然而如果你不太熟悉的话，不建议使用，某些情况下它并不会生效，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream()<br>        .map(i -&gt; i * <span class="hljs-number">10</span>)<br>        .peek(System.out::println)<br>        .count();<br></code></pre></td></tr></table></figure><p>API文档上面也注明了此方法是用于Debug，通过我的经验，只有当Stream最终需要重新生产元素时，peek才会执行。</p><p>上面的例子中，count只需要返回元素个数，所以peek没有执行，如果换成collect方法就会执行。</p><p>或者如果Stream中存在过滤方法如filter方法和match相关方法，它也会执行。</p><h3 id="3-1-基础类型Stream"><a href="#3-1-基础类型Stream" class="headerlink" title="3.1 基础类型Stream"></a>3.1 基础类型Stream</h3><p>上一节提到了三个Stream中最常用的三个无状态方法，在Stream的无状态方法中还有几个和map()与flatMap()对应的方法，它们分别是：</p><ol><li><code>mapToInt</code></li><li><code>mapToLong</code></li><li><code>mapToDouble</code></li><li><code>flatMapToInt</code></li><li><code>flatMapToLong</code></li><li><code>flatMapToDouble</code></li></ol><p>这六个方法首先从方法名中就可以看出来，它们只是在map()或者flatMap()的基础上对返回值进行转换操作，按理说没必要单拎出来做成一个方法，实际上它们的关键在于返回值：</p><ol><li>mapToInt返回值为<strong>IntStream</strong></li><li>mapToLong返回值为<strong>LongStream</strong></li><li>mapToDouble返回值为<strong>DoubleStream</strong></li><li>flatMapToInt返回值为<strong>IntStream</strong></li><li>flatMapToLong返回值为<strong>LongStream</strong></li><li>flatMapToDouble返回值为<strong>DoubleStream</strong></li></ol><p>在JDK5中为了使Java更加的面向对象，引入了包装类的概念，八大基础数据类型都对应着一个包装类，这使你在使用基础类型时可以无感的进行自动拆箱/装箱，也就是自动使用包装类的转换方法。</p><p>比如，在最前文的示例中，我用了这样一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>我在创建Stream中使用了基本数据类型参数，其泛型则被自动包装成了Integer，但是我们有时可能忽略自动拆装箱也是有代价的，如果我们想在使用Stream中忽略这个代价则可以使用Stream中转为基础数据类型设计的Stream：</p><ol><li><strong>IntStream：对应</strong> 基础数据类型中的int、short、char、boolean</li><li>LongStream：对应基础数据类型中的long</li><li>DoubleStream：对应基础数据类型中的double和float</li></ol><p>在这些接口中都可以和上文的例子一样通过of方法构造Stream，且不会自动拆装箱。</p><p>所以上文中提到的那六个方法实际上就是将普通流转换成这种基础类型流，在我们需要的时候可以拥有更高的效率。</p><p>基础类型流在API方面拥有Stream一样的API，所以在使用方面只要明白了Stream，基础类型流也都是一样的。</p><p><strong>注</strong> ：IntStream、LongStream和DoubleStream都是接口，但并非继承自Stream接口。</p><h3 id="3-2-无状态方法的循环合并"><a href="#3-2-无状态方法的循环合并" class="headerlink" title="3.2 无状态方法的循环合并"></a>3.2 无状态方法的循环合并</h3><p>说完无状态的这几个方法我们来看一个前文中的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream()<br>        .filter(i -&gt; i &gt; <span class="hljs-number">2</span>)<br>        .filter(i -&gt; i &lt; <span class="hljs-number">10</span>)<br>        .filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        .collect(toList());<br></code></pre></td></tr></table></figure><p>在这个例子中我用了三次filter方法，那么大家觉得Stream会循环三次进行过滤吗？</p><p>如果换掉其中一个filter为map，大家觉得会循环几次？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).stream()<br>        .map(i -&gt; i * <span class="hljs-number">10</span>)<br>        .filter(i -&gt; i &lt; <span class="hljs-number">10</span>)<br>        .filter(i -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        .collect(toList());<br></code></pre></td></tr></table></figure><p>从我们的直觉来看，需要先使用map方法对所有元素做处理，然后再使用filter方法做过滤，所以需要执行三次循环。</p><p>但回顾无状态方法的定义，你可以发现其他这三个条件可以放在一个循环里面做，因为filter只依赖map的计算结果，而不必依赖map执行完后的结果集，所以只要保证先操作map再操作filter，它们就可以在一次循环内完成，这种优化方式被称为<code>循环合并</code>。</p><p><strong>所有的无状态方法都可以放在同一个循环内执行，它们也可以方便的使用并行流在多个CPU上执行。</strong></p><h2 id="4-Stream转换操作之有状态方法"><a href="#4-Stream转换操作之有状态方法" class="headerlink" title="4. Stream转换操作之有状态方法"></a>4. Stream转换操作之有状态方法</h2><p>前面说完了无状态方法，有状态方法就比较简单了，只看名字就可以知道它的作用：</p><table><thead><tr><th>方法名</th><th>方法结果</th></tr></thead><tbody><tr><td>distinct()</td><td>元素去重。</td></tr><tr><td>sorted()</td><td>元素排序，重载的两个方法，需要的时候可以传入一个排序对象。</td></tr><tr><td>limit(long maxSize)</td><td>传入一个数字，代表只取前X个元素。</td></tr><tr><td>skip(long n)</td><td>传入一个数字，代表跳过X个元素，取后面的元素。</td></tr><tr><td>takeWhile(Predicate predicate)</td><td>JDK9新增，传入一个断言参数当第一次断言为false时停止，返回前面断言为true的元素。</td></tr><tr><td>dropWhile(Predicate predicate)</td><td>JDK9新增，传入一个断言参数当第一次断言为false时停止，删除前面断言为true的元素。</td></tr></tbody></table><p>以上就是所有的有状态方法，它们的方法执行都必须依赖前面方法执行的结果集才能执行，比如排序方法就需要依赖前面方法的结果集才能进行排序。</p><p>同时limit方法和takeWhile是两个短路操作方法，这意味效率更高，因为可能内部循环还没有走完时就已经选出了我们想要的元素。</p><p>所以有状态的方法不像无状态方法那样可以在一个循环内执行，每个有状态方法都要经历一个单独的内部循环，所以编写代码时的顺序会影响到程序的执行结果以及性能，希望各位读者在开发过程中注意。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文主要是对Stream做了一个概览，并讲述了Stream的两大特点：</p><ol><li><code>不可变</code>：不影响原集合，每次调用都返回一个新的Stream。</li><li><code>延迟执行</code>：在遇到终结操作之前，Stream不会执行。</li></ol><p>同时也将Stream的API分成了转换操作和终结操作两类，并讲解了所有常用的转换操作，下一章的主要内容将是终结操作。</p><p>在看Stream源码的过程中发现了一个有趣的事情，在<code>ReferencePipeline</code>类中(Stream的实现类)，它的方法顺序从上往下正好是：无状态方法 → 有状态方法 → 聚合方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>JavaStream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud实现数据权限控制</title>
    <link href="/blog/2021/07/11/SpringCloud%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <url>/blog/2021/07/11/SpringCloud%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>举个例子：</p><blockquote><p>有一批业务员跟进全国的销售订单。他们被按城市进行划分，一个业务员跟进3个城市的订单，为了保护公司的业务数据不能被所有人都掌握，故每个业务员只能看到自己负责城市的订单数据。所以从系统来讲每个业务员都有访问销售订单的功能，然后再需要配置每个业务员负责的城市，以此对订单数据进行筛选。</p></blockquote><p>要实现此功能有很多方法，如果系统中多个地方都需要类似的需求，那我们就可以将其提出来做成一个通用的功能。这里我介绍一个相对简单的解决方案，以供参考。</p><h2 id="一、-整体架构"><a href="#一、-整体架构" class="headerlink" title="一、 整体架构"></a>一、 整体架构</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34009bc0eba841a29ba31eec66227a90~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><code>数据权限</code>为作一个<code>注解</code>的形式挂在每一个需要数据权限控制的<strong>Controller</strong>上，由于和具体的程序逻辑有关故有一定的入侵性，且需要数据库配合使用。</p><h2 id="二、-实现流程"><a href="#二、-实现流程" class="headerlink" title="二、 实现流程"></a>二、 实现流程</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1038d1e89ecc4d819999f65bb7a8d400~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ol><li>浏览器传<code>带查询权限范围参数</code>访问<strong>Controller</strong>，如<code>cities</code></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8000</span><span class="hljs-regexp">/order/</span>query<br>accept: */*<br>Content-Type: application/json<br>token: <span class="hljs-number">1</span>e2b2298-<span class="hljs-number">8274</span>-<span class="hljs-number">4599</span>-a26f-a799167cc82f<br><br>&#123;<span class="hljs-string">&quot;cities&quot;</span>:[<span class="hljs-string">&quot;cq&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;bj&quot;</span>],<span class="hljs-string">&quot;userName&quot;</span>:<span class="hljs-string">&quot;string&quot;</span>&#125;<br><br><br></code></pre></td></tr></table></figure><ol><li><p>通过注解拦截权限范围参数，并根据预授权范围比较，回写在授权范围内的权限范围参数</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">cities</span> = [<span class="hljs-string">&quot;cq&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>]<br><br><br></code></pre></td></tr></table></figure></li><li><p>通过参数传递到DAO层，在SQL语句中拼装出查询条件，实现数据的过滤</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">where</span> city <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;cq&#x27;</span>,<span class="hljs-string">&#x27;cd&#x27;</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="三、-实现步骤"><a href="#三、-实现步骤" class="headerlink" title="三、 实现步骤"></a>三、 实现步骤</h2></li></ol><h3 id="1-注解实现"><a href="#1-注解实现" class="headerlink" title="1. 注解实现"></a>1. 注解实现</h3><p>注解的完整代码，请详见<a href="https://link.juejin.cn/?target=https://links.jianshu.com/go?to=https://gitee.com/hypier/barry-cloud/tree/master/cloud-auth-logic">源代码</a></p><h4 id="1）创建注解"><a href="#1）创建注解" class="headerlink" title="1）创建注解"></a>1）创建注解</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Retention</span>(value = RetentionPolicy.RUNTIME)<br><span class="hljs-meta">@Target</span>(value = &#123;ElementType.METHOD&#125;)<br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ScopeAuth &#123;<br><br>    <span class="hljs-built_in">String</span> token() <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;AUTH_TOKEN&quot;</span>;<br>    <span class="hljs-built_in">String</span> scope() <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">String</span>[] scopes() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>此注解为运行时<code>RetentionPolicy.RUNTIME</code>作用在方法上<code>ElementType.METHOD</code>的</p><p><code>token</code>：获取识别唯一用户的标识，与用户数据权限存储有关</p><p><code>scope</code>，<code>scopes</code>：预请求的数据权限范围</p><h4 id="2）-AOP实现注解"><a href="#2）-AOP实现注解" class="headerlink" title="2） AOP实现注解"></a>2） AOP实现注解</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ScopeAuthAdvice &#123;<br><br>    @<span class="hljs-constructor">Around(<span class="hljs-string">&quot;@annotation(scopeAuth)&quot;</span>)</span><br>    public Object before(ProceedingJoinPoint thisJoinPoint, ScopeAuth scopeAuth) throws Throwable &#123;<br>        <span class="hljs-comment">// ... 省略过程</span><br>        <span class="hljs-comment">// 获取token</span><br>        String authToken = get<span class="hljs-constructor">Token(<span class="hljs-params">args</span>, <span class="hljs-params">scopeAuth</span>.<span class="hljs-params">token</span>()</span>, methodSignature.get<span class="hljs-constructor">Method()</span>);<br>            <span class="hljs-comment">// 回写范围参数</span><br>        set<span class="hljs-constructor">Scope(<span class="hljs-params">scopeAuth</span>.<span class="hljs-params">scope</span>()</span>, methodSignature, args, authToken);<br><br>        return thisJoinPoint.proceed<span class="hljs-literal">()</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置范围</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void set<span class="hljs-constructor">Scope(String <span class="hljs-params">scope</span>, MethodSignature <span class="hljs-params">methodSignature</span>, Object[] <span class="hljs-params">args</span>, String <span class="hljs-params">authToken</span>)</span> &#123;<br>        <span class="hljs-comment">// 获取请求范围</span><br>        Set&lt;String&gt; requestScope = get<span class="hljs-constructor">RequestScope(<span class="hljs-params">args</span>, <span class="hljs-params">scope</span>, <span class="hljs-params">methodSignature</span>.<span class="hljs-params">getMethod</span>()</span>);<br>        ScopeAuthAdapter adapter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ScopeAuthAdapter(<span class="hljs-params">supplier</span>)</span>;<br>        <span class="hljs-comment">// 已授权范围</span><br>        Set&lt;String&gt; authorizedScope = adapter.identify<span class="hljs-constructor">PermissionScope(<span class="hljs-params">authToken</span>, <span class="hljs-params">requestScope</span>)</span>;<br>        <span class="hljs-comment">// 回写新范围</span><br>        set<span class="hljs-constructor">RequestScope(<span class="hljs-params">args</span>, <span class="hljs-params">scope</span>, <span class="hljs-params">authorizedScope</span>, <span class="hljs-params">methodSignature</span>.<span class="hljs-params">getMethod</span>()</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回写请求范围</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void set<span class="hljs-constructor">RequestScope(Object[] <span class="hljs-params">args</span>, String <span class="hljs-params">scopeName</span>, Collection&lt;String&gt; <span class="hljs-params">scopeValues</span>, Method <span class="hljs-params">method</span>)</span> &#123;<br>        <span class="hljs-comment">// 解析 SPEL 表达式</span><br>        <span class="hljs-keyword">if</span> (scopeName.index<span class="hljs-constructor">Of(SPEL_FLAG)</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ParseSPEL</span>.</span></span>set<span class="hljs-constructor">MethodValue(<span class="hljs-params">scopeName</span>, <span class="hljs-params">scopeValues</span>, <span class="hljs-params">method</span>, <span class="hljs-params">args</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>此为演示代码省略了过程，主要功能为通过token拿到预先授权的数据范围，再与本次请求的范围做交集，最后回写回原参数。</p><p>过程中用到了较多的<code>SPEL表达式</code>，用于计算表达式结果，具体请参考<a href="https://link.juejin.cn/?target=https://links.jianshu.com/go?to=https://gitee.com/hypier/barry-cloud/blob/master/cloud-auth-logic/src/main/java/fun/barryhome/cloud/util/ParseSPEL.java">ParseSPEL文件</a></p><h4 id="3）权限范围交集计算"><a href="#3）权限范围交集计算" class="headerlink" title="3）权限范围交集计算"></a>3）权限范围交集计算</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopeAuthAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> final AuthQuerySupplier supplier;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">ScopeAuthAdapter</span>(<span class="hljs-params">AuthQuerySupplier supplier</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.supplier = supplier;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证权限范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-variable">token</span></span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-variable">requestScope</span></span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">identifyPermissionScope</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> token, <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; requestScope</span>)</span> &#123;<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; authorizeScope = supplier.queryScope(token);<br><br>        <span class="hljs-built_in">String</span> ALL_SCOPE = <span class="hljs-string">&quot;AUTH_ALL&quot;</span>;<br>        <span class="hljs-built_in">String</span> USER_ALL = <span class="hljs-string">&quot;USER_ALL&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (authorizeScope == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (authorizeScope.contains(ALL_SCOPE)) &#123;<br>            <span class="hljs-comment">// 如果是全开放则返回请求范围</span><br>            <span class="hljs-keyword">return</span> requestScope;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (requestScope == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (requestScope.contains(USER_ALL))&#123;<br>            <span class="hljs-comment">// 所有授权的范围</span><br>            <span class="hljs-keyword">return</span> authorizeScope;<br>        &#125;<br><br>        <span class="hljs-comment">// 移除不同的元素</span><br>        requestScope.retainAll(authorizeScope);<br><br>        <span class="hljs-keyword">return</span> requestScope;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>此处为了方便设置，有两个关键字范围</p><ul><li><code>AUTH_ALL</code>：预设所有范围，全开放的意思，为数据库预先设置值，请求传什么值都通过</li><li><code>USER_ALL</code>：请求所有授权的范围，请求时传此值则会以数据库预设值为准</li></ul><h4 id="4）-spring-factories自动导入类配置"><a href="#4）-spring-factories自动导入类配置" class="headerlink" title="4） spring.factories自动导入类配置"></a>4） spring.factories自动导入类配置</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.AutoConfigurationImportSelector=\<br>  fun<span class="hljs-selector-class">.barryhome</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.annotation</span>.ScopeAuthAdvice<br><br><br></code></pre></td></tr></table></figure><p>如果注解功能是单独项目存在，在使用时有可能会存在找不到引入文件的问题，可通过此配置文件自动载入需要初始化的类</p><h3 id="2-注解使用"><a href="#2-注解使用" class="headerlink" title="2. 注解使用"></a>2. 注解使用</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ScopeAuth</span>(scopes = &#123;<span class="hljs-string">&quot;#orderDTO.cities&quot;</span>&#125;, token = <span class="hljs-string">&quot;#request.getHeader(\&quot;</span>X-User-Name\<span class="hljs-string">&quot;)&quot;</span>)<br><span class="hljs-variable">@PostMapping</span>(value = <span class="hljs-string">&quot;/query&quot;</span>)<br>public String query(<span class="hljs-variable">@RequestBody</span> OrderDTO orderDTO, HttpServletRequest request) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Arrays</span><span class="hljs-selector-class">.toString</span>(orderDTO.getCities());<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在需要使用数据权限的<strong>controller</strong>方法上增加<code>@ScopeAuth</code>注解</p><p><code>scopes = &#123;&quot;#orderDTO.cities&quot;&#125;</code>：表示取输入参数<strong>orderDTO</strong>的<strong>cities</strong>值，这里是表达式必须加**#**</p><blockquote><p>实际开发过程中，需要将**orderDTO.getCities()**带入后续逻辑中，在DAO层将此拼装在SQL中，以实现数据过滤功能</p></blockquote><h3 id="3-实现AuthStoreSupplier"><a href="#3-实现AuthStoreSupplier" class="headerlink" title="3. 实现AuthStoreSupplier"></a>3. 实现AuthStoreSupplier</h3><p><code>AuthStoreSupplier</code>接口为数据权限的存储接口，与<strong>AuthQuerySupplier</strong>配合使用，可按实际情况实现</p><p>此接口为非必要接口，可由数据库或Redis存储（推荐），一般在登录的同时保存在<code>Redis</code>中</p><h3 id="4-实现AuthQuerySupplier"><a href="#4-实现AuthQuerySupplier" class="headerlink" title="4. 实现AuthQuerySupplier"></a>4. 实现AuthQuerySupplier</h3><p><code>AuthQuerySupplier</code>接口为数据权限查询接口，可按存储方法进行查询，推荐使用Redis</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAuthQuerySupplier</span> <span class="hljs-title">implements</span> <span class="hljs-title">AuthQuerySupplier</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询范围</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">queryScope</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> AUTH_USER_KEY = <span class="hljs-string">&quot;auth:logic:user:%s&quot;</span>;<br>        <span class="hljs-built_in">String</span> redisKey = <span class="hljs-built_in">String</span>.format(AUTH_USER_KEY, key);<br><br>        List&lt;<span class="hljs-built_in">String</span>&gt; range = redisTemplate.opsForList().range(redisKey, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span> (range != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HashSet&lt;&gt;(range);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在分布式结构里，也可将此实现提出到权限模块，采用远程调用方式，进一步解耦</p><h3 id="5-开启数据权限"><a href="#5-开启数据权限" class="headerlink" title="5. 开启数据权限"></a>5. 开启数据权限</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EnableScopeAuth</span><br><span class="hljs-variable">@EnableDiscoveryClient</span><br><span class="hljs-variable">@SpringBootApplication</span><br>public class OrderApplication &#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(OrderApplication.class, args);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="四、-综述"><a href="#四、-综述" class="headerlink" title="四、 综述"></a>四、 综述</h2><p>至此数据权限功能就实现了。在微服务器架构中为了实现功能的复用，将<strong>注解的创建</strong>和<strong>AuthQuerySupplier</strong>的实现提取到公共模块中，那么在具体的使用模块就简单得多了。只需增加<code>@ScopeAuth</code>注解，配置好查询方法就可以使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>数据权限</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码实现IOC</title>
    <link href="/blog/2021/07/10/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0IOC/"/>
    <url>/blog/2021/07/10/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0IOC/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Spring ioc</code>  相信很多人都知道这是<code>Spring</code>框架中一个非常核心的组件，<code>IoC(控制反转)</code>，对于初学<code>Spring</code>的人来说，对其的设计思想理解可能非常表面，要理解好<code>Ioc</code>的关键是要明确 以下几点，<strong>谁控制谁，控制什么，为何是反转（那正转？），哪些方面反转了</strong> 。</p><p><strong>谁控制谁，控制什么</strong> 还记得你们当时学习<code>servlet</code>的时候在每一层内部通过<code>new</code>关键字进行创建对象吗，要清楚这是<strong>程序主动去创建依赖对象</strong>; 而当你们接触了<code>Spring</code>之后<code>IoC</code>是有<strong>专门一个容器来创建这些对象</strong>，控制对象。</p><p>**为何是反转（那正转？)**，这个简单理解当我们主动控制去获取依赖对象，这就是正转？ 而反转则是由容器来帮忙创建及注入依赖对象; 为何是反转 ？ 因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转; 哪些方面反转了？依赖对象的获取被反转了。</p><h3 id="手撕最简易版IOC容器"><a href="#手撕最简易版IOC容器" class="headerlink" title="手撕最简易版IOC容器"></a>手撕最简易版IOC容器</h3><p>可能你还不明白，觉得很抽象？那么跟着博主手把手带你来实现<code>IOC</code>！</p><blockquote><p><em>这里实现仅仅是为了理解ioc概念的手写<code>demo</code>,<code>ioc</code>背后还拥有超多细节等我们去学习，感兴趣同学可以去公众号看看之前发表的一篇关于<code>spring ioc</code>源码走读的文章</em></p></blockquote><p>ioc不是一个容器嘛，ok，我们先来定义一个容器，容器的特性肯定拥有存、取对象嘛~</p><p><code>Spring</code>的对象都是一个个<code>bean</code>，但是我们不知道<code>bean</code>类型是什么，那么就泛型体现，还有<code>bean</code>什么时候存放进容器的啊？<code>spring</code>是在启动的时候会进行初始化扫描，我们就定义一个<code>initAutoWired</code>方法来模拟。</p><h5 id="先定义一个橘松容器接口JsContainer。"><a href="#先定义一个橘松容器接口JsContainer。" class="headerlink" title="先定义一个橘松容器接口JsContainer。"></a>先定义一个橘松容器接口<code>JsContainer</code>。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JsContainer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据Class获取Bean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册一个Class到容器中</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化装配</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initAutoWired</span><span class="hljs-params">()</span></span>;<br><br></code></pre></td></tr></table></figure><h5 id="我们再写一个自定义注解标识JsAutowired，来为了后面通过反射获取实例化bean，自定义注解可以指定要注入的类型，以及注入的bean名称。"><a href="#我们再写一个自定义注解标识JsAutowired，来为了后面通过反射获取实例化bean，自定义注解可以指定要注入的类型，以及注入的bean名称。" class="headerlink" title="我们再写一个自定义注解标识JsAutowired，来为了后面通过反射获取实例化bean，自定义注解可以指定要注入的类型，以及注入的bean名称。"></a>我们再写一个自定义注解标识<code>JsAutowired</code>，来为了后面通过反射获取实例化<code>bean</code>，自定义注解可以指定要注入的类型，以及注入的<code>bean</code>名称。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.orangesongjava.ioc;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> JsAutowired &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 要注入的类类型</span><br><span class="hljs-comment">     */</span><br>    Class&lt;?&gt; value() <span class="hljs-keyword">default</span> Class.class;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bean的名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="容器接口和注解都有了，接下来我们思考来实现它！我们定义一个类-JsSampleContainer-来实现容器接口JsContainer-。"><a href="#容器接口和注解都有了，接下来我们思考来实现它！我们定义一个类-JsSampleContainer-来实现容器接口JsContainer-。" class="headerlink" title="容器接口和注解都有了，接下来我们思考来实现它！我们定义一个类 JsSampleContainer 来实现容器接口JsContainer 。"></a>容器接口和注解都有了，接下来我们思考来实现它！我们定义一个类 <code>JsSampleContainer</code> 来实现容器接口<code>JsContainer</code> 。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.orangesongjava.ioc;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsSampleContainer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JsContainer</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存所有bean对象，格式为 com.xxx.xxx.XxxClass : @56x2ya</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; beanNameMap;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存储bean和name的关系</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; beanKeys;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JsSampleContainer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.beanNameMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    <span class="hljs-keyword">this</span>.beanKeys = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>String name = clazz.getName();<br>Object object = beanNameMap.get(name);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != object)&#123;<br><span class="hljs-keyword">return</span> (T) object;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">registerBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>String name = clazz.getName();<br>beanKeys.put(name, name);<br>Object bean = newInstance(clazz);<br>        beanNameMap.put(name, bean);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initAutoWired</span><span class="hljs-params">()</span> </span>&#123;<br>        beanNameMap.forEach((k,v) -&gt; injection(v));<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注入对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> object</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injection</span><span class="hljs-params">(Object object)</span> </span>&#123;<br><span class="hljs-comment">// 所有字段</span><br>    <span class="hljs-keyword">try</span> &#123;<br>Field[] fields = object.getClass().getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br><span class="hljs-comment">// 需要注入的字段</span><br>                JsAutowired jsAutowired = field.getAnnotation(JsAutowired.class);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != jsAutowired) &#123;<br>    <span class="hljs-comment">// 要注入的字段</span><br>        Object autoAutoWiredField = <span class="hljs-keyword">null</span>;<br>        String name = jsAutowired.name();<br>        <span class="hljs-comment">// 如果说这里JsAutowired自定义注解没指定name属性 则默认值是&quot;&quot;</span><br>        <span class="hljs-keyword">if</span>(!name.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-comment">// 指定了特定的name</span><br>        String className = beanKeys.get(name);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != className &amp;&amp; !className.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>                                            autoAutoWiredField = beanNameMap.get(className);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == autoAutoWiredField) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to load &quot;</span> + name);<br>        &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                                        <span class="hljs-comment">// JsAutowired注解没有name属性</span><br>                                        <span class="hljs-comment">// 判断注入的类型 是否是类Class类型 默认值也是Class</span><br>        <span class="hljs-keyword">if</span>(jsAutowired.value() == Class.class)&#123;<br>                                               autoAutoWiredField = register(field.getType());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 指定装配的类</span><br>                                            autoAutoWiredField = <span class="hljs-keyword">this</span>.getBean(jsAutowired.value());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == autoAutoWiredField) &#123;<br>                                                autoAutoWiredField = register(jsAutowired.value());<br>            &#125;<br>&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == autoAutoWiredField) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to load &quot;</span> + field.getType().getCanonicalName());<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> accessible = field.isAccessible();<br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        field.set(object, autoAutoWiredField);<br>        field.setAccessible(accessible);<br>    &#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>        e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>        e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>        e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">register</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != clazz)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.registerBean(clazz);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个实例对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz class对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> clazz.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>我们现在来测试一下，我们先定义一个类<code>OrangeSongJavaService</code>，方便待会测试被调用。<strong>注意哦，这个类上面没有任何注解</strong>。也就是他并没有被Spring管理起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> com.orangesongjava.ioc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrangeSongJavaService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeArticleOnJs</span><span class="hljs-params">(String name)</span></span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;在掘金上写文章!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在定义本地调用的模拟调用<code>OrangeSongJavaClient</code>。<strong>注意这个类上面也是没有注解</strong>，另外引用的<code>OrangeSongJavaService</code> 被我们的<strong>自定义注解<code>JsAutowired</code>标识</strong>起来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> com.orangesongjava.ioc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrangeSongJavaClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@JsAutowired</span><br>    <span class="hljs-keyword">private</span> OrangeSongJavaService orangeSongJavaService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        orangeSongJavaService.writeArticleOnJs(<span class="hljs-string">&quot;橘松Java&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrangeSongJavaService <span class="hljs-title">getOrangeSongJavaService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orangeSongJavaService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们写个测试<code>main</code>方法测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.orangesongjava.ioc;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IocTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JsSampleContainer jsContainer = <span class="hljs-keyword">new</span> JsSampleContainer();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 将类注入容器</span><br>        jsContainer.registerBean(OrangeSongJavaClient.class);<br>        <span class="hljs-comment">// 初始化注入-扫描引用</span><br>        jsContainer.initAutoWired();<br>        <span class="hljs-comment">// 容器获取bean</span><br>        OrangeSongJavaClient client jsContainer.getBean(OrangeSongJavaClient.class);<br>        <span class="hljs-comment">// 执行</span><br>        client.work();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果能输出执行逻辑，则表示这段程序没问题。果不其然，没问题。看到这里，你对ioc理解是不是有点清晰了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六种分布式事务方案</title>
    <link href="/blog/2021/07/08/%E5%85%AD%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/"/>
    <url>/blog/2021/07/08/%E5%85%AD%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在分布式系统、微服务架构大行其道的今天，服务间互相调用出现失败已经成为常态。如何处理异常，如何保证数据一致性，成为微服务设计过程中，绕不开的一个难题。</p><p>在不同的业务场景下，解决方案会有所差异，常见的方式有：</p><ul><li>阻塞式重试；</li><li>2PC、3PC 传统事务；</li><li>使用队列，后台异步处理；</li><li>TCC 补偿事务；</li><li>本地消息表（异步确保）；</li><li>MQ 事务。</li></ul><p>本文侧重于其他几项，关于 2PC、3PC 传统事务，网上资料已经非常多了，这里不多做重复。</p><h2 id="阻塞式重试"><a href="#阻塞式重试" class="headerlink" title="阻塞式重试"></a>阻塞式重试</h2><p>在微服务架构中，阻塞式重试是比较常见的一种方式。</p><p>伪代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">m := db.Insert(sql)<br><br>err := request(B-Service,m)<br><br><span class="hljs-function">func <span class="hljs-title">request</span><span class="hljs-params">(url string,body interface&#123;&#125;)</span></span>&#123;<br>  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i ++ &#123;<br>    result, err = request.POST(url,body)<br>    <span class="hljs-keyword">if</span> err == nil &#123;<br>        <span class="hljs-keyword">break</span> <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.Print()<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上，当请求 B 服务的 API 失败后，发起最多三次重试。如果三次还是失败，就打印日志，继续执行下或向上层抛出错误。</p><ul><li><a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247492102&idx=2&sn=bbad088a4ce061b20c1d6f0a14805004&chksm=fcf73dcbcb80b4dd4f5d3ca1ddefa53f39d901e1e8d82ede86f4c0dd89a055869d332bc7f20f&token=792828782&lang=zh_CN%23rd">原文出自于码猿技术专栏</a></li></ul><p>这种方式会带来以下问题：</p><ul><li>调用 B 服务成功，但由于网络超时原因，当前服务认为其失败了，继续重试，这样 B 服务会产生 2 条一样的数据。</li><li>调用 B 服务失败，由于 B 服务不可用，重试 3 次依然失败，当前服务在前面代码中插入到 DB 的一条记录，就变成了脏数据。</li><li>重试会增加上游对本次调用的延迟，如果下游负载较大，重试会放大下游服务的压力。</li></ul><blockquote><p>第一个问题：通过让 B 服务的 API 支持幂等性来解决。</p></blockquote><blockquote><p>第二个问题：可以通过后台定时脚步去修正数据，但这并不是一个很好的办法。</p></blockquote><blockquote><p>第三个问题：这是通过阻塞式重试提高一致性、可用性，必不可少的牺牲。</p></blockquote><p>阻塞式重试适用于业务对一致性要求不敏感的场景下。如果对数据一致性有要求的话，就必须要引入额外的机制来解决。另外关注公众号码猿技术专栏，回复关键词“9527”免费获取spring Cloud Alibaba最新视频教程。</p><h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><p>在解决方案演化的过程中，引入队列是个比较常见也较好的方式。如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">m := db.Insert(sql)<br><br>err := mq.Publish(<span class="hljs-string">&quot;B-Service-topic&quot;</span>,m)<br><br></code></pre></td></tr></table></figure><p>在当前服务将数据写入 DB 后，推送一条消息给 MQ，由独立的服务去消费 MQ 处理业务逻辑。和阻塞式重试相比，虽然 MQ 在稳定性上远高于普通的业务服务，但在推送消息到 MQ 中的调用，还是会有失败的可能性，比如网络问题、当前服务宕机等。这样还是会遇到阻塞式重试相同的问题，即 DB 写入成功了，但推送失败了。</p><p>理论上来讲，分布式系统下，涉及多个服务调用的代码都存在这样的情况，在长期运行中，调用失败的情况一定会出现。这也是分布式系统设计的难点之一。</p><h2 id="TCC-补偿事务"><a href="#TCC-补偿事务" class="headerlink" title="TCC 补偿事务"></a>TCC 补偿事务</h2><p>在对事务有要求，且不方便解耦的情况下，TCC 补偿式事务是个较好的选择。</p><p>TCC 把调用每个服务都分成 2 个阶段、 3 个操作：</p><ul><li>阶段一、Try 操作：对业务资源做检测、资源预留，比如对库存的检查、预扣。</li><li>阶段二、Confirm 操作：提交确认 Try 操作的资源预留。比如把库存预扣更新为扣除。</li><li>阶段二、Cancel 操作：Try 操作失败后，释放其预扣的资源。比如把库存预扣的加回去。</li></ul><p>TCC 要求每个服务都实现上面 3 个操作的 API，服务接入 TCC 事务前一次调用就完成的操作，现在需要分 2 阶段完成、三次操作来完成。</p><p>比如一个商城应用需要调用 A 库存服务、B 金额服务、C 积分服务，如下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">m := db.Insert(sql)<br>aResult, aErr := A.Try(m)<br>bResult, bErr := B.Try(m)<br>cResult, cErr := C.Try(m)<br><span class="hljs-keyword">if</span> cErr != nil &#123;<br>    A.Cancel()<br>    B.Cancel()<br> C.Cancel()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    A.Confirm()<br>    B.Confirm()<br>    C.Confirm()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码中分别调用 A、B、C 服务 API 检查并保留资源，都返回成功了再提交确认（Confirm）操作；如果 C 服务 Try 操作失败后，则分别调用 A、B、C 的 Cancel API 释放其保留的资源。</p><p>TCC 在业务上解决了分布式系统下，跨多个服务、跨多个数据库的数据一致性问题。但 TCC 方式依然存在一些问题，实际使用中需要注意，包括上面章节提到的调用失败的情况。</p><h3 id="空释放"><a href="#空释放" class="headerlink" title="空释放"></a>空释放</h3><p>上面代码中如果 C.Try() 是真正调用失败，那下面多余的 C.Cancel() 调用会出现释放并没有锁定资源的行为。这是因为当前服务无法判断调用失败是不是真的锁定 C 资源了。如果不调用，实际上成功了，但由于网络原因返回失败了，这会导致 C 的资源被锁定，一直得不到释放。</p><p>空释放在生产环境经常出现，服务在实现 TCC 事务 API 时，应支持空释放的执行。</p><h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><p>上面代码中如果 C.Try() 失败，接着调用 C.Cancel() 操作。因为网络原因，有可能会出现 C.Cancel() 请求会先到 C 服务，C.Try() 请求后到，这会导致空释放问题，同时引起 C 的资源被锁定，一直得不到释放。</p><p>所以 C 服务应拒绝释放资源之后的 Try() 操作。具体实现上，可以用唯一事务ID来区分第一次 Try() 还是释放后的 Try()。</p><h3 id="调用失败"><a href="#调用失败" class="headerlink" title="调用失败"></a>调用失败</h3><p>Cancel 、Confirm 在调用过程中，还是会存在失败的情况，比如常见的网络原因。</p><p>Cancel() 或 Confirm() 操作失败都会导致资源被锁定，一直得不到释放。这种情况常见解决方案有：</p><ul><li>阻塞式重试。但有同样的问题，比如宕机、一直失败的情况。</li><li>写入日志、队列，然后有单独的异步服务自动或人工介入处理。但一样会有问题，写日志或队列时，会存在失败的情况。</li></ul><p>理论上来讲非原子性、事务性的二段代码，都会存在中间态，有中间态就会有失败的可能性。</p><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>本地消息表最初是 ebay 提出的，它让本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来满足事务特性。</p><p>具体做法是在本地事务中插入业务数据时，也插入一条消息数据。然后在做后续操作，如果其他操作成功，则删除该消息；如果失败则不删除，异步监听这个消息，不断重试。</p><p>本地消息表是一个很好的思路，可以有多种使用方式：</p><h3 id="配合MQ"><a href="#配合MQ" class="headerlink" title="配合MQ"></a>配合MQ</h3><p>示例伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">messageTx := tc.NewTransaction(<span class="hljs-string">&quot;order&quot;</span>)<br>messageTxSql := tx.TryPlan(<span class="hljs-string">&quot;content&quot;</span>)<br><br>m,err := db.InsertTx(sql,messageTxSql)<br><span class="hljs-keyword">if</span> err!=nil &#123;<br> <span class="hljs-keyword">return</span> err<br>&#125;<br><br>aErr := mq.Publish(<span class="hljs-string">&quot;B-Service-topic&quot;</span>,m)<br><span class="hljs-keyword">if</span> aErr!=nil &#123; <span class="hljs-comment">// 推送到 MQ 失败</span><br> messageTx.Confirm() <span class="hljs-comment">// 更新消息的状态为 confirm</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br> messageTx.Cancel() <span class="hljs-comment">// 删除消息</span><br>&#125;<br><br><span class="hljs-comment">// 异步处理 confirm 的消息，继续推送</span><br><span class="hljs-function">func <span class="hljs-title">OnMessage</span><span class="hljs-params">(task *Task)</span></span>&#123;<br>   err := mq.Publish(<span class="hljs-string">&quot;B-Service-topic&quot;</span>, task.Value())<br>   <span class="hljs-keyword">if</span> err==nil &#123;<br>     messageTx.Cancel()<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码中其 messageTxSql 是插入本地消息表的一段 SQL ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tcc_async_task` (`uid`,`name`,`<span class="hljs-keyword">value</span>`,`status`)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>它和业务 SQL 在同一个事务中去执行，要么成功，要么失败。</p><p>成功则推送到队列，推送成功，则调用 messageTx.Cancel() 删除本地消息；推送失败则标记消息为 confirm。本地消息表中 status 有 2 种状态 try、confirm， 无论哪种状态在 OnMessage 都可以监听到，从而发起重试。</p><p>本地事务保障消息和业务一定会写入数据库，此后的执行无论宕机还是网络推送失败，异步监听都可以进行后续处理，从而保障了消息一定会推到 MQ。</p><p>而 MQ 则保障一定会到达消费者服务中，利用 MQ 的 QOS 策略，消费者服务一定能处理，或继续投递到下一个业务队列中，从而保障了事务的完整性。</p><h3 id="配合服务调用"><a href="#配合服务调用" class="headerlink" title="配合服务调用"></a>配合服务调用</h3><p>示例伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">messageTx := tc.NewTransaction(<span class="hljs-string">&quot;order&quot;</span>)<br>messageTxSql := tx.TryPlan(<span class="hljs-string">&quot;content&quot;</span>)<br><br>body,err := db.InsertTx(sql,messageTxSql)<br><span class="hljs-keyword">if</span> err!=nil &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br><br>aErr := request.POST(<span class="hljs-string">&quot;B-Service&quot;</span>,body)<br><span class="hljs-keyword">if</span> aErr!=nil &#123; <span class="hljs-comment">// 调用 B-Service 失败</span><br> messageTx.Confirm() <span class="hljs-comment">// 更新消息的状态为 confirm</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br> messageTx.Cancel() <span class="hljs-comment">// 删除消息</span><br>&#125;<br><br><br><span class="hljs-comment">// 异步处理 confirm 或 try 的消息，继续调用 B-Service</span><br><span class="hljs-function">func <span class="hljs-title">OnMessage</span><span class="hljs-params">(task *Task)</span></span>&#123;<br>  <span class="hljs-comment">// request.POST(&quot;B-Service&quot;,body)</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这是本地消息表 + 调用其他服务的例子，没有 MQ 的引入。这种使用异步重试，并用本地消息表保障消息的可靠性，解决了阻塞式重试带来的问题，在日常开发中比较常见。</p><p>如果本地没有要写 DB 的操作，可以只写入本地消息表，同样在 OnMessage中处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">messageTx := tc.NewTransaction(<span class="hljs-string">&quot;order&quot;</span>)<br>messageTx := tx.Try(<span class="hljs-string">&quot;content&quot;</span>)<br>aErr := request.POST(<span class="hljs-string">&quot;B-Service&quot;</span>,body)<br><span class="hljs-comment">// ....</span><br><br></code></pre></td></tr></table></figure><h3 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h3><p>配置本地消息表的 Try 和 Confirm 消息的处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">TCC.SetTryHandler(OnTryMessage())<br>TCC.SetConfirmHandler(OnConfirmMessage())<br><br></code></pre></td></tr></table></figure><p>在消息处理函数中要判断当前消息任务是否存在过久，比如一直重试了一小时，还是失败，就考虑发邮件、短信、日志告警等方式，让人工介入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">func <span class="hljs-title">OnConfirmMessage</span><span class="hljs-params">(task *tcc.Task)</span> </span>&#123;<br><span class="hljs-keyword">if</span> time.Now().Sub(task.CreatedAt) &gt; time.Hour &#123;<br>    err := task.Cancel() <span class="hljs-comment">// 删除该消息，停止重试。</span><br>   <span class="hljs-comment">// doSomeThing() 告警，人工介入</span><br>    <span class="hljs-keyword">return</span><br> &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在 Try 处理函数中，还要单独判断当前消息任务是否存在过短，因为 Try状态的消息，可能才刚刚创建，还没被确认提交或删除。这会和正常业务逻辑的执行重复，意味着成功的调用，也会被重试；为尽量避免这种情况，可以检测消息的创建时间是否很短，短的话可以跳过。</p><p>重试机制必然依赖下游 API 在业务逻辑上的幂等性，虽然不处理也可行，但设计上还是要尽量避免干扰正常的请求。</p><h3 id="独立消息服务"><a href="#独立消息服务" class="headerlink" title="独立消息服务"></a>独立消息服务</h3><p>独立消息服务是本地消息表的升级版，把本地消息表抽离成一个独立的服务。所有操作之前先在消息服务添加个消息，后续操作成功则删除消息，失败则提交确认消息。</p><p>然后用异步逻辑去监听消息，做对应的处理，和本地消息表的处理逻辑基本一致。但由于向消息服务添加消息，无法和本地操作放到一个事务里，所以会存在添加消息成功，后续失败，则此时的消息就是个无用消息。</p><p>如下示例场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">err := request.POST(<span class="hljs-string">&quot;Message-Service&quot;</span>,body)<br><span class="hljs-keyword">if</span> err!=nil &#123;<br>  <span class="hljs-keyword">return</span> err<br>&#125;<br><br>aErr := request.POST(<span class="hljs-string">&quot;B-Service&quot;</span>,body)<br><span class="hljs-keyword">if</span> aErr!=nil &#123;<br>  <span class="hljs-keyword">return</span> aErr<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="MQ-事务"><a href="#MQ-事务" class="headerlink" title="MQ 事务"></a>MQ 事务</h2><p>有些 MQ 的实现支持事务，比如 RocketMQ 。MQ 的事务可以看作独立消息服务的一种具体实现，逻辑完全一致。</p><p>所有操作之前先在 MQ 投递个消息，后续操作成功则 Confirm 确认提交消息，失败则Cancel删除消息。MQ 事务也会存在 prepare状态，需要 MQ 的消费处理逻辑来确认业务是否成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从分布式系统实践中来看，要保障数据一致性的场景，必然要引入额外的机制处理。</p><p>TCC 的优点是作用于业务服务层，不依赖某个具体数据库、不与具体框架耦合、资源锁的粒度比较灵活，非常适用于微服务场景下。缺点是每个服务都要实现 3 个 API，对于业务侵入和改动较大，要处理各种失败异常。开发者很难完整处理各种情况，找个成熟的框架可以大大降低成本，比如阿里的 Fescar。</p>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Autowired报错原因分析和4种解决方案</title>
    <link href="/blog/2021/07/06/Autowired%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%E5%92%8C4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/blog/2021/07/06/Autowired%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%E5%92%8C4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5668f70c3dcf4b04b38aed355e6b87d9~tplv-k3u1fbpfcp-zoom-1.image" alt="autowired-logo.png"> 上图的报错信息相信大部分程序员都遇到过，<strong>奇怪的是虽然代码报错，但丝毫不影响程序的正常执行</strong>，也就是虽然编译器 IDEA 报错，但程序却能正常的执行，那这其中的原因又是为何？ </p><h2 id="报错原因分析"><a href="#报错原因分析" class="headerlink" title="报错原因分析"></a>报错原因分析</h2><p>报错的原因首先是因为 IDEA 强大的报警机制，@Autowired 为 Spring 的注解，含义是将某类动态的注入到当前类中，如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37751b49f3a940d3a307b9554ef6a5e2~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> @Autowired 默认是根据 type 进行注入，并且注入时要求（注入）对象不能为 NULL，默认值如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1bf342f8b749b08495cb5d371a2271~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 而 <strong>IDEA 报错的原因是：@Autowired 为 Spring 的注解，而注入的 Mapper 对象使用的又是 @Mapper 的注解，然而 @Mapper 又为 MyBaits 的注解，IDEA 能很好的兼容并识别 Spring 的注解，但不能很好的识别 MyBatis 的注解，因此在使用 @Autowired 注解时，IDEA 并不能检测到 @Mapper 注解的对象不为 NULL，因此就会报错。</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c80bfdcfc70745988bb05ccfb7c0505e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>这就是为什么使用 Spring 的注解 @Repository/@Component… 不报错，而使用 @Mapper 注解却会报错的根本原因，如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f997825fabdb43feb4e452efbfa1df7d~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b08c4d099d4352ac8eb38c6c5a6451~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04c01661c3e541bc8b6f92cd0431ecee~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h2 id="解决方案1：关闭报警机制"><a href="#解决方案1：关闭报警机制" class="headerlink" title="解决方案1：关闭报警机制"></a>解决方案1：关闭报警机制</h2><p>关闭 IDEA 注入报警机制，可以避免报错，实现步骤如下。 </p><p>1.打开 IDEA，找到参数设置选项 “Preferences…” ，如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b76ba5dc3be4e26a86640a8292b41df~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 2.依次选择 “Editor” -&gt; “Inspections” -&gt; “Spring” -&gt; “Spring Core” -&gt; “Code” -&gt; “Autowiring for bean class” 将 “Error” 级别修改成 “Waring” 级别，如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff5e0e7833c3496e91399efbd90f7d7c~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 设置完成之后点击确认，查看之前报错的 Mapper 类，此时展示效果如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4121b3fa7a34b1aa6577a545ef5e0c2~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 报错信息消失了。 </p><h2 id="解决方案2：添加Spring注解"><a href="#解决方案2：添加Spring注解" class="headerlink" title="解决方案2：添加Spring注解"></a>解决方案2：添加Spring注解</h2><p>在 Mapper 的类上添加 Spring 的注解，也可以解决 IDEA 报错的问题，如 @Repository 或 @Component 这类注解，如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/754a9348dd8446c7bed38fdbe402c77c~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 或使用 @Repository 注解，如下图所示： <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4aad4f652ef0472eb0225deb143c3b78~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 查看之前的报错信息： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df1ac0c3a3f1460f8ac6ff5139bb634e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> 报错消失了。</p><h2 id="解决方案3：允许注入对象为NULL"><a href="#解决方案3：允许注入对象为NULL" class="headerlink" title="解决方案3：允许注入对象为NULL"></a>解决方案3：允许注入对象为NULL</h2><p>设置允许注入的 Mapper 对象为 NULL，也可以避免 IDEA 报错，只需要设置 @Autowired(required=false) 即可，如下图所示： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4e4d05472744c90bc1b3b7afef6e449~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> （其中 userMapper2 对象就不报错了）</p><ul><li>@Autowired(required=true)：表示当使用 @Autowired 注解的时候，该 bean 必须存在，否则注入失败，默认值。</li><li>@Autowired(required=false)：表示忽略当前要注入的 bean，如果有直接注入，没有则跳过，不会报错。</li></ul><p>@Autowired 默认值的实现源码： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7d309a4196345498f1616e84a8c881b~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h2 id="解决方案4：使用-Resource注解"><a href="#解决方案4：使用-Resource注解" class="headerlink" title="解决方案4：使用@Resource注解"></a>解决方案4：使用@Resource注解</h2><p>使用 @Resource 注解替换 @Autowired 注解也可以避免报错，它们的对比效果如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0806fd14b2674b3eab9aa72a7525ebf8~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"> @Resource 注解和 @Autowired 注解以当前的场景来说，它们的主要区别是 @Resource 是 Java 自身提供的注解，而 @Autowired 是 Spring 提供的注解，@Autowired 默认值为 required=true，所以必须要一个非 NULL 的对象，当 IDEA 检测不到对象为 NULL 时就会报错，而 @Resource 并没有这项要求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 @Autowired 注解导入 Mapper 对象报错的原因，是因为 @Autowired 默认情况下，需要注入一个非 NULL 的对象，而被 @Mapper 修饰的类为 MyBatis 的注解，IDEA 并不能很好的识别其为非 NULL 对象，因此就会报错。当然，它的解决方案也有很多，推荐使用 @Resource 替代 @Autowired 注解的方式来解决此问题。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>解决方案</tag>
      
      <tag>Autowired</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何设计一个高可用的订单系统</title>
    <link href="/blog/2021/07/05/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/"/>
    <url>/blog/2021/07/05/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>订单系统的基本架构： <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3746a351df34ba2b52af70b70798be2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 前台有结算页提供用户去结算，当后台收到前台用户点击结算操作时就会开始处理下单服务，起初订单被写入到后台的数据库中，然后异构数据到缓存中以此提供用户在我的订单系统中进行订单查询，当用户支付完成后，收银台发送消息给下单的服务进行数据库和混存中订单状态的修改，这样简单的订单系统就完成了，但是真实的订单系统有更加复杂的业务，使系统更加复杂。 接下来，看看系统中哪些环节会出现丢单的问题</p><p>订单丢失：写数据库和接受和发送订单消息</p><p>1.关键逻辑不能使用读写分离的查询方式，避免从库同步延迟造成订单查询异常 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59c062e57dc34f6c9c221a8cfa0a5e6a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 2.关键逻辑不要使用缓存进行订单查询，由于缓存延迟造成订单反查询失败</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73efb89b1d4e4fce80e66d457d8d97c4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>3.订单补偿不要简单粗暴的使用消息队列的方式，避免中间件引发的订单丢失，比如在订单状态修改的时候，如果处理失败，就将这个订单信息插入到消息队列中重新消费，以此完成订单的补偿，这种方式在发送消息和接收消息时有可能存在丢消息的可能 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a0a63f49f947ffa1f46eb7ee19eb30~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>4接收消息处理失败时一定要让消息重试，避免丢失尤其注意return，continue等关键字，比如一次消费多条记录一条条地进行处理，如果修改状态成功，就继续处理下一条，如果修改失败，可能会因为return或者continue等关键字将其余的消息都丢失掉了</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d38d5f7d7954c769fc6a22f7ca280cd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如何设计一个支持日万级订单系统，考虑到前面可能丢单的问题，以及系统的稳定性和可用性，我们如何进行系统化的重构优化。之前的系统其实很容易处理日万级的订单，所以你只要注意几个关键点就可以了： 1.写数据库时，数据库事务的粒度不要太大，避免锁表，关注慢查询，比如最不要犯的错误就是在数据库事物里面同时去更新其他的数据源或者发送消息到消息中，这不仅不能保证数据的一致性还会把数据库的连接耗尽。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd87f2ba0ac8452888b5c1811311b3f3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 另外需要注意的是关注数据异构的性能和稳定性，尤其是在网路抖动的情况下，可能会影响用户体验 最后，要关注订单的幂等性，避免出现计费错误，影响后续的操作流程。 做好这几点前面的架构方案基本上能够满足日万级的订单系统了。</p><p>如何设计一个支撑日千万级的订单系统，与日万级的订单系统的区别在于量，由于量的增大造成系统负载过重，导致服务最终宕机，那么分析一下前面的系统架构中哪些是系统的瓶颈呢？</p><p>首先，前面的架构设计中过度的依赖于数据库，而且数据库还是订单库，持续的读写请求会给数据库造成很大的压力，比如修改订单状态的时候需要反查数据库并进行订单状态更新，这些操作在高并发请求时，会造成数据库资源的抢占，从而影响系统的稳定性，其次，为了避免数据不一致，请求访问主要集中在主库上，因此主库的压力比较大</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a365cdf0d2054cde9a03276f2f7faefc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>因此在用分库分表的架构，下单服务为此也必须进行改造，支持分库分表的架构设计，但是由于热点数据的存在，可能导致数据库出现数据倾斜的问题，引发提早的数据库扩容问题</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456a01dd18b4466d8af15f0be8f82512~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>还有，由于下单服务耦合过重，使得即使是多集群的部署架构，也很难快速的处理业务响应，更何况不同业务的订单处理流程还是不一样的，使得系统的维护性越来越差，比如：创建订单时由于业务不同，数码，3c，图书等订单系统的信息时不一样的，这就需要特殊处理，这种特殊处理与创建订单耦合在一起，就会导致系统处理速度很慢，最后由于数据库的存储数据量增大，还会导致数据异构性能直线下降以及缓存容量的不断扩大，这都会极大的影响查询性能，而且可能出现业务间的互相影响等问题 总的来说，前面的系统出现问题：下单系统处理订单慢，数据库压力大，数据异构延迟高，缓存数据质量差 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1658a9a7263400ba2d4a1aa2ac66bd6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>为了应对日千万级的订单量，我们对下单服务进行了拆分，使用的单独的接单服务处理订单，使用订单引擎和订单管道处理订单业务逻辑，改用双写和事物补偿的方式处理缓存，使用缓存过期的方式处理数据量，</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e8b30fb43040d48cf0350254b2bfe3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来就具体的分析实现方案：当用户点击提交订单之后，接单服务就会在同一个事务里，将订单插入接单库，将首任务插入到任务库，再由订单引擎进行任务调度，什么是任务？任务就是执行订单操作的步骤，比如写订单缓存，减库存，发送订单通知等，以及前面提到的不同的特殊业务流程，这些都是一个个的任务，我们将整个订单处理流程分解成一个个的任务，逐个单独处理，来应对日千万级的订单处理压力。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83dc400adb6845618cea70e4f766d58a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>其中接单库为多台数据库，通过随机的方式写入数据库中，之所以没有采用哈希等算法，其原因在于扩展能力更加灵活，当遇到流量洪峰来临时，新增数台数据库对写入逻辑是无感的，接单库采用一主多从的部署架构，当一台机器故障，可以通过快读切换主从或者摘除故障机等手段进行修复，</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85e89d0a0bb9404eb70d89b5d918f420~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 而其中任务库由订单引擎驱动执行，任务通过订单引擎的服务编排能力，生成任务队列，首任务执行成功之后，会插入第二个任务，或者同时插入第三个和第四个任务，如果任务插入失败，订单引擎会重新执行当前任务，执行成功之后，会继续执行插入操作，这里就需要每个任务的业务处理都需要保证幂等性， <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fd31bd7d6c348889b0c211017c408be~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来，说一下任务的线程调度方式，任务使用多线程的异步方式进行调度，并根据配置选择是串行执行还是并行执行，有一点注意的是：前面说的任务线程调度执行，那么如果任务执行失败么，订单引擎如何重新执行任务失败的任务呢？这就是任务状态机来实现的，任务状态机就如同一个系统的守护线程。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2c1624401fd54b50a9947c7b3534b97c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>任务状态机通过识别任务状态来识别每个任务是执行完成还是执行失败，并根据状态进行任务调度，并且对多次执行失败的任务重试调度的频次也会逐渐减弱，当超过一定重试次数之后就会发出报警进行人工干预， <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20dd40a053d94b479dc39ea5d79b1915~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 其实，订单引擎真正执行远程调度远程服务的并非订单引擎来执行的，而是由订单引擎调度订单管道，订单管道去调度远程真实的服务来执行的，其原因在于任务引擎本身就是多线程设计架构，对线程占用就比较高，而远程调度会注册很多服务，服务调度也会启动很多多线程去执行，如果共同部署在同一个系统里，就会出现线程数过多导致cpu飙升的情况，</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30bdf6a68db74db284f3cf22bc1638ca~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 接下来再来说一下订单缓存的实现策略：接单服务在处理完一些业务逻辑之后，最后调用下单服务提交订单到订单中心，而在此之前，为了保证订单的及时性，在插入订单和任务之后，接单服务会现将订单通过接口写入到订单中心的缓存中，以支持用户在支付之后，在我的订单列表中能立即查询到我的订单，总体来说，订单中心接到下单服务之后，会将订单落库，便同步到缓存中，在后续订单中心收到台帐的消息之后，也会同时更新数据库和缓存，将订单状态更新为订单完成。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bd3a2ea7dd74bc987c13bb10fef900c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 最后，讲述日千万级的订单系统架构再概括的讲一下，用户在结算页点击结算，结算页调用后台的接单服务，接单服务接收到下单请求之后会负责接单，将订单插入到接单库，同时在一个事务里将首任务插入到任务库并通知调度起订单引擎开始执行任务，订单引擎根据任务编号依次执行任务调度并更新任务状态，并由状态机进行任务校验补偿处理，订单引擎通过调度订单管道实现真实远程调度，订单管道请求服务之后，将处理结果返回任务引擎，最后，订单中心会在接单服务创建订单时异步地写一份订单缓存到订单中心，然后再通过数据异构的方式再次写一份数据在订单缓存中，</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66b83a538fe34bc5855702c8256c41a9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>了解完订单的处理流程之后，我们再整个流程中如何保证下单流程的高可用和高性能的，整个订单系统接单的核心流程及几乎为同步执行，只有少数任务，比如发送订单通知给下游，系统时采用消息异步的方式执行，以此来保证订单流程的高性能而整个处理过程，基于订单引擎的调度，通过服务流程编排确定一个订单的执行步骤，并有效地保证每个环节的正确执行避免订单丢单，卡单等异常问题出现，进而保证订单流程的高可用，</p>]]></content>
    
    
    
    <tags>
      
      <tag>订单系统</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引技术</title>
    <link href="/blog/2021/07/04/%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF/"/>
    <url>/blog/2021/07/04/%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h1><blockquote><p><strong>本篇文章主要介绍了相关MySQL技术系列体系中，最重要的部分-索引，带你从索引的本质（底层原理）、索引的类型、索引的原理、索引的数据结构，最后到索引的使用角度以及索引的优化，全方位360度去探索索引的奥秘！</strong></p></blockquote><h1 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h1><ul><li>OLAP：<strong>联机分析处理—-对海量历史数据进行分析，产生决策性的策略—-数据仓库—Hive</strong></li><li>OLTP：<strong>联机事务处理—-要求很短时效内返回对应的结果—-数据库—关系型数据库(mysql、oracle)</strong></li></ul><h1 id="内容架构"><a href="#内容架构" class="headerlink" title="内容架构"></a>内容架构</h1><ul><li><strong>磁盘角度去看索引机制（运作机制提升性能原理）</strong></li><li><strong>索引机制的分析和基本介绍</strong></li><li><strong>索引机制的分类和概念</strong></li><li><strong>索引本身的优缺点以及不同分类的优缺点</strong></li></ul><h2 id="索引和磁盘的关系"><a href="#索引和磁盘的关系" class="headerlink" title="索引和磁盘的关系"></a>索引和磁盘的关系</h2><h3 id="数据读取时主要时间开销"><a href="#数据读取时主要时间开销" class="headerlink" title="数据读取时主要时间开销"></a>数据读取时主要时间开销</h3><p>从概念模型上来讲，从磁盘读出一条数据需要两步：</p><ul><li><strong>将磁头移动到数据所在的扇区，找到数据所在的页，将这一页数据加载到内存</strong></li><li><strong>在内存中，找到数据所在的偏移量，并返回该记录</strong></li></ul><h3 id="总结分析瓶颈点"><a href="#总结分析瓶颈点" class="headerlink" title="总结分析瓶颈点"></a>总结分析瓶颈点</h3><blockquote><p><strong>这两步中，第1步消耗的时间远远大于第2步，其原因是需要移动磁头到给定扇区，时间开销由寻道和延迟两部分构成，通常在毫秒级。而从内存直接读取数据，时间为纳秒级。</strong></p></blockquote><h3 id="优化的方式"><a href="#优化的方式" class="headerlink" title="优化的方式"></a>优化的方式</h3><p>主要的时间开销来源于寻找数据所在的页。<strong>因此优化寻找数据所在页的需求是非常紧急且重要的。</strong></p><h4 id="数据量计算"><a href="#数据量计算" class="headerlink" title="数据量计算"></a>数据量计算</h4><p>对于给定大小的数据量（比如2^ 20条）、平均每条记录所占用的内存空间（比如2^ 7byte）和每一页的大小（如4kb），那么平均每页的记录数和所需的数据页数就可以确定，分别是(32（2^12/2^7）条和2^15（2^20/2^5）页)。</p><h4 id="传统暴力（顺序型读写）X"><a href="#传统暴力（顺序型读写）X" class="headerlink" title="传统暴力（顺序型读写）X"></a>传统暴力（顺序型读写）X</h4><p>如果使用遍历的方式，将每一页加载到内存然后搜索，那么最坏情况下需要1万次的读取数据页的操作才能搜索到给定记录。这就好像我有一本书，我要从第一页一指翻到最后一页，才能找到我要读到的某一行文字，这显然不太高效。</p><h4 id="索引机制（半随机性读写）√"><a href="#索引机制（半随机性读写）√" class="headerlink" title="索引机制（半随机性读写）√"></a>索引机制（半随机性读写）√</h4><blockquote><p><strong>优化的办法是建立索引，将数据按索引排序，对于每一条数据，我可以建立一个索引+指针来指向该数据的起始地址</strong>。(<strong>空间来换时间</strong>)</p></blockquote><blockquote><p><strong>那么我就可以将这个索引存起来，并使用指针指向该记录。</strong></p></blockquote><ul><li><p>现在需要 2^ 20个索引，假设</p><p>每条索引和指针共占8byte空间</p><p>，</p><p>那么所需的索引页为2^ 11（2^ 20 * 8 / 4kb）页。</p><ul><li><strong>此时如果遍历索引页，然后再去找到对应的记录，最坏需要2^11 + 1次读取，显然效率高了些</strong>。</li></ul></li></ul><h4 id="索引升级之多级索引化（全随机性读写）"><a href="#索引升级之多级索引化（全随机性读写）" class="headerlink" title="索引升级之多级索引化（全随机性读写）"></a>索引升级之多级索引化（全随机性读写）</h4><p>如果利用递归的思想，对索引页再建索引（<strong>是不是在内存管理中有类似的想法，对页表建立页表</strong>）。</p><blockquote><p><strong>比如，对这2^20条数据的索引建立索引。对于给定的一页，它的第一条索引是确定的</strong>。</p></blockquote><ol><li><strong>那么将第一条索引再存到另一个索引中(索引的索引)，假设索引都连续，那么对于给定的一个索引，就可以根据索引的索引找到这个索引所在的页</strong>。</li><li><strong>然后找到这个索引，根据这个索引指向的数据去读取数据。比如：检索索引15，它在0到31之间，便可以知道它在第一个数据页上，通过之前保存起来的指针即可访问到该页</strong>。</li><li><strong>由于更上层的索引更稀疏了，因此可以保存更多的索引，使每一页能表示更多的数据。</strong></li><li><strong>递归到最终只需1页就能保存某一级索引的时候，就可以停止递归了</strong>。<strong>此时根据索引来访问数据，只需要查每一级索引中的某一页，就可以确定下一级索引所在的页。直到最底一层的索引，它指向了数据</strong>。</li><li><strong>那么需要读取的总页数为索引级数+1。这个次数远远小于总数据页数</strong>。</li></ol><h4 id="使用索引的好处在于"><a href="#使用索引的好处在于" class="headerlink" title="使用索引的好处在于"></a>使用索引的好处在于</h4><ul><li><strong>第一，将数据进行了分桶，对于落在桶内区间段的索引，都可以通过一个指针访问到对应的数据页</strong>。</li><li><strong>第二，索引所占的内存要远远小于1条记录所占的空间，因此个索引页能保存非常多的索引</strong>。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39e244d86e334a0bad7dd3ea3cfaeef9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="索引机制总结"><a href="#索引机制总结" class="headerlink" title="索引机制总结"></a>索引机制总结</h3><blockquote><p>一句话：减少加载磁盘的次数（寻道的时间和次数），且索引占用数据较少，所以可以存放更多的数据内存（提高检索效率）。</p></blockquote><h3 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h3><ul><li><strong>去磁盘读取数据，是用多少读取多少吗？</strong><ul><li><strong>内存和磁盘发生数据交互的时候，一般情况下有一个最小的逻辑单元：页（Page）。</strong></li><li><strong>页一般由操作系统觉得大小，4k或8k，而我们在进行数据交互的时候，可以取页的整数倍来读取。</strong></li><li><strong>innodb存储引擎每次读取数据，读取16k</strong></li></ul></li></ul><h4 id="局部性原理：数据和程序都有聚集成群的倾向，同时之前被访问过的数据很可能再次被查询，空间局部性，时间局部性"><a href="#局部性原理：数据和程序都有聚集成群的倾向，同时之前被访问过的数据很可能再次被查询，空间局部性，时间局部性" class="headerlink" title="局部性原理：数据和程序都有聚集成群的倾向，同时之前被访问过的数据很可能再次被查询，空间局部性，时间局部性"></a>局部性原理：<strong>数据和程序都有聚集成群的倾向，同时之前被访问过的数据很可能再次被查询，空间局部性，时间局部性</strong></h4><h3 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h3><blockquote><p><strong>磁盘，查询数据的时候会优先将索引加载到内存中</strong></p></blockquote><ul><li><strong>索引在存储的时候，需要什么信息？需要存储存储什么字段值？</strong><ul><li><strong>key：实际数据行中存储的索引键。</strong></li><li><strong>文件地址，所在磁盘文件地址</strong></li><li><strong>offset：偏移量</strong></li></ul></li></ul><h2 id="索引系统性介绍"><a href="#索引系统性介绍" class="headerlink" title="索引系统性介绍"></a>索引系统性介绍</h2><h3 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h3><blockquote><p><strong>索引（index）是帮助MySQL高效获取数据的数据结构（有序）</strong>。</p></blockquote><blockquote><p><strong>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</strong></p></blockquote><h3 id="索引的介绍"><a href="#索引的介绍" class="headerlink" title="索引的介绍"></a>索引的介绍</h3><ul><li><strong>索引是一种用于快速查询和检索数据的数据结构</strong>。</li><li><strong>索引的作用就相当于目录的作用，可以类比字典、 火车站的车次表、图书的目录等</strong>。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3ce1c9efe4247448f279659c9a8fef7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li><strong>索引是在存储【引擎层】实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现</strong>。</li></ul><blockquote><p><strong>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，数据库还维护者一个满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构，就是索引。</strong></p></blockquote><blockquote><p>索引本身也很大，不可能全部存储在内存中，一般以索引文件的形式存储在磁盘上，(<strong>InnoDB数据表上的索引是表空间的一个组成部分</strong>)，它们包含着对数据表里所有记录的引用指针。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35ffd54668b14c8d891ac510af340f40~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li><strong>左边是数据表，一共有两列七行记录，最左边的0x07格式的数据是物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）</strong>。</li><li><strong>为了加快Col 2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据的物理地址的指针，这样就可以运用二叉查找快速获取到对应的数据了</strong>。</li><li><strong>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。建立索引是数据库中用来提高性能的最常用的方式。</strong></li></ul><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>效率：<strong>大大提高数据检索效率（减少了检索的数据量以及次数），降低数据库IO成本，这也是创建索引的最主要原因</strong>；</li><li>性能：<strong>降低数据排序的成本，降低CPU的消耗，提高系统性能</strong>；</li><li>索引大大减小了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机IO变成顺序IO</li></ul><p>在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。</p><p>对不需要的元组的加锁，会增加锁的开销，降低并发性。</p><p>InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。</p><p>一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，已经无法避免对那些元组加锁了。</p><p>如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>空间方面：<strong>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以索引也需要占用内存（物理空间）。</strong><ul><li><strong>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快</strong></li></ul></li><li>时间方面：<strong>创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</strong><ul><li><strong>索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件</strong>。</li></ul></li></ul><h4 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h4><ul><li><strong>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</strong></li><li><strong>对于非常小的表，大部分情况下简单的全表扫描更高效；</strong></li><li><strong>因此应该只为最经常查询和最经常排序的数据列建立索引</strong></li><li><strong>MySQL里同一个数据表里的索引总数限制为16个。</strong></li></ul><p>关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）</p><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><h4 id="存储数据结构划分"><a href="#存储数据结构划分" class="headerlink" title="存储数据结构划分"></a>存储数据结构划分</h4><blockquote><p><strong>B-Tree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引，这里所描述的是索引存储时保存的形式。</strong></p></blockquote><h4 id="【从物理角度划分】"><a href="#【从物理角度划分】" class="headerlink" title="【从物理角度划分】"></a>【从物理角度划分】</h4><ul><li><p>聚集索引：</p><p>即数据文件本身就是主键索引文件（InnoDB）</p><p>。</p><ul><li><strong>聚集索引(聚簇索引、Innodb)：聚集索引即索引结构和数据一起存放的索引，主键索引属于聚集索引。表中记录的物理顺序与键值的索引顺序相同。 因为真实数据的物理顺序只有一种，所以一个表只能有一个聚集索引</strong>。</li><li><strong>InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于InnoDB 引擎表来说，该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据</strong>。</li></ul></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/87c45c978d6c419ca3e0a06539b52875~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><a href="https://upload-images.jianshu.io/upload_images/26078969-3c1cf9cee4bc53b7.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp">【图片来源】</a></p><ul><li><p>非聚集索引（辅助索引）：</p><p>即索引文件与数据文件是分离的（MyISAM），聚集索引和非聚集索引都是B+树结构</p><p>。</p><ul><li><strong>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引</strong>。</li><li><strong>记录的物理顺序与键值的索引顺序不同。这也是非聚集索引与聚集索引的根本区别。</strong></li><li><strong>表中记录的物理顺序与键值的索引顺序不同。这也是非聚集索引与聚集索引的根本区别</strong>。</li></ul></li></ul><blockquote><p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</strong>。</p></blockquote><blockquote><p><strong>MYISAM引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d01f1a4163b4d6c84cb09dfb6b06933~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> <a href="https://upload-images.jianshu.io/upload_images/26078969-3c1cf9cee4bc53b7.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp">【图片来源】</a></p><h5 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h5><blockquote><p><strong>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</strong></p></blockquote><h5 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h5><ul><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h5 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h5><blockquote><p><strong>更新代价比聚集索引要小 。因为非聚集索引的叶子节点是不存放数据的</strong></p></blockquote><h5 id="非聚集索引的缺点："><a href="#非聚集索引的缺点：" class="headerlink" title="非聚集索引的缺点："></a>非聚集索引的缺点：</h5><ul><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表) ：这应该是非聚集索引最大的缺点了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</strong>。</li></ul><h4 id="【从功能角度划分】"><a href="#【从功能角度划分】" class="headerlink" title="【从功能角度划分】"></a>【从功能角度划分】</h4><ul><li>普通索引（单列索引）：<strong>每个索引只包含单个列，一个表可以有多个单列索引，仅加速查询；</strong></li><li>唯一索引：<strong>加速查询 + 列值唯一（可以有null）</strong></li><li>主键索引：<strong>加速查询 + 列值唯一（不可以有null）+ 表中只有一个，在 mysql 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个6Byte的自增主键</strong>。</li><li>组合/复合索引（多列索引）：<strong>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并（即使用多个单列索引组合搜索）</strong></li></ul><h5 id="主键与唯一索引的区别"><a href="#主键与唯一索引的区别" class="headerlink" title="主键与唯一索引的区别"></a>主键与唯一索引的区别</h5><ul><li>主键是一种约束，目的是对这个表的某一列进行限制；唯一索引是一种索引，目的是为了加速查询；</li><li>主键列不允许为空值，而唯一索引列可以为空值（null）</li><li>一个表中最多只能有一个主键，但是可以包含多个唯一索引</li><li>主键一定是唯一性索引，唯一性索引并不一定就是主键</li></ul><h4 id="【从特性角度划分】"><a href="#【从特性角度划分】" class="headerlink" title="【从特性角度划分】"></a>【从特性角度划分】</h4><blockquote><p>MySQL目前主要有以下几种索引类型：<strong>B+Tree 索引、哈希索引、全文索引（full-index）与空间数据索引（R-Tree）</strong></p></blockquote><ul><li>B+Tree 索引：<strong>是大多数 MySQL 存储引擎的默认索引类型，不需进行全表扫描，只需对树进行搜索，所以查找速度快很多； B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组</strong>。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/413584f808ca42b1a11c67de3f040dcc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><blockquote><p>B+树把数据全放在了叶子节点中，叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。 例如： 查询范围 select * from table where id between 11 and 35？</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c28441553448debe7a6c2d195b3c7d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>第一步，将磁盘一加载到内存中，发现11&lt;28,寻找地址磁盘2</li><li>第二步，将磁盘二加载到内存中，发现10&gt;11&gt;17,寻找地址磁盘5</li><li>第三步，将磁盘五加载到内存中，发现11=11，读取data</li><li>第四步，继续向右查询，读取磁盘5，发现35=35，读取11-35之间数据，结束 由此可见，这样的范围查询比B树速度提高了不少。</li><li>哈希索引：<strong>哈希索引能以 O(1) 时间进行查找，一次定位，不需要像树形索引逐层查找，具有极高的效率</strong>。<strong>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。但是失去了有序性</strong><ul><li>对排序与组合索引效率不高；</li><li>只支持精确查找（等值查询，如=、in()、&lt;=&gt;），无法用于部分查找和范围查找。</li><li>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35133d7329704d958af63a1f39f3ee37~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>全文索引：<strong>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等</strong>。<ul><li>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。<strong>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引</strong>。</li></ul></li><li>空间数据索引：MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据</li></ul><blockquote><p>树(二叉树、红黑树、AVL树、B树、B+树)，这里为什么索引默认用 B+树，而不用B树、二叉树、hash和红黑树呢？</p></blockquote><h3 id="为什么不用B-tree："><a href="#为什么不用B-tree：" class="headerlink" title="为什么不用B-tree："></a>为什么不用B-tree：</h3><ul><li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针（B树每个节点都存储数据，B+树只有叶子节点才存储节点），所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。</li><li>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可（叶子节点使用双向链表连接）。但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来找，所以B+树更加适合在区间查询的情况，通常B+树用于数据库索引。</li></ul><h3 id="为什么不用Hash方式："><a href="#为什么不用Hash方式：" class="headerlink" title="为什么不用Hash方式："></a>为什么不用Hash方式：</h3><blockquote><p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，只适合等值查询（等值查询效率高），如=、in()、&lt;=&gt;多个数据在存储关系上是完全没有任何顺序关系的，所以对于区间查询是无法直接通过索引查询的，就需要全表扫描，即不支持范围查询 。</p></blockquote><blockquote><p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p></blockquote><h3 id="为什么不用二叉树方式："><a href="#为什么不用二叉树方式：" class="headerlink" title="为什么不用二叉树方式："></a>为什么不用二叉树方式：</h3><blockquote><p><strong>树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</strong></p></blockquote><h3 id="什么不用红黑树"><a href="#什么不用红黑树" class="headerlink" title="什么不用红黑树"></a>什么不用红黑树</h3><blockquote><p><strong>树的高度随着数据量增加而增加，IO代价高。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入</strong>。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>掌握JavaStream流操作</title>
    <link href="/blog/2021/07/03/%E6%8E%8C%E6%8F%A1JavaStream%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <url>/blog/2021/07/03/%E6%8E%8C%E6%8F%A1JavaStream%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p><code>Stream</code>将要处理的元素集合看作一种流，在流的过程中，借助<code>Stream API</code>对流中的元素进行操作，比如：筛选、排序、聚合等。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ee19bebe5294d5386518b2a6397cd50~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210701194245361"></p><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Stream` 的操作符大体上分为两种：`中间操作符`和`终止操作符<br></code></pre></td></tr></table></figure></blockquote><h2 id="中间操作符"><a href="#中间操作符" class="headerlink" title="中间操作符"></a>中间操作符</h2><p><strong>对于数据流来说，中间操作符在执行制定处理程序后，数据流依然可以传递给下一级的操作符。</strong></p><p><strong>中间操作符包含8种(排除了parallel,sequential，这两个操作并不涉及到对数据流的加工操作)：</strong></p><ol><li>map(mapToInt,mapToLong,mapToDouble) 转换操作符，把比如A-&gt;B，这里默认提供了转int，long，double的操作符。</li><li>flatmap(flatmapToInt,flatmapToLong,flatmapToDouble) 拍平操作比如把 int[]{2,3,4} 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。</li><li>limit 限流操作，比如数据流中有10个 我只要出前3个就可以使用。</li><li>distint 去重操作，对重复元素去重，底层使用了equals方法。</li><li>filter 过滤操作，把不想要的数据过滤。</li><li>peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。</li><li>skip 跳过操作，跳过某些元素。</li><li>sorted(unordered) 排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。</li></ol><h2 id="终止操作符"><a href="#终止操作符" class="headerlink" title="终止操作符"></a>终止操作符</h2><p><strong>数据经过中间加工操作，就轮到终止操作符上场了；</strong></p><p><strong>终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。</strong></p><ol><li>collect 收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的Collectors 提供了非常多收集器，可以说Stream 的核心在于Collectors。</li><li>count 统计操作，统计最终的数据个数。</li><li>findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为Optional。</li><li>noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值。</li><li>min、max 最值操作，需要自定义比较器，返回数据流中最大最小的值。</li><li>reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。</li><li>forEach、forEachOrdered 遍历操作，这里就是对最终的数据进行消费了。</li><li>toArray 数组操作，将数据流的元素转换成数组。</li></ol><h2 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h2><p>1、通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-comment">// 创建一个顺序流</span><br>Stream&lt;String&gt; stream = list.stream();<br><span class="hljs-comment">// 创建一个并行流</span><br>Stream&lt;String&gt; parallelStream = list.parallelStream();<br><br></code></pre></td></tr></table></figure><p>2、使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] array=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br>IntStream stream = Arrays.stream(array);<br><br></code></pre></td></tr></table></figure><p>3、使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><br>Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">3</span>).limit(<span class="hljs-number">4</span>);<br>stream2.forEach(System.out::println); <span class="hljs-comment">// 0 3 6 9</span><br><br>Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="hljs-number">3</span>);<br>stream3.forEach(System.out::println);<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">9</span><br><span class="hljs-number">0.8106623442686114</span><br><span class="hljs-number">0.11554643727388458</span><br><span class="hljs-number">0.1404645961428974</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><blockquote><p><code>stream</code>和<code>parallelStream</code>的简单区分：</p></blockquote><p><code>stream</code>是顺序流，由主线程按顺序对流执行操作； <code>parallelStream</code>是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。</p><p>例如筛选集合中的奇数，两者的处理不同之处：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/840f813b60f84a12ac2add0bfa9a2919~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210701230623951"></p><h2 id="Stream使用"><a href="#Stream使用" class="headerlink" title="Stream使用"></a>Stream使用</h2><h3 id="遍历-匹配（foreach-find-match）"><a href="#遍历-匹配（foreach-find-match）" class="headerlink" title="遍历/匹配（foreach/find/match）"></a>遍历/匹配（foreach/find/match）</h3><p><code>Stream</code>也是支持类似集合的遍历和匹配元素的，只是<code>Stream</code>中的元素是以<code>Optional</code>类型存在的。<code>Stream</code>的遍历、匹配非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 遍历输出符合条件的元素</span><br>        list.stream().filter(x -&gt; x &gt; <span class="hljs-number">6</span>).forEach(System.out::println);<br>        <span class="hljs-comment">// 匹配第一个</span><br>        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; <span class="hljs-number">6</span>).findFirst();<br>        <span class="hljs-comment">// 匹配任意（适用于并行流）</span><br>        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; <span class="hljs-number">6</span>).findAny();<br>        <span class="hljs-comment">// 是否包含符合特定条件的元素</span><br>        <span class="hljs-keyword">boolean</span> anyMatch = list.stream().anyMatch(x -&gt; x &lt; <span class="hljs-number">6</span>);<br>        System.out.println(<span class="hljs-string">&quot;匹配第一个值：&quot;</span> + findFirst.get());<br>        System.out.println(<span class="hljs-string">&quot;匹配任意一个值：&quot;</span> + findAny.get());<br>        System.out.println(<span class="hljs-string">&quot;是否存在大于6的值：&quot;</span> + anyMatch);<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">7</span><br><span class="hljs-number">9</span><br><span class="hljs-number">8</span><br>匹配第一个值：<span class="hljs-number">7</span><br>匹配任意一个值：<span class="hljs-number">8</span><br>是否存在大于<span class="hljs-number">6</span>的值：true<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="筛选（filter）"><a href="#筛选（filter）" class="headerlink" title="筛选（filter）"></a>筛选（filter）</h3><p>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p><p><strong>筛选出<code>Integer</code>集合中大于7的元素，并打印出来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>);<br>        Stream&lt;Integer&gt; stream = list.stream();<br>        stream.filter(x -&gt; x &gt; <span class="hljs-number">7</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="聚合（max-min-count"><a href="#聚合（max-min-count" class="headerlink" title="聚合（max/min/count)"></a>聚合（max/min/count)</h3><p><code>max</code>、<code>min</code>、<code>count</code>这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p><p><strong>案例一：获取<code>String</code>集合中最长的元素。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;adnm&quot;</span>, <span class="hljs-string">&quot;admmt&quot;</span>, <span class="hljs-string">&quot;pot&quot;</span>, <span class="hljs-string">&quot;xbangd&quot;</span>, <span class="hljs-string">&quot;weoujgsd&quot;</span>);<br>        Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));<br>        System.out.println(<span class="hljs-string">&quot;最长的字符串：&quot;</span> + max.get());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">最长的字符串：weoujgsd<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p><strong>案例二：获取<code>Integer</code>集合中的最大值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 自然排序</span><br>        Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);<br>        <span class="hljs-comment">// 自定义排序</span><br>        Optional&lt;Integer&gt; max2 = list.stream().max(<span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;自然排序的最大值：&quot;</span> + max.get());<br>        System.out.println(<span class="hljs-string">&quot;自定义排序的最大值：&quot;</span> + max2.get());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">自然排序的最大值：<span class="hljs-number">11</span><br>自定义排序的最大值：<span class="hljs-number">11</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p><strong>案例三：计算<code>Integer</code>集合中大于6的元素的个数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">9</span>);<br>        <span class="hljs-keyword">long</span> count = list.stream().filter(x -&gt; x &gt; <span class="hljs-number">6</span>).count();<br>        System.out.println(<span class="hljs-string">&quot;list中大于6的元素个数：&quot;</span> + count);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">list中大于<span class="hljs-number">6</span>的元素个数：<span class="hljs-number">4</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="映射-map-flatMap"><a href="#映射-map-flatMap" class="headerlink" title="映射(map/flatMap)"></a>映射(map/flatMap)</h3><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为<code>map</code>和<code>flatMap</code>：</p><ul><li><code>map</code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li><li><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li></ul><p><strong>案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] strArr = &#123; <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;bcdd&quot;</span>, <span class="hljs-string">&quot;defde&quot;</span>, <span class="hljs-string">&quot;fTr&quot;</span> &#125;;<br>        List&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;每个元素大写：&quot;</span> + strList);<br>        List&lt;Integer&gt; intList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>);<br>        List&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + <span class="hljs-number">3</span>).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;每个元素+3：&quot;</span> + intListNew);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">每个元素大写：[ABCD, BCDD, DEFDE, FTR]<br>每个元素+<span class="hljs-number">3</span>：[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p><strong>案例二：将两个字符数组合并成一个新的字符数组。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;m,k,l,a&quot;</span>, <span class="hljs-string">&quot;1,3,5,7&quot;</span>);<br>        List&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;<br>            <span class="hljs-comment">// 将每个元素转换成一个stream</span><br>            String[] split = s.split(<span class="hljs-string">&quot;,&quot;</span>);<br>            Stream&lt;String&gt; s2 = Arrays.stream(split);<br>            <span class="hljs-keyword">return</span> s2;<br>        &#125;).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;处理前的集合：&quot;</span> + list);<br>        System.out.println(<span class="hljs-string">&quot;处理后的集合：&quot;</span> + listNew);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">处理前的集合：[m,k,l,a, <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br>处理后的集合：[m, k, l, a, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="归约-reduce"><a href="#归约-reduce" class="headerlink" title="归约(reduce)"></a>归约(reduce)</h3><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p><p><strong>案例一：求<code>Integer</code>集合的元素之和、乘积和最大值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>);<br>        <span class="hljs-comment">// 求和方式1</span><br>        Optional&lt;Integer&gt; sum = list.stream().reduce(Integer::sum);<br>        <span class="hljs-comment">// 求和方式2</span><br>        Optional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);<br>        <span class="hljs-comment">// 求和方式3</span><br>        Integer sum3 = list.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<br>        <span class="hljs-comment">// 求乘积</span><br>        Optional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);<br>        <span class="hljs-comment">// 求最大值方式1</span><br>        Optional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);<br>        <span class="hljs-comment">// 求最大值写法2</span><br>        Integer max2 = list.stream().reduce(<span class="hljs-number">1</span>, Integer::max);<br>        System.out.println(<span class="hljs-string">&quot;list求和：&quot;</span> + sum.get() + <span class="hljs-string">&quot;,&quot;</span> + sum2.get() + <span class="hljs-string">&quot;,&quot;</span> + sum3);<br>        System.out.println(<span class="hljs-string">&quot;list求积：&quot;</span> + product.get());<br>        System.out.println(<span class="hljs-string">&quot;list求和：&quot;</span> + max.get() + <span class="hljs-string">&quot;,&quot;</span> + max2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">list求和：<span class="hljs-number">29</span>,<span class="hljs-number">29</span>,<span class="hljs-number">29</span><br>list求积：<span class="hljs-number">2112</span><br>list求和：<span class="hljs-number">11</span>,<span class="hljs-number">11</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="归集-toList-toSet-toMap"><a href="#归集-toList-toSet-toMap" class="headerlink" title="归集(toList/toSet/toMap)"></a>归集(toList/toSet/toMap)</h3><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。<code>toList</code>、<code>toSet</code>和<code>toMap</code>比较常用，另外还有<code>toCollection</code>、<code>toConcurrentMap</code>等复杂一些的用法。</p><p>下面用一个案例演示<code>toList</code>、<code>toSet</code>和<code>toMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// 姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> salary; <span class="hljs-comment">// 薪资</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 年龄</span><br>    <span class="hljs-keyword">private</span> String sex; <span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">private</span> String area;  <span class="hljs-comment">// 地区</span><br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> salary, <span class="hljs-keyword">int</span> age,String sex,String area)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>        <span class="hljs-keyword">this</span>.area = area;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setArea</span><span class="hljs-params">(String area)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.area = area;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, salary=&quot;</span> + salary +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, area=&#x27;&quot;</span> + area + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">20</span>);<br>        List&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect(Collectors.toList());<br>        Set&lt;Integer&gt; set = list.stream().filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect(Collectors.toSet());<br>        List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">8900</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">7800</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Anni&quot;</span>, <span class="hljs-number">8200</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        Map&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; <span class="hljs-number">8000</span>)<br>                .collect(Collectors.toMap(Person::getName, p -&gt; p));<br>        System.out.println(<span class="hljs-string">&quot;toList:&quot;</span> + listNew);<br>        System.out.println(<span class="hljs-string">&quot;toSet:&quot;</span> + set);<br>        System.out.println(<span class="hljs-string">&quot;toMap:&quot;</span> + map);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">toList:[6, 4, 6, 6, 20]<br>toSet:[4, 20, 6]<br>toMap:&#123;<span class="hljs-attribute">Tom</span>=Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attribute">salary</span>=8900, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;, <span class="hljs-attribute">Anni</span>=Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Anni&#x27;</span>, <span class="hljs-attribute">salary</span>=8200, <span class="hljs-attribute">age</span>=24, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;&#125;<br><br>Process finished with exit code 0<br><br></code></pre></td></tr></table></figure><h3 id="统计-count-averaging"><a href="#统计-count-averaging" class="headerlink" title="统计(count/averaging)"></a>统计(count/averaging)</h3><p><code>Collectors</code>提供了一系列用于数据统计的静态方法：</p><ul><li>计数：<code>count</code></li><li>平均值：<code>averagingInt</code>、<code>averagingLong</code>、<code>averagingDouble</code></li><li>最值：<code>maxBy</code>、<code>minBy</code></li><li>求和：<code>summingInt</code>、<code>summingLong</code>、<code>summingDouble</code></li><li>统计以上所有：<code>summarizingInt</code>、<code>summarizingLong</code>、<code>summarizingDouble</code></li></ul><p><strong>案例：统计员工人数、平均工资、工资总额、最高工资。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">8900</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">7800</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        <span class="hljs-comment">// 求总数</span><br>        <span class="hljs-keyword">long</span> count = personList.size();<br>        <span class="hljs-comment">// 求平均工资</span><br>        Double average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));<br>        <span class="hljs-comment">// 求最高工资</span><br>        Optional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).max(Integer::compare);<br>        <span class="hljs-comment">// 求工资之和</span><br>        <span class="hljs-keyword">int</span> sum = personList.stream().mapToInt(Person::getSalary).sum();<br>        <span class="hljs-comment">// 一次性统计所有信息</span><br>        DoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));<br>        System.out.println(<span class="hljs-string">&quot;员工总数：&quot;</span> + count);<br>        System.out.println(<span class="hljs-string">&quot;员工平均工资：&quot;</span> + average);<br>        System.out.println(<span class="hljs-string">&quot;员工最高工资：&quot;</span> + max.get());<br>        System.out.println(<span class="hljs-string">&quot;员工工资总和：&quot;</span> + sum);<br>        System.out.println(<span class="hljs-string">&quot;员工工资所有统计：&quot;</span> + collect);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">员工总数：<span class="hljs-number">3</span><br>员工平均工资：<span class="hljs-number">7900.0</span><br>员工最高工资：<span class="hljs-number">8900</span><br>员工工资总和：<span class="hljs-number">23700</span><br>员工工资所有统计：DoubleSummaryStatistics&#123;count=<span class="hljs-number">3</span>, sum=<span class="hljs-number">23700.000000</span>, min=<span class="hljs-number">7000.000000</span>, average=<span class="hljs-number">7900.000000</span>, max=<span class="hljs-number">8900.000000</span>&#125;<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="分组-partitioningBy-groupingBy"><a href="#分组-partitioningBy-groupingBy" class="headerlink" title="分组(partitioningBy/groupingBy)"></a>分组(partitioningBy/groupingBy)</h3><ul><li>分区：将<code>stream</code>按条件分为两个<code>Map</code>，比如员工按薪资是否高于8000分为两部分。</li><li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</li></ul><p><strong>案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">8900</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">7800</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Anni&quot;</span>, <span class="hljs-number">8200</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        <span class="hljs-comment">// 将员工按薪资是否高于8000分组</span><br>        Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; <span class="hljs-number">8000</span>));<br>        <span class="hljs-comment">// 将员工按性别分组</span><br>        Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));<br>        <span class="hljs-comment">// 将员工先按性别分组，再按地区分组</span><br>        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));<br>        System.out.println(<span class="hljs-string">&quot;员工按薪资是否大于8000分组情况：&quot;</span> + part);<br>        System.out.println(<span class="hljs-string">&quot;员工按性别分组情况：&quot;</span> + group);<br>        System.out.println(<span class="hljs-string">&quot;员工按性别、地区：&quot;</span> + group2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">员工按薪资是否大于8000分组情况：&#123;<span class="hljs-literal">false</span>=[Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-attribute">salary</span>=7000, <span class="hljs-attribute">age</span>=25, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;Washington&#x27;</span>&#125;, Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-attribute">salary</span>=7800, <span class="hljs-attribute">age</span>=21, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;], <span class="hljs-literal">true</span>=[Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attribute">salary</span>=8900, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;Washington&#x27;</span>&#125;, Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Anni&#x27;</span>, <span class="hljs-attribute">salary</span>=8200, <span class="hljs-attribute">age</span>=24, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;]&#125;<br>员工按性别分组情况：&#123;female=[Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-attribute">salary</span>=7800, <span class="hljs-attribute">age</span>=21, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;, Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Anni&#x27;</span>, <span class="hljs-attribute">salary</span>=8200, <span class="hljs-attribute">age</span>=24, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;], male=[Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attribute">salary</span>=8900, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;Washington&#x27;</span>&#125;, Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-attribute">salary</span>=7000, <span class="hljs-attribute">age</span>=25, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;Washington&#x27;</span>&#125;]&#125;<br>员工按性别、地区：&#123;female=&#123;New York=[Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-attribute">salary</span>=7800, <span class="hljs-attribute">age</span>=21, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;, Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Anni&#x27;</span>, <span class="hljs-attribute">salary</span>=8200, <span class="hljs-attribute">age</span>=24, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;New York&#x27;</span>&#125;]&#125;, male=&#123;Washington=[Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attribute">salary</span>=8900, <span class="hljs-attribute">age</span>=23, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;Washington&#x27;</span>&#125;, Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-attribute">salary</span>=7000, <span class="hljs-attribute">age</span>=25, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;Washington&#x27;</span>&#125;]&#125;&#125;<br><br>Process finished with exit code 0<br><br></code></pre></td></tr></table></figure><h3 id="接合-joining"><a href="#接合-joining" class="headerlink" title="接合(joining)"></a>接合(joining)</h3><p><code>joining</code>可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">8900</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">7800</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        String names = personList.stream().map(Person::getName).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;所有员工的姓名：&quot;</span> + names);<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>        String string = list.stream().collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;拼接后的字符串：&quot;</span> + string);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">所有员工的姓名：Tom,Jack,Lily<br>拼接后的字符串：A-B-C<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="排序-sorted"><a href="#排序-sorted" class="headerlink" title="排序(sorted)"></a>排序(sorted)</h3><p><code>sorted</code>，中间操作。有两种排序：</p><ul><li><code>sorted()</code>：自然排序，流中元素需实现<code>Comparable</code>接口</li><li><code>sorted(Comparator com)</code>：<code>Comparator</code>排序器自定义排序</li></ul><p><strong>案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Sherry&quot;</span>, <span class="hljs-number">9000</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">8900</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">9000</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Washington&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">8800</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alisa&quot;</span>, <span class="hljs-number">9000</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>));<br>        <span class="hljs-comment">// 按工资升序排序（自然排序）</span><br>        List&lt;String&gt; newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)<br>                .collect(Collectors.toList());<br>        <span class="hljs-comment">// 按工资倒序排序</span><br>        List&lt;String&gt; newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())<br>                .map(Person::getName).collect(Collectors.toList());<br>        <span class="hljs-comment">// 先按工资再按年龄升序排序</span><br>        List&lt;String&gt; newList3 = personList.stream()<br>                .sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)<br>                .collect(Collectors.toList());<br>        <span class="hljs-comment">// 先按工资再按年龄自定义排序（降序）</span><br>        List&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (p1.getSalary() == p2.getSalary()) &#123;<br>                <span class="hljs-keyword">return</span> p2.getAge() - p1.getAge();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> p2.getSalary() - p1.getSalary();<br>            &#125;<br>        &#125;).map(Person::getName).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;按工资升序排序：&quot;</span> + newList);<br>        System.out.println(<span class="hljs-string">&quot;按工资降序排序：&quot;</span> + newList2);<br>        System.out.println(<span class="hljs-string">&quot;先按工资再按年龄升序排序：&quot;</span> + newList3);<br>        System.out.println(<span class="hljs-string">&quot;先按工资再按年龄自定义降序排序：&quot;</span> + newList4);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]<br>按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]<br>先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]<br>先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="提取-组合"><a href="#提取-组合" class="headerlink" title="提取/组合"></a>提取/组合</h3><p>流也可以进行合并、去重、限制、跳过等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] arr1 = &#123; <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span> &#125;;<br>        String[] arr2 = &#123; <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;g&quot;</span> &#125;;<br>        Stream&lt;String&gt; stream1 = Stream.of(arr1);<br>        Stream&lt;String&gt; stream2 = Stream.of(arr2);<br>        <span class="hljs-comment">// concat:合并两个流 distinct：去重</span><br>        List&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());<br>        <span class="hljs-comment">// limit：限制从流中获得前n个数据</span><br>        List&lt;Integer&gt; collect = Stream.iterate(<span class="hljs-number">1</span>, x -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).collect(Collectors.toList());<br>        <span class="hljs-comment">// skip：跳过前n个数据</span><br>        List&lt;Integer&gt; collect2 = Stream.iterate(<span class="hljs-number">1</span>, x -&gt; x + <span class="hljs-number">2</span>).skip(<span class="hljs-number">1</span>).limit(<span class="hljs-number">5</span>).collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;流合并：&quot;</span> + newList);<br>        System.out.println(<span class="hljs-string">&quot;limit：&quot;</span> + collect);<br>        System.out.println(<span class="hljs-string">&quot;skip：&quot;</span> + collect2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">流合并：[a, b, c, d, e, f, g]<br>limit：[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>]<br>skip：[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>]<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h3><p>stream api 的强大之处还不仅仅是对集合进行各种组合操作，还支持分页操作。</p><p>例如，将如下的数组从小到大进行排序，排序完成之后，从第1行开始，查询10条数据出来，操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//需要查询的数据</span><br>List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">100</span>);<br>List&lt;Integer&gt; dataList = numbers.stream().sorted(Integer::compareTo).skip(<span class="hljs-number">0</span>).limit(<span class="hljs-number">10</span>).collect(Collectors.toList());<br>System.out.println(dataList.toString());<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="并行操作"><a href="#并行操作" class="headerlink" title="并行操作"></a>并行操作</h3><p>所谓并行，指的是多个任务在同一时间点发生，并由不同的cpu进行处理，不互相抢占资源；而并发，指的是多个任务在同一时间点内同时发生了，但由同一个cpu进行处理，互相抢占资源。</p><p>stream api 的并行操作和串行操作，只有一个方法区别，其他都一样，例如下面我们使用parallelStream来输出空字符串的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br><span class="hljs-comment">// 采用并行计算方法，获取空字符串的数量</span><br><span class="hljs-keyword">long</span> count = strings.parallelStream().filter(String::isEmpty).count();<br>System.out.println(count);<br><br></code></pre></td></tr></table></figure><p><strong>在实际使用的时候，<code>并行操作</code>不一定比<code>串行操作</code>快！对于简单操作，数量非常大，同时服务器是多核的话，建议使用Stream并行！反之，采用串行操作更可靠！</strong></p><h3 id="集合转Map操作"><a href="#集合转Map操作" class="headerlink" title="集合转Map操作"></a>集合转Map操作</h3><p>在实际的开发过程中，还有一个使用最频繁的操作就是，将集合元素中某个主键字段作为key，元素作为value，来实现集合转map的需求，这种需求在数据组装方面使用的非常多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">7000</span>,<span class="hljs-number">25</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-string">&quot;安徽&quot;</span>));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jack&quot;</span>,<span class="hljs-number">8000</span>,<span class="hljs-number">30</span>,<span class="hljs-string">&quot;female&quot;</span>,<span class="hljs-string">&quot;北京&quot;</span>));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lucy&quot;</span>,<span class="hljs-number">9000</span>,<span class="hljs-number">40</span>,<span class="hljs-string">&quot;male&quot;</span>,<span class="hljs-string">&quot;上海&quot;</span>));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Airs&quot;</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">40</span>,<span class="hljs-string">&quot;female&quot;</span>,<span class="hljs-string">&quot;深圳&quot;</span>));<br>    Map&lt;Integer, Person&gt; collect = personList.stream().collect(Collectors.toMap(Person::getAge, v -&gt; v, (k1, k2) -&gt; k1));<br>    System.out.println(collect);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">40</span>=Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Lucy&#x27;</span>, <span class="hljs-attribute">salary</span>=9000, <span class="hljs-attribute">age</span>=40, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;上海&#x27;</span>&#125;, <span class="hljs-attribute">25</span>=Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attribute">salary</span>=7000, <span class="hljs-attribute">age</span>=25, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;安徽&#x27;</span>&#125;, <span class="hljs-attribute">30</span>=Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-attribute">salary</span>=8000, <span class="hljs-attribute">age</span>=30, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-attribute">area</span>=<span class="hljs-string">&#x27;北京&#x27;</span>&#125;&#125;<br><br>Process finished with exit code 0<br><br></code></pre></td></tr></table></figure><p>打开<code>Collectors.toMap</code>方法源码，一起来看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U&gt;<br>    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; keyMapper,<br>                                    Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; valueMapper,<br>                                    BinaryOperator&lt;U&gt; mergeFunction) &#123;<br>    <span class="hljs-keyword">return</span> toMap(keyMapper, valueMapper, mergeFunction, HashMap::<span class="hljs-keyword">new</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从参数表可以看出：</p><ul><li>第一个参数：表示 key</li><li>第二个参数：表示 value</li><li>第三个参数：表示某种规则</li></ul><p>上文中的<code>Collectors.toMap(Person::getAge, v -&gt; v, (k1,k2) -&gt; k1)</code>，表达的意思就是将<code>age</code>的内容作为<code>key</code>，<code>v -&gt; v</code>是表示将元素<code>person</code>作为<code>value</code>，其中<code>(k1,k2) -&gt; k1</code>表示如果存在相同的<code>key</code>，将第一个匹配的元素作为内容，第二个舍弃！</p>]]></content>
    
    
    
    <tags>
      
      <tag>1.8</tag>
      
      <tag>JavaStream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>书写高质量SQL的30条建议</title>
    <link href="/blog/2021/07/02/%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%8430%E6%9D%A1%E5%BB%BA%E8%AE%AE/"/>
    <url>/blog/2021/07/02/%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%8430%E6%9D%A1%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h5 id="1、查询SQL尽量不要使用select-，而是select具体字段。"><a href="#1、查询SQL尽量不要使用select-，而是select具体字段。" class="headerlink" title="1、查询SQL尽量不要使用select *，而是select具体字段。"></a>1、查询SQL尽量不要使用select *，而是select具体字段。</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">- 反例子：<br>- <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employee;<br>- 正例子：<br>- <span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee;<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>只取需要的字段，节省资源、减少网络开销。 select * 进行查询时，很可能就<strong>不会使用到覆盖索引</strong>了，就会造成回表查询。</p><h5 id="2、如果知道查询结果只有一条或者只要最大-最小一条记录，建议用limit-1"><a href="#2、如果知道查询结果只有一条或者只要最大-最小一条记录，建议用limit-1" class="headerlink" title="2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1"></a>2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1</h5><p>假设现在有employee员工表，要找出一个名字叫jay的人.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`employee`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`date`</span> datetime DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`sex`</span> int(<span class="hljs-number">1</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>反例：<br><span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name=<span class="hljs-string">&#x27;jay&#x27;</span><br>正例<br><span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name=<span class="hljs-string">&#x27;jay&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。 当然，<strong>如果name是唯一索引的话，是不必要加上limit 1了</strong>，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</p><h5 id="3、应尽量避免在where子句中使用or来连接条件"><a href="#3、应尽量避免在where子句中使用or来连接条件" class="headerlink" title="3、应尽量避免在where子句中使用or来连接条件"></a>3、应尽量避免在where子句中使用or来连接条件</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">新建一个user表，它有一个普通索引userId，表结构如下：<br><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`userId`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_userId`</span> (<span class="hljs-symbol">`userId`</span>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>假设现在需要查询userid为1或者年龄为18岁的用户，很容易有以下sql<br><br>反例:<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> age =<span class="hljs-number">18</span><br><br>正例：<br>//使用<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">1</span> <br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age = <span class="hljs-number">18</span><br><br>//或者分开两条sql写：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age = <span class="hljs-number">18</span><br><br></code></pre></td></tr></table></figure><p>理由：</p><p><strong>使用or可能会使索引失效，从而全表扫描。</strong></p><p>对于or+没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程：全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。</p><h5 id="4、优化limit分页"><a href="#4、优化limit分页" class="headerlink" title="4、优化limit分页"></a>4、优化limit分页</h5><p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br><span class="hljs-keyword">select</span> id，<span class="hljs-type">name</span>，age <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">limit</span> <span class="hljs-number">10000</span>，<span class="hljs-number">10</span><br><br>正例：<br>//方案一 ：返回上次查询的最大记录(偏移量)<br><span class="hljs-keyword">select</span> id，<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> id&gt;<span class="hljs-number">10000</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">10.</span><br><br>//方案二：<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> + 索引<br><span class="hljs-keyword">select</span> id，<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id  <span class="hljs-keyword">limit</span> <span class="hljs-number">10000</span>，<span class="hljs-number">10</span><br><br>//方案三：在业务允许的情况下限制页数：<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。 如果使用优化方案一，返回上次最大查询记录（偏移量），这样可以跳过偏移量，效率提升不少。 方案二使用order by+索引，也是可以提高查询效率的。 方案三的话，建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</p><h5 id="5、优化你的like语句"><a href="#5、优化你的like语句" class="headerlink" title="5、优化你的like语句"></a>5、优化你的like语句</h5><p>日常开发中，如果用到模糊关键字查询，很容易想到like，但是like很可能让你的索引失效。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">select</span> userId，name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123&#x27;</span>;<br><br>正例：<br><span class="hljs-keyword">select</span> userId，name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;123%&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>把%放前面，并不走索引，如下： <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4037e6e8362e4d1da2e3cef51aba7206~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 把% 放关键字后面，还是会走索引的。如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c89a3a301045d3a0fa13b7c36e1952~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="6、使用where条件限定要查询的数据，避免返回多余的行"><a href="#6、使用where条件限定要查询的数据，避免返回多余的行" class="headerlink" title="6、使用where条件限定要查询的数据，避免返回多余的行"></a>6、使用where条件限定要查询的数据，避免返回多余的行</h5><p>假设业务场景是这样：查询某个用户是否是会员。曾经看过老的实现代码是这样。。。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br>List&lt;Long&gt; userIds = sqlMap.queryList(&quot;<span class="hljs-keyword">select</span> userId <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> isVip=<span class="hljs-number">1</span><span class="hljs-string">&quot;);</span><br><span class="hljs-string">boolean isVip = userIds.contains(userId);</span><br><span class="hljs-string"></span><br><span class="hljs-string">正例：</span><br><span class="hljs-string">Long userId = sqlMap.queryObject(&quot;</span><span class="hljs-keyword">select</span> userId <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId=<span class="hljs-string">&#x27;userId&#x27;</span> <span class="hljs-keyword">and</span> isVip=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-string">&quot;)</span><br><span class="hljs-string">boolean isVip = userId！=null;</span><br></code></pre></td></tr></table></figure><p>理由：</p><p>需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。</p><h5 id="7、尽量避免在索引列上使用mysql的内置函数"><a href="#7、尽量避免在索引列上使用mysql的内置函数" class="headerlink" title="7、尽量避免在索引列上使用mysql的内置函数"></a>7、尽量避免在索引列上使用mysql的内置函数</h5><p>业务需求：查询最近七天内登陆过的用户(假设loginTime加了索引)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br><span class="hljs-keyword">select</span> userId,loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span> Date_ADD(loginTime,<span class="hljs-type">Interval</span> <span class="hljs-number">7</span> DAY) &gt;=now();<br><br>正例：<br><span class="hljs-keyword">explain</span>  <span class="hljs-keyword">select</span> userId,loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span>  loginTime &gt;= Date_ADD(NOW(),<span class="hljs-type">INTERVAL</span> - <span class="hljs-number">7</span> DAY);<br></code></pre></td></tr></table></figure><p>理由：</p><p>索引列上使用mysql的内置函数，索引失效 <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8587ecefb8174d14a86ee1056e279a1e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> img 如果索引列不加内置函数，索引还是会走的。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91009e602de94d5e9dcf5a667c8f70b4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="8、应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"><a href="#8、应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫" class="headerlink" title="8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"></a>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age<span class="hljs-number">-1</span> =<span class="hljs-number">10</span>；<br><br>正例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age =<span class="hljs-number">11</span>；<br></code></pre></td></tr></table></figure><p>理由：</p><p>虽然age加了索引，但是因为对它进行运算，索引直接迷路了。。。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3b42b76819467c8a418a74fe96ea4f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="9、Inner-join-、left-join、right-join，优先使用Inner-join，如果是left-join，左边表结果尽量小"><a href="#9、Inner-join-、left-join、right-join，优先使用Inner-join，如果是left-join，左边表结果尽量小" class="headerlink" title="9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小"></a>9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</h5><ul><li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul><p>都满足SQL需求的前提下，推荐优先使用Inner join（内连接），如果要使用left join，左边表数据结果尽量小，如果有条件的尽量放到左边处理。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例:<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tab1 t1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tab2 t2  <span class="hljs-keyword">on</span> t1.size = t2.size <span class="hljs-keyword">where</span> t1.id&gt;<span class="hljs-number">2</span>;<br><br>正例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tab1 <span class="hljs-keyword">where</span> id &gt;<span class="hljs-number">2</span>) t1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tab2 t2 <span class="hljs-keyword">on</span> t1.size = t2.size;<br></code></pre></td></tr></table></figure><p>理由：</p><p>如果inner join是等值连接，或许返回的行数比较少，所以性能相对会好一点。 同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。</p><h5 id="10、应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。"><a href="#10、应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。" class="headerlink" title="10、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。"></a>10、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br><span class="hljs-keyword">select</span> age,<span class="hljs-type">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &lt;&gt;<span class="hljs-number">18</span>;<br><br>正例：<br>//可以考虑分开两条<span class="hljs-keyword">sql</span>写<br><span class="hljs-keyword">select</span> age,<span class="hljs-type">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &lt;<span class="hljs-number">18</span>;<br><span class="hljs-keyword">select</span> age,<span class="hljs-type">name</span>  <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age &gt;<span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><p>理由：</p><p>使用!=和&lt;&gt;很可能会让索引失效</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c3e00b57e6e46f88c4cc250e14783be~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。"><a href="#11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。" class="headerlink" title="11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。"></a>11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</h5><p>表结构：（有一个联合索引idx_userid_age，userId在前，age在后）</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`user`</span> (<br>  <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br>  <span class="hljs-symbol">`userId`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br>  <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`idx_userid_age`</span> (<span class="hljs-symbol">`userId`</span>,<span class="hljs-symbol">`age`</span>) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">2</span> DEFAULT CHARSET=utf8;<br><br>反例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age = <span class="hljs-number">10</span>;<br><br>正例：<br>//符合最左匹配原则<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">10</span> <span class="hljs-keyword">and</span> age =<span class="hljs-number">10</span>；<br>//符合最左匹配原则<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid =<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa4bfa71c8d84d10b9fe5eb5f950c410~tplv-k3u1fbpfcp-watermark.image" alt="image.png"> 理由：</p><p>当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。 联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。</p><h5 id="12、对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描。"><a href="#12、对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描。" class="headerlink" title="12、对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。"></a>12、对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> address =<span class="hljs-string">&#x27;深圳&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age ;<br><br>正例：<br>添加索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">index</span> idx_address_age (address,age)<br></code></pre></td></tr></table></figure><h5 id="13、如果插入数据过多，考虑批量插入。"><a href="#13、如果插入数据过多，考虑批量插入。" class="headerlink" title="13、如果插入数据过多，考虑批量插入。"></a>13、如果插入数据过多，考虑批量插入。</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">User</span> u :list)&#123;<br> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>,age) <span class="hljs-keyword">values</span>(#<span class="hljs-type">name</span>#,#age#)   <br>&#125;<br><br>正例：<br>//一次<span class="hljs-number">500</span>批量插入，分批进行<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(<span class="hljs-type">name</span>,age) <span class="hljs-keyword">values</span><br>&lt;<span class="hljs-keyword">foreach</span> collection=&quot;list&quot; item=&quot;item&quot; <span class="hljs-keyword">index</span>=&quot;index&quot; separator=&quot;,&quot;&gt;<br>    (#&#123;item.name&#125;,#&#123;item.age&#125;)<br>&lt;/<span class="hljs-keyword">foreach</span>&gt;<br></code></pre></td></tr></table></figure><p>理由：</p><p>批量插入性能好，更加省时间 打个比喻:假如你需要搬一万块砖到楼顶,你有一个电梯,电梯一次可以放适量的砖（最多放500）,你可以选择一次运送一块砖,也可以一次运送500,你觉得哪个时间消耗大?</p><h5 id="14、在适当的时候，使用覆盖索引。"><a href="#14、在适当的时候，使用覆盖索引。" class="headerlink" title="14、在适当的时候，使用覆盖索引。"></a>14、在适当的时候，使用覆盖索引。</h5><p>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br>// like模糊查询，不走索引了<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span>;<br><br>正例：<br>//id为主键，那么为普通索引，即覆盖索引登场了。<br><span class="hljs-keyword">select</span> id,name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="15、慎用distinct关键字"><a href="#15、慎用distinct关键字" class="headerlink" title="15、慎用distinct关键字"></a>15、慎用distinct关键字</h5><p>distinct 关键字一般用来过滤重复记录，以返回不重复的记录。在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> * <span class="hljs-keyword">from</span>  <span class="hljs-keyword">user</span>;<br><br>正例：<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">DISTINCT</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p>理由：</p><p><strong>带distinct的语句cpu时间和占用时间都高于不带distinct的语句</strong>。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，过滤的过程会占用系统资源，cpu时间。</p><h5 id="16、删除冗余和重复索引"><a href="#16、删除冗余和重复索引" class="headerlink" title="16、删除冗余和重复索引"></a>16、删除冗余和重复索引</h5><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">反例：<br>  KEY `idx_userId` (`userId`)<br>  KEY `idx_userId_age` (`userId`,`age`)<br>  <br><span class="hljs-title">正例:</span><br>  //删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引<br>  KEY `idx_userId_age` (`userId`,`age`)<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能的。</p><h5 id="17、如果数据量较大，优化你的修改-删除语句。"><a href="#17、如果数据量较大，优化你的修改-删除语句。" class="headerlink" title="17、如果数据量较大，优化你的修改/删除语句。"></a>17、如果数据量较大，优化你的修改/删除语句。</h5><p>避免同时修改或删除过多数据，因为会造成cpu利用率过高，从而影响别人对数据库的访问。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br>//一次删除<span class="hljs-number">10</span>万或者<span class="hljs-number">100</span>万+？<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id &lt;<span class="hljs-number">100000</span>;<br>//或者采用单一循环操作，效率低，时间漫长<br><span class="hljs-keyword">for</span>（<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>：list）&#123;<br>   <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>；<br>&#125;<br><br>正例：<br>//分批进行删除,如每次<span class="hljs-number">500</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id&lt;<span class="hljs-number">500</span><br><span class="hljs-keyword">delete</span> product <span class="hljs-keyword">where</span> id&gt;=<span class="hljs-number">500</span> <span class="hljs-keyword">and</span> id&lt;<span class="hljs-number">1000</span>；<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>一次性删除太多数据，可能会有lock wait timeout exceed的错误，所以建议分批操作。</p><h5 id="18、where子句中考虑使用默认值代替null。"><a href="#18、where子句中考虑使用默认值代替null。" class="headerlink" title="18、where子句中考虑使用默认值代替null。"></a>18、where子句中考虑使用默认值代替null。</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;(未使用索引)<br><br>正例：<br>//设置0为默认值<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age&gt;<span class="hljs-number">0</span>;(使用索引age)<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。 如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件！=，&gt;is null，is not null经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃的。</p><p>如果<strong>把null值，换成默认值，很多时候让走索引成为可能</strong>，同时，表达意思会相对清晰一点。</p><h5 id="19、不要有超过5个以上的表连接"><a href="#19、不要有超过5个以上的表连接" class="headerlink" title="19、不要有超过5个以上的表连接"></a>19、不要有超过5个以上的表连接</h5><ul><li>连表越多，编译的时间和开销也就越大。</li><li>把连接表拆开成较小的几个执行，可读性更高。</li><li>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li></ul><h5 id="20、exist-amp-in的合理利用"><a href="#20、exist-amp-in的合理利用" class="headerlink" title="20、exist &amp; in的合理利用"></a>20、exist &amp; in的合理利用</h5><p><strong>(in 就是遍历A里面嵌套遍历B，exist就是遍历B里面嵌套遍历B)</strong></p><p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:</p><p>select * from A where deptId in (select deptId from B); 这样写等价于：</p><p>先查询部门表B</p><p>select deptId from B</p><p>再由部门deptId，查询A的员工</p><p>select * from A where A.deptId = B.deptId</p><p>可以抽象成这样的一个循环：</p><p>List&lt;&gt; resultSet ; for(int i=0;i&lt;B.length;i++) { for(int j=0;j&lt;A.length;j++) { if(A[i].id==B[j].id) { resultSet.add(A[i]); break; } } } 显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：</p><p>select * from A where exists (select 1 from B where A.deptId = B.deptId); 因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。</p><p>那么，这样写就等价于：</p><p>select * from A,先从A表做循环</p><p>select * from B where A.deptId = B.deptId,再从B表做循环.</p><p>同理，可以抽象成这样一个循环：</p><p>List&lt;&gt; resultSet ; for(int i=0;i&lt;A.length;i++) { for(int j=0;j&lt;B.length;j++) { if(A[i].deptId==B[j].deptId) { resultSet.add(A[i]); break; } } } 数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。</p><p>因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exist。</p><h5 id="21、尽量用-union-all-替换-union"><a href="#21、尽量用-union-all-替换-union" class="headerlink" title="21、尽量用 union all 替换 union"></a>21、尽量用 union all 替换 union</h5><p>如果检索结果中不会有重复的记录，推荐union all 替换 union。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">1</span> <br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age = <span class="hljs-number">10</span><br><br>正例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-number">1</span> <br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age = <span class="hljs-number">10</span><br><br></code></pre></td></tr></table></figure><p>理由：</p><p>如果使用union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。如果已知检索结果没有重复记录，使用union all 代替union，这样会提高效率。</p><h5 id="22、索引不宜太多，一般5个以内。"><a href="#22、索引不宜太多，一般5个以内。" class="headerlink" title="22、索引不宜太多，一般5个以内。"></a>22、索引不宜太多，一般5个以内。</h5><ul><li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li><li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li></ul><h5 id="23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"><a href="#23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型" class="headerlink" title="23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"></a>23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br>king_id` <span class="hljs-type">varchar</span>（<span class="hljs-number">20</span>） <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;守护者Id&#x27;</span><br><br>正例：<br>`king_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;守护者Id&#x27;</span>`<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>相对于数字型字段，字符型会降低查询和连接的性能，并会增加<strong>存储开销</strong>。</p><h5 id="24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。"><a href="#24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。" class="headerlink" title="24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。"></a>24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</h5><p>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p><h5 id="25、尽量避免向客户端返回过多数据量。"><a href="#25、尽量避免向客户端返回过多数据量。" class="headerlink" title="25、尽量避免向客户端返回过多数据量。"></a>25、尽量避免向客户端返回过多数据量。</h5><p>假设业务需求是，用户请求查看自己最近一年观看过的直播数据。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br>//一次性查询所有数据回来<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime &gt;= Date_sub(now(),<span class="hljs-type">Interval</span> <span class="hljs-number">1</span> Y)<br><br>正例：<br>//分页查询<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime&gt;= Date_sub(now(),<span class="hljs-type">Interval</span> <span class="hljs-number">1</span> Y) <span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span>，pageSize<br><br>//如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId =useId <span class="hljs-keyword">and</span> watchTime&gt;= Date_sub(now(),<span class="hljs-type">Interval</span> <span class="hljs-number">1</span> Y) <span class="hljs-keyword">limit</span> <span class="hljs-number">200</span> ;<br><br></code></pre></td></tr></table></figure><h5 id="26、当在SQL语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。"><a href="#26、当在SQL语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。" class="headerlink" title="26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。"></a>26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">select</span>  * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">inner</span><br><span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.deptId = B.deptId;<br><br>正例：<br><span class="hljs-keyword">select</span>  memeber.name,deptment.deptName <span class="hljs-keyword">from</span> A member <span class="hljs-keyword">inner</span><br><span class="hljs-keyword">join</span> B deptment <span class="hljs-keyword">on</span> member.deptId = deptment.deptId;<br><br></code></pre></td></tr></table></figure><h5 id="27、尽可能使用varchar-nvarchar-代替-char-nchar。"><a href="#27、尽可能使用varchar-nvarchar-代替-char-nchar。" class="headerlink" title="27、尽可能使用varchar/nvarchar 代替 char/nchar。"></a>27、尽可能使用varchar/nvarchar 代替 char/nchar。</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">反例：<br>  `deptName` <span class="hljs-type">char</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;部门名称&#x27;</span><br><br>正例：<br>  `deptName` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;部门名称&#x27;</span><br><br></code></pre></td></tr></table></figure><p>理由：</p><ul><li>因为首先变长字段存储空间小，可以节省存储空间。</li><li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li></ul><h5 id="28、为了提高group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。"><a href="#28、为了提高group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。" class="headerlink" title="28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。"></a>28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">select</span> job，<span class="hljs-built_in">avg</span>（salary） <span class="hljs-keyword">from</span> employee  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job <span class="hljs-keyword">having</span> job =<span class="hljs-string">&#x27;president&#x27;</span> <br><span class="hljs-keyword">or</span> job = <span class="hljs-string">&#x27;managent&#x27;</span><br><br>正例：<br><span class="hljs-keyword">select</span> job，<span class="hljs-built_in">avg</span>（salary） <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> job =<span class="hljs-string">&#x27;president&#x27;</span> <br><span class="hljs-keyword">or</span> job = <span class="hljs-string">&#x27;managent&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job；<br><br></code></pre></td></tr></table></figure><h5 id="29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效"><a href="#29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效" class="headerlink" title="29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效"></a>29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">反例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid =<span class="hljs-number">123</span>;<br><br>正例：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid =<span class="hljs-string">&#x27;123&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>理由：</p><p>为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，<strong>MySQL会做隐式的类型转换</strong>，把它们转换为浮点数再做比较。</p><h5 id="30、使用explain-分析你SQL的计划"><a href="#30、使用explain-分析你SQL的计划" class="headerlink" title="30、使用explain 分析你SQL的计划"></a>30、使用explain 分析你SQL的计划</h5><p>日常开发写SQL的时候，尽量养成一个习惯吧。用explain分析一下你写的SQL，尤其是走不走索引这一块。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid =<span class="hljs-number">10086</span> <span class="hljs-keyword">or</span> age =<span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>建议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot拦截器</title>
    <link href="/blog/2021/07/01/SpringBoot%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/blog/2021/07/01/SpringBoot%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="HandlerInterceptor-详解"><a href="#HandlerInterceptor-详解" class="headerlink" title="HandlerInterceptor 详解"></a>HandlerInterceptor 详解</h2><p><code>HandlerInterceptor</code> 允许定制 <code>handler</code> 处理器执行链的工作流接口。我们可以自定义拦截器用于拦截 handlers 处理器（你可以理解为 controller 层的接口），从而可以添加一些共同的重复性的处理行为（例如接口鉴权，接口日志记录，性能监控等），而不用修改每一个 handler 的实现。</p><p>注意，此基于 <code>SpringBoot 2.3.12.RELEASE</code> 版本讲解。</p><p>HandlerInterceptor 接口只有三个默认空实现方法，在低版本中这三个方法不是默认方法，而是抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,                 Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,                 Object handler, <span class="hljs-meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,             Object handler, <span class="hljs-meta">@Nullable</span> Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这三个方法的执行顺序图如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/542998aef2804e5ea8a072698e75530a~tplv-k3u1fbpfcp-watermark.image" alt="image-20210630225337581.png"></p><h3 id="preHandle"><a href="#preHandle" class="headerlink" title="preHandle"></a>preHandle</h3><p><code>preHandle</code> 前置处理，拦截一个处理器（handler）的执行，preHandle 方法会在 <code>HandlerMapping</code> 确定一个适当的处理器对象之后，但在 <code>HandlerAdapter</code> 调用处理器之前被调用。可以简单理解为 controller 接口被调用之前执行。</p><p>Intercepter 是链式的，就是一个接着一个执行。如果此方法返回 true，则会执行下一个拦截器或者直接执行处理器。如果此方法返回 false 或者抛出异常则终止执行链，也不再调用处理器。</p><p>注意，此方法如果不返回 true，那么 <code>postHandle</code> 和 <code>afterCompletion</code> 不会被执行。</p><p>那这个方法有什么用呢？其实可以做一些接口被调用前的预处理，例如用户权限校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chenpi;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> org.springframework.lang.Nullable;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> 用户权限验证拦截</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 陈皮</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2021/6/27</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPermissionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">            Object handler)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br><br>            HandlerMethod handlerMethod = (HandlerMethod) handler;<br><br>            <span class="hljs-comment">// 获取用户权限校验注解</span><br>            UserAuthenticate userAuthenticate =<br>                    handlerMethod.getMethod().getAnnotation(UserAuthenticate.class);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == userAuthenticate) &#123;<br>                userAuthenticate = handlerMethod.getMethod().getDeclaringClass()<br>                        .getAnnotation(UserAuthenticate.class);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (userAuthenticate != <span class="hljs-keyword">null</span> &amp;&amp; userAuthenticate.permission()) &#123;<br>                <span class="hljs-comment">// 验证用户信息</span><br>                UserContext userContext = userContextManager.getUserContext(request);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == userContext) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="postHandle"><a href="#postHandle" class="headerlink" title="postHandle"></a>postHandle</h3><p><code>postHandle</code> 后置处理，会在 <code>HandlerAdapter</code> 调用处理器之后，但在 <code>DispatcherServlet</code> 渲染视图之前被调用。可以在此对 <code>ModelAndView</code> 做一些额外的处理。可以简单理解为 controller 接口被调用之后执行。</p><p>注意，此方法在执行链中的执行顺序是倒着执行的，即先声明的拦截器后执行。</p><h3 id="afterCompletion"><a href="#afterCompletion" class="headerlink" title="afterCompletion"></a>afterCompletion</h3><p>afterCompletion 完成之后，在请求处理完之后被执行，也就是渲染完视图之后。一般用于做一些资源的清理工作，配合 preHandle 计算接口执行时间等。</p><p>注意，和 postHandle 一样，此方法在执行链中的执行顺序也是倒着执行的，即先声明的拦截器后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">                            Object handler, <span class="hljs-meta">@Nullable</span> Exception ex)</span> </span>&#123;<br>    <span class="hljs-comment">// 请求完后，清除当前线程的用户信息</span><br>    UserContextHolder.removeUserContext();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h2><p>注意，我们自定义的拦截器要通过 <code>WebMvcConfigurer</code> 的实现类进行注册，才能生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yzj.ehr.common.config;<br><br><span class="hljs-keyword">import</span> com.yzj.ehr.common.context.UserContextResolver;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-keyword">import</span> com.yzj.ehr.common.interceptor.UserPermissionInterceptor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> 注册拦截器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 陈皮</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2021/6/27</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAppConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> UserPermissionInterceptor userPermissionInterceptor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebAppConfigurer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserPermissionInterceptor userPermissionInterceptor)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userPermissionInterceptor = userPermissionInterceptor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 匹配所有接口，排除/base/test接口</span><br>        registry.addInterceptor(userPermissionInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/base/test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>拦截器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个线程OOM后其他线程还能运行吗</title>
    <link href="/blog/2021/06/30/%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8BOOM%E5%90%8E%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%BF%98%E8%83%BD%E8%BF%90%E8%A1%8C%E5%90%97/"/>
    <url>/blog/2021/06/30/%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8BOOM%E5%90%8E%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%BF%98%E8%83%BD%E8%BF%90%E8%A1%8C%E5%90%97/</url>
    
    <content type="html"><![CDATA[<p>由于面试官仅提到OOM，但 Java 的OOM又分很多类型的呀：</p><ul><li><p>堆溢出（“java.lang.OutOfMemoryError: Java heap space”）</p></li><li><p>永久代溢出（“java.lang.OutOfMemoryError:Permgen space”）</p></li><li><p>不能创建线程（“java.lang.OutOfMemoryError:Unable to create new native thread”）</p><p>OOM在《Java虚拟机规范》里，除程序计数器，虚拟机内存的其他几个运行时区域都可能发生OOM，那本文的目的是啥呢？</p></li><li><p>通过代码验证《Java虚拟机规范》中描述的各个运行时区域储存的内容</p></li><li><p>在工作中遇到实际的内存溢出异常时，能根据异常的提示信息迅速得知是哪个区域的内存溢出，知道怎样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。</p></li></ul><p>本文代码均由笔者在基于OpenJDK 8中的HotSpot虚拟机上进行过实际测试。</p><h1 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1 Java堆溢出"></a>1 Java堆溢出</h1><p>Java堆用于储存对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免GC机制清除这些对象，则随对象数量增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p><p>限制Java堆的大小20MB，不可扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX：+HeapDumpOnOutOf-MemoryError<br></code></pre></td></tr></table></figure><p>可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照。</p><h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4215c6ca1180441286ebe4ca21552578~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>报错</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37450be9f5334f329efa11bb81fded28~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> Java堆内存的OOM是实际应用中最常见的内存溢出异常场景。出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。</p><p>那既然发生了，<strong>如何解决这个内存区域的异常呢</strong>？ 一般先通过内存映像分析工具（如jprofile）对Dump出来的堆转储快照进行分析。 第一步首先确认内存中导致OOM的对象是否是必要的，即先分清楚到底是</p><ul><li>内存泄漏（Memory Leak）</li><li>还是内存溢出（Memory Overflow）</li><li>下图是使用 jprofile打开的堆转储快照文件（java_pid44526.hprof）</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a245f48bb2014aae92522856b3528ba0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>若是内存泄漏，可查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。</p><p>若不是内存泄漏，即就是内存中的对象确实都必须存活，则应：</p><ol><li>检查JVM堆参数（-Xmx与-Xms）的设置，与机器内存对比，看是否还有向上调整的空间</li><li>再检查代码是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运 行期的内存消耗</li></ol><p>以上是处理Java堆内存问题的简略思路。</p><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h2><p>JVM启动参数设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms5m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/721b77441c6b41f8bb66eee8b80c9738~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d9a482af8af4461b0dde3d47b264d9b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>JVM堆空间的变化</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df06a0bec7dc453b86a12c4a561df357~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 堆的使用大小，突然抖动！说明当一个线程抛OOM后，它所占据的内存资源会全部被释放掉，而不会影响其他线程的正常运行！ 所以一个线程溢出后，进程里的其他线程还能照常运行。 发生OOM的线程一般情况下会死亡，也就是会被终结掉，该线程持有的对象占用的heap都会被gc了，释放内存。因为发生OOM之前要进行gc，就算其他线程能够正常工作，也会因为频繁gc产生较大的影响。</p><p>堆溢出和栈溢出，结论是一样的。</p><h1 id="2-虚拟机栈-本地方法栈溢出"><a href="#2-虚拟机栈-本地方法栈溢出" class="headerlink" title="2 虚拟机栈/本地方法栈溢出"></a>2 虚拟机栈/本地方法栈溢出</h1><p>由于<strong>HotSpot JVM并不区分虚拟机栈和本地方法栈</strong>，因此HotSpot的<code>-Xoss</code>参数（设置本地方法栈的大小）虽然存在，但无任何效果，栈容量只能由<code>-Xss</code>参数设定。</p><p>关于虚拟机栈和本地方法栈，《Java虚拟机规范》描述如下异常：</p><ol><li>若线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常</li><li>若虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常</li></ol><p>《Java虚拟机规范》明确允许JVM实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是<strong>不支持扩展</strong>，所以除非在创建线程申请内存时就因无法获得足够内存而出现OOM，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError。</p><h2 id="如何验证呢？"><a href="#如何验证呢？" class="headerlink" title="如何验证呢？"></a>如何验证呢？</h2><p>做俩实验，先在单线程操作，尝试下面两种行为是否能让HotSpot OOM：</p><h3 id="使用-Xss减少栈内存容量"><a href="#使用-Xss减少栈内存容量" class="headerlink" title="使用-Xss减少栈内存容量"></a>使用<code>-Xss</code>减少栈内存容量</h3><ul><li>示例</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2f172994ef5443b9504ba7f28e7773e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>结果</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da56a60e24b4af181ff7c5e6fb46153~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 抛StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</p><p>不同版本的Java虚拟机和不同的操作系统，栈容量最小值可能会有所限制，这主要取决于操作系统内存分页大小。譬如上述方法中的参数-Xss160k可以正常用于62位macOS系统下的JDK 8，但若用于64位Windows系统下的JDK 11，则会提示栈容量最小不能低于180K，而在Linux下这个值则可能是228K，如果低于这个最小限制，HotSpot虚拟器启动时会给出如下提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">The stack size specified is too small, Specify at<br></code></pre></td></tr></table></figure><h3 id="定义大量局部变量，增大此方法帧中本地变量表的长度"><a href="#定义大量局部变量，增大此方法帧中本地变量表的长度" class="headerlink" title="定义大量局部变量，增大此方法帧中本地变量表的长度"></a>定义大量局部变量，增大此方法帧中本地变量表的长度</h3><ul><li>示例</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a664e59ed04a7b9a8d19d9e08b1f06~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>结果</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edb208cad5a94a399de700539e8c11de~tplv-k3u1fbpfcp-zoom-1.image" alt="img">所以无论是由于栈帧太或虚拟机栈容量太小，当新的栈帧内存无法分配时， HotSpot 都抛SOF。可若在允许动态扩展栈容量大小的虚拟机上，相同代码则会导致不同情况。</p><p>若测试时不限于单线程，而是不断新建线程，在HotSpot上也会产生OOM。但这样产生OOM和栈空间是否足够不存在直接的关系，主要取决于os本身内存使用状态。甚至说这种情况下，给每个线程的栈分配的内存越大，反而越容易产生OOM。 不难理解，os分配给每个进程的内存有限制，比如32位Windows的单个进程最大内存限制为2G。HotSpot提供参数可以控制Java堆和方法区这两部分的内存的最大值，那剩余的内存即为2G（os限制）减去最大堆容量，再减去最大方法区容量，由于程序计数器消耗内存很小，可忽略，若把直接内存和虚拟机进程本身耗费的内存也去掉，剩下的内存就由虚拟机栈和本地方法栈来分配了。因此为每个线程分配到的栈内存越大，可以建立的线程数量越少，建立线程时就越容易把剩下的内存耗尽：</p><ul><li>示例</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec1ae82583044026be453cf67d07374e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: unable to create native thread<br></code></pre></td></tr></table></figure><p>出现SOF时，会有明确错误堆栈可供分析，相对容易定位问题。如果使用HotSpot虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）到达1000~2000没有问题，对于正常的方法调用（包括不能做尾递归优化的递归调用），这个深度应该完全够用。但如果是建立过多线程导致的内存溢出，在不能减少线程数量或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量换取更多的线程。这种通过“减少内存”手段解决内存溢出的方式，如果没有这方面处理经验，一般比较难以想到。也是由于这种问题较为隐蔽，从 JDK 7起，以上提示信息中“unable to create native thread”后面，虚拟机会特别注明原因可能是“possibly</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#define OS_NATIVE_THREAD_CREATION_FAILED_MSG </span><br><span class="hljs-string">&quot;unable to create native thread: possibly out of memory or process/resource limits reached&quot;</span><br></code></pre></td></tr></table></figure><h1 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3 方法区和运行时常量池溢出"></a>3 方法区和运行时常量池溢出</h1><p>运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起。</p><p>HotSpot从JDK 7开始逐步“去永久代”，在JDK 8中完全使用元空间代替永久代，那么方法区使用“永久代”还是“元空间”来实现，对程序有何影响呢。</p><p>String::intern()是一个本地方法：若字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池，并且返回此String对象的引用。</p><p>在JDK6或之前HotSpot虚拟机，常量池都是分配在永久代，可以通过如下两个参数： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae3f1186b8a48d1af58d62dfbc52fc0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 限制永久代的大小，即可间接限制其中常量池的容量，</p><ul><li>实例</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f011eda4e9a420a82e9bf8901316a25~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: PermGen space <br>at java.lang.String.intern(Native Method) <br>at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: 18)<br>复制代码<br></code></pre></td></tr></table></figure><p>可见，运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是“PermGen space”，说明运行时常量池的确是属于方法区（即JDK 6的HotSpot虚拟机中的永久代）的 一部分。</p><p>而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使 用-XX：MaxPermSize参数或者在JDK 8及以上版本使用-XX：MaxMeta-spaceSize参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将一直进行下去，永不停歇。 这种变化是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆，所以在JDK 7及以上版 本，限制方法区的容量对该测试用例来说是毫无意义。</p><p>这时候使用-Xmx参数限制最大堆到6MB就能看到以下两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">// OOM异常一： Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space <br>at java.base/java.lang.Integer.toString(Integer.java:440) <br>at java.base/java.lang.String.valueOf(String.java:3058) <br>at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:12) <br><br>// OOM异常二： Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space at java.base/java.util.HashMap.resize(HashMap.java:699) <br>at java.base/java.util.HashMap.putVal(HashMap.java:658) <br>at java.base/java.util.HashMap.put(HashMap.java:607) <br>at java.base/java.util.HashSet.add(HashSet.java:220) <br>at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java from InputFile-Object:14)<br></code></pre></td></tr></table></figure><p>字符串常量池的实现位置还有很多趣事： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb73761bd4674d5aa2ff95599220418e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> JDK 6中运行，结果是两个false JDK 7中运行，一个true和一个false <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c1b0172eb7453ca6ef2191afee22f6~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 因为JDK6的intern()会把首次遇到的字符串实例复制到永久代的字符串常量池中，返回的也是永久代里这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在 Java 堆，所以不可能是同一个引用，结果将返回false。</p><p>JDK 7及以后的intern()无需再拷贝字符串的实例到永久代，字符串常量池已移到Java堆，只需在常量池里记录一下首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。</p><p>str2比较返回false，这是因为“java”这个字符串在执行String-Builder.toString()之前就已经出现过了，字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，而“计算机软件”这个字符串则是首次 出现的，因此结果返回true！</p><p>对于方法区的测试，基本的思路是运行时产生大量类去填满方法区，直到溢出。虽然直接使用Java SE API也可动态产生类（如反射时的 GeneratedConstructorAccessor和动态代理），但操作麻烦。 借助了CGLib直接操作字节码运行时生成大量动态类。 当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到 CGLib字节码增强，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。 很多运行于JVM的动态语言（例如Groovy）通常都会持续创建新类型来支撑语言的动态性，随着这类动态语言的流行，与如下代码相似的溢出场景也越来越容易遇到</p><p>在JDK 7中的运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Caused by: java.lang.OutOfMemoryError: PermGen space <br>at java.lang.ClassLoader.defineClass1(Native Method) <br>at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) <br>at java.lang.ClassLoader.defineClass(ClassLoader.java:616)<br></code></pre></td></tr></table></figure><p>JDK8及以后：可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MetaspaceSize=10M<br>-XX:MaxMetaspaceSize=10M<br></code></pre></td></tr></table></figure><p>设置元空间初始大小以及最大可分配大小。 1.如果不指定元空间的大小，默认情况下，元空间最大的大小是系统内存的大小，元空间一直扩大，虚拟机可能会消耗完所有的可用系统内存。 2.如果元空间内存不够用，就会报OOM。 3.默认情况下，对应一个64位的服务端JVM来说，其默认的-XX:MetaspaceSize值为21MB，这就是初始的高水位线，一旦元空间的大小触及这个高水位线，就会触发Full GC并会卸载没有用的类，然后高水位线的值将会被重置。 4.从第3点可以知道，如果初始化的高水位线设置过低，会频繁的触发Full GC，高水位线会被多次调整。所以为了避免频繁GC以及调整高水位线，建议将-XX:MetaspaceSize设置为较高的值，而-XX:MaxMetaspaceSize不进行设置。</p><p>JDK8 运行结果： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/951ead1c3a9f4afb910c12bcf1eac96a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 一个类如果要被gc，要达成的条件比较苛刻。在经常运行时生成大量动态类的场景，就应该特别关注这些类的回收状况。 这类场景除了之前提到的程序使用了CGLib字节码增强和动态语言外，常见的还有：</p><ul><li>大量JSP或动态产生JSP 文件的应用（JSP第一次运行时需要编译为Java类）</li><li>基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）</li></ul><p>JDK8后，永久代完全废弃，而使用元空间作为其替代者。在默认设置下，前面列举的那些正常的动态创建新类型的测试用例已经很难再迫使虚拟机产生方法区OOM。 为了让使用者有预防实际应用里出现类似于如上代码那样的破坏性操作，HotSpot还是提供了一些参数作为元空间的防御措施：</p><ul><li>-XX:MetaspaceSize</li></ul><p>指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整。如果释放了大量的空间，就适当降低该值，如果释放了很少空间，则在不超过-XX:MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值</p><ul><li>-XX:MaxMetaspaceSize</li></ul><p>设置元空间最大值，默认-1，即不限制，或者说只受限于本地内存的大小</p><ul><li>-XX:MinMetaspaceFreeRatio</li></ul><p>在GC后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的GC频率</p><ul><li>-XX:Max-MetaspaceFreeRatio</li></ul><p>控制最大的元空间剩余容量的百分比</p><h1 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h1><p>直接内存（Direct Memory）的容量大小可通过<code>-XX:MaxDirectMemorySize</code>指定，若不指定，则默认与Java堆最大值（<code>-Xmx</code>）一致。</p><p>这里越过DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配。 Unsafe类的getUnsafe()指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe，JDK10时才将Unsafe的部分功能通过VarHandle开放给外部。 因为虽然使用DirectByteBuffer分配内存也会抛OOM，但它抛异常时并未真正向os申请分配内存，而是通过计算得知内存无法分配，就在代码里手动抛了OOM，真正申请分配内存的方法是<strong>Unsafe::allocateMemory()</strong></p><ul><li>使用unsafe分配本机内存</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/cf101fc006de4ef5ae21599718c536d1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>结果</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e66e8b8257f4e49bbf2497f7ef78f1b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显异常，若发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了 DirectMemory（比如使用NIO），则该考虑直接内存了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>OOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows11正式发布</title>
    <link href="/blog/2021/06/28/Windows11%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/"/>
    <url>/blog/2021/06/28/Windows11%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p>Windows 11正式发布了，新一代的Windows在图标、菜单栏、声音、性能上都有很多变化，而且还有了新的自定义电脑方法。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97667baba64464989bed1fe1d1312aa~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>上个月，微软CEO纳德拉在微软开发者大会上预告了“下一代Windows”即将来临，果然，就在上周，Windows 11预览版镜像就被提前泄漏了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5247d668c1074337b12f89c5bc22afd2~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76be8f9441754e8698d6918f4bb017df~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>Windows系统从1985年开始至今，已经经历了30多年，陪伴了很多人的成长。</p><p>那这次Windows 11的更新，有什么不一样呢？</p><h3 id="一、新LOGO和新壁纸"><a href="#一、新LOGO和新壁纸" class="headerlink" title="一、新LOGO和新壁纸"></a>一、新LOGO和新壁纸</h3><p>Windows 10的logo是有倾斜度的透视效果，但Windows 11将这一设计取消，换成了方正的田字。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0edee98b014e94a1f448c729b3ef90~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>左侧是Win 10，右侧是Win 11</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/854d5e290ca54fdfafd58fc94d6c0957~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>Window 11自带的官方壁纸也挺好看的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d01c2359e384870a021a419a078d673~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>而且还可以调整色调，在色彩设置中，可以选择系统的主题色。Window 11的暗黑模式做得很漂亮，层级鲜明，色彩高级。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c17d1df68a54433bcea887ebe75ec01~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><h3 id="二、任务栏和图标"><a href="#二、任务栏和图标" class="headerlink" title="二、任务栏和图标"></a>二、任务栏和图标</h3><p>和Win10做个对比，最明显的变化就是任务栏变到了完全居中的位置。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d0d8fc2b0904417bb42a16d765e4ba3~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>任务栏图标的打开动效是这样 ↓</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/269a44880ef3416cbc05f4a6f08655af~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>开始菜单变成了这样 ↓</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c492f014dab543d18e6ee9e44cd9cee1~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>这一改动，引起了网友们的吐槽，称其显得「果里果气」的。当然，也可以改为靠左放置。配合毛玻璃效果，看起来和Windows 10差别不大了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c78f557ba124d80b3b42dcc34d6d159~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>默认设置下，任务栏里包含五个常驻图标。开始菜单的右侧，依次是搜索、多任务视图、新增的组件（Widgets）、文件管理器和Edge浏览器。</p><p>其中，搜索栏包含的功能没什么变化，但布局有所改动，并以卡片的形式悬浮于任务栏上方。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1306189cdaa04100ac35b47bc8c26324~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>多任务视图，新建桌面功能更显眼，其他变化不大。文件管理器和Edge浏览器就不说了，没什么新内容。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea00d2eb886b4b67b25d460acdd24f2f~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>和方方正正logo一样，回收站的图标换成了正面视角。另外文件管理器中的图像、音乐、视频等图标，设置中心里的图标，都经过了重新设计，间距也有所调整，视觉上更明晰。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a3d5863d60a144acb208476efb47c5a2~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83ac7b54769a4c89911bcad325900fc5~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>Windows 11的开始菜单里，磁贴设计不见了。从上到下分别是软件库、建议、个人账户和开关机选项。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/305fa80a53b2492f898121fb82d82c59~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>上方的软件库，可以手动添加、隐藏常用的软件，更改软件的排列顺序，上下滑动可以翻页。</p><p>点击右上角的「全部软件」，可以看到按首字母顺序排列的所有软件。点击字母，可快速跳转至字母表，方便用户查找。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f0e3b23bbe9e4c10a785d3ad713e8fe6~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>建议一栏就是根据用户的使用习惯，推荐当前可能会使用的应用或程序。点击「更多」，可看到最近添加的文件等资源。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b02a7a3fc1394d48b91701feed6ed5b4~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><h3 id="三、功能更新"><a href="#三、功能更新" class="headerlink" title="三、功能更新"></a>三、功能更新</h3><p>Windows 11的通知中心里，移除了「平板模式」。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4b48ed83ea5d4807966a57bbf512cb57~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>首先来看分屏操作的变化。Windows 11的窗口提供了多种排列的方式，操作很便捷，只需右键全屏化的按钮，或将光标移动至其上层稍作停顿，便可触发分屏机制。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8dce102e943f48ab986970f3975c003c~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f5a7ac350c914373a9cc17ef13eada93~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>除了上述比较明显的改动，Windows 11还有许多细微的变化。比如圆角的大量应用。大小窗口和按钮，都使用了圆角矩形边框。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af59ce72b56470daa3a72d036a69782~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>还有就是毛玻璃效果的应用场景更多了。新增的组件功能、状态栏、各类卡片都使用了毛玻璃效果，这让系统看起来更年轻。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/c111ae1599a54b1ba54a36ca43249fc9~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>除此之外，窗口的阴影效果也更为明显，还加了一些专场。这让界面的层级关系更为清晰，体验上十分是非顺滑。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/bae4705c643e4e569f5bb357eb3b50dd~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4f848fe03875407397c4fc7fb8665fd6~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>看了这些，你对Windows 11期待吗？</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Windows11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常开发中如何减少bug</title>
    <link href="/blog/2021/06/20/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91bug/"/>
    <url>/blog/2021/06/20/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91bug/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据库篇"><a href="#1-数据库篇" class="headerlink" title="1. 数据库篇"></a>1. 数据库篇</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a05dccf50dc3403c8c665d3395cdcc91~tplv-k3u1fbpfcp-zoom-1.image" alt="慢查询"></p><p>数据库篇的话，哪些地方容易导致bug出现呢？我总结了7个方面：<strong>慢查询、数据库字段注意点、事务失效的场景、死锁、主从延迟、新老数据兼容、一些SQL经典注意点</strong>。</p><h3 id="1-1-慢查询"><a href="#1-1-慢查询" class="headerlink" title="1.1 慢查询"></a>1.1 慢查询</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8d38c462aa484b47b9fcfded5f4f2140~tplv-k3u1fbpfcp-watermark.image" alt="慢查询.gif"></p><h4 id="1-1-1-是否命中索引"><a href="#1-1-1-是否命中索引" class="headerlink" title="1.1.1 是否命中索引"></a>1.1.1 是否命中索引</h4><p>提起慢查询，我们马上就会想到加索引。如果一条SQL没加索引，或者没有命中索引的话，就会产生慢查询。</p><p><strong>索引哪些情况会失效？</strong></p><ul><li>查询条件包含or，可能导致索引失效</li><li>如何字段类型是字符串，where时一定用引号括起来，否则索引失效</li><li>like通配符可能导致索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用mysql的内置函数，索引失效。</li><li>对索引列运算（如，+、-、*、/），索引失效。</li><li>索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li><li>索引字段上使用is null， is not null，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>mysql估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><h4 id="1-1-2-数据量大，考虑分库分表"><a href="#1-1-2-数据量大，考虑分库分表" class="headerlink" title="1.1.2 数据量大，考虑分库分表"></a>1.1.2 数据量大，考虑分库分表</h4><p>单表数据量太大，就会影响SQL执行性能。我们知道索引数据结构一般是B+树，一棵高度为3的B+树，大概可以存储两千万的数据。超过这个数的话，B+树要变高，查询性能会下降。</p><p>因此，数据量大的时候，建议分库分表。分库分表的中间件有<strong>mycat、sharding-jdbc</strong></p><h4 id="1-1-3-不合理的SQL"><a href="#1-1-3-不合理的SQL" class="headerlink" title="1.1.3 不合理的SQL"></a>1.1.3 不合理的SQL</h4><p>日常开发中，笔者见过很多不合理的SQL：比如一个SQL居然用了<strong>6个表连接</strong>,连表太多会影响查询性能；再比如一个表，居然加了<strong>10个索引</strong>等等。索引是会降低了插入和更新SQL性能，所以索引一般不建议太多，一般不能超过五个。</p><h3 id="1-2-数据库字段注意点"><a href="#1-2-数据库字段注意点" class="headerlink" title="1.2 数据库字段注意点"></a>1.2 数据库字段注意点</h3><p>数据库字段这块内容，很容易出bug。比如，你测试环境修改了表结构，加了某个字段，忘记把脚本带到生产环境，那发版肯定有问题了。</p><h4 id="1-2-1-字段是否会超长"><a href="#1-2-1-字段是否会超长" class="headerlink" title="1.2.1 字段是否会超长"></a>1.2.1 字段是否会超长</h4><p>假设你的数据库字段是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">`<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><br></code></pre></td></tr></table></figure><p>如果请求参数来了变量name，字段长度是300，那插入表的时候就<strong>报错</strong>了。所以需要校验参数，防止字段超长。</p><h4 id="1-2-2-字段为空，是否会导致空指针等"><a href="#1-2-2-字段为空，是否会导致空指针等" class="headerlink" title="1.2.2 字段为空，是否会导致空指针等"></a>1.2.2 字段为空，是否会导致空指针等</h4><p>我们设计数据库表字段的时候,尽量把字段设置为<strong>not null</strong>。</p><ul><li>如果是整形，我们一般使用0或者-1作为默认值。</li><li>如果字符串，默认空字符串</li></ul><p>如果数据库字段设置为<code>NULL</code>值，容易导致程序空指针；如果数据库字段设置为<code>NULL</code>值，需要注意<strong>count(具体列)</strong> 的使用，会有坑。</p><h4 id="1-2-3-字段缺失"><a href="#1-2-3-字段缺失" class="headerlink" title="1.2.3 字段缺失"></a>1.2.3 字段缺失</h4><p>我们的日常开发任务，如果在测试环境，对表进行修改，比如添加了一个新字段，必须要把SQL脚本带到生产环境，否则字段缺失，发版就有问题啦。</p><h4 id="1-2-4-字段类型是否支持表情"><a href="#1-2-4-字段类型是否支持表情" class="headerlink" title="1.2.4 字段类型是否支持表情"></a>1.2.4 字段类型是否支持表情</h4><p>如果一个表字段需要支持表情存储，使用<strong>utf8mb4</strong>。</p><h4 id="1-2-5-谨慎使用text、blob字段"><a href="#1-2-5-谨慎使用text、blob字段" class="headerlink" title="1.2.5 谨慎使用text、blob字段"></a>1.2.5 谨慎使用text、blob字段</h4><p>如果你要用一个字段存储文件，考虑<strong>存储文件的路径</strong>，而不保存整个文件下去。使用text时，涉及查询条件时，注意创建<strong>前缀索引</strong>。</p><h3 id="1-3-事务失效的场景"><a href="#1-3-事务失效的场景" class="headerlink" title="1.3 事务失效的场景"></a>1.3 事务失效的场景</h3><h4 id="1-3-1-Transactional-在非public修饰的方法上失效"><a href="#1-3-1-Transactional-在非public修饰的方法上失效" class="headerlink" title="1.3.1 @Transactional 在非public修饰的方法上失效"></a>1.3.1 @Transactional 在非public修饰的方法上失效</h4><p>@Transactional注解，加在非public修饰的方法上，事务是不会生效的。spring事务是借鉴了AOP的思想，也是通过动态代理来实现的。spring事务自己在调用动态代理之前，已经对非public方法过滤了，所以非public方法，事务不生效。</p><h4 id="1-3-2-本地方法直接调用"><a href="#1-3-2-本地方法直接调用" class="headerlink" title="1.3.2 本地方法直接调用"></a>1.3.2 本地方法直接调用</h4><p>以下这个场景，  @Transactional事务也是无效的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionTest</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//插入一条数据</span><br>    <span class="hljs-comment">//调用方法B (本地的类调用，事务失效了)</span><br>    B();<br>  &#125;<br>  <br>  <span class="hljs-meta">@Transactional</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">B</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//插入数据</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-3-3-异常被try…catch吃了，导致事务失效。"><a href="#1-3-3-异常被try…catch吃了，导致事务失效。" class="headerlink" title="1.3.3 异常被try…catch吃了，导致事务失效。"></a>1.3.3 异常被try…catch吃了，导致事务失效。</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Transactional<br><span class="hljs-keyword">public</span> void <span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">  try&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    //插入一条数据</span></span><br><span class="hljs-function"><span class="hljs-comment">    insertA();</span></span><br><span class="hljs-function"><span class="hljs-comment">    //更改一条数据</span></span><br><span class="hljs-function"><span class="hljs-comment">    updateB();</span></span><br><span class="hljs-function"><span class="hljs-comment">  &#125;</span><span class="hljs-title">catch</span><span class="hljs-params">(Exception e)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    logger.error(&quot;异常被捕获了，那你的事务就失效咯&quot;,e);</span></span><br><span class="hljs-function"><span class="hljs-comment">  &#125;</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h4 id="1-3-4-rollbackFor属性设置错误"><a href="#1-3-4-rollbackFor属性设置错误" class="headerlink" title="1.3.4 rollbackFor属性设置错误"></a>1.3.4 rollbackFor属性设置错误</h4><p>Spring默认抛出了未检查<code>unchecked</code>异常（继承自RuntimeException 的异常）或者Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，就需要指定<code>rollbackFor</code>属性。</p><h4 id="1-3-5-底层数据库引擎不支持事务"><a href="#1-3-5-底层数据库引擎不支持事务" class="headerlink" title="1.3.5 底层数据库引擎不支持事务"></a>1.3.5 底层数据库引擎不支持事务</h4><p>MyISAM存储引擎不支持事务，InnoDb就支持事务</p><h4 id="1-3-6-spring事务和业务逻辑代码必须在一个线程中"><a href="#1-3-6-spring事务和业务逻辑代码必须在一个线程中" class="headerlink" title="1.3.6 spring事务和业务逻辑代码必须在一个线程中"></a>1.3.6 spring事务和业务逻辑代码必须在一个线程中</h4><p>业务代码要和spring事务的源码在同一个线程中，才会受spring事务的控制。比如下面代码，方法mothed的子线程，内部执行的事务操作，将不受mothed方法上spring事务的控制，这一点大家要注意。这是因为spring事务实现中使用了ThreadLocal，实现同一个线程中数据共享。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">mothed</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Thread</span>(<span class="hljs-params"></span>)</span> &#123;<br>      事务操作<br>    &#125;.start();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-4-死锁"><a href="#1-4-死锁" class="headerlink" title="1.4 死锁"></a>1.4 死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/3513a3fd3ef64e318f157dd51ec280ef~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>MySQL内部有一套死锁检测机制，一旦发生死锁会立即回滚一个事务，让另一个事务执行下去。但死锁有<strong>资源的利用率降低、进程得不到正确结果</strong>等危害。</p><h4 id="1-4-1-9种情况的SQL加锁分析"><a href="#1-4-1-9种情况的SQL加锁分析" class="headerlink" title="1.4.1 9种情况的SQL加锁分析"></a>1.4.1 9种情况的SQL加锁分析</h4><p>要避免死锁，需要学会分析：一条SQL的加锁是如何进行的?一条SQL加锁，可以分9种情况进行探讨：</p><ul><li>组合一：id列是主键，RC隔离级别</li><li>组合二：id列是二级唯一索引，RC隔离级别</li><li>组合三：id列是二级非唯一索引，RC隔离级别</li><li>组合四：id列上没有索引，RC隔离级别</li><li>组合五：id列是主键，RR隔离级别</li><li>组合六：id列是二级唯一索引，RR隔离级别</li><li>组合七：id列是二级非唯一索引，RR隔离级别</li><li>组合八：id列上没有索引，RR隔离级别</li><li>组合九：Serializable隔离级别</li></ul><h4 id="1-4-2-如何分析解决死锁？"><a href="#1-4-2-如何分析解决死锁？" class="headerlink" title="1.4.2 如何分析解决死锁？"></a>1.4.2 如何分析解决死锁？</h4><p>分析解决死锁的步骤如下：</p><ul><li>模拟死锁场景</li><li>show engine innodb status;查看死锁日志</li><li>找出死锁SQL</li><li>SQL加锁分析，这个可以去官网看哈</li><li>分析死锁日志（持有什么锁，等待什么锁）</li><li>熟悉锁模式兼容矩阵，InnoDB存储引擎中锁的兼容性矩阵。</li></ul><p>有兴趣的小伙伴，可以看下我之前写的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487979&idx=1&sn=588c83d77a8851f3b3c18cd68ed9c454&chksm=cf21cec2f85647d4a77cc239ae9a4cfd31bb8832be3d98540a08ea8b4a1f46b38cf736210a02&token=1327808550&lang=zh_CN#rd">手把手教你分析Mysql死锁问题</a></p><h3 id="1-5-主从延迟问题考虑"><a href="#1-5-主从延迟问题考虑" class="headerlink" title="1.5 主从延迟问题考虑"></a>1.5 主从延迟问题考虑</h3><p>先插入，接着就去查询,这类代码逻辑比较常见，这可能会有问题的。一般数据库都是有主库，从库的。写入的话是写主库，读一般是读从库。如果发生主从延迟，，很可能出现你插入成功了，但是你查询不到的情况。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/560555c31cfe42a0b07dd9bcad24c0e1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="1-5-1-要求强一致性，考虑读主库"><a href="#1-5-1-要求强一致性，考虑读主库" class="headerlink" title="1.5.1 要求强一致性，考虑读主库"></a>1.5.1 要求强一致性，考虑读主库</h4><p>如果是重要业务，要求强一致性，考虑直接读主库</p><h4 id="1-5-2-不要求强一致性，读从库"><a href="#1-5-2-不要求强一致性，读从库" class="headerlink" title="1.5.2 不要求强一致性，读从库"></a>1.5.2 不要求强一致性，读从库</h4><p>如果是一般业务，可以接受短暂的数据不一致的话，优先考虑读从库。因为从库可以分担主库的读写压力，提高系统性能。</p><h3 id="1-6-新老数据兼容"><a href="#1-6-新老数据兼容" class="headerlink" title="1.6 新老数据兼容"></a>1.6 新老数据兼容</h3><h4 id="1-6-1-新加的字段，考虑存量数据的默认值"><a href="#1-6-1-新加的字段，考虑存量数据的默认值" class="headerlink" title="1.6.1 新加的字段，考虑存量数据的默认值"></a>1.6.1 新加的字段，考虑存量数据的默认值</h4><p>我们日常开发中，随着业务需求变更，经常需要给某个数据库表添加个字段。比如在某个APP配置表，需要添加个场景号字段，如<code>scene_type</code>,它的枚举值是 <code>01、02、03</code>，那我们就要跟业务对齐，新添加的字段，老数据是什么默认值，是为空还是默认01，如果是为<code>NULL</code>的话，程序代码就要做好空指针处理。</p><h4 id="1-6-2-如果新业务用老的字段，考虑老数据的值是否有坑"><a href="#1-6-2-如果新业务用老的字段，考虑老数据的值是否有坑" class="headerlink" title="1.6.2 如果新业务用老的字段，考虑老数据的值是否有坑"></a>1.6.2 如果新业务用老的字段，考虑老数据的值是否有坑</h4><p>如果我们开发中，需要沿用数据库表的老字段，并且有存量数据，那就需要考虑老存量数据库的值是否有坑。比如我们表有个user_role_code 的字段，老的数据中，它枚举值是 <code> 01：超级管理员 02：管理员 03：一般用户</code>。假设业务需求是<strong>一般用户</strong>拆分为<strong>03查询用户和04操作用户</strong>，那我们在开发中，就要考虑老数据的问题啦。</p><h3 id="1-7-一些SQL的经典注意点"><a href="#1-7-一些SQL的经典注意点" class="headerlink" title="1.7 一些SQL的经典注意点"></a>1.7 一些SQL的经典注意点</h3><h4 id="1-7-1-limit大分页问题"><a href="#1-7-1-limit大分页问题" class="headerlink" title="1.7.1 limit大分页问题"></a>1.7.1 limit大分页问题</h4><p>limit大分页是一个非常经典的SQL问题，我们一般有这3种对应的解决方案</p><p><strong>方案一：</strong> 如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span>,<span class="hljs-built_in">name</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>&gt;<span class="hljs-number">1000000</span> limit <span class="hljs-number">10.</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>方案二:</strong> 在业务允许的情况下限制页数：</p><p>建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。谷歌搜索页也是限制了页数，因此不存在limit大分页问题。</p><p><strong>方案三：</strong>  利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> a.* <span class="hljs-keyword">FROM</span> employee a, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span> ) b <span class="hljs-keyword">where</span> a.id=b.id<br></code></pre></td></tr></table></figure><h4 id="1-7-2-修改、查询数据量多时，考虑分批进行。"><a href="#1-7-2-修改、查询数据量多时，考虑分批进行。" class="headerlink" title="1.7.2 修改、查询数据量多时，考虑分批进行。"></a>1.7.2 修改、查询数据量多时，考虑分批进行。</h4><p>我们更新或者查询数据库数据时，尽量避免循环去操作数据库，可以考虑分批进行。比如你要插入10万数据的话，可以一次插入500条</p><p><strong>正例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">remoteBatchQuery(param);</span><br><br></code></pre></td></tr></table></figure><p><strong>反例：</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-variable">int</span> <span class="hljs-variable">i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">i</span>&lt;<span class="hljs-number">100000</span>;<span class="hljs-variable">i</span>++)&#123;</span><br><span class="hljs-function">  <span class="hljs-title">remoteSingleQuery</span>(<span class="hljs-variable">param</span>)</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-代码层面篇"><a href="#2-代码层面篇" class="headerlink" title="2. 代码层面篇"></a>2. 代码层面篇</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/819c4665e0064db5bb3441c5bee4cb7a~tplv-k3u1fbpfcp-zoom-1.image" alt="代码层面"></p><h3 id="2-1-编码细节"><a href="#2-1-编码细节" class="headerlink" title="2.1 编码细节"></a>2.1 编码细节</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/aaa1fee8efa745d39a2ef869caa55b4f~tplv-k3u1fbpfcp-watermark.image" alt="编码细节.gif"></p><h4 id="2-1-1-六大典型空指针问题"><a href="#2-1-1-六大典型空指针问题" class="headerlink" title="2.1.1 六大典型空指针问题"></a>2.1.1 六大典型空指针问题</h4><p>我们编码的时候，需要注意这六种类型的空指针问题</p><ul><li>包装类型的空指针问题</li><li>级联调用的空指针问题</li><li>Equals方法左边的空指针问题</li><li>ConcurrentHashMap 类似容器不支持 k-v为 null。</li><li>集合，数组直接获取元素</li><li>对象直接获取属性</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">object</span>!=<span class="hljs-literal">null</span>)&#123;<br>   <span class="hljs-built_in">String</span> name = <span class="hljs-built_in">object</span>.getName();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-1-2-线程池使用注意点"><a href="#2-1-2-线程池使用注意点" class="headerlink" title="2.1.2 线程池使用注意点"></a>2.1.2 线程池使用注意点</h4><ul><li>使用 Executors.newFixedThreadPool，可能会出现OOM问题，因为它使用的是无界阻塞队列</li><li>建议使用自定义的线程池，最好给线程池一个清晰的命名，方便排查问题</li><li>不同的业务，最好做线程池隔离，避免所有的业务公用一个线程池。</li><li>线程池异常处理要考虑好</li></ul><h4 id="2-1-3-线性安全的集合、类"><a href="#2-1-3-线性安全的集合、类" class="headerlink" title="2.1.3 线性安全的集合、类"></a>2.1.3 线性安全的集合、类</h4><p>在高并发场景下，<code>HashMap</code>可能会出现死循环。因为它是非线性安全的，可以考虑使用<code>ConcurrentHashMap</code>。所以我们使用这些集合的时候，需要注意是不是线性安全的。</p><ul><li>Hashmap、Arraylist、LinkedList、TreeMap等都是线性不安全的；</li><li>Vector、Hashtable、ConcurrentHashMap等都是线性安全的</li></ul><h4 id="2-1-4-日期格式，金额处理精度等"><a href="#2-1-4-日期格式，金额处理精度等" class="headerlink" title="2.1.4  日期格式，金额处理精度等"></a>2.1.4  日期格式，金额处理精度等</h4><p>日常开发，经常需要对日期格式化，但是呢，年份设置为YYYY大写的时候，是有坑的哦。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Calendar calendar = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Calendar</span>.</span></span>get<span class="hljs-constructor">Instance()</span>;<br>calendar.set(<span class="hljs-number">2019</span>, Calendar.DECEMBER, <span class="hljs-number">31</span>);<br><br>Date testDate = calendar.get<span class="hljs-constructor">Time()</span>;<br><br>SimpleDateFormat dtf = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleDateFormat(<span class="hljs-string">&quot;YYYY-MM-dd&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;2019-12-31 转 YYYY-MM-dd 格式后 &quot;</span> + dtf.format(testDate));<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2019</span>-<span class="hljs-number">12</span>-<span class="hljs-number">31</span> 转 YYYY-MM-dd 格式后 <span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">31</span><br><br></code></pre></td></tr></table></figure><p>还有金额计算也比较常见，我们要注意精度问题：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DoubleTest &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">1.0</span><span class="hljs-number">-0.8</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">4.015</span>*<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">123.3</span>/<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">double</span> amount1 = <span class="hljs-number">3.15</span>;<br>        <span class="hljs-type">double</span> amount2 = <span class="hljs-number">2.10</span>;<br>        <span class="hljs-keyword">if</span> (amount1 - amount2 == <span class="hljs-number">1.05</span>)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OK&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">30000000000000004</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">19999999999999996</span><br><span class="hljs-attribute">401</span>.<span class="hljs-number">49999999999994</span><br><span class="hljs-attribute">1</span>.<span class="hljs-number">2329999999999999</span><br><br></code></pre></td></tr></table></figure><h4 id="2-1-5-大文件处理"><a href="#2-1-5-大文件处理" class="headerlink" title="2.1.5 大文件处理"></a>2.1.5 大文件处理</h4><p>读取大文件的时候，不要<code>Files.readAllBytes</code>直接读到内存，会OOM的，建议使用<code>BufferedReader </code>一行一行来，或者使用<code>NIO</code></p><h4 id="2-1-6-使用完IO资源流，需要关闭"><a href="#2-1-6-使用完IO资源流，需要关闭" class="headerlink" title="2.1.6 使用完IO资源流，需要关闭"></a>2.1.6 使用完IO资源流，需要关闭</h4><p>使用try-with-resource，读写完文件，需要关闭流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 关注公众号，捡田螺的小男孩</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">try</span> (FileInputStream inputStream = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FileInputStream</span>(<span class="hljs-params"><span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;jay.txt&quot;</span>)</span>)</span> &#123;<br>    <span class="hljs-comment">// use resources   </span><br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    log.error(e);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    log.error(e);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-1-7-try…catch异常使用的一些坑"><a href="#2-1-7-try…catch异常使用的一些坑" class="headerlink" title="2.1.7 try…catch异常使用的一些坑"></a>2.1.7 try…catch异常使用的一些坑</h4><ul><li>尽量不要使用e.printStackTrace()打印，可能导致字符串常量池内存空间占满</li><li>catch了异常，使用log把它打印出来</li><li>不要用一个Exception捕捉所有可能的异常</li><li>不要把捕获异常当做业务逻辑来处理</li></ul><h4 id="2-1-8-先查询，再更新-删除的并发一致性"><a href="#2-1-8-先查询，再更新-删除的并发一致性" class="headerlink" title="2.1.8 先查询，再更新/删除的并发一致性"></a>2.1.8 先查询，再更新/删除的并发一致性</h4><p>日常开发中，这种代码实现经常可见：先查询是否有剩余可用的票，再去更新票余量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-function"><span class="hljs-title">selectIsAvailable</span>(<span class="hljs-params">ticketId</span>)</span>&#123;<br>    <span class="hljs-number">1</span>、deleteTicketById(ticketId)<br>    <span class="hljs-number">2</span>、给现金增加操作<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> “没有可用现金券”<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果是并发执行，很可能有问题的，应该利用数据库更新/删除的原子性，正解如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(deleteAvailableTicketById(ticketId)</span></span> == <span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-number">1</span>、给现金增加操作<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    return “没有可用现金券”<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-2-提供对外接口"><a href="#2-2-提供对外接口" class="headerlink" title="2.2 提供对外接口"></a>2.2 提供对外接口</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/818d79dfadab43e5a2bddf26a3ea2870~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="2-2-1-校验参数合法性"><a href="#2-2-1-校验参数合法性" class="headerlink" title="2.2.1 校验参数合法性"></a>2.2.1 校验参数合法性</h4><p>我们提供对外的接口，不管是提供给客户端、还是前端，又或是别的系统调用，都需要校验一下入参的合法性。</p><blockquote><p>如果你的数据库字段设置为varchar(16),对方传了一个32位的字符串过来，你不校验参数长度，插入数据库直接异常了。</p></blockquote><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4f4649f1bb3b43418ef808b8c5599c76~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h4 id="2-2-2-新老接口兼容"><a href="#2-2-2-新老接口兼容" class="headerlink" title="2.2.2 新老接口兼容"></a>2.2.2 新老接口兼容</h4><p>很多bug都是因为修改了对外老接口，但是却不做兼容导致的。关键这个问题多数是比较严重的，可能直接导致系统发版失败的。新手程序员很容易犯这个错误哦~</p><p>比如我们有个dubbo的分布式接口，本次你修改了入参，就需要考虑新老接口兼容。原本是只接收A，B参数，现在你加了一个参数C，就可以考虑这样处理。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//老接口</span><br>void old<span class="hljs-constructor">Service(A,B)</span>&#123;<br>  <span class="hljs-comment">//兼容新接口，传个null代替C</span><br>  <span class="hljs-keyword">new</span><span class="hljs-constructor">Service(A,B,<span class="hljs-params">null</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//新接口，暂时不能删掉老接口，需要做兼容。</span><br>void <span class="hljs-keyword">new</span><span class="hljs-constructor">Service(A,B,C)</span>;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-3-限流，防止大流量压垮系统"><a href="#2-2-3-限流，防止大流量压垮系统" class="headerlink" title="2.2.3 限流，防止大流量压垮系统"></a>2.2.3 限流，防止大流量压垮系统</h4><p>如果瞬间的大流量请求过来，容易压垮系统。所以为了保护我们的系统，一般要做限流处理。可以使用<strong>guava ratelimiter</strong> 组件做限流，也可以用阿里开源的<strong>Sentinel</strong></p><h4 id="2-2-4-接口安全性，加签验签，鉴权"><a href="#2-2-4-接口安全性，加签验签，鉴权" class="headerlink" title="2.2.4 接口安全性，加签验签，鉴权"></a>2.2.4 接口安全性，加签验签，鉴权</h4><p>我们转账等类型的接口，一定要注意安全性。一定要鉴权，<strong>加签验签</strong>，为用户交易保驾护航。</p><h4 id="2-2-5-考虑接口幂等性"><a href="#2-2-5-考虑接口幂等性" class="headerlink" title="2.2.5 考虑接口幂等性"></a>2.2.5 考虑接口幂等性</h4><p>接口是需要考虑幂等性的，尤其抢红包、转账这些重要接口。最直观的业务场景，就是<strong>用户连着点击两次</strong>，你的接口有没有hold住。</p><blockquote><ol><li>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</li><li>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。</li></ol></blockquote><p>一般「幂等技术方案」有这几种:</p><ol><li>查询操作</li><li>唯一索引</li><li>token机制，防止重复提交</li><li>数据库的delete删除操作</li><li>乐观锁</li><li>悲观锁</li><li>Redis、zookeeper 分布式锁（以前抢红包需求，用了Redis分布式锁）</li><li>状态机幂等</li></ol><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/55e09e293249431a85d68f8b217d9a8d~tplv-k3u1fbpfcp-watermark.image" alt="接口幂等性.gif"></p><h3 id="2-3-调用第三方接口"><a href="#2-3-调用第三方接口" class="headerlink" title="2.3 调用第三方接口"></a>2.3 调用第三方接口</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/41e0a0d34083431ca0d44f3354dca2f5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="2-3-1-超时处理"><a href="#2-3-1-超时处理" class="headerlink" title="2.3.1 超时处理"></a>2.3.1 超时处理</h4><p>我们调用别人的接口，如果超时了怎么办呢？</p><blockquote><p>举个例子，我们调用一个远程转账接口，A客户给B客户转100万，成功的时候就把本地转账流水置为成功，失败的时候就把本地流水置为失败。如果调用转账系统超时了呢，我们怎么处理呢？置为成功还是失败呢？这个<strong>超时处理可要考虑好</strong>，要不然就资金损失了。这种场景下，调接口超时，我们就可以先<strong>不更新本地转账流水</strong>状态，而是重新发起查询远程转账请求，查询到转账成功的记录，再更新本地状态状态</p></blockquote><h4 id="2-3-2-考虑重试机制"><a href="#2-3-2-考虑重试机制" class="headerlink" title="2.3.2 考虑重试机制"></a>2.3.2 考虑重试机制</h4><p>如果我们调用一个远程http或者dubbo接口，调用失败了，我们可以考虑引入重试机制。有时候网路抖动一下，接口就调失败了，引入重试机制可以提高用户体验。但是这个重试机制需要评估次数，或者有些接口不支持幂等，就不适合重试的。</p><h4 id="2-3-3-考虑是否降级处理"><a href="#2-3-3-考虑是否降级处理" class="headerlink" title="2.3.3 考虑是否降级处理"></a>2.3.3 考虑是否降级处理</h4><p>假设我们系统是一个提供注册的服务：用户注册成功之后，调远程A接口发短信，调远程B接口发邮件，最后更新注册状态为成功。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/d2a2180e624d4f8fadcf8fc8f63651bf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如果调用接口B发邮件失败，那用户就注册失败，业务可能就不会同意了。这时候我们可以考虑给B接口<strong>降级处理</strong>，提供<strong>有损服务</strong>。也就是说，如果调用B接口失败，那先不发邮件，而是先让用户注册成功，后面搞个定时补发邮件就好啦。</p><h4 id="2-3-4-考虑是否异步处理"><a href="#2-3-4-考虑是否异步处理" class="headerlink" title="2.3.4 考虑是否异步处理"></a>2.3.4 考虑是否异步处理</h4><p>我还是使用上个小节的<strong>用户注册</strong>的例子。我们可以开个异步线程去调A接口发短信，异步调B接口发邮件，那即使A或者B接口调失败，我们还是可以保证用户先注册成功。</p><p>把发短信这些通知类接口，放到异步线程处理，可以降低接口耗时，提升用户体验哦。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/07eef178cfe04048ade9fbed2f465d12~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="2-3-5-调接口异常处理"><a href="#2-3-5-调接口异常处理" class="headerlink" title="2.3.5 调接口异常处理"></a>2.3.5 调接口异常处理</h4><p>如果我们调用一个远程接口，一般需要思考以下：如果别人接口异常，我们要怎么处理，怎么兜底，是重试还是当做失败？怎么保证数据的最终一致性等等。</p><h2 id="3-缓存篇"><a href="#3-缓存篇" class="headerlink" title="3. 缓存篇"></a>3. 缓存篇</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f84d96671e8e451d936e110a53bf9cf6~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="3-1-数据库与缓存一致性"><a href="#3-1-数据库与缓存一致性" class="headerlink" title="3.1 数据库与缓存一致性"></a>3.1 数据库与缓存一致性</h3><p>使用缓存，可以降低耗时，提供系统吞吐性能。但是，使用缓存，会存在数据一致性的问题。</p><h4 id="3-1-1-几种缓存使用模式"><a href="#3-1-1-几种缓存使用模式" class="headerlink" title="3.1.1 几种缓存使用模式"></a>3.1.1 几种缓存使用模式</h4><ul><li>Cache-Aside Pattern，旁路缓存模式</li><li>Read-Through/Write-Through（读写穿透）</li><li>Write- behind （异步缓存写入）</li></ul><p>一般我们使用缓存，都是<strong>旁路缓存模式</strong>，读请求流程如下:</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/38f7efc4d066409dbf65a56eb10eb90e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>读的时候，先读缓存，缓存命中的话，直接返回数据</li><li>缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。</li></ul><p>旁路缓存模式的写流程： <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/c80f0df22739439088d6a47ced7b6ae0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="3-1-2-删除缓存呢，还是更新缓存？"><a href="#3-1-2-删除缓存呢，还是更新缓存？" class="headerlink" title="3.1.2 删除缓存呢，还是更新缓存？"></a>3.1.2 删除缓存呢，还是更新缓存？</h4><p>我们在操作缓存的时候，到底应该删除缓存还是更新缓存呢？我们先来看个例子：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b0a52a30ec994ca7b66cf83fba5398a2~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ol><li>线程A先发起一个写操作，第一步先更新数据库</li><li>线程B再发起一个写操作，第二步更新了数据库</li><li>由于网络等原因，线程B先更新了缓存</li><li>线程A更新缓存。</li></ol><p>这时候，缓存保存的是A的数据（老数据），数据库保存的是B的数据（新数据），数据不一致了，脏数据出现啦。如果是删除缓存取代更新缓存则不会出现这个脏数据问题。</p><h4 id="3-1-3-先操作数据库还是先操作缓存"><a href="#3-1-3-先操作数据库还是先操作缓存" class="headerlink" title="3.1.3 先操作数据库还是先操作缓存"></a>3.1.3 先操作数据库还是先操作缓存</h4><p>双写的情况下，先操作数据库还是先操作缓存？我们再来看一个例子：假设有A、B两个请求，请求A做更新操作，请求B做查询读取操作。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/95b0b2cd05d34ff1b66a8aa0a768cc04~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol><li>线程A发起一个写操作，第一步del cache</li><li>此时线程B发起一个读操作，cache miss</li><li>线程B继续读DB，读出来一个老数据</li><li>然后线程B把老数据设置入cache</li><li>线程A写入DB最新的数据</li></ol><p>酱紫就有问题啦，缓存和数据库的数据不一致了。缓存保存的是老数据，数据库保存的是新数据。因此，Cache-Aside缓存模式，选择了先操作数据库而不是先操作缓存。</p><h4 id="3-1-4-如何保证最终一致性"><a href="#3-1-4-如何保证最终一致性" class="headerlink" title="3.1.4 如何保证最终一致性"></a>3.1.4 如何保证最终一致性</h4><ul><li>缓存延时双删</li><li>删除缓存重试机制</li><li>读取biglog异步删除缓存</li></ul><h3 id="3-2-缓存穿透"><a href="#3-2-缓存穿透" class="headerlink" title="3.2 缓存穿透"></a>3.2 缓存穿透</h3><blockquote><p>缓存穿透：指查询一个一定不存在的数据，由于缓存不命中时，需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。</p></blockquote><p>缓存穿透一般都是这几种情况产生的：<strong>业务不合理的设计、业务/运维/开发失误的操作、黑客非法请求攻击</strong>。 如何避免缓存穿透呢？ 一般有三种方法。</p><ul><li>如果是非法请求，我们在API入口，<strong>对参数进行校验</strong>，过滤非法值。</li><li>如果查询数据库为空，我们可以<strong>给缓存设置个空值，或者默认值</strong>。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）</li><li>使用<strong>布隆过滤器</strong>快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。</li></ul><h3 id="3-3-缓存雪崩"><a href="#3-3-缓存雪崩" class="headerlink" title="3.3 缓存雪崩"></a>3.3 缓存雪崩</h3><blockquote><p>缓存雪崩：指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。</p></blockquote><ul><li>缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过<strong>均匀设置过期时间解决，即让过期时间相对离散一点</strong>。如采用一个较大固定值+一个较小的随机值，5小时+0到1800秒酱紫。</li><li><strong>Redis 故障宕机也可能引起缓存雪奔</strong>。这就需要构造Redis高可用集群啦。</li></ul><h3 id="3-4-缓存机击穿"><a href="#3-4-缓存机击穿" class="headerlink" title="3.4  缓存机击穿"></a>3.4  缓存机击穿</h3><blockquote><p>缓存击穿： 指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。</p></blockquote><p>缓存击穿看着有点像缓存雪崩，其实它两区别是，缓存雪奔是指数据库压力过大甚至down机，缓存击穿只是大量并发请求到了DB数据库层面。可以认为击穿是缓存雪奔的一个子集吧。有些文章认为它俩区别，是在于击穿针对某一热点key缓存，雪奔则是很多key。</p><p>解决方案就有两种：</p><ol><li><strong>使用互斥锁方案</strong>。缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。</li><li><strong>“永不过期”</strong>，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。</li></ol><h3 id="3-5-缓存热Key"><a href="#3-5-缓存热Key" class="headerlink" title="3.5 缓存热Key"></a>3.5 缓存热Key</h3><p>在Redis中，我们把访问频率高的key，称为热点key。如果某一热点key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。</p><p>如何解决热key问题？</p><ul><li><strong>Redis集群扩容</strong>：增加分片副本，均衡读流量；</li><li><strong>对热key进行hash散列</strong>，比如将一个key备份为key1,key2……keyN，同样的数据N个备份，N个备份分布到不同分片，访问时可随机访问N个备份中的一个，进一步分担读流量；</li><li><strong>使用二级缓存</strong>，即JVM本地缓存,减少Redis的读请求。</li></ul><h3 id="3-6-缓存容量内存考虑"><a href="#3-6-缓存容量内存考虑" class="headerlink" title="3.6 缓存容量内存考虑"></a>3.6 缓存容量内存考虑</h3><h4 id="3-6-1-评估容量，合理利用"><a href="#3-6-1-评估容量，合理利用" class="headerlink" title="3.6.1 评估容量，合理利用"></a>3.6.1 评估容量，合理利用</h4><p>如果我们使用的是Redis，而Redis的内存是比较昂贵的，我们不要什么数据都往Redis里面塞，一般Redis只缓存查询比较频繁的数据。同时，我们要合理评估Redis的容量，也避免频繁set覆盖，导致设置了过期时间的key失效。</p><p>如果我们使用的是本地缓存，如guava的本地缓存，也要评估下容量。避免容量不够。</p><h4 id="3-6-2-Redis的八种内存淘汰机制"><a href="#3-6-2-Redis的八种内存淘汰机制" class="headerlink" title="3.6.2 Redis的八种内存淘汰机制"></a>3.6.2 Redis的八种内存淘汰机制</h4><p>为了避免Redis内存不够用，Redis用8种内存淘汰策略保护自己~</p><blockquote><ul><li>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；</li><li>allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。</li><li>volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。</li><li>allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；</li><li>volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。</li><li>allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；</li><li>noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ul></blockquote><h4 id="3-6-3-不同的业务场景，Redis选择适合的数据结构"><a href="#3-6-3-不同的业务场景，Redis选择适合的数据结构" class="headerlink" title="3.6.3 不同的业务场景，Redis选择适合的数据结构"></a>3.6.3 不同的业务场景，Redis选择适合的数据结构</h4><ul><li>排行榜适合用zset</li><li>缓存用户信息一般用hash</li><li>消息队列，文章列表适用用list</li><li>用户标签、社交需求一般用set</li><li>计数器、分布式锁等一般用String类型</li></ul><h3 id="3-7-Redis一些有坑的命令"><a href="#3-7-Redis一些有坑的命令" class="headerlink" title="3.7 Redis一些有坑的命令"></a>3.7 Redis一些有坑的命令</h3><ol><li>不能使用 keys指令</li><li>慎用O(n)复杂度命令，如hgetall等</li><li>慎用Redis的monitor命令</li><li>禁止使用flushall、flushdb</li><li>注意使用del命令</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>减少bug</tag>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程常用</title>
    <link href="/blog/2021/06/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8/"/>
    <url>/blog/2021/06/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在实际工作中，错误使用多线程非但不能提高效率还可能使程序崩溃。以在路上开车为例：</p><p>在一个单向行驶的道路上，每辆汽车都遵守交通规则，这时候整体通行是正常的。『单向车道』意味着『一个线程』，『多辆车』意味着『多个job任务』。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4fe734a0308c428893fc6d4002d9137e~tplv-k3u1fbpfcp-zoom-1.image" alt="单线程顺利同行">单线程顺利同行</p><p>如果需要提升车辆的同行效率，一般的做法就是扩展车道，对应程序来说就是『加线程池』，增加线程数。这样在同一时间内，通行的车辆数远远大于单车道。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/3319e1d25eec448998699b48b60e4ed2~tplv-k3u1fbpfcp-zoom-1.image" alt="多线程顺利同行">多线程顺利同行</p><p>然而成年人的世界没有那么完美，车道一旦多起来『加塞』的场景就会越来越多，出现碰撞后也会影响整条马路的通行效率。这么一对比下来『多车道』确实可能比『单车道』要慢。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ab3e6b1fa4794941903c51e00d36b2e7~tplv-k3u1fbpfcp-zoom-1.image" alt="多线程故障">多线程故障</p><p>防止汽车频繁变道加塞可以采取在车道间增加『护栏』，那在程序的世界该怎么做呢？</p><p>程序世界中多线程遇到的问题归纳起来就是三类：<code>『线程安全问题』</code>、<code>『活跃性问题』</code>、<code>『性能问题』</code>，接下来会讲解这些问题，以及问题对应的解决手段。</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>有时候我们会发现，明明在单线程环境中正常运行的代码，在多线程环境中可能会出现意料之外的结果，其实这就是大家常说的『线程不安全』。那到底什么是线程不安全呢？往下看。</p><p><strong>原子性</strong></p><p>举一个银行转账的例子，比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元，两个操作都成功才意味着一次转账最终成功。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a714472c3bd14fdc95f04da2e04f6346~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>试想一下，如果这两个操作不具备原子性，从A的账户扣减了1000元之后，操作突然终止了，账户B没有增加1000元，那问题就大了。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ebe28c1bdb0c419588e35454b5e721ed~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>银行转账这个例子有两个步骤，出现了意外后导致转账失败，说明没有原子性。</p><blockquote><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>原子操作：即不会被线程调度机制打断的操作，没有上下文切换。</p></blockquote><p>在并发编程中很多操作都不是原子操作，出个小题目：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">i = <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span> 操作<span class="hljs-number">1</span><br>i++;   <span class="hljs-regexp">//</span> 操作<span class="hljs-number">2</span><br>i = j; <span class="hljs-regexp">//</span> 操作<span class="hljs-number">3</span><br>i = i + <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 操作<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>上面这四个操作中有哪些是原子操作，哪些不是的？不熟悉的人可能认为这些都是原子操作，其实只有操作1是原子操作。</p><ul><li>操作1：对基本数据类型变量的赋值是原子操作；</li><li>操作2：包含三个操作，读取i的值，将i加1，将值赋给i；</li><li>操作3：读取j的值，将j的值赋给i；</li><li>操作4：包含三个操作，读取i的值，将i加1，将值赋给i；</li></ul><p>在单线程环境下上述四个操作都不会出现问题，但是在多线程环境下，如果不通过加锁操作，往往可能得到意料之外的值。</p><p>在Java语言中通过可以使用synchronize或者lock来保证原子性。</p><p><strong>可见性</strong></p><p>talk is cheap，先show一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Author: leixiaoshuai</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">50</span>;<br>  <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 线程1执行</span><br>    i = <span class="hljs-number">100</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 线程2执行</span><br>    j = i;<br>    <span class="hljs-keyword">return</span> j;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程1执行update方法将 i 赋值为100，一般情况下线程1会在自己的工作内存中完成赋值操作，却没有及时将新值刷新到主内存中。</p><p>这个时候线程2执行get方法，首先会从主内存中读取i的值，然后加载到自己的工作内存中，这个时候读取到i的值是50，再将50赋值给j，最后返回j的值就是50了。原本期望返回100，结果返回50，这就是可见性问题，线程1对变量i进行了修改，线程2没有立即看到i的新值。</p><blockquote><p>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/0bf6ca1e10ae48d79be7730df52ec04a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如上图每个线程都有属于自己的工作内存，工作内存和主内存间需要通过store和load等进行交互。</p><p>为了解决多线程可见性问题，Java语言提供了<code>volatile</code>这个关键字。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，另外一个线程读的可能就是旧值。</p><p>当然Java的锁机制如synchronize和lock也是可以保证可见性的，加锁可以保证在同一时刻只有一个线程在执行同步代码块，释放锁之前会将变量刷回至主存，这样也就保证了可见性。</p><p>关于线程不安全的表现还有『有序性』，这个问题会在后面的文章中深入讲解。</p><h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><p>上面讲到为了解决<code>可见性</code>问题，我们可以采取加锁方式解决，但是如果加锁使用不当也容易引入其他问题，比如『死锁』。</p><p>在说『死锁』前我们先引入另外一个概念：<code>活跃性问题</code>。</p><blockquote><p>活跃性是指某件正确的事情最终会发生，当某个操作无法继续下去的时候，就会发生活跃性问题。</p></blockquote><p>概念是不是有点拗口，如果看不懂也没关系，你可以记住活跃性问题一般有这样几类：<code>死锁</code>，<code>活锁</code>，<code>饥饿问题</code>。</p><p><strong>（1）死锁</strong></p><p>死锁是指多个线程因为环形的等待锁的关系而永远的阻塞下去。一图胜千语，不多解释。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a382ae0db4eb477f85770c819c0a4ea7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><strong>（2）活锁</strong></p><p>死锁是两个线程都在等待对方释放锁导致阻塞。而<code>活锁</code>的意思是线程没有阻塞，还活着呢。</p><p>当多个线程都在运行并且修改各自的状态，而其他线程彼此依赖这个状态，导致任何一个线程都无法继续执行，只能重复着自身的动作和修改自身的状态，这种场景就是发生了活锁。</p><p><img src="/Users/ray/Library/Application%20Support/typora-user-images/image-20210408232019843.png"></p><p>如果大家还有疑惑，那我再举一个生活中的例子，大家平时在走路的时候，迎面走来一个人，两个人互相让路，但是又同时走到了一个方向，如果一直这样重复着避让，这俩人就是发生了活锁，学到了吧，嘿嘿。</p><p><strong>（3）饥饿</strong></p><p>如果一个线程无其他异常却迟迟不能继续运行，那基本是处于饥饿状态了。</p><p>常见有几种场景:</p><ul><li>高优先级的线程一直在运行消耗CPU，所有的低优先级线程一直处于等待；</li><li>一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问；</li></ul><p>有一个非常经典的饥饿问题就是<code>哲学家用餐问题</code>，如下图所示，有五个哲学家在用餐，每个人必须要同时拿两把叉子才可以开始就餐，如果哲学家1和哲学家3同时开始就餐，那哲学家2、4、5就得饿肚子等待了。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/25683ef8fb9445fe825fd9230023bdb5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>前面讲到了线程安全和死锁、活锁这些问题会影响多线程执行过程，如果这些都没有发生，多线程并发一定比单线程串行执行快吗，答案是不一定，因为多线程有<code>创建线程</code>和<code>线程上下文切换</code>的开销。</p><p>创建线程是直接向系统申请资源的，对操作系统来说创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等。</p><p>线程创建完之后，还会遇到线程<code>上下文切换</code>。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/22ebd72ce85f45efaa4946a9016fe6e9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>CPU是很宝贵的资源速度也非常快，为了保证雨露均沾，通常为给不同的线程分配<code>时间片</code>，当CPU从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等，这个开关被称为『上下文切换』。</p><p>一般减少上下文切换的方法有：<code>无锁并发编程</code>、<code>CAS 算法</code>、<code>使用协程</code>等。</p><h2 id="有态度的总结"><a href="#有态度的总结" class="headerlink" title="有态度的总结"></a>有态度的总结</h2><p>多线程用好了可以让程序的效率成倍提升，用不好可能比单线程还要慢。</p><p>用一张图总结一下上面讲的：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/c184348c1e014ad38f72b0d26b684b8a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210412234350204"></p><p>文章讲了多线程并发会遇到的问题，你可能也发现了，文章中并没有给出具体的解决方案，因为这些问题在Java语言设计过程中大神都已经为你考虑过了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>json解析工具类合集</title>
    <link href="/blog/2021/06/14/json%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%90%88%E9%9B%86/"/>
    <url>/blog/2021/06/14/json%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>在工作中，少不了Json解析处理，一般我们常用的就是FastJson、Jackson、Gson这三大工具类，他们都有各自的优缺点，本篇文章我们来使用一下他们各自的API，对比一下。</p><h1 id="一、各个JSON技术的简介"><a href="#一、各个JSON技术的简介" class="headerlink" title="一、各个JSON技术的简介"></a>一、各个JSON技术的简介</h1><h2 id="1-1-FastJson角色"><a href="#1-1-FastJson角色" class="headerlink" title="1.1 FastJson角色"></a>1.1 FastJson角色</h2><blockquote><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p></blockquote><p>Github官网简介：<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">github.com/alibaba/fas…</a></p><h2 id="1-2-Jackson角色"><a href="#1-2-Jackson角色" class="headerlink" title="1.2 Jackson角色"></a>1.2 Jackson角色</h2><blockquote><p>Jackson被称为“ Java JSON库”或“ Java的最佳JSON解析器”。或简称为“ JSON for Java”。</p></blockquote><p>Github官网简介：<a href="https://github.com/FasterXML/jackson">github.com/FasterXML/j…</a></p><h2 id="1-3-Gson角色"><a href="#1-3-Gson角色" class="headerlink" title="1.3 Gson角色"></a>1.3 Gson角色</h2><blockquote><p>Gson是一个Java库，可用于将Java对象转换为其JSON表示形式。它也可以用于将JSON字符串转换为等效的Java对象。Gson可以处理任意Java对象，包括您没有源代码的预先存在的对象。</p></blockquote><p>Github官网简介：<a href="https://github.com/google/gson">github.com/google/gson</a></p><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="2-1-引入库"><a href="#2-1-引入库" class="headerlink" title="2.1 引入库"></a>2.1 引入库</h2><h3 id="1、FastJson依赖"><a href="#1、FastJson依赖" class="headerlink" title="1、FastJson依赖"></a>1、FastJson依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.75<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Maven中央仓库：<a href="https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.75">mvnrepository.com/artifact/co…</a></p><h3 id="2、Jackson依赖"><a href="#2、Jackson依赖" class="headerlink" title="2、Jackson依赖"></a>2、Jackson依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Maven中央仓库：<a href="https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations/2.12.1">mvnrepository.com/artifact/co…</a></p><h3 id="3、Gson依赖"><a href="#3、Gson依赖" class="headerlink" title="3、Gson依赖"></a>3、Gson依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Maven中央仓库：<a href="https://mvnrepository.com/artifact/com.google.code.gson/gson/2.8.6">mvnrepository.com/artifact/co…</a></p><h2 id="2-2-将JSON-字符串转换为Java-对象"><a href="#2-2-将JSON-字符串转换为Java-对象" class="headerlink" title="2.2 将JSON 字符串转换为Java 对象"></a>2.2 将JSON 字符串转换为Java 对象</h2><p><strong>Person对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> DT开发者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@EqualsAndHashCode(callSuper = false)</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Integer id;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">private</span> Date createTime;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、FastJson版本"><a href="#1、FastJson版本" class="headerlink" title="1、FastJson版本"></a>1、FastJson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String json = <span class="hljs-string">&quot;&#123;\&quot;createTime\&quot;:1621341922450,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;DT\&quot;&#125;&quot;</span>;<br>    <span class="hljs-comment">// 方式1: 将json字符串转为Java对象</span><br>    Person person = JSON.parseObject(json,Person.class);<br>    System.out.println(<span class="hljs-string">&quot;java对象-&gt;&gt;&gt;&quot;</span>+person);<br>    System.out.println(<span class="hljs-string">&quot;=========================================================&quot;</span>);<br>    <span class="hljs-comment">// 方式2: 将json字符串转为Java对象</span><br>    Person newPerson2 = JSONObject.parseObject(json, Person.class);<br>    System.out.println(<span class="hljs-string">&quot;java对象-&gt;&gt;&gt;&quot;</span>+newPerson2);<br>&#125;<br>JSON.parseObject(String,Object.class)<br>JSONObject.parseObject(String, Object.class)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1415d0fa394c46518c427d79b5419b08~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2、Jackson版本"><a href="#2、Jackson版本" class="headerlink" title="2、Jackson版本"></a>2、Jackson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建Jackson核心对象 ObjectMapper</span><br>    ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>    String json = <span class="hljs-string">&quot;&#123;\&quot;createTime\&quot;:1621341922450,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;DT\&quot;&#125;&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Person person = objectMapper.readValue(json, Person.class);<br>        System.out.println(<span class="hljs-string">&quot;java对象-&gt;&gt;&gt;&quot;</span>+person);<br>    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/7c1079bbf3a54babac40ea14372629d0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="3、Gson版本"><a href="#3、Gson版本" class="headerlink" title="3、Gson版本"></a>3、Gson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     <span class="hljs-comment">// gson无法正常将时间戳转化成date</span><br>     <span class="hljs-comment">// 使用JSON内存树注册Date类型</span><br>     <span class="hljs-keyword">final</span> Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>     .registerTypeAdapter(Date.class, <span class="hljs-keyword">new</span> JsonDeserializer&lt;Date&gt;() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">deserialize</span><span class="hljs-params">(JsonElement jsonElement, Type type, JsonDeserializationContext context)</span> <span class="hljs-keyword">throws</span> JsonParseException </span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(jsonElement.getAsJsonPrimitive().getAsLong());<br>         &#125;<br>     &#125;).create();<br><br>     String json = <span class="hljs-string">&quot;&#123;\&quot;createTime\&quot;:1621341922450,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;DT\&quot;&#125;&quot;</span>;<br>     Person person = gson.fromJson(json, Person.class);<br>     System.out.println(<span class="hljs-string">&quot;java对象-&gt;&gt;&gt;&quot;</span>+person);<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/05a48204156442f58078f8ce28537740~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h2 id="2-3-将Java对象转换为JSON-字符串"><a href="#2-3-将Java对象转换为JSON-字符串" class="headerlink" title="2.3 将Java对象转换为JSON 字符串"></a>2.3 将Java对象转换为JSON 字符串</h2><h3 id="1、FastJson版本-1"><a href="#1、FastJson版本-1" class="headerlink" title="1、FastJson版本"></a>1、FastJson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date());<br>     <span class="hljs-comment">// 方式1：将对象转为json字符串</span><br>     String json = JSON.toJSONString(person);<br>     System.out.println(<span class="hljs-string">&quot;json字符串-&gt;&gt;&gt;&quot;</span>+json);<br>     System.out.println(<span class="hljs-string">&quot;=========================================================&quot;</span>);<br>     <span class="hljs-comment">// 方式2：将对象转为json字符串</span><br>     String json2 = JSONObject.toJSONString(person);<br>     System.out.println(<span class="hljs-string">&quot;json字符串-&gt;&gt;&gt;&quot;</span>+json2);<br> &#125;<br>JSONObject.toJSONString(String)<br>JSON.toJSONString(String)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4b35a068508c462a8fbb134e21b156b7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="2、Jackson版本-1"><a href="#2、Jackson版本-1" class="headerlink" title="2、Jackson版本"></a>2、Jackson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>     <span class="hljs-comment">// 创建Jackson核心对象 ObjectMapper</span><br>     ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>     Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date());<br>     <span class="hljs-keyword">try</span> &#123;<br>         String json = objectMapper.writeValueAsString(person);<br>         System.out.println(<span class="hljs-string">&quot;json字符串-&gt;&gt;&gt;&quot;</span>+json);<br>     &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/bbd119d3521d453f85219d43cc7fc8a7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h3 id="3、Gson版本-1"><a href="#3、Gson版本-1" class="headerlink" title="3、Gson版本"></a>3、Gson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Gson gson = <span class="hljs-keyword">new</span> Gson();<br>    Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date());<br>    String json = gson.toJson(person);<br>    System.out.println(<span class="hljs-string">&quot;json字符串-&gt;&gt;&gt;&quot;</span>+json);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ef61066c9f804d888705a864af74621a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h2 id="2-4-将JSON-字符串数组转为JSON数组"><a href="#2-4-将JSON-字符串数组转为JSON数组" class="headerlink" title="2.4 将JSON 字符串数组转为JSON数组"></a>2.4 将JSON 字符串数组转为JSON数组</h2><h3 id="1、FastJson版本-2"><a href="#1、FastJson版本-2" class="headerlink" title="1、FastJson版本"></a>1、FastJson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;DT1&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;DT2&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    String json = JSONObject.toJSONString(personList);<br>    JSONArray jsArr = JSONObject.parseArray(json);<br>    System.out.println(jsArr);<br>&#125;<br>JSONObject.parseArray(json)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/189f78f87f674e3fb1c7943aaff31a7a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"> 遍历循环Json数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;DT1&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;DT2&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    String json = JSONObject.toJSONString(personList);<br>    JSONArray jsArr = JSONObject.parseArray(json);<br>    <span class="hljs-comment">// 遍历方式1</span><br>    jsArr.stream().forEach(json1 -&gt;&#123;<br>        System.out.println(json1.toString());<br>    &#125;);<br>    <span class="hljs-comment">// 遍历方式2</span><br>    <span class="hljs-keyword">for</span> (Object o : jsArr) &#123;<br>        JSONObject obj = (JSONObject) o;<br>        System.out.println(<span class="hljs-string">&quot;取到id-&gt;&gt;&gt;&quot;</span> + obj.get(<span class="hljs-string">&quot;id&quot;</span>));<br>        <span class="hljs-comment">// 判断是否存在key</span><br>        System.out.println(<span class="hljs-string">&quot;key是否存在-&gt;&gt;&gt;&quot;</span>+obj.containsKey(<span class="hljs-string">&quot;name1&quot;</span>));<br>        <span class="hljs-comment">// 判断是否存在值</span><br>        System.out.println(<span class="hljs-string">&quot;value是否存在-&gt;&gt;&gt;&quot;</span>+obj.containsValue(obj.get(<span class="hljs-string">&quot;id&quot;</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Jackson版本-2"><a href="#2、Jackson版本-2" class="headerlink" title="2、Jackson版本"></a>2、Jackson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br>    <span class="hljs-comment">// 将JSON数组转换为array对象</span><br>    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>    String json = <span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;createTime\&quot;:1622719597081&#125;, &#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;createTime\&quot;:1622719597081&#125;]&quot;</span>;<br>    <span class="hljs-comment">// 方式1</span><br>    Person[] pp1 = mapper.readValue(json, Person[].class);<br>    <span class="hljs-keyword">for</span> (Person person : pp1) &#123;<br>        System.out.println(person);<br>    &#125;<br>    <span class="hljs-comment">// 方式2</span><br>    List&lt;Person&gt; ppl2 = Arrays.asList(mapper.readValue(json, Person[].class));<br>    ppl2.stream().forEach(System.out::println);<br>    <span class="hljs-comment">// 方式3</span><br>    List&lt;Person&gt; pp3 = mapper.readValue(json, <span class="hljs-keyword">new</span> TypeReference&lt;List&lt;Person&gt;&gt;() &#123;&#125;);<br>    pp3.stream().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Gson版本-2"><a href="#3、Gson版本-2" class="headerlink" title="3、Gson版本"></a>3、Gson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">```java<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// gson无法正常将时间戳转化成date</span><br>    <span class="hljs-comment">// 使用JSON内存树注册Date类型</span><br>    <span class="hljs-keyword">final</span> Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>            .registerTypeAdapter(Date.class, <span class="hljs-keyword">new</span> JsonDeserializer&lt;Date&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">deserialize</span><span class="hljs-params">(JsonElement jsonElement, Type type, JsonDeserializationContext context)</span> <span class="hljs-keyword">throws</span> JsonParseException </span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(jsonElement.getAsJsonPrimitive().getAsLong());<br>                &#125;<br>            &#125;).create();<br>    <br>    String json = <span class="hljs-string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;createTime\&quot;:1622719597081&#125;, &#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;createTime\&quot;:1622719597081&#125;]&quot;</span>;<br>    Type type = <span class="hljs-keyword">new</span> TypeToken&lt;ArrayList&lt;Person&gt;&gt;()&#123;&#125;.getType();<br>    List&lt;Person&gt; personList = gson.fromJson(json, type);<br>    personList.stream().forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>List反序列化时必须提供它的Type，通过Gson提供的TypeToken.getType()方法可以定义当前List的Type。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f7b73a8c0a05466ca87f7930bc019115~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h2 id="2-5-将JSON数组转为JSON-字符串"><a href="#2-5-将JSON数组转为JSON-字符串" class="headerlink" title="2.5 将JSON数组转为JSON 字符串"></a>2.5 将JSON数组转为JSON 字符串</h2><h3 id="1、FastJson版本-3"><a href="#1、FastJson版本-3" class="headerlink" title="1、FastJson版本"></a>1、FastJson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;DT1&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;DT2&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    String json = JSONObject.toJSONString(personList);<br>    System.out.println(<span class="hljs-string">&quot;json-&gt;&gt;&gt;&quot;</span>+json);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Jackson版本-3"><a href="#2、Jackson版本-3" class="headerlink" title="2、Jackson版本"></a>2、Jackson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br>   ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>    List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;DT1&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;DT2&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    String json = objectMapper.writeValueAsString(personList);<br>    System.out.println(<span class="hljs-string">&quot;json-&gt;&gt;&gt;&quot;</span>+json);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Gson版本-3"><a href="#3、Gson版本-3" class="headerlink" title="3、Gson版本"></a>3、Gson版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Gson gson = <span class="hljs-keyword">new</span> Gson();<br>    List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DT&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;DT1&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    personList.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;DT2&quot;</span>,<span class="hljs-keyword">new</span> Date()));<br>    String json = gson.toJson(personList);<br>    System.out.println(<span class="hljs-string">&quot;json-&gt;&gt;&gt;&quot;</span>+json);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用策略模式，优化你代码里的的if-else</title>
    <link href="/blog/2021/06/12/%E4%BC%98%E5%8C%96%E4%BD%A0%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E7%9A%84if-else/"/>
    <url>/blog/2021/06/12/%E4%BC%98%E5%8C%96%E4%BD%A0%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E7%9A%84if-else/</url>
    
    <content type="html"><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a46b3d8654904fc6becedc7dd348a27f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是策略模式？它的原理实现是怎么样的？</p><blockquote><p>定义一系列算法，封装每个算法，并使他们可以互换，不同的策略可以让算法独立于使用它们的客户而变化。 以上定义来自设计模式之美</p></blockquote><p>感觉有点抽象？那就来看一张结构图吧</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/caf12785e40b41fb9313b3fc60fe9211~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><ul><li>Strategy（抽象策略）：抽象策略类，并且定义策略执行入口</li><li>ConcreteStrategy（具体策略）：实现抽象策略，实现algorithm方法</li><li>Context（环境）：运行特定的策略类。</li></ul></blockquote><p>这么看结构其实还是不复杂的，而且跟状态模式类似。</p><p>那么这个代码怎么实现？</p><p>举个例子，汽车大家肯定都不陌生，愿大家早日完成汽车梦，汽车的不同档(concreteStrategy）就好比不同的策略，驾驶者选择几档则汽车按几档的速度前进，整个选择权在驾驶者（context）手中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GearStrategy</span> </span>&#123;<br><br>    <span class="hljs-comment">// 定义策略执行方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(String param)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>首先还是先定义抽象策略</p><blockquote><p>这里是用接口的形式，还有一种方式可以用抽象方法<strong>abstract</strong>来写也是一样的。具体就看大家自己选择了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GearStrategyAbstract</span> </span>&#123;<br> <span class="hljs-comment">// 定义策略执行方法</span><br> <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(String param)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GearStrategyOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GearStrategy</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(String param)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前档位&quot;</span> + param);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其次定义具体档位策略，实现algorithm方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br><span class="hljs-comment">// 缓存所有的策略，当前是无状态的，可以共享策略类对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, GearStrategy&gt; strategies = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 第一种写法</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        strategies.put(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-keyword">new</span> GearStrategyOne());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GearStrategy <span class="hljs-title">getStrategy</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-keyword">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> strategies.get(type);<br>    &#125;<br><br>    <span class="hljs-comment">// 第二种写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GearStrategy <span class="hljs-title">getStrategySecond</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-keyword">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;one&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GearStrategyOne();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 测试结果</span><br>        GearStrategy strategyOne = Context.getStrategy(<span class="hljs-string">&quot;one&quot;</span>);<br>        strategyOne.algorithm(<span class="hljs-string">&quot;1档&quot;</span>);<br>         <span class="hljs-comment">// 结果：当前档位1档</span><br>        GearStrategy strategyTwo = Context.getStrategySecond(<span class="hljs-string">&quot;one&quot;</span>);<br>        strategyTwo.algorithm(<span class="hljs-string">&quot;1档&quot;</span>);<br>        <span class="hljs-comment">// 结果：当前档位1档</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后就是实现运行时环境（Context），你可以定义成StrategyFactory，但都是一个意思。</p><p>在main方法里面的测试demo，可以看到通过不同的type类型，可以实现不同的策略，这就是策略模式主要思想。</p><p>在Context里面定义了两种写法：</p><blockquote><ul><li>第一种是维护了一个strategies的Map容器。用这种方式就需要判断每种策略是否可以共享使用，它只是作为算法的实现。</li><li>第二种是直接通过有状态的类，每次根据类型new一个新的策略类对象。这个就需要根据实际业务场景去做的判断。</li></ul></blockquote><h3 id="框架的应用"><a href="#框架的应用" class="headerlink" title="框架的应用"></a>框架的应用</h3><p>策略模式在框架中也在一个很常见的地方体现出来了，而且大家肯定都有使用过。</p><p>那就是JDK中的线程池<strong>ThreadPoolExecutor</strong></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/86c90d21d5524f9b98a3f2b45fbddfe5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>首先都是类似于这样定义一个线程池，里面实现线程池的异常策略。</p><p>这个线程池的异常策略就是用的策略模式的思想。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/15b5bff7cb6c4d77a97ca5dff25ab060~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在源码中有RejectedExecutionHandler这个抽象异常策略接口，同时它也有四种拒绝策略。关系图如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/46f0039d6cdb4a6ab6c85b5f028a40b2~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1e16d4b6d9dc48cbb782f28bbfa360ce~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这就是在框架中的体现了，根据自己的业务场景，合理的选择线程池的异常策略。</p><h3 id="业务改造举例"><a href="#业务改造举例" class="headerlink" title="业务改造举例"></a>业务改造举例</h3><p>在真实的业务场景中策略模式也还是应用很多的。</p><p>在社交电商中分享商品是一个很重要的环节，假设现在要我们实现一个分享图片功能，比如当前有 单商品、多商品、下单、会场、邀请、小程序链接等等多种分享场景。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4120a446ad4d43a0aff9a2ae50c79f06~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>针对上线这个流程图先用if else语句做一个普通业务代码判断，就像下面的这中方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleItemShare</span> </span>&#123;<br>    <span class="hljs-comment">// 单商品</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(String param)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前分享图片是&quot;</span> + param);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiItemShare</span> </span>&#123;<br>    <span class="hljs-comment">// 多商品</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(String param)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前分享图片是&quot;</span> + param);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderItemShare</span> </span>&#123;<br>    <span class="hljs-comment">// 下单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">(String param)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前分享图片是&quot;</span> + param);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Integer shareType = <span class="hljs-number">1</span>;<br>       <span class="hljs-comment">// 测试业务逻辑</span><br>        <span class="hljs-keyword">if</span> (shareType.equals(ShareType.SINGLE.getCode())) &#123;<br>            SingleItemShare singleItemShare = <span class="hljs-keyword">new</span> SingleItemShare();<br>            singleItemShare.algorithm(<span class="hljs-string">&quot;单商品&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shareType.equals(ShareType.MULTI.getCode())) &#123;<br>            MultiItemShare multiItemShare = <span class="hljs-keyword">new</span> MultiItemShare();<br>            multiItemShare.algorithm(<span class="hljs-string">&quot;多商品&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shareType.equals(ShareType.ORDER.getCode())) &#123;<br>            OrderItemShare orderItemShare = <span class="hljs-keyword">new</span> OrderItemShare();<br>            orderItemShare.algorithm(<span class="hljs-string">&quot;下单&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;未知分享类型&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// .....省略更多分享场景</span><br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ShareType</span> </span>&#123;<br>        SINGLE(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;单商品&quot;</span>),<br>        MULTI(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;多商品&quot;</span>),<br>        ORDER(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;下单&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 场景对应的编码</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> Integer code;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 业务场景描述</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String desc;<br>        ShareType(Integer code, String desc) &#123;<br>            <span class="hljs-keyword">this</span>.code = code;<br>            <span class="hljs-keyword">this</span>.desc = desc;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> code;<br>        &#125;<br>       <span class="hljs-comment">// 省略 get set 方法</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里大家可以看到每新加一种分享类型，就需要加一次if else 判断，当如果有十几种场景的时候那代码整体就会非常的长，看起来给人的感觉也不是很舒服。</p><p>接下来就看看如何用策略模式进行重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ShareStrategy</span> </span>&#123;<br>    <span class="hljs-comment">// 定义分享策略执行方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shareAlgorithm</span><span class="hljs-params">(String param)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderItemShare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ShareStrategy</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shareAlgorithm</span><span class="hljs-params">(String param)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前分享图片是&quot;</span> + param);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 省略 MultiItemShare以及SingleItemShare策略</span><br><br><span class="hljs-comment">// 分享工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareFactory</span> </span>&#123;<br><span class="hljs-comment">// 定义策略枚举</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ShareType</span> </span>&#123;<br>        SINGLE(<span class="hljs-string">&quot;single&quot;</span>, <span class="hljs-string">&quot;单商品&quot;</span>),<br>        MULTI(<span class="hljs-string">&quot;multi&quot;</span>, <span class="hljs-string">&quot;多商品&quot;</span>),<br>        ORDER(<span class="hljs-string">&quot;order&quot;</span>, <span class="hljs-string">&quot;下单&quot;</span>);<br>        <span class="hljs-comment">// 场景对应的编码</span><br>        <span class="hljs-keyword">private</span> String code;<br>       <br>        <span class="hljs-comment">// 业务场景描述</span><br>        <span class="hljs-keyword">private</span> String desc;<br>        ShareType(String code, String desc) &#123;<br>            <span class="hljs-keyword">this</span>.code = code;<br>            <span class="hljs-keyword">this</span>.desc = desc;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> code;<br>        &#125;<br>       <span class="hljs-comment">// 省略 get set 方法</span><br>    &#125;<br><span class="hljs-comment">// 定义策略map缓存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, ShareStrategy&gt; shareStrategies = <span class="hljs-keyword">new</span>       HashMap&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        shareStrategies.put(<span class="hljs-string">&quot;order&quot;</span>, <span class="hljs-keyword">new</span> OrderItemShare());<br>        shareStrategies.put(<span class="hljs-string">&quot;single&quot;</span>, <span class="hljs-keyword">new</span> SingleItemShare());<br>        shareStrategies.put(<span class="hljs-string">&quot;multi&quot;</span>, <span class="hljs-keyword">new</span> MultiItemShare());<br>    &#125;<br>    <span class="hljs-comment">// 获取指定策略</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShareStrategy <span class="hljs-title">getShareStrategy</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-keyword">null</span> || type.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;type should not be empty.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> shareStrategies.get(type);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 测试demo</span><br>        String shareType = <span class="hljs-string">&quot;order&quot;</span>;<br>        ShareStrategy shareStrategy = ShareFactory.getShareStrategy(shareType);<br>        shareStrategy.shareAlgorithm(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">// 输出结果：当前分享图片是order</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里策略模式就已经改造完了。在client请求端，根本看不到那么多的if else判断，只需要传入对应的策略方式即可，这里我们维护了一个策略缓存map，在直接调用的ShareFactory获取策略的时候就直接是从换种获取策略类对象。</p><p>这就已经达到了行为解偶的思想。同时也避免了长串的if else 判断。</p><p>优点：</p><blockquote><ul><li>算法策略可以自由实现切换</li><li>扩展性好，加一个策略，只需要增加一个类</li></ul></blockquote><p>缺点：</p><blockquote><ul><li>策略类数量多</li><li>需要维护一个策略枚举，让别人知道你当前具有哪些策略</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就讲完了策略模式，整体看上去其实还是比较简单的，还是那句话学习设计模式我们还是要学习每种设计模式的思想，任何一种设计模式存在即合理。当然也不要因为设计模式而设计代码，那样反而得不偿失。</p>]]></content>
    
    
    
    <tags>
      
      <tag>策略模式</tag>
      
      <tag>if-else</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口上注解AOP拦截不到场景兼容</title>
    <link href="/blog/2021/06/08/%E6%8E%A5%E5%8F%A3%E4%B8%8A%E6%B3%A8%E8%A7%A3AOP%E6%8B%A6%E6%88%AA%E4%B8%8D%E5%88%B0%E5%9C%BA%E6%99%AF%E5%85%BC%E5%AE%B9/"/>
    <url>/blog/2021/06/08/%E6%8E%A5%E5%8F%A3%E4%B8%8A%E6%B3%A8%E8%A7%A3AOP%E6%8B%A6%E6%88%AA%E4%B8%8D%E5%88%B0%E5%9C%BA%E6%99%AF%E5%85%BC%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>在 Java 的开发过程中，面向接口的编程可能是大家的常态，切面也是各位大佬使用 Spring 时，或多或少会使用的一项基本技能；结果这两个碰到一起，有意思的事情就发生了，接口方法上添加注解，面向注解的切面拦截，居然不生效</p><p>这就有点奇怪了啊，最开始遇到这个问题时，表示难以相信；事务注解也挺多是写在接口上的，好像也没有遇到这个问题（难道是也不生效，只是自己没有关注到？）</p><p>接下来我们好好瞅瞅，这到底是怎么个情况</p><h2 id="I-场景复现"><a href="#I-场景复现" class="headerlink" title="I. 场景复现"></a>I. 场景复现</h2><p>这个场景复现相对而言比较简单了，一个接口，一个实现类；一个注解，一个切面完事</p><h3 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1. 项目环境"></a>1. 项目环境</h3><p>采用<code>SpringBoot 2.2.1.RELEASE</code> + <code>IDEA</code> + <code>maven</code> 进行开发</p><p>添加 aop 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="2-复现-case"><a href="#2-复现-case" class="headerlink" title="2. 复现 case"></a>2. 复现 case</h3><p>声明一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AnoDot &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>拦截切面，下面这段代码来自之前分享的博文 <a href="https://spring.hhui.top/spring-blog/2019/03/13/190313-SpringCloud%E5%BA%94%E7%94%A8%E7%AF%87%E4%B9%8BAOP%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/">【基础系列】AOP 实现一个日志插件（应用篇）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPLIT_SYMBOL = <span class="hljs-string">&quot;|&quot;</span>;<br><br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * com.git.hui.boot.aop.demo.*.*(..)) || @annotation(AnoDot)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Around(value = &quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doAround</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object res = <span class="hljs-keyword">null</span>;<br>        String req = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> &#123;<br>            req = buildReqLog(proceedingJoinPoint);<br>            res = proceedingJoinPoint.proceed();<br>            <span class="hljs-keyword">return</span> res;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            res = <span class="hljs-string">&quot;Un-Expect-Error&quot;</span>;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>            System.out.println(req + <span class="hljs-string">&quot;&quot;</span> + JSON.toJSONString(res) + SPLIT_SYMBOL + (end - start));<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">buildReqLog</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;<br>        <span class="hljs-comment">// 目标对象</span><br>        Object target = joinPoint.getTarget();<br>        <span class="hljs-comment">// 执行的方法</span><br>        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();<br>        <span class="hljs-comment">// 请求参数</span><br>        Object[] args = joinPoint.getArgs();<br><br>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(target.getClass().getName());<br>        builder.append(SPLIT_SYMBOL).append(method.getName()).append(SPLIT_SYMBOL);<br>        <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>            builder.append(JSON.toJSONString(arg)).append(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.substring(<span class="hljs-number">0</span>, builder.length() - <span class="hljs-number">1</span>) + SPLIT_SYMBOL;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后定义一个接口与实现类，注意下面的两个方法，一个注解在接口上，一个注解在实现类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseApi</span> </span>&#123;<br>    <span class="hljs-meta">@AnoDot</span><br>    <span class="hljs-function">String <span class="hljs-title">print</span><span class="hljs-params">(String obj)</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">print2</span><span class="hljs-params">(String obj)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseApiImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BaseApi</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">print</span><span class="hljs-params">(String obj)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ano in interface:&quot;</span> + obj);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;return:&quot;</span> + obj;<br>    &#125;<br><br>    <span class="hljs-meta">@AnoDot</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">print2</span><span class="hljs-params">(String obj)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ano in impl:&quot;</span> + obj);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;return:&quot;</span> + obj;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试 case</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Application</span><span class="hljs-params">(BaseApi baseApi)</span> </span>&#123;<br>        System.out.println(baseApi.print(<span class="hljs-string">&quot;hello world&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br>        System.out.println(baseApi.print2(<span class="hljs-string">&quot;hello world&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行后输出结果如下（有图有真相，别说我骗你 🙃）</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/825c84d3c2e74897a4833c26aa1a4a8a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="3-事务注解测试"><a href="#3-事务注解测试" class="headerlink" title="3. 事务注解测试"></a>3. 事务注解测试</h3><p>上面这个不生效，那我们通常写在接口上的事务注解，会生效么？</p><p>添加 mysql 操作的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>数据库配置 <code>application.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">## DataSource</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/story?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2b8</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string"></span><br><br></code></pre></td></tr></table></figure><p>接下来就是我们的接口定义与实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransApi</span> </span>&#123;<br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransApiImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TransApi</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        String sql = <span class="hljs-string">&quot;replace into money (id, name, money) values (&quot;</span> + id + <span class="hljs-string">&quot;, &#x27;事务测试&#x27;, 200)&quot;</span>;<br>        jdbcTemplate.execute(sql);<br><br>        Object ans = jdbcTemplate.queryForMap(<span class="hljs-string">&quot;select * from money where id = 111&quot;</span>);<br>        System.out.println(ans);<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;事务回滚&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意上面的 update 方法，事务注解在接口上，接下来我们需要确认调用之后，是否会回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Application</span><span class="hljs-params">(TransApiImpl transApi, JdbcTemplate jdbcTemplate)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            transApi.update(<span class="hljs-number">111</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br><br>        System.out.println(jdbcTemplate.queryForList(<span class="hljs-string">&quot;select * from money where id=111&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4d903bbd1356440ab79cf56fb94f6b10~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>回滚了，有木有！！！</p><p>果然是没有问题的，吓得我一身冷汗，这要是有问题，那就…(不敢想不敢想)</p><p>所以问题来了，为啥第一种方式不生效呢？？？</p><h2 id="II-接口注解切面拦截实现"><a href="#II-接口注解切面拦截实现" class="headerlink" title="II. 接口注解切面拦截实现"></a>II. 接口注解切面拦截实现</h2><p>暂且按下探寻究竟的欲望，先看下如果想让我们可以拦截接口上的注解，可以怎么做呢?</p><p>既然拦截不上，多半是因为子类没有继承父类的注解，所以在进行切点匹配时，匹配不到；既然如此，那就让它在匹配时，找下父类看有没有对应的注解</p><h3 id="1-自定义-Pointcut"><a href="#1-自定义-Pointcut" class="headerlink" title="1. 自定义 Pointcut"></a>1. 自定义 Pointcut</h3><p>虽说是自定义，但也没有要求我们直接实现这个接口，我们选择<code>StaticMethodMatcherPointcut</code>来补全逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.core.annotation.AnnotatedElementUtils;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogPointCut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StaticMethodMatcherPointcut</span> </span>&#123;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; aClass)</span> </span>&#123;<br>        <span class="hljs-comment">// 直接使用spring工具包，来获取method上的注解（会找父类上的注解）</span><br>        <span class="hljs-keyword">return</span> AnnotatedElementUtils.hasAnnotation(method, AnoDot.class);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接下来我们采用声明式来实现切面逻辑</p><h3 id="2-自定义-Advice"><a href="#2-自定义-Advice" class="headerlink" title="2. 自定义 Advice"></a>2. 自定义 Advice</h3><p>这个 advice 就是我们需要执行的切面逻辑，和上面的日志输出差不多，区别在于参数不同</p><p>自定义 advice 实现自接口<code>MethodInterceptor</code>，顶层接口是<code>Advice</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SPLIT_SYMBOL = <span class="hljs-string">&quot;|&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object res = <span class="hljs-keyword">null</span>;<br>        String req = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> &#123;<br>            req = buildReqLog(methodInvocation);<br>            res = methodInvocation.proceed();<br>            <span class="hljs-keyword">return</span> res;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            res = <span class="hljs-string">&quot;Un-Expect-Error&quot;</span>;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>            System.out.println(<span class="hljs-string">&quot;ExtendLogAspect:&quot;</span> + req + <span class="hljs-string">&quot;&quot;</span> + JSON.toJSONString(res) + SPLIT_SYMBOL + (end - start));<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">buildReqLog</span><span class="hljs-params">(MethodInvocation joinPoint)</span> </span>&#123;<br>        <span class="hljs-comment">// 目标对象</span><br>        Object target = joinPoint.getThis();<br>        <span class="hljs-comment">// 执行的方法</span><br>        Method method = joinPoint.getMethod();<br>        <span class="hljs-comment">// 请求参数</span><br>        Object[] args = joinPoint.getArguments();<br><br>        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(target.getClass().getName());<br>        builder.append(SPLIT_SYMBOL).append(method.getName()).append(SPLIT_SYMBOL);<br>        <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>            builder.append(JSON.toJSONString(arg)).append(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.substring(<span class="hljs-number">0</span>, builder.length() - <span class="hljs-number">1</span>) + SPLIT_SYMBOL;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-自定义-Advisor"><a href="#3-自定义-Advisor" class="headerlink" title="3. 自定义 Advisor"></a>3. 自定义 Advisor</h3><p>将上面自定义的切点 pointcut 与通知 advice 整合，实现我们的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAdvisor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactoryPointcutAdvisor</span> </span>&#123;<br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> Pointcut logPointCut;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> logPointCut;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-最后注册切面"><a href="#4-最后注册切面" class="headerlink" title="4. 最后注册切面"></a>4. 最后注册切面</h3><p>说是注册，实际上就是声明为 bean，丢到 spring 容器中而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> LogAdvisor <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    LogAdvisor logAdvisor = <span class="hljs-keyword">new</span> LogAdvisor();<br>    <span class="hljs-comment">// 自定义实现姿势</span><br>    logAdvisor.setLogPointCut(<span class="hljs-keyword">new</span> LogPointCut());<br>    logAdvisor.setAdvice(<span class="hljs-keyword">new</span> LogAdvice());<br>    <span class="hljs-keyword">return</span> logAdvisor;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后再次执行上面的测试用例，输出如下</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/7ca7e497951640048fb6b0d15e458629~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>接口上的注解也被拦截了，但是最后一个耗时的输出，有点夸张了啊，采用上面这种方式，这个耗时有点夸张了啊，生产环境这么一搞，岂不是分分钟卷铺盖的节奏</p><ul><li>可以借助 StopWatch 来查看到底是哪里的开销增加了这么多 （关于 StopWatch 的使用，下篇介绍）</li><li>单次执行的统计偏差问题，将上面的调用，执行一百遍之后，再看耗时，趋于平衡，如下图</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/c3fa3c026e67418e90a9367986331e45~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><p>到这里，我们实现了接口上注解的拦截，虽说解决了我们的需求，但是疑惑的地方依然没有答案</p><ul><li>为啥接口上的注解拦截不到 ？</li><li>为啥事务注解，放在接口上可以生效，事务注解的实现机制是怎样的？</li><li>自定义的切点，可以配合我们的注解来玩么？</li><li>为什么首次执行时，耗时比较多；多次执行之后，则耗时趋于正常？</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>注解</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA同一IP访问同一接口进行频率限制</title>
    <link href="/blog/2021/06/07/JAVA%E5%90%8C%E4%B8%80IP%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6/"/>
    <url>/blog/2021/06/07/JAVA%E5%90%8C%E4%B8%80IP%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-如何对同一IP访问同一接口进行每秒、每分钟、每小时频率限制"><a href="#1-如何对同一IP访问同一接口进行每秒、每分钟、每小时频率限制" class="headerlink" title="1.如何对同一IP访问同一接口进行每秒、每分钟、每小时频率限制"></a>1.如何对同一IP访问同一接口进行每秒、每分钟、每小时频率限制</h4><p>话不多说，直接开干，首先写一个注解类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接口限流</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rs</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD,ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> VisitLimit &#123;<br>    <span class="hljs-comment">//标识 指定sec时间段内的访问次数限制</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">limit</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 5</span>;  <br>    <span class="hljs-comment">//标识 时间段</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">sec</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用注解的原因是：我们使用拦截器在请求处理之前，检查某个请求接口是否有该注解，如果有该注解，获取访问次数和时间段（比如：在1s中只能访问一次）。接下来我们就来写一个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.test.annotation.VisitLimit;<br><span class="hljs-keyword">import</span> org.test.exception.BusinessException;<br><span class="hljs-keyword">import</span> org.test.redis.RedisCache;<br><span class="hljs-keyword">import</span> org.test.service.redis.RedisService;<br><span class="hljs-keyword">import</span> org.test.util.IPUtils;<br><span class="hljs-keyword">import</span> org.test.util.RedisUtils;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitLimitInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HandlerInterceptorAdapter</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisUtils redisService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理请求之前被调用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>            HandlerMethod handlerMethod = (HandlerMethod) handler;<br>            Method method = handlerMethod.getMethod();<br>            <span class="hljs-keyword">if</span> (!method.isAnnotationPresent(VisitLimit.class)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            VisitLimit accessLimit = method.getAnnotation(VisitLimit.class);<br>            <span class="hljs-keyword">if</span> (accessLimit == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> limit = accessLimit.limit();<br>            <span class="hljs-keyword">long</span> sec = accessLimit.sec();<br>            String key = IPUtils.getIpAddr(request) + request.getRequestURI();<br>            Integer maxLimit =<span class="hljs-keyword">null</span>;<br>            Object value =redisService.get(key);<br>            <span class="hljs-keyword">if</span>(value!=<span class="hljs-keyword">null</span> &amp;&amp; !value.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            maxLimit = Integer.valueOf(String.valueOf(value));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxLimit == <span class="hljs-keyword">null</span>) &#123;<br>            redisService.set(key, <span class="hljs-string">&quot;1&quot;</span>, sec);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxLimit &lt; limit) &#123;<br>            Integer i = maxLimit+<span class="hljs-number">1</span>;<br>            redisService.set(key, i.toString(), sec);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//              output(response, &quot;请求太频繁!&quot;);</span><br><span class="hljs-comment">//            return false;</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(<span class="hljs-number">500</span>,<span class="hljs-string">&quot;请求太频繁!&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br> <br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br> <br>    &#125;<br></code></pre></td></tr></table></figure><p>这里用到了redis,解释一下redis的key（IP+URL）记录了某个ip访问某个接口，value存的是访问的次数，加上一个过期时间，过期时间就是我们在注解上赋值的值。</p><p>这里的redis的部分代码也贴出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtils</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 写入缓存设置时效时间</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 有效时间，单位秒</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key, Object value, Long expireTime)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();<br>            operations.set(key, value);<br>            redisTemplate.expire(key, expireTime, TimeUnit.SECONDS);<br>            result = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>#怎么获取用户的真实IP呢???如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IP Utils</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> rs</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IPUtils</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(IPUtils.class);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取IP地址</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用Nginx等反向代理软件， 则不能通过request.getRemoteAddr()获取IP地址</span><br><span class="hljs-comment"> * 如果使用了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP地址，X-Forwarded-For中第一个非unknown的有效IP字符串，则为真实IP地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getIpAddr</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>    String ip = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ip = request.getHeader(<span class="hljs-string">&quot;x-forwarded-for&quot;</span>);<br>         <span class="hljs-keyword">if</span> (ip != <span class="hljs-keyword">null</span> &amp;&amp; ip.length() != <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;<br>             <span class="hljs-comment">// 多次反向代理后会有多个ip值，第一个ip才是真实ip</span><br>             <span class="hljs-keyword">if</span>( ip.indexOf(<span class="hljs-string">&quot;,&quot;</span>)!=-<span class="hljs-number">1</span> )&#123;<br>                 ip = ip.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>];<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (ip == <span class="hljs-keyword">null</span> || ip.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;<br>             ip = request.getHeader(<span class="hljs-string">&quot;Proxy-Client-IP&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (ip == <span class="hljs-keyword">null</span> || ip.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;<br>             ip = request.getHeader(<span class="hljs-string">&quot;WL-Proxy-Client-IP&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (ip == <span class="hljs-keyword">null</span> || ip.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;<br>             ip = request.getHeader(<span class="hljs-string">&quot;HTTP_CLIENT_IP&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (ip == <span class="hljs-keyword">null</span> || ip.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;<br>             ip = request.getHeader(<span class="hljs-string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (ip == <span class="hljs-keyword">null</span> || ip.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;<br>             ip = request.getHeader(<span class="hljs-string">&quot;X-Real-IP&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (ip == <span class="hljs-keyword">null</span> || ip.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;<br>             ip = request.getRemoteAddr();<br>         &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(<span class="hljs-string">&quot;IPUtils ERROR &quot;</span>, e);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ip;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>下面来正式使用一下</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@VisitLimit</span>(limit = <span class="hljs-number">1</span>, sec = <span class="hljs-number">1</span>)<br><span class="hljs-variable">@RequestMapping</span>(value = <span class="hljs-string">&quot;/close&quot;</span>, method = RequestMethod.POST)<br></code></pre></td></tr></table></figure><p>这种方式不能很好的应对突发请求，需要对这一类情形平滑处理，比如200ms处理一个请求，下面就到<strong>令牌桶</strong>出场了！</p><h2 id="二、令牌桶实战介绍"><a href="#二、令牌桶实战介绍" class="headerlink" title="二、令牌桶实战介绍"></a>二、令牌桶实战介绍</h2><p>2.1 先来个总结吧，让大家分清什么时候用令牌桶，什么时候用漏桶</p><ul><li>令牌桶：生产一个令牌消费一个</li><li>漏桶： 处理大流量，并且以固定的速度平滑处理</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/14ff9094e5dd4cdcb351af00a3ce0f55~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>使用场景：geteway网关</p><p>Bucket4j是基于令牌桶算法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.test.gateway.filter.limit;<br><br><span class="hljs-keyword">import</span> java.time.Duration;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.core.Ordered;<br><span class="hljs-keyword">import</span> org.springframework.core.io.buffer.DataBuffer;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpHeaders;<br><span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;<br><span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><br><span class="hljs-keyword">import</span> io.github.bucket4j.Bandwidth;<br><span class="hljs-keyword">import</span> io.github.bucket4j.Bucket;<br><span class="hljs-keyword">import</span> io.github.bucket4j.Bucket4j;<br><span class="hljs-keyword">import</span> io.github.bucket4j.Refill;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RateLimitByIpFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GatewayFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(RateLimitByIpFilter.class);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> refillTokens;<br><br><span class="hljs-keyword">private</span> Duration refillDuration;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Bucket&gt; CACHE = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RateLimitByIpFilter</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RateLimitByIpFilter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">int</span> refillTokens, Duration refillDuration)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.capacity = capacity;<br><span class="hljs-keyword">this</span>.refillTokens = refillTokens;<br><span class="hljs-keyword">this</span>.refillDuration = refillDuration;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>String ip = getIpAddr(exchange.getRequest());<br><span class="hljs-keyword">if</span> (ip.indexOf(<span class="hljs-string">&quot;192.168&quot;</span>) != -<span class="hljs-number">1</span> || ip.indexOf(<span class="hljs-string">&quot;172.31.202&quot;</span>) != -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> chain.filter(exchange);<br>&#125;<br>Bucket bucket = CACHE.computeIfAbsent(ip, k -&gt; createNewBucket());<br>logger.info(<span class="hljs-string">&quot;限频来访ip: &quot;</span> + ip + <span class="hljs-string">&quot;, 可用令牌数量：&quot;</span> + bucket.getAvailableTokens());<br><span class="hljs-keyword">if</span> (bucket.tryConsume(<span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> chain.filter(exchange);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 不合法(超过限流)</span><br>ServerHttpResponse response = exchange.getResponse();<br><span class="hljs-comment">// 设置headers</span><br>HttpHeaders httpHeaders = response.getHeaders();<br>httpHeaders.add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json; charset=UTF-8&quot;</span>);<br>httpHeaders.add(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-store, no-cache, must-revalidate, max-age=0&quot;</span>);<br><span class="hljs-comment">// 设置body</span><br>String warningStr = <span class="hljs-string">&quot;&#123;\&quot;code\&quot;:\&quot;500\&quot;,\&quot;message\&quot;:\&quot;超过限流\&quot;&#125;&quot;</span>;<br>DataBuffer bodyDataBuffer = response.bufferFactory().wrap(warningStr.getBytes());<br><span class="hljs-keyword">return</span> response.writeWith(Mono.just(bodyDataBuffer));<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Bucket <span class="hljs-title">createNewBucket</span><span class="hljs-params">()</span> </span>&#123;<br>Refill refill = Refill.of(refillTokens, refillDuration);<br>Bandwidth limit = Bandwidth.classic(capacity, refill);<br><span class="hljs-keyword">return</span> Bucket4j.builder().addLimit(limit).build();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getIpAddr</span><span class="hljs-params">(ServerHttpRequest request)</span> </span>&#123;<br>String ip = <span class="hljs-string">&quot;&quot;</span>;<br>String str = request.getHeaders().getFirst(<span class="hljs-string">&quot;x-forwarded-for&quot;</span>);<br><span class="hljs-keyword">if</span> (StringUtils.isEmpty(str)) &#123;<br>ip = request.getRemoteAddress().getAddress().getHostAddress();<br>logger.info(<span class="hljs-string">&quot;通过address方式限流获取到的IP为：&quot;</span> + ip);<br><span class="hljs-keyword">return</span> ip;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>String[] ips = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">for</span> (String s : ips) &#123;<br><span class="hljs-keyword">if</span> (s.indexOf(<span class="hljs-string">&quot;192.168&quot;</span>) != -<span class="hljs-number">1</span> || s.indexOf(<span class="hljs-string">&quot;172.31.202&quot;</span>) != -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>ip = ip + s + <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br>ip = ip.substring(<span class="hljs-number">0</span>, ip.length() - <span class="hljs-number">1</span>);<br>logger.info(<span class="hljs-string">&quot;通过x-forwarded-for限流获取到的IP，且过滤掉内网后的地址为：&quot;</span> + ip);<br><span class="hljs-keyword">if</span> (ip.indexOf(<span class="hljs-string">&quot;,&quot;</span>) != -<span class="hljs-number">1</span>) &#123;<br>ip = ip.substring(<span class="hljs-number">0</span>, ip.indexOf(<span class="hljs-string">&quot;,&quot;</span>));<br><span class="hljs-keyword">return</span> ip.trim();<br>&#125;<br><span class="hljs-keyword">return</span> ip.trim();<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>配置route: TEST-AUTH/**的api接口都会路由到TEST-AUTH服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GateWayApplication</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(GateWayApplication.class, args);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">routeLocator</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> </span>&#123;<br><span class="hljs-keyword">return</span> builder.routes()<br><span class="hljs-comment">// 认证中心</span><br>.route(r -&gt; r.path(<span class="hljs-string">&quot;/TEST-AUTH/**&quot;</span>)<br>.filters(f -&gt; f.stripPrefix(<span class="hljs-number">1</span>).filter(<span class="hljs-keyword">new</span> RateLimitByIpFilter(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, Duration.ofSeconds(<span class="hljs-number">1</span>))))<br>.uri(<span class="hljs-string">&quot;lb://TEST-AUTH&quot;</span>).id(<span class="hljs-string">&quot;TEST-AUTH&quot;</span>))<br>.build();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、分布式限流（这里摘自京东抢购业务）"><a href="#三、分布式限流（这里摘自京东抢购业务）" class="headerlink" title="三、分布式限流（这里摘自京东抢购业务）"></a>三、分布式限流（这里摘自京东抢购业务）</h2><p>使用Redis+Lua的方式来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">local key = <span class="hljs-string">&quot;rate.limit:&quot;</span> .. KEYS[<span class="hljs-number">1</span>] --限流KEY<br>local limit = tonumber(ARGV[<span class="hljs-number">1</span>])        --限流大小<br>local current = tonumber(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, key) or <span class="hljs-string">&quot;0&quot;</span>)<br><span class="hljs-keyword">if</span> current + <span class="hljs-number">1</span> &gt; limit then --如果超出限流大小<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">else</span>  --请求数+<span class="hljs-number">1</span>，并设置<span class="hljs-number">1</span>秒过期<br>  redis.call(<span class="hljs-string">&quot;INCRBY&quot;</span>, key,<span class="hljs-string">&quot;1&quot;</span>)<br>   redis.call(<span class="hljs-string">&quot;expire&quot;</span>, key,<span class="hljs-string">&quot;1&quot;</span>)<br>   <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span><br>end<br>复制代码<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, URISyntaxException </span>&#123;<br>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    File luaFile = <span class="hljs-keyword">new</span> File(RedisLimitRateWithLUA.class.getResource(<span class="hljs-string">&quot;/&quot;</span>).toURI().getPath() + <span class="hljs-string">&quot;limit.lua&quot;</span>);<br>    String luaScript = FileUtils.readFileToString(luaFile);<br><br>    String key = <span class="hljs-string">&quot;ip:&quot;</span> + System.currentTimeMillis()/<span class="hljs-number">1000</span>; <span class="hljs-comment">// 当前秒</span><br>    String limit = <span class="hljs-string">&quot;5&quot;</span>; <span class="hljs-comment">// 最大限制</span><br>    List&lt;String&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    keys.add(key);<br>    List&lt;String&gt; args = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    args.add(limit);<br>    Long result = (Long)(jedis.eval(luaScript, keys, args)); <span class="hljs-comment">// 执行lua脚本，传入参数</span><br>    <span class="hljs-keyword">return</span> result == <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>简单说明一下：redis k = rate.limit:ip:当前秒 V: 5</p>]]></content>
    
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程条件下分段处理List集合</title>
    <link href="/blog/2021/06/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%88%86%E6%AE%B5%E5%A4%84%E7%90%86List%E9%9B%86%E5%90%88/"/>
    <url>/blog/2021/06/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%88%86%E6%AE%B5%E5%A4%84%E7%90%86List%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>第一次接触到多线程处理同一个任务，是使用IO多线程下载文件，之后也一直没有再处理这一块的任务，直到前几天有同事问我，为什么多线程处理一个list集合会出现各种bug，以及如何使用多线程的方式处理同一个list集合。</p><p>第一、为什么会出现类似于重复处理某一个模块的问题？</p><p>我们都知道，在Java中，每个线程都有自己独立的工作内存，线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</p><p>如果线程1的修改内容想被线程2得到，那么线程1工作内存中修改后的共享变量需要先刷新到主内存中，再把主内存中更新过的共享变量更新到工作内存2中。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/fd0ed7fd279d498fb0f7ceb8288fabc0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这个时候一般我们是考虑使用java中各种同步化的方法，首先，因为是需要高效处理list集合，所以可以排除synchronized方法，于是我想到了使用CompletionService操作异步任务。</p><p>大家可以在这篇文章看到具体的详解： <a href="https://juejin.cn/post/6908882835235405832">【进阶之路】线程池拓展与CompletionService操作异步任务</a></p><h2 id="一、CompletionService"><a href="#一、CompletionService" class="headerlink" title="一、CompletionService"></a>一、CompletionService</h2><p>首先，按照之前文章的方法自定义一个WeedThreadPool</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeedThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span>&lt;<span class="hljs-type">Long</span>&gt; startTime =<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> log =<span class="hljs-type">Logger</span>.getLogger(<span class="hljs-string">&quot;WeedThreadPool&quot;</span>);<br>    <span class="hljs-comment">//统计执行次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> numTasks =<span class="hljs-keyword">new</span> <span class="hljs-type">AtomicLong</span>();<br>    <span class="hljs-comment">//统计总执行时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> totalTime =<span class="hljs-keyword">new</span> <span class="hljs-type">AtomicLong</span>();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里是实现线程池的构造方法，我随便选了一个，大家可以根据自己的需求找到合适的构造方法</span><br><span class="hljs-comment">     */</span><br>    public <span class="hljs-type">WeedThreadPool</span>(int corePoolSize, int maximumPoolSize, long keepAliveTime, <span class="hljs-type">TimeUnit</span> unit, <span class="hljs-type">BlockingQueue</span>&lt;<span class="hljs-type">Runnable</span>&gt; workQueue) &#123;<br>        <span class="hljs-keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后就是实现线程池处理list集合的方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> WeedExecutorServiceDemo &#123;<br>    BlockingQueue&lt;Runnable&gt; taskQueue;<br>    final static WeedThreadPool weedThreadPool = <span class="hljs-built_in">new</span> WeedThreadPool(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS, <span class="hljs-built_in">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>));<br>    // 开始时间<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws InterruptedException, ExecutionException &#123;<br>        //记录任务开始时间<br>        long start = <span class="hljs-keyword">System</span>.currentTimeMillis();<br>        CompletionService&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; cs = <span class="hljs-built_in">new</span> ExecutorCompletionService&lt;&gt;(weedThreadPool);<br>        <span class="hljs-type">int</span> tb=<span class="hljs-number">1</span>;<br>        //生成集合<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; list1 =<span class="hljs-built_in">new</span> ArrayList();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            List&lt;<span class="hljs-type">Integer</span>&gt; list =<span class="hljs-built_in">new</span> ArrayList();<br>            //随机生成任务处理<br>            <span class="hljs-type">int</span> hb=tb;<br>            tb =tb*<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> finalTb = tb;<br>            cs.submit(<span class="hljs-built_in">new</span> Callable&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt;()&#123;<br><br>                @Override<br>                <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = hb; j&lt; finalTb; j++)&#123;<br>                        list.<span class="hljs-keyword">add</span>(j);<br>                    &#125;<br>                    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+&quot;[&quot;+list+&quot;]&quot;);<br><br>                    <span class="hljs-keyword">return</span> list;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        //注意在处理完毕后结束任务<br>        weedThreadPool.shutdown();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Future&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; future = cs.take();<br>            <span class="hljs-keyword">if</span> (future != <span class="hljs-keyword">null</span>) &#123;<br>                list1.<span class="hljs-keyword">add</span>(future.<span class="hljs-keyword">get</span>());<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(future.<span class="hljs-keyword">get</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">System</span>.err.println(&quot;执行任务消耗了 ：&quot; + (<span class="hljs-keyword">System</span>.currentTimeMillis() - <span class="hljs-keyword">start</span>) + &quot;毫秒&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;結果[&quot;+list1.size()+&quot;]===&quot;+list1);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>处理结果：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/55d934b7d65b4c41abd4f567529f9c5b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>从结果上来看，还是比较美好的，通过CompletionService能够比较快速地分段处理任务，我之前也有提过，合理的线程池大小设计有助于提高任务的处理效率，网上通用的设置方法一般是这样的：</p><blockquote><p>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</p></blockquote><p>进而得出</p><blockquote><p>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p></blockquote><h2 id="二、ForkJoinPool"><a href="#二、ForkJoinPool" class="headerlink" title="二、ForkJoinPool"></a>二、ForkJoinPool</h2><p>当然，除了使用CompletionService之外，也可以使用ForkJoinPool来设计一个处理方法。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4f251ca321074c22b4f3a09df402a5cf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>ForkJoinPool和ThreadPoolExecutor都是继承自AbstractExecutorService抽象类，所以它和ThreadPoolExecutor的使用几乎没有多少区别。其核心思想是将大的任务拆分成多个小任务，然后在将多个小任务处理汇总到一个结果上。</p><p>ForkJoinPool框架通过初始化ForkJoinTask来执行任务，并提供了以下两个子类：</p><ul><li><strong>RecursiveAction</strong>：用于没有返回结果的任务。</li><li><strong>RecursiveTask</strong> ：用于有返回结果的任务。</li></ul><p>我们实现的过程中可以使用RecursiveTask方法来分段处理list集合。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class RecursiveTaskDemo &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue(<span class="hljs-number">10</span>));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> totalRow = <span class="hljs-number">53000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> splitRow = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-comment">//先循环生成待待处理集合</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(totalRow);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; totalRow; i++) &#123;<br>            list.<span class="hljs-built_in">add</span>(i);<br>        &#125;<br>        <span class="hljs-comment">//计算出需要创建的任务数</span><br>        <span class="hljs-built_in">int</span> loopNum = (<span class="hljs-built_in">int</span>)Math.<span class="hljs-built_in">ceil</span>((<span class="hljs-keyword">double</span>)totalRow/splitRow);<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(loopNum);<br>        ForkJoinTask&lt;List&gt; submit = pool.submit(<span class="hljs-keyword">new</span> MyTask(list, <span class="hljs-number">0</span>, list.<span class="hljs-built_in">size</span>()));<br><br>        List&lt;List&lt;Integer&gt;&gt;list1=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list1.<span class="hljs-built_in">add</span>(submit.<span class="hljs-built_in">get</span>());<br>        System.err.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;执行任务消耗了 ：&quot;</span> + (System.currentTimeMillis() - start) + <span class="hljs-string">&quot;毫秒&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;結果[&quot;</span>+list1.<span class="hljs-built_in">size</span>()+<span class="hljs-string">&quot;]===&quot;</span>+list1);<br>    &#125;<br>    <span class="hljs-comment">//继承RecursiveTask</span><br>    <span class="hljs-keyword">static</span> class MyTask extends RecursiveTask&lt;List&gt; &#123;<br>        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> startRow;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> endRow;<br><br>        <span class="hljs-keyword">public</span> MyTask(List&lt;Integer&gt; list, <span class="hljs-built_in">int</span> startRow, <span class="hljs-built_in">int</span> endRow) &#123;<br>            <span class="hljs-keyword">this</span>.list = list;<br>            <span class="hljs-keyword">this</span>.startRow = startRow;<br>            <span class="hljs-keyword">this</span>.endRow = endRow;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 递归处理数据，计算</span><br><span class="hljs-comment">         * @return</span><br><span class="hljs-comment">         */</span><br>        @Override<br>        <span class="hljs-keyword">protected</span> List compute() &#123;<br>            <span class="hljs-keyword">if</span> (endRow - startRow &lt;= splitRow) &#123;<br>                List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = startRow; i &lt; endRow; i++) &#123;<br>                    <span class="hljs-comment">//递归处理数据</span><br>                    ret.<span class="hljs-built_in">add</span>(list.<span class="hljs-built_in">get</span>(i));<br>                &#125;<br>                System.out.<span class="hljs-built_in">println</span>(Thread.currentThread().getName()+<span class="hljs-string">&quot;[&quot;</span>+ret+<span class="hljs-string">&quot;]&quot;</span>);<br>                <span class="hljs-keyword">return</span> ret;<br>            &#125;<br>            <span class="hljs-built_in">int</span> loopNum = (<span class="hljs-built_in">int</span>)Math.<span class="hljs-built_in">ceil</span>((<span class="hljs-keyword">double</span>)totalRow/splitRow);<br>            <span class="hljs-built_in">int</span> startRow = <span class="hljs-number">0</span>;<br>            List&lt;MyTask&gt; myTaskList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>                <span class="hljs-keyword">if</span> (startRow &gt; totalRow) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-built_in">int</span> endRow = Math.<span class="hljs-built_in">min</span>(startRow + splitRow, totalRow);<br>                System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;startRow：%s, endRow:%s&quot;</span>, startRow, endRow));<br>                myTaskList.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> MyTask(list, startRow, endRow));<br>                startRow += splitRow;<br>            &#125;<br>            <span class="hljs-comment">//调用不同线程上独立执行的任务</span><br>            invokeAll(myTaskList);<br>            List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">//归并</span><br>            <span class="hljs-keyword">for</span> (MyTask myTask : myTaskList) &#123;<br>                ret.addAll(myTask.<span class="hljs-built_in">join</span>());<br>            &#125;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>处理结果：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/5f4bebd2dd974fcdb763dc602a87b5c4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>通过上文展示的方法，大家可以在不加锁的方式来增加任务处理的效率，遇到类似于爬虫数据处理、数据迁移等场景都可以采用，实测效果还不错。当然，根据处理结果来分析，CompletionService的效率大概更高一些~。</p>]]></content>
    
    
    
    <tags>
      
      <tag>List</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GraphicsMagick文字水印及中文乱码</title>
    <link href="/blog/2021/06/05/GraphicsMagick%E6%96%87%E5%AD%97%E6%B0%B4%E5%8D%B0%E5%8F%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <url>/blog/2021/06/05/GraphicsMagick%E6%96%87%E5%AD%97%E6%B0%B4%E5%8D%B0%E5%8F%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>需求背景：</strong> 图片服务需要提供文字水印功能。支持自定义字体颜色、类型、透明度以及水印位置，对外暴露的字体类型是：楷体、宋体、黑体。</p></blockquote><p>这需求看似很简单，其实会有很多坑。下面一起来看下。<code>下面是个人在实现过程中遇到的问题，在查看官方文档以及相应博客下并没有找到很好的解决办法，如果其他大佬有更好的实现，欢迎在评论区一起讨论。</code></p><p><strong>官方文档：</strong></p><ul><li><a href="http://www.graphicsmagick.org/convert.html">www.graphicsmagick.org/convert.htm…</a></li><li><a href="http://www.graphicsmagick.org/composite.html">www.graphicsmagick.org/composite.h…</a></li></ul><h2 id="文字水印"><a href="#文字水印" class="headerlink" title="文字水印"></a>文字水印</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gm convert -font <span class="hljs-variable">$&#123;fontType&#125;</span> -fill <span class="hljs-variable">$&#123;color&#125;</span> -pointsize <span class="hljs-variable">$&#123;fontSize&#125;</span> -draw <span class="hljs-string">&quot;text <span class="hljs-variable">$&#123;dx&#125;</span>,<span class="hljs-variable">$&#123;dy&#125;</span> &#x27;<span class="hljs-variable">$&#123;textContent&#125;</span>&#x27;&quot;</span> <span class="hljs-variable">$&#123;sourceImgPath&#125;</span> <span class="hljs-variable">$&#123;distImgPath&#125;</span><br></code></pre></td></tr></table></figure><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><table><thead><tr><th>参数</th><th>定义</th></tr></thead><tbody><tr><td>fontType</td><td>字体类型</td></tr><tr><td>color</td><td>字体颜色</td></tr><tr><td>fontSize</td><td>字体大小</td></tr><tr><td>dx</td><td>水印位置</td></tr><tr><td>dy</td><td>水印位置</td></tr><tr><td>textContent</td><td>文字内容</td></tr><tr><td>sourceImgPath</td><td>源图片路径</td></tr><tr><td>distImgPath</td><td>目标图片路径</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>原图外网访问地址：<a href="https://cvte-dev-public.seewo.com/shan-test/f60e65b7440840708c3bc827d69adcca">cvte-dev-public.seewo.com/shan-test/f…</a></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/5967579d657a4dc0afb751b5c38a422a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><p>英文文字水印</p><ul><li>测试命令：<code>gm convert -font Helvetica -fill red -pointsize 50 -draw &quot;text 100,100 &#39;Hello World&#39;&quot; example.jpg test.jpg</code></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/56647254ca2349609d735619a64f2201~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p></li><li><p>中文文字水印（乱码）</p><ul><li>测试命令：<code>gm convert -font Helvetica -fill red -pointsize 50 -draw &quot;text 100,100 &#39;你好&#39;&quot; example.jpg test.jpg</code></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f5190b02a11446a4b13b322435b30abe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p></li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li><p>首先出现中文乱码应该是我们本机环境的字体库问题，但是我mac电脑上的字体集是支持中文字体的，更换字体类型并不能解决这个问题。</p></li><li><p>目前文字水印的命令是否可以满足需求？</p><ul><li><p>查看文档，没有找到可以指定文字透明度</p></li><li><p>文字位置对比现有服务商的水印位置有出入：</p><ul><li><p>测试用例：字体大小50px、位置（100,100），红色字体</p><ul><li><a href="https://cvte-dev-public.seewo.com/shan-test/f6a3b5adab244a3b9b19624b3ec32144">阿里云水印效果</a></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ca9b9b3bebf246b8a75898a6e75518c1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><a href="https://store-tg1.cvte.com/shan-test/ef3593ea21594c588ed91437e9f7ae21">七牛云水印效果</a></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2246c4f57d6d4b309fb4f184e8ab1bee~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p></li></ul></li></ul></li><li><p><strong>总结：</strong> 目前根据官方文档，并未找到对于文字水印透明度的参数设置，以及文字水印的位置与预期位置相差较大。这种方式无法满足需求，而且需要解决中文乱码问题，所以暂时不再往文字水印命令的方向去尝试。目前的想法是：先根据文字生成透明的临时图片，再将临时图片作为图片水印打到原图上，这种方式可以设置透明度。</p></li></ul><h2 id="图片水印"><a href="#图片水印" class="headerlink" title="图片水印"></a>图片水印</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gm composite -gravity <span class="hljs-variable">$&#123;gravity&#125;</span> -dissolve <span class="hljs-variable">$&#123;dissolve&#125;</span> -geometry +<span class="hljs-variable">$&#123;dx&#125;</span>+<span class="hljs-variable">$&#123;dy&#125;</span> <span class="hljs-variable">$&#123;tmpImgPath&#125;</span> <span class="hljs-variable">$&#123;sourceImgPath&#125;</span> <span class="hljs-variable">$&#123;distImgPath&#125;</span><br></code></pre></td></tr></table></figure><h3 id="参数解析-1"><a href="#参数解析-1" class="headerlink" title="参数解析"></a>参数解析</h3><table><thead><tr><th>参数</th><th>定义</th><th>参数范围</th></tr></thead><tbody><tr><td>gravity</td><td>水印相对位置</td><td>NorthWest：左上   North：中上   NorthEast：右上   West：左中   Center：中部   East：右中   SouthWest：左下   South：中下   SouthEast：右下</td></tr><tr><td>dissolve</td><td>水印透明度</td><td>[1, 100]   默认值：100，不透明</td></tr><tr><td>dx</td><td>指定水印的水平边距， 即距离图片边缘的水平距离。这个参数只有当水印位置是左上、左中、左下、右上、右中、右下才有意义</td><td></td></tr><tr><td>dy</td><td>指定水印的垂直边距，即距离图片边缘的垂直距离， 这个参数只有当水印位置是左上、中上、右上、左下、中下、右下才有意义</td><td></td></tr><tr><td>tmpImgPath</td><td>临时图片的路径</td><td></td></tr><tr><td>sourceImgPath</td><td>源图片路径</td><td></td></tr><tr><td>distImgPath</td><td>目标图片路径</td><td></td></tr></tbody></table><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a2666f43407c46958b5da37c958d41fe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>事先生成了临时文件（后面再教你们怎么玩）：<a href="https://cvte-dev-public.seewo.com/shan-test/b949becb4a064f989693026302f242ca">text.png</a></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/db0c061e7c2b4b18927892ec530a8c60~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>图片处理命令：<code>gm composite -gravity NorthWest -dissolve 100 -geometry +100+100 text.png example.jpg test.jpg</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e179c8c6f6994a1e9c718562de71efb5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>位置对了！</strong> 那接下来就是解决<strong>中文乱码问题</strong>了，生成临时文字图片还是需要解决字体库问题。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1、安装字体库"><a href="#1、安装字体库" class="headerlink" title="1、安装字体库"></a>1、安装字体库</h3><p>为了方便管理，我直接把需要的字体集放到项目中，在项目启动时，将字体集拷贝到操作系统，并进行 Map 映射。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/9e90e89b9e9d4d4aa48995a4bc03d8b2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>字体集文件需要可以自取：</p><ul><li><a href="https://cvte-dev-public.seewo.com/shan-test/f779c1d3572d4a6fb533c102c6cebe42">HeiTi.ttc</a>（黑体）</li><li><a href="https://cvte-dev-public.seewo.com/shan-test/b0f8219d926d4632aa1a60f57d74176e">KaiTi.ttf</a>（楷体）</li><li><a href="https://cvte-dev-public.seewo.com/shan-test/2c249a668d634d09b9986368c32d93b6">SongTi.ttc</a>（宋体）</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生成默认的中文字体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChineseFontComponent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Font&gt; chineseFontMap;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFont</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        chineseFontMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        String heiTiFontPath = <span class="hljs-string">&quot;font/HeiTi.ttc&quot;</span>;<br>        String kaiTiFontPath = <span class="hljs-string">&quot;font/KaiTi.ttf&quot;</span>;<br>        String songTiFontPath = <span class="hljs-string">&quot;font/SongTi.ttc&quot;</span>;<br>        createChineseFont(<span class="hljs-string">&quot;HeiTi&quot;</span>, heiTiFontPath);<br>        createChineseFont(<span class="hljs-string">&quot;KaiTi&quot;</span>, kaiTiFontPath);<br>        createChineseFont(<span class="hljs-string">&quot;SongTi&quot;</span>, songTiFontPath);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建中文字体</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key       字体类型的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fontPath  字体路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createChineseFont</span><span class="hljs-params">(String key, String fontPath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        log.info(<span class="hljs-string">&quot;初始化中文字体: &#123;&#125;, path: &#123;&#125;&quot;</span>, key, fontPath);<br>        InputStream fisInJar = <span class="hljs-keyword">new</span> ClassPathResource(fontPath).getInputStream();<br>        File file = File.createTempFile(<span class="hljs-string">&quot;Font-&quot;</span>, <span class="hljs-string">&quot;.ttf&quot;</span>);<br>        <span class="hljs-comment">//将jar包里的字体文件复制到操作系统的目录里</span><br>        OutputStream fosInOs = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> readLength = fisInJar.read(buffer);<br>        <span class="hljs-keyword">while</span> (readLength != -<span class="hljs-number">1</span>) &#123;<br>            fosInOs.write(buffer, <span class="hljs-number">0</span>, readLength);<br>            readLength = fisInJar.read(buffer);<br>        &#125;<br>        IOUtils.closeQuietly(fosInOs);<br>        IOUtils.closeQuietly(fisInJar);<br>        Font font;<br>        <span class="hljs-keyword">try</span> &#123;<br>            font = Font.createFont(Font.TRUETYPE_FONT, file);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;加载默认中文字体失败&quot;</span>, e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ImageServiceException(ErrorCode.COMMON_SERVER_ERROR, <span class="hljs-string">&quot;加载默认中文字体失败: &quot;</span>+e.getMessage());<br>        &#125;<br>        chineseFontMap.put(key, font);<br>        log.info(<span class="hljs-string">&quot;初始化中文字体完成: &#123;&#125;&quot;</span>, key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取中文字体</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Font <span class="hljs-title">getChineseFont</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        Font font = chineseFontMap.get(key);<br>        <span class="hljs-keyword">return</span> font == <span class="hljs-keyword">null</span> ? chineseFontMap.get(FontTypeEnum.KaiTi.toString()) : font;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、将文字转换为透明的临时图片"><a href="#2、将文字转换为透明的临时图片" class="headerlink" title="2、将文字转换为透明的临时图片"></a>2、将文字转换为透明的临时图片</h3><p>逛了一圈<code>GraphicsMagick</code>官网，没看到有将文字转换为图片的操作，这里使用JDK自带的<code>ImageIO</code>生成临时文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将文字转换为图片（解决中文字符乱码以及文字透明度问题）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> text      文本内容</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fontType  字体类型（HeiTi、KaiTi、SongTi）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fontSize  字体大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fontColor 字体颜色</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outFile   输出文件路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">convertFontToImage</span><span class="hljs-params">(String text, String fontType, Integer fontSize, String fontColor, String outFile)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>    Color textColor = Color.BLACK;<br>    <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(fontColor)) &#123;<br>        textColor = <span class="hljs-keyword">new</span> Color(Integer.valueOf(fontColor, <span class="hljs-number">16</span>));<br>    &#125;<br>    <span class="hljs-comment">// 获取字体库映射字体集</span><br>    Font font = chineseFontComponent.getChineseFont(fontType).deriveFont(Font.PLAIN, fontSize);<br>    File file = <span class="hljs-keyword">new</span> File(outFile);<br>    <span class="hljs-comment">// 获取font的样式应用在str上的整个矩形</span><br>    Rectangle2D r = font.getStringBounds(text, <span class="hljs-keyword">new</span> FontRenderContext(AffineTransform.getScaleInstance(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>));<br>    <span class="hljs-comment">// 获取单个字符的高度</span><br>    <span class="hljs-keyword">int</span> unitHeight = (<span class="hljs-keyword">int</span>) Math.floor(r.getHeight()); <br>    <span class="hljs-comment">// 获取整个str用了font样式的宽度这里用四舍五入后+1保证宽度绝对能容纳这个字符串作为图片的宽度</span><br>    <span class="hljs-keyword">int</span> width = (<span class="hljs-keyword">int</span>)Math.round(r.getWidth())+<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 把单个字符的高度+3保证高度绝对能容纳字符串作为图片的高度</span><br>    <span class="hljs-keyword">int</span> height = unitHeight+<span class="hljs-number">3</span>; <br>    <span class="hljs-comment">// 创建图片</span><br>    BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);<br>    Graphics2D g2d = image.createGraphics();<br>    image = g2d.getDeviceConfiguration().createCompatibleImage(width, height, Transparency.TRANSLUCENT);<br>    g2d.dispose();<br>    g2d = image.createGraphics();<br>    g2d.setStroke(<span class="hljs-keyword">new</span> BasicStroke(<span class="hljs-number">1</span>));<br>    g2d.setColor(textColor); <span class="hljs-comment">// 在换成所需要的字体颜色</span><br>    g2d.setFont(font);<br>    g2d.drawString(text, <span class="hljs-number">0</span>, font.getSize());<br>    <span class="hljs-keyword">try</span> &#123;<br>        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, file); <span class="hljs-comment">// 输出png图片</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        log.error(<span class="hljs-string">&quot;文字水印生成临时文件出现异常&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    log.info(<span class="hljs-string">&quot;生成临时文件时间：&#123;&#125; ms&quot;</span>, (System.currentTimeMillis()-startTime));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⚠️注意：</strong> ImageIO在高并发的情况下容易造成OOM，所以生成临时文件这个操作需要使用线程池控制并发数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutorConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> textWaterMarkThreadPoolSize = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> textWaterMarkThreadPoolQueueSize = <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文字水印线程池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean(name = &quot;textWaterMarkThreadPool&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ExecutorService <span class="hljs-title">getTextWaterMarkThreadPoolTaskServiceExecutor</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;textWaterMarkThreadPool线程池开始初始化，线程池中线程数：&#123;&#125;&quot;</span>, textWaterMarkThreadPoolSize);<br>        ThreadFactory threadFactory = <span class="hljs-keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="hljs-string">&quot;TextWaterMark-task-%d&quot;</span>).build();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(textWaterMarkThreadPoolSize, textWaterMarkThreadPoolSize, <span class="hljs-number">0L</span>,<br>                TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;(textWaterMarkThreadPoolQueueSize),<br>                threadFactory, <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、使用GM合成图片"><a href="#3、使用GM合成图片" class="headerlink" title="3、使用GM合成图片"></a>3、使用GM合成图片</h3><ul><li>将水印文字生成透明的背景图片<ul><li>提交任务到线程池，并获取结果</li></ul></li><li>使用GM合成图片</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将文字生成图片，再合成</span><br><span class="hljs-comment">// 1、生成透明的背景图片</span><br>File tmpTextFile = File.createTempFile(<span class="hljs-string">&quot;TmpText-&quot;</span>, <span class="hljs-string">&quot;.png&quot;</span>);<br><span class="hljs-keyword">boolean</span> res = textWaterMarkThreadPool.submit(() -&gt; <span class="hljs-keyword">this</span>.convertFontToImage(text, fontType, fontSize, color, tmpTextFile.getAbsolutePath())).get();<br><span class="hljs-keyword">if</span> (! res) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ImageServiceException(ErrorCode.IMAGE_HANDLER_ERROR, <span class="hljs-string">&quot;文字水印生成临时文件异常&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 2、合成图片</span><br>CompositeCommand compositeCommand = <span class="hljs-keyword">new</span> CompositeCommand();<br>compositeCommand.watermarkImg(gravityEnum, dx, dy, dissolve, tmpTextFile.getAbsolutePath()).addImage(sourceImg, distPath);<br>pooledGMService.execute(compositeCommand.getCmdArgs());<br></code></pre></td></tr></table></figure><h3 id="4、最终结果"><a href="#4、最终结果" class="headerlink" title="4、最终结果"></a>4、最终结果</h3><p><strong>测试需求：</strong> 文字位置：(100, 100)、文字内容：“你好，世界”，透明度：60%，颜色：ff0000，文字类型：黑体，文字大小：40px。</p><ul><li><a href="https://cvte-dev-public.seewo.com/shan-test/fb56c8886ad34e69926ac35a51c2d127">阿里云文字水印效果</a></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b5a4c16cfa3943db9297307d4f123690~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><a href="https://cvte-dev-public.seewo.com/shan-test/52927fed12f546539c6796fd7fad07ce">自研图片水印效果</a></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7088e59808e48d0836dcea0fed93848~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>GraphicsMagick</tag>
      
      <tag>水印</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot项目瘦身</title>
    <link href="/blog/2021/06/04/SpringBoot%E9%A1%B9%E7%9B%AE%E7%98%A6%E8%BA%AB/"/>
    <url>/blog/2021/06/04/SpringBoot%E9%A1%B9%E7%9B%AE%E7%98%A6%E8%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>SpringBoot 部署起来虽然简单，如果服务器部署在公司内网，速度还行，但是如果部署在公网（阿里云等云服务器上），部署起来实在头疼：编译出来的 Jar 包很大，如果工程引入了许多开源组件（SpringCloud 等），那就更大了。</p><p>这个时候如果想要对线上运行工程有一些微调，则非常痛苦</p><h1 id="二、瘦身前的-Jar-包"><a href="#二、瘦身前的-Jar-包" class="headerlink" title="二、瘦身前的 Jar 包"></a>二、瘦身前的 Jar 包</h1><p>Tomcat 在部署 Web 工程的时候，可以进行增量更新，SpringBoot 也是可以的～</p><p>SpringBoot 编译出来的 Jar 包中，磁盘占用大的，是一些外部依赖库（jar 包），例如：</p><p>进入项目工程根目录，执行 mvn clean install 命令，得到的 Jar 包，用压缩软件打开，目录结构如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/d191cf2d49c042cbba8a1450db41f628~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>整个 Jar 包 18.18 MB, 但是 BOOT-INF/lib 就占用了将近 18 MB：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1eedabed015b40758873bbd1ec8dc2cf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h1 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h1><p>步骤 1: 正常编译 JAR 包，解压出 lib 文件夹</p><p>POM 文件如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/38c98d9e9b7b45aa84366ddd3beaac70~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>进入项目根目录，执行命令：mvn clean install</p><p>将编译后的 Jar 包解压，拷贝 BOOT-INF 目录下的 lib 文件夹 到目标路径；</p><p>步骤 2: 修改 pom.xml 配置，编译出不带 lib 文件夹的 Jar 包</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/49f3d7bb81314f16bfeeec61e326a2d0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>配置完成后，再次执行编译：mvn clean install</p><p>生成的 Jar 包体积明显变小，如下所示， 外部的 jar 包已经不会被引入了：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/76c686a9bc2c4cb9a00497cac2f436cc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>步骤 3: 运行编译后的 Jar 包</p><p>将 步骤 1 解压出来的 lib 文件夹、步骤 2 编译的 jar 包放在同一个目录, 运行下面命令：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a8763842b17f413584be84069cbf07c9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>或者在 maven 中输入一下命令导出需要用到的 jar 包</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/baade11e805d47f695f4a40d970f452e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>备注：</p><p>将/path/to/改成实际的路径。</p><p>-Dloader.path=lib 文件夹路径</p><p>最终目录文件结构是：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/52623002e80b451796f9085b19c0b987~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>说明</p><p>1、通常，一个工程项目架构确定后，引入的 jar 包基本上不会变，改变的大部分是业务逻辑；</p><p>2、后面如果需要变更业务逻辑，只需要轻量地编译工程，大大提高项目部署的效率。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>jar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性Lambda表达式</title>
    <link href="/blog/2021/06/01/Java8%E6%96%B0%E7%89%B9%E6%80%A7Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/blog/2021/06/01/Java8%E6%96%B0%E7%89%B9%E6%80%A7Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>集合优化了对象的存储，而流和对象的处理有关。</p></blockquote><p>流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说。</p><p>利用流，无需迭代集合中的元素，就可以提取和操作它们。这些管道通常被组合在一起，在流上形成一条操作管道。</p><p>大多数情况下，将对象存储在集合是为了处理他们，因此你将会发现编程焦点从集合转移到了流。流的一个核心好处是，它使得<strong>程序更加短小并且更易理解</strong>。当 Lambda 表达式和方法引用和流一起使用的时候会让人感觉自成一体。流使得 Java 8 更添魅力。</p><p>假如你要随机展示 5 至 20 之间不重复的整数并进行排序。实际上，你的关注点首先是创建一个有序集合。围绕这个集合进行后续操作。但使用流式编程，就可以简单陈述你想做什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Randoms.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Randoms</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>)<br>            .ints(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>)<br>            .distinct()<br>            .limit(<span class="hljs-number">7</span>)<br>            .sorted()<br>            .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br>10<br>13<br>16<br>17<br>18<br>19<br>复制代码<br></code></pre></td></tr></table></figure><p>首先，我们给 <strong>Random</strong> 对象一个种子（以便程序再次运行时产生相同的输出）。<code>ints()</code> 方法产生一个流并且 <code>ints()</code> 方法有多种方式的重载 — 两个参数限定了数值产生的边界。这将生成一个整数流。我们可以使用中间流操作（intermediate stream operation） <code>distinct()</code> 来获取它们的非重复值，然后使用 <code>limit()</code> 方法获取前 7 个元素。接下来，我们使用 <code>sorted()</code> 方法排序。最终使用 <code>forEach()</code> 方法遍历输出，它根据传递给它的函数对每个流对象执行操作。在这里，我们传递了一个可以在控制台显示每个元素的方法引用。<code>System.out::println</code> 。</p><p>注意 <code>Randoms.java</code> 中没有声明任何变量。流可以在不使用赋值或可变数据的情况下对有状态的系统建模，这非常有用。</p><p>声明式编程（Declarative programming）是一种：声明要做什么，而非怎么做的编程风格。正如我们在函数式编程中所看到的。<strong>注意</strong>，命令式编程的形式更难以理解。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/ImperativeRandoms.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImperativeRandoms</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>        SortedSet&lt;Integer&gt; rints = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(rints.size() &lt; <span class="hljs-number">7</span>) &#123;<br>            <span class="hljs-keyword">int</span> r = rand.nextInt(<span class="hljs-number">20</span>);<br>            <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">5</span>) <span class="hljs-keyword">continue</span>;<br>            rints.add(r);<br>        &#125;<br>        System.out.println(rints);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[7, 8, 9, 11, 13, 15, 18]</span><br>复制代码<br></code></pre></td></tr></table></figure><p>在 <code>Randoms.java</code> 中，我们无需定义任何变量，但在这里我们定义了 3 个变量： <code>rand</code>，<code>rints</code> 和 <code>r</code>。由于 <code>nextInt()</code> 方法没有下限的原因（其内置的下限永远为 0），这段代码实现起来更复杂。所以我们要生成额外的值来过滤小于 5 的结果。</p><p><strong>注意</strong>，你必须要研究程序的真正意图，而在 <code>Randoms.java</code> 中，代码只是告诉了你它正在做什么。这种语义清晰性也是 Java 8 的流式编程更受推崇的重要原因。</p><p>在 <code>ImperativeRandoms.java</code> 中显式地编写迭代机制称为外部迭代。而在 <code>Randoms.java</code> 中，流式编程采用内部迭代，这是流式编程的核心特性之一。这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。通过放弃对迭代过程的控制，我们把控制权交给并行化机制。我们将在<a href="24-Concurrent-Programming.md">并发编程</a>一章中学习这部分内容。</p><p>另一个重要方面，流是懒加载的。这代表着它只在绝对必要时才计算。你可以将流看作“延迟列表”。由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。</p><h2 id="流支持"><a href="#流支持" class="headerlink" title="流支持"></a>流支持</h2><p>Java 设计者面临着这样一个难题：现存的大量类库不仅为 Java 所用，同时也被应用在整个 Java 生态圈数百万行的代码中。如何将一个全新的流的概念融入到现有类库中呢？</p><p>比如在 <strong>Random</strong> 中添加更多的方法。只要不改变原有的方法，现有代码就不会受到干扰。</p><p>问题是，接口部分怎么改造呢？特别是涉及集合类接口的部分。如果你想把一个集合转换为流，直接向接口添加新方法会破坏所有老的接口实现类。</p><p>Java 8 采用的解决方案是：在<a href="10-Interfaces.md">接口</a>中添加被 <code>default</code>（<code>默认</code>）修饰的方法。通过这种方案，设计者们可以将流式（<em>stream</em>）方法平滑地嵌入到现有类中。流方法预置的操作几乎已满足了我们平常所有的需求。流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。</p><p>下面我们来看下每种类型的流操作。</p><h2 id="流创建"><a href="#流创建" class="headerlink" title="流创建"></a>流创建</h2><p>你可以通过 <code>Stream.of()</code> 很容易地将一组元素转化成为流（<code>Bubble</code> 类在本章的后面定义）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/StreamOf.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamOf</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-keyword">new</span> Bubble(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> Bubble(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> Bubble(<span class="hljs-number">3</span>))<br>            .forEach(System.out::println);<br>        Stream.of(<span class="hljs-string">&quot;It&#x27;s &quot;</span>, <span class="hljs-string">&quot;a &quot;</span>, <span class="hljs-string">&quot;wonderful &quot;</span>, <span class="hljs-string">&quot;day &quot;</span>, <span class="hljs-string">&quot;for &quot;</span>, <span class="hljs-string">&quot;pie!&quot;</span>)<br>            .forEach(System.out::print);<br>        System.out.println();<br>        Stream.of(<span class="hljs-number">3.14159</span>, <span class="hljs-number">2.718</span>, <span class="hljs-number">1.618</span>)<br>            .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">Bubble</span>(<span class="hljs-number">1</span>)</span><br><span class="hljs-function"><span class="hljs-title">Bubble</span>(<span class="hljs-number">2</span>)</span><br><span class="hljs-function"><span class="hljs-title">Bubble</span>(<span class="hljs-number">3</span>)</span><br><span class="hljs-variable">It</span><span class="hljs-string">&#x27;s a wonderful day for pie!</span><br><span class="hljs-string">3.14159</span><br><span class="hljs-string">2.718</span><br><span class="hljs-string">1.618</span><br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure><p>每个集合都可通过 <code>stream()</code> 产生一个流。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionToStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Bubble&gt; bubbles = Arrays.asList(<span class="hljs-keyword">new</span> Bubble(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> Bubble(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> Bubble(<span class="hljs-number">3</span>));<br>        System.out.println(bubbles.stream()<br>            .mapToInt(b -&gt; b.i)<br>            .sum());<br>        <br>        Set&lt;String&gt; w = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;It&#x27;s a wonderful day for pie!&quot;</span>.split(<span class="hljs-string">&quot; &quot;</span>)));<br>        w.stream()<br>         .map(x -&gt; x + <span class="hljs-string">&quot; &quot;</span>)<br>         .forEach(System.out::print);<br>        System.out.println();<br>        <br>        Map&lt;String, Double&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        m.put(<span class="hljs-string">&quot;pi&quot;</span>, <span class="hljs-number">3.14159</span>);<br>        m.put(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">2.718</span>);<br>        m.put(<span class="hljs-string">&quot;phi&quot;</span>, <span class="hljs-number">1.618</span>);<br>        m.entrySet().stream()<br>                    .map(e -&gt; e.getKey() + <span class="hljs-string">&quot;: &quot;</span> + e.getValue())<br>                    .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-number">6</span><br>a pie! It<span class="hljs-comment">&#x27;s for wonderful day</span><br><span class="hljs-symbol">phi:</span> <span class="hljs-number">1.618</span><br><span class="hljs-symbol">e:</span> <span class="hljs-number">2.718</span><br><span class="hljs-symbol">pi:</span> <span class="hljs-number">3.14159</span><br>复制代码<br></code></pre></td></tr></table></figure><ul><li>创建 <code>List&lt;Bubble&gt;</code> 对象后，只需简单调用<strong>所有集合中都有</strong>的 <code>stream()</code>。</li><li>中间操作 <code>map()</code> 会获取流中的所有元素，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。通常 <code>map()</code> 会获取对象并产生新的对象，但在这里产生了特殊的用于数值类型的流。例如，<code>mapToInt()</code> 方法将一个对象流（object stream）转换成为包含整型数字的 <code>IntStream</code>。</li><li>通过调用字符串的 <code>split()</code>来获取元素用于定义变量 <code>w</code>。</li><li>为了从 <strong>Map</strong> 集合中产生流数据，我们首先调用 <code>entrySet()</code> 产生一个对象流，每个对象都包含一个 <code>key</code> 键以及与其相关联的 <code>value</code> 值。然后分别调用 <code>getKey()</code> 和 <code>getValue()</code> 获取值。</li></ul><h3 id="随机数流"><a href="#随机数流" class="headerlink" title="随机数流"></a>随机数流</h3><p><code>Random</code> 类被一组生成流的方法增强了。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/RandomGenerators.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomGenerators</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Stream&lt;T&gt; stream)</span> </span>&#123;<br>        stream<br>        .limit(<span class="hljs-number">4</span>)<br>        .forEach(System.out::println);<br>        System.out.println(<span class="hljs-string">&quot;++++++++&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>        show(rand.ints().boxed());<br>        show(rand.longs().boxed());<br>        show(rand.doubles().boxed());<br>        <span class="hljs-comment">// 控制上限和下限：</span><br>        show(rand.ints(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>).boxed());<br>        show(rand.longs(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>).boxed());<br>        show(rand.doubles(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>).boxed());<br>        <span class="hljs-comment">// 控制流大小：</span><br>        show(rand.ints(<span class="hljs-number">2</span>).boxed());<br>        show(rand.longs(<span class="hljs-number">2</span>).boxed());<br>        show(rand.doubles(<span class="hljs-number">2</span>).boxed());<br>        <span class="hljs-comment">// 控制流的大小和界限</span><br>        show(rand.ints(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>).boxed());<br>        show(rand.longs(<span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>).boxed());<br>        show(rand.doubles(<span class="hljs-number">3</span>, <span class="hljs-number">11.5</span>, <span class="hljs-number">12.3</span>).boxed());<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">-1172028779<br>1717241110<br>-2014573909<br>229403722<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>2955289354441303771<br>3476817843704654257<br>-8917117694134521474<br>4941259272818818752<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>0.2613610344283964<br>0.0508673570556899<br>0.8037155449603999<br>0.7620665811558285<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>16<br>10<br>11<br>12<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>65<br>99<br>54<br>58<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>29.86777681078574<br>24.83968447804611<br>20.09247112332014<br>24.046793846338723<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>1169976606<br>1947946283<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>2970202997824602425<br>-2325326920272830366<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>0.7024254510631527<br>0.6648552384607359<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>6<br>7<br>7<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>17<br>12<br>20<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>12.27872414236691<br>11.732085449736195<br>12.196509449817267<br><span class="hljs-code">+++</span><span class="hljs-code">+++</span>++<br>复制代码<br></code></pre></td></tr></table></figure><p>为了消除冗余代码，我创建了一个泛型方法 <code>show(Stream&lt;T&gt; stream)</code> （在讲解泛型之前就使用这个特性，确实有点作弊，但是回报是值得的）。类型参数 <code>T</code> 可以是任何类型，所以这个方法对 <strong>Integer</strong>、<strong>Long</strong> 和 <strong>Double</strong> 类型都生效。但是 <strong>Random</strong> 类只能生成基本类型 <strong>int</strong>， <strong>long</strong>， <strong>double</strong> 的流。幸运的是， <code>boxed()</code> 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 <code>show()</code> 能够接受流。</p><p>我们可以使用 <strong>Random</strong> 为任意对象集合创建 <strong>Supplier</strong>。如下是一个文本文件提供字符串对象的例子。</p><p>Cheese.dat 文件内容：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// streams/Cheese.dat</span><br><span class="hljs-keyword">Not</span> much <span class="hljs-keyword">of</span> a cheese shop really, <span class="hljs-keyword">is</span> it?<br>Finest <span class="hljs-keyword">in</span> the district, sir.<br><span class="hljs-keyword">And</span> what leads you <span class="hljs-keyword">to</span> that conclusion?<br>Well, it<span class="hljs-string">&#x27;s so clean.</span><br><span class="hljs-string">It&#x27;</span>s certainly uncontaminated <span class="hljs-keyword">by</span> cheese.<br>复制代码<br></code></pre></td></tr></table></figure><p>我们通过 <strong>File</strong> 类将 Cheese.dat 文件的所有行读取到 <code>List&lt;String&gt;</code> 中。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/RandomWords.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomWords</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    List&lt;String&gt; words = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>    RandomWords(String fname) <span class="hljs-keyword">throws</span> IOException &#123;<br>        List&lt;String&gt; lines = Files.readAllLines(Paths.get(fname));<br>        <span class="hljs-comment">// 略过第一行</span><br>        <span class="hljs-keyword">for</span> (String line : lines.subList(<span class="hljs-number">1</span>, lines.size())) &#123;<br>            <span class="hljs-keyword">for</span> (String word : line.split(<span class="hljs-string">&quot;[ .?,]+&quot;</span>))<br>                words.add(word.toLowerCase());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> words.get(rand.nextInt(words.size()));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> words.stream()<br>            .collect(Collectors.joining(<span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<br>            Stream.generate(<span class="hljs-keyword">new</span> RandomWords(<span class="hljs-string">&quot;Cheese.dat&quot;</span>))<br>                .limit(<span class="hljs-number">10</span>)<br>                .collect(Collectors.joining(<span class="hljs-string">&quot; &quot;</span>)));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">it</span> shop sir <span class="hljs-keyword">the</span> much cheese <span class="hljs-keyword">by</span> conclusion district <span class="hljs-keyword">is</span><br>复制代码<br></code></pre></td></tr></table></figure><p>在这里你可以看到更为复杂的 <code>split()</code> 运用。在构造器中，每一行都被 <code>split()</code> 通过空格或者被方括号包裹的任意标点符号进行分割。在结束方括号后面的 <code>+</code> 代表 <code>+</code> 前面的东西可以出现一次或者多次。</p><p>我们注意到在构造函数中循环体使用命令式编程（外部迭代）。在以后的例子中，你甚至会看到我们如何消除这一点。这种旧的形式虽不是特别糟糕，但使用流会让人感觉更好。</p><p>在 <code>toString()</code> 和主方法中你看到了 <code>collect()</code> 收集操作，它根据参数来组合所有流中的元素。</p><p>当你使用 <strong>Collectors.</strong><code>joining()</code>，你将会得到一个 <code>String</code> 类型的结果，每个元素都根据 <code>joining()</code> 的参数来进行分割。还有许多不同的 <code>Collectors</code> 用于产生不同的结果。</p><p>在主方法中，我们提前看到了 <strong>Stream.</strong><code>generate()</code> 的用法，它可以把任意  <code>Supplier&lt;T&gt;</code> 用于生成 <code>T</code> 类型的流。</p><h3 id="int-类型的范围"><a href="#int-类型的范围" class="headerlink" title="int 类型的范围"></a>int 类型的范围</h3><p><code>IntStream</code> 类提供了  <code>range()</code> 方法用于生成整型序列的流。编写循环时，这个方法会更加便利：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Ranges.java</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.IntStream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ranges</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 传统方法:</span><br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>            result += i;<br>        System.out.println(result);<br>        <span class="hljs-comment">// for-in 循环:</span><br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>).toArray())<br>            result += i;<br>        System.out.println(result);<br>        <span class="hljs-comment">// 使用流:</span><br>        System.out.println(range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>).sum());<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">145<br>145<br>145<br>复制代码<br></code></pre></td></tr></table></figure><p>在主方法中的第一种方式是我们传统编写 <code>for</code> 循环的方式；第二种方式，我们使用 <code>range()</code> 创建了流并将其转化为数组，然后在 <code>for-in</code> 代码块中使用。但是，如果你能像第三种方法那样全程使用流是更好的。我们对范围中的数字进行求和。在流中可以很方便的使用 <code>sum()</code> 操作求和。</p><p>注意 <strong>IntStream.</strong><code>range()</code> 相比 <code>onjava.Range.range()</code> 拥有更多的限制。这是由于其可选的第三个参数，后者允许步长大于 1，并且可以从大到小来生成。</p><p>实用小功能 <code>repeat()</code> 可以用来替换简单的 <code>for</code> 循环。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// onjava/Repeat.java</span><br><span class="hljs-keyword">package</span> onjava;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.IntStream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Repeat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">repeat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Runnable action)</span> </span>&#123;<br>        range(<span class="hljs-number">0</span>, n).forEach(i -&gt; action.run());<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>其产生的循环更加清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Looping.java</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> onjava.Repeat.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Looping</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hi!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        repeat(<span class="hljs-number">3</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;Looping!&quot;</span>));<br>        repeat(<span class="hljs-number">2</span>, Looping::hi);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Looping!<br>Looping!<br>Looping!<br>Hi!<br>Hi!<br>复制代码<br></code></pre></td></tr></table></figure><p>原则上，在代码中包含并解释 <code>repeat()</code> 并不值得。诚然它是一个相当透明的工具，但结果取决于你的团队和公司的运作方式。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate()"></a>generate()</h3><p>参照 <code>RandomWords.java</code> 中 <strong>Stream.</strong><code>generate()</code> 搭配 <code>Supplier&lt;T&gt;</code> 使用的例子。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Generator.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>    <span class="hljs-keyword">char</span>[] letters = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>.toCharArray();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> + letters[rand.nextInt(letters.length)];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String word = Stream.generate(<span class="hljs-keyword">new</span> Generator())<br>                            .limit(<span class="hljs-number">30</span>)<br>                            .collect(Collectors.joining());<br>        System.out.println(word);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">YNZBRNYGCFOWZNTCQRGSEGZMMJMROE<br>复制代码<br></code></pre></td></tr></table></figure><p>使用 <code>Random.nextInt()</code> 方法来挑选字母表中的大写字母。<code>Random.nextInt()</code> 的参数代表可以接受的最大的随机数范围，所以使用数组边界是经过深思熟虑的。</p><p>如果要创建包含相同对象的流，只需要传递一个生成那些对象的 <code>lambda</code> 到 <code>generate()</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Duplicator.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duplicator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.generate(() -&gt; <span class="hljs-string">&quot;duplicate&quot;</span>)<br>              .limit(<span class="hljs-number">3</span>)<br>              .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">duplicate</span><br><span class="hljs-keyword">duplicate</span><br><span class="hljs-keyword">duplicate</span><br>复制代码<br></code></pre></td></tr></table></figure><p>如下是在本章之前例子中使用过的 <code>Bubble</code> 类。<strong>注意</strong>它包含了自己的静态生成器（Static generator）方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Bubble.java</span><br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bubble</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bubble</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        i = n;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bubble(&quot;</span> + i + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bubble <span class="hljs-title">bubbler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bubble(count++);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>由于 <code>bubbler()</code> 与 <code>Supplier&lt;Bubble&gt;</code> 是接口兼容的，我们可以将其方法引用直接传递给 <strong>Stream.</strong><code>generate()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Bubbles.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bubbles</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.generate(Bubble::bubbler)<br>              .limit(<span class="hljs-number">5</span>)<br>              .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Bubble</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Bubble</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Bubble</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Bubble</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Bubble</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span><br>复制代码<br></code></pre></td></tr></table></figure><p>这是创建单独工厂类（Separate Factory class）的另一种方式。在很多方面它更加整洁，但是这是一个对于代码组织和品味的问题——你总是可以创建一个完全不同的工厂类。</p><h3 id="iterate"><a href="#iterate" class="headerlink" title="iterate()"></a>iterate()</h3><p><strong>Stream.</strong><code>iterate()</code> 以种子（第一个参数）开头，并将其传给方法（第二个参数）。方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code>iterate()</code>，依次类推。我们可以利用 <code>iterate()</code> 生成一个斐波那契数列。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Fibonacci.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fibonacci</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-function">Stream&lt;Integer&gt; <span class="hljs-title">numbers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Stream.iterate(<span class="hljs-number">0</span>, i -&gt; &#123;<br>            <span class="hljs-keyword">int</span> result = x + i;<br>            x = i;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Fibonacci().numbers()<br>                       .skip(<span class="hljs-number">20</span>) <span class="hljs-comment">// 过滤前 20 个</span><br>                       .limit(<span class="hljs-number">10</span>) <span class="hljs-comment">// 然后取 10 个</span><br>                       .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">6765</span><br><span class="hljs-number">10946</span><br><span class="hljs-number">17711</span><br><span class="hljs-number">28657</span><br><span class="hljs-number">46368</span><br><span class="hljs-number">75025</span><br><span class="hljs-number">121393</span><br><span class="hljs-number">196418</span><br><span class="hljs-number">317811</span><br><span class="hljs-number">514229</span><br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure><p>斐波那契数列将数列中最后两个元素进行求和以产生下一个元素。<code>iterate()</code> 只能记忆结果，因此我们需要利用一个变量 <code>x</code> 追踪另外一个元素。</p><p>在主方法中，我们使用了一个之前没有见过的 <code>skip()</code> 操作。它根据参数丢弃指定数量的流元素。在这里，我们丢弃了前 20 个元素。</p><h3 id="流的建造者模式"><a href="#流的建造者模式" class="headerlink" title="流的建造者模式"></a>流的建造者模式</h3><p>在建造者设计模式（也称构造器模式）中，首先创建一个 <code>builder</code> 对象，传递给它多个构造器信息，最后执行“构造”。<strong>Stream</strong> 库提供了这样的 <code>Builder</code>。在这里，我们重新审视文件读取并将其转换成为单词流的过程。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FileToWordsBuilder.java</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileToWordsBuilder</span> </span>&#123;<br>    Stream.Builder&lt;String&gt; builder = Stream.builder();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileToWordsBuilder</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Files.lines(Paths.get(filePath))<br>             .skip(<span class="hljs-number">1</span>) <span class="hljs-comment">// 略过开头的注释行</span><br>             .forEach(line -&gt; &#123;<br>                  <span class="hljs-keyword">for</span> (String w : line.split(<span class="hljs-string">&quot;[ .?,]+&quot;</span>))<br>                      builder.add(w);<br>              &#125;);<br>    &#125;<br>    <br>    <span class="hljs-function">Stream&lt;String&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">new</span> FileToWordsBuilder(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>            .stream()<br>            .limit(<span class="hljs-number">7</span>)<br>            .map(w -&gt; w + <span class="hljs-string">&quot; &quot;</span>)<br>            .forEach(System.out::print);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Not much <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> cheese shop really<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>注意</strong>，构造器会添加文件中的所有单词（除了第一行，它是包含文件路径信息的注释），但是其并没有调用 <code>build()</code>。只要你不调用 <code>stream()</code> 方法，就可以继续向 <code>builder</code> 对象中添加单词。</p><p>在该类的更完整形式中，你可以添加一个标志位用于查看 <code>build()</code> 是否被调用，并且可能的话增加一个可以添加更多单词的方法。在 <code>Stream.Builder</code> 调用 <code>build()</code> 方法后继续尝试添加单词会产生一个异常。</p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p><code>Arrays</code> 类中含有一个名为 <code>stream()</code> 的静态方法用于把数组转换成为流。我们可以重写 <code>interfaces/Machine.java</code> 中的主方法用于创建一个流，并将 <code>execute()</code> 应用于每一个元素。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Machine2.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> onjava.Operations;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Machine2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Arrays.stream(<span class="hljs-keyword">new</span> Operations[] &#123;<br>            () -&gt; Operations.show(<span class="hljs-string">&quot;Bing&quot;</span>),<br>            () -&gt; Operations.show(<span class="hljs-string">&quot;Crack&quot;</span>),<br>            () -&gt; Operations.show(<span class="hljs-string">&quot;Twist&quot;</span>),<br>            () -&gt; Operations.show(<span class="hljs-string">&quot;Pop&quot;</span>)<br>        &#125;).forEach(Operations::execute);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Bing</span><br><span class="hljs-symbol">Crack</span><br><span class="hljs-symbol">Twist</span><br><span class="hljs-symbol">Pop</span><br>复制代码<br></code></pre></td></tr></table></figure><p><code>new Operations[]</code> 表达式动态创建了 <code>Operations</code> 对象的数组。</p><p><code>stream()</code> 同样可以产生 <strong>IntStream</strong>，<strong>LongStream</strong> 和 <strong>DoubleStream</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/ArrayStreams.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStreams</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[] &#123; <span class="hljs-number">3.14159</span>, <span class="hljs-number">2.718</span>, <span class="hljs-number">1.618</span> &#125;)<br>            .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%f &quot;</span>, n));<br>        System.out.println();<br>        <br>        Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;)<br>            .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>        System.out.println();<br>        <br>        Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[] &#123; <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">44</span>, <span class="hljs-number">66</span> &#125;)<br>            .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>        System.out.println();<br>        <br>        <span class="hljs-comment">// 选择一个子域:</span><br>        Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">28</span>, <span class="hljs-number">37</span> &#125;, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>)<br>            .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">3.141590 2</span>.<span class="hljs-number">718000 1</span>.<span class="hljs-number">618000</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-number">11 22 44 66</span><br><span class="hljs-number">7</span> <span class="hljs-number">15</span> <span class="hljs-number">28</span><br>复制代码<br></code></pre></td></tr></table></figure><p>最后一次 <code>stream()</code> 的调用有两个额外的参数。第一个参数告诉 <code>stream()</code> 从数组的哪个位置开始选择元素，第二个参数用于告知在哪里停止。每种不同类型的 <code>stream()</code> 都有类似的操作。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Java 的正则表达式将在<a href="18-Strings.md">字符串</a>这一章节详细介绍。Java 8 在 <code>java.util.regex.Pattern</code> 中增加了一个新的方法 <code>splitAsStream()</code>。这个方法可以根据传入的公式将字符序列转化为流。但是有一个限制，输入只能是 <strong>CharSequence</strong>，因此不能将流作为 <code>splitAsStream()</code> 的参数。</p><p>我们再一次查看将文件处理为单词流的过程。这一次，我们使用流将文件分割为单独的字符串，接着使用正则表达式将字符串转化为单词流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FileToWordsRegexp.java</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileToWordsRegexp</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String all;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileToWordsRegexp</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        all = Files.lines(Paths.get(filePath))<br>        .skip(<span class="hljs-number">1</span>) <span class="hljs-comment">// First (comment) line</span><br>        .collect(Collectors.joining(<span class="hljs-string">&quot; &quot;</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Stream&lt;String&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Pattern<br>        .compile(<span class="hljs-string">&quot;[ .,?]+&quot;</span>).splitAsStream(all);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>    main(String[] args) <span class="hljs-keyword">throws</span> Exception &#123;<br>        FileToWordsRegexp fw = <span class="hljs-keyword">new</span> FileToWordsRegexp(<span class="hljs-string">&quot;Cheese.dat&quot;</span>);<br>        fw.stream()<br>          .limit(<span class="hljs-number">7</span>)<br>          .map(w -&gt; w + <span class="hljs-string">&quot; &quot;</span>)<br>          .forEach(System.out::print);<br>        fw.stream()<br>          .skip(<span class="hljs-number">7</span>)<br>          .limit(<span class="hljs-number">2</span>)<br>          .map(w -&gt; w + <span class="hljs-string">&quot; &quot;</span>)<br>          .forEach(System.out::print);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Not much <span class="hljs-keyword">of</span> a cheese shop really <span class="hljs-keyword">is</span> <span class="hljs-keyword">it</span><br>复制代码<br></code></pre></td></tr></table></figure><p>在构造器中我们读取了文件中的所有内容（跳过第一行注释，并将其转化成为单行字符串）。现在，当你调用 <code>stream()</code> 的时候，可以像往常一样获取一个流，但这次你可以多次调用 <code>stream()</code> 在已存储的字符串中创建一个新的流。这里有个限制，整个文件必须存储在内存中；在大多数情况下这并不是什么问题，但是这损失了流操作非常重要的优势：</p><ol><li>流“不需要存储”。当然它们需要一些内部存储，但是这只是序列的一小部分，和持有整个序列并不相同。</li><li>它们是懒加载计算的。</li></ol><p>幸运的是，我们稍后就会知道如何解决这个问题。</p><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。</p><h3 id="跟踪和调试"><a href="#跟踪和调试" class="headerlink" title="跟踪和调试"></a>跟踪和调试</h3><p><code>peek()</code> 操作的目的是帮助调试。它允许你无修改地查看流中的元素。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Peeking.java</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Peeking</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>        .skip(<span class="hljs-number">21</span>)<br>        .limit(<span class="hljs-number">4</span>)<br>        .map(w -&gt; w + <span class="hljs-string">&quot; &quot;</span>)<br>        .peek(System.out::print)<br>        .map(String::toUpperCase)<br>        .peek(System.out::print)<br>        .map(String::toLowerCase)<br>        .forEach(System.out::print);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Well</span> WELL well <span class="hljs-keyword">it</span> <span class="hljs-keyword">IT</span> <span class="hljs-keyword">it</span> s S s so SO so<br>复制代码<br></code></pre></td></tr></table></figure><p><code>FileToWords</code> 稍后定义，但它的功能实现貌似和之前我们看到的差不多：产生字符串对象的流。之后在其通过管道时调用 <code>peek()</code> 进行处理。</p><p>因为 <code>peek()</code> 符合无返回值的 <strong>Consumer</strong> 函数式接口，所以我们只能观察，无法使用不同的元素来替换流中的对象。</p><h3 id="流元素排序"><a href="#流元素排序" class="headerlink" title="流元素排序"></a>流元素排序</h3><p>在 <code>Randoms.java</code> 中，我们熟识了 <code>sorted()</code> 的默认比较器实现。其实它还有另一种形式的实现：传入一个 <strong>Comparator</strong> 参数。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/SortedComparator.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedComparator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>        .skip(<span class="hljs-number">10</span>)<br>        .limit(<span class="hljs-number">10</span>)<br>        .sorted(Comparator.reverseOrder())<br>        .map(w -&gt; w + <span class="hljs-string">&quot; &quot;</span>)<br>        .forEach(System.out::print);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">you what <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">that</span> sir leads <span class="hljs-keyword">in</span> district And<br>复制代码<br></code></pre></td></tr></table></figure><p><code>sorted()</code> 预设了一些默认的比较器。这里我们使用的是反转“自然排序”。当然你也可以把 Lambda 函数作为参数传递给 <code>sorted()</code>。</p><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><ul><li><code>distinct()</code>：在 <code>Randoms.java</code> 类中的 <code>distinct()</code> 可用于消除流中的重复元素。相比创建一个 <strong>Set</strong> 集合，该方法的工作量要少得多。</li><li><code>filter(Predicate)</code>：过滤操作会保留与传递进去的过滤器函数计算结果为 <code>true</code> 的元素。</li></ul><p>在下例中，<code>isPrime()</code> 作为过滤器函数，用于检测质数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.LongStream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prime</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> rangeClosed(<span class="hljs-number">2</span>, (<span class="hljs-keyword">long</span>)Math.sqrt(n))<br>        .noneMatch(i -&gt; n % i == <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LongStream <span class="hljs-title">numbers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> iterate(<span class="hljs-number">2</span>, i -&gt; i + <span class="hljs-number">1</span>)<br>        .filter(Prime::isPrime);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Prime().numbers()<br>        .limit(<span class="hljs-number">10</span>)<br>        .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>        System.out.println();<br>        <span class="hljs-keyword">new</span> Prime().numbers()<br>        .skip(<span class="hljs-number">90</span>)<br>        .limit(<span class="hljs-number">10</span>)<br>        .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">2<span class="hljs-number"> 3 </span>5<span class="hljs-number"> 7 </span>11<span class="hljs-number"> 13 </span>17<span class="hljs-number"> 19 </span>23 29<br>467<span class="hljs-number"> 479 </span>487<span class="hljs-number"> 491 </span>499<span class="hljs-number"> 503 </span>509<span class="hljs-number"> 521 </span>523 541<br>复制代码<br></code></pre></td></tr></table></figure><p><code>rangeClosed()</code> 包含了上限值。如果不能整除，即余数不等于 0，则 <code>noneMatch()</code> 操作返回 <code>true</code>，如果出现任何等于 0 的结果则返回 <code>false</code>。 <code>noneMatch()</code> 操作一旦有失败就会退出。</p><h3 id="应用函数到元素"><a href="#应用函数到元素" class="headerlink" title="应用函数到元素"></a>应用函数到元素</h3><ul><li><code>map(Function)</code>：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</li><li><code>mapToInt(ToIntFunction)</code>：操作同上，但结果是 <strong>IntStream</strong>。</li><li><code>mapToLong(ToLongFunction)</code>：操作同上，但结果是 <strong>LongStream</strong>。</li><li><code>mapToDouble(ToDoubleFunction)</code>：操作同上，但结果是 <strong>DoubleStream</strong>。</li></ul><p>在这里，我们使用 <code>map()</code> 映射多种函数到一个字符串流中。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FunctionMap.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionMap</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> String[] elements = &#123; <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-string">&quot;45&quot;</span> &#125;;<br>    <span class="hljs-keyword">static</span> Stream&lt;String&gt;<br>    testStream() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(elements);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String descr, Function&lt;String, String&gt; func)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot; ---( &quot;</span> + descr + <span class="hljs-string">&quot; )---&quot;</span>);<br>        testStream()<br>        .map(func)<br>        .forEach(System.out::println);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(<span class="hljs-string">&quot;add brackets&quot;</span>, s -&gt; <span class="hljs-string">&quot;[&quot;</span> + s + <span class="hljs-string">&quot;]&quot;</span>);<br>        test(<span class="hljs-string">&quot;Increment&quot;</span>, s -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.parseInt(s) + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">catch</span>(NumberFormatException e) &#123;<br>                <span class="hljs-keyword">return</span> s;<br>            &#125;<br>        &#125;<br>        );<br>        test(<span class="hljs-string">&quot;Replace&quot;</span>, s -&gt; s.replace(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>));<br>        test(<span class="hljs-string">&quot;Take last digit&quot;</span>, s -&gt; s.length() &gt; <span class="hljs-number">0</span> ?<br>        s.charAt(s.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;&quot;</span> : s);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-literal">-</span><span class="hljs-comment">(</span> <span class="hljs-comment">add</span> <span class="hljs-comment">brackets</span> <span class="hljs-comment">)</span>--<span class="hljs-literal">-</span><br><span class="hljs-title">[</span><span class="hljs-comment">12</span><span class="hljs-title">]</span><br><span class="hljs-title">[</span><span class="hljs-title">]</span><br><span class="hljs-title">[</span><span class="hljs-comment">23</span><span class="hljs-title">]</span><br><span class="hljs-title">[</span><span class="hljs-comment">45</span><span class="hljs-title">]</span><br>--<span class="hljs-literal">-</span><span class="hljs-comment">(</span> <span class="hljs-comment">Increment</span> <span class="hljs-comment">)</span>--<span class="hljs-literal">-</span><br><span class="hljs-comment">13</span><br><span class="hljs-comment">24</span><br><span class="hljs-comment">46</span><br><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-comment">(</span> <span class="hljs-comment">Replace</span> <span class="hljs-comment">)</span>--<span class="hljs-literal">-</span><br><span class="hljs-comment">19</span><br><span class="hljs-comment">93</span><br><span class="hljs-comment">45</span><br><span class="hljs-comment"></span>--<span class="hljs-literal">-</span><span class="hljs-comment">(</span> <span class="hljs-comment">Take</span> <span class="hljs-comment">last</span> <span class="hljs-comment">digit</span> <span class="hljs-comment">)</span>--<span class="hljs-literal">-</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">复制代码</span><br></code></pre></td></tr></table></figure><p>在上面的自增示例中，我们使用 <code>Integer.parseInt()</code> 尝试将一个字符串转化为整数。如果字符串不能转化成为整数就会抛出 <strong>NumberFormatException</strong> 异常，我们只须回过头来将原始字符串放回到输出流中。</p><p>在以上例子中，<code>map()</code> 将一个字符串映射为另一个字符串，但是我们完全可以产生和接收类型完全不同的类型，从而改变流的数据类型。下面代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FunctionMap2.java</span><br><span class="hljs-comment">// Different input and output types （不同的输入输出类型）</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Numbered</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n;<br>    Numbered(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Numbered(&quot;</span> + n + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionMap2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>)<br>        .map(Numbered::<span class="hljs-keyword">new</span>)<br>        .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Numbered</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Numbered</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Numbered</span><span class="hljs-params">(<span class="hljs-number">7</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Numbered</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Numbered</span><span class="hljs-params">(<span class="hljs-number">11</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Numbered</span><span class="hljs-params">(<span class="hljs-number">13</span>)</span></span><br>复制代码<br></code></pre></td></tr></table></figure><p>我们将获取到的整数通过构造器 <code>Numbered::new</code> 转化成为 <code>Numbered</code> 类型。</p><p>如果使用 <strong>Function</strong> 返回的结果是数值类型的一种，我们必须使用合适的 <code>mapTo数值类型</code> 进行替代。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FunctionMap3.java</span><br><span class="hljs-comment">// Producing numeric output streams（ 产生数值输出流）</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionMap3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>)<br>        .mapToInt(Integer::parseInt)<br>        .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>        System.out.println();<br>        Stream.of(<span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-string">&quot;19&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>)<br>        .mapToLong(Long::parseLong)<br>        .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>        System.out.println();<br>        Stream.of(<span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-string">&quot;1.9&quot;</span>, <span class="hljs-string">&quot;.23&quot;</span>)<br>        .mapToDouble(Double::parseDouble)<br>        .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%f &quot;</span>, n));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span><br><span class="hljs-number">17</span> <span class="hljs-number">19</span> <span class="hljs-number">23</span><br><span class="hljs-number">17.000000</span> <span class="hljs-number">1.900000</span> <span class="hljs-number">0.230000</span><br>复制代码<br></code></pre></td></tr></table></figure><p>遗憾的是，Java 设计者并没有尽最大努力去消除基本类型。</p><h3 id="在-map-中组合流"><a href="#在-map-中组合流" class="headerlink" title="在 map() 中组合流"></a>在 <code>map()</code> 中组合流</h3><p>假设我们现在有了一个传入的元素流，并且打算对流元素使用 <code>map()</code> 函数。现在你已经找到了一些可爱并独一无二的函数功能，但是问题来了：这个函数功能是产生一个流。我们想要产生一个元素流，而实际却产生了一个元素流的流。</p><p><code>flatMap()</code> 做了两件事：将产生流的函数应用在每个元素上（与 <code>map()</code> 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。</p><p><code>flatMap(Function)</code>：当 <code>Function</code> 产生流时使用。</p><p><code>flatMapToInt(Function)</code>：当 <code>Function</code> 产生 <code>IntStream</code> 时使用。</p><p><code>flatMapToLong(Function)</code>：当 <code>Function</code> 产生 <code>LongStream</code> 时使用。</p><p><code>flatMapToDouble(Function)</code>：当 <code>Function</code> 产生 <code>DoubleStream</code> 时使用。</p><p>为了弄清它的工作原理，我们从传入一个刻意设计的函数给  <code>map()</code> 开始。该函数接受一个整数并产生一个字符串流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/StreamOfStreams.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamOfStreams</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>        .map(i -&gt; Stream.of(<span class="hljs-string">&quot;Gonzo&quot;</span>, <span class="hljs-string">&quot;Kermit&quot;</span>, <span class="hljs-string">&quot;Beaker&quot;</span>))<br>        .map(e-&gt; e.getClass().getName())<br>        .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span>.ReferencePipeline<span class="hljs-variable">$Head</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span>.ReferencePipeline<span class="hljs-variable">$Head</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span>.ReferencePipeline<span class="hljs-variable">$Head</span><br>复制代码<br></code></pre></td></tr></table></figure><p>我们天真地希望能够得到字符串流，但实际得到的却是“Head”流的流。我们可以使用 <code>flatMap()</code> 解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FlatMap.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlatMap</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>        .flatMap(i -&gt; Stream.of(<span class="hljs-string">&quot;Gonzo&quot;</span>, <span class="hljs-string">&quot;Fozzie&quot;</span>, <span class="hljs-string">&quot;Beaker&quot;</span>))<br>        .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Gonzo<br>Fozzie<br><span class="hljs-keyword">Beaker</span><br><span class="hljs-keyword">Gonzo</span><br><span class="hljs-keyword">Fozzie</span><br><span class="hljs-keyword">Beaker</span><br><span class="hljs-keyword">Gonzo</span><br><span class="hljs-keyword">Fozzie</span><br><span class="hljs-keyword">Beaker</span><br><span class="hljs-keyword">复制代码</span><br></code></pre></td></tr></table></figure><p>从映射返回的每个流都会自动扁平为组成它的字符串。</p><p>下面是另一个演示，我们从一个整数流开始，然后使用每一个整数去创建更多的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/StreamOfRandoms.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamOfRandoms</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>            .flatMapToInt(i -&gt; IntStream.concat(<br>        rand.ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>).limit(i), IntStream.of(-<span class="hljs-number">1</span>)))<br>            .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">58 -1<span class="hljs-number"> 55 </span>93 -1<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 29 </span>-1<span class="hljs-number"> 68 </span>0<span class="hljs-number"> 22 </span>7 -1<span class="hljs-number"> 88 </span>28<span class="hljs-number"> 51 </span>89<span class="hljs-number"> 9 </span>-1<br>复制代码<br></code></pre></td></tr></table></figure><p>在这里我们引入了 <code>concat()</code>，它以参数顺序组合两个流。 如此，我们在每个随机 <code>Integer</code> 流的末尾添加一个 -1 作为标记。你可以看到最终流确实是从一组扁平流中创建的。</p><p>因为 <code>rand.ints()</code> 产生的是一个 <code>IntStream</code>，所以我必须使用 <code>flatMap()</code>、<code>concat()</code> 和 <code>of()</code> 的特定整数形式。</p><p>让我们再看一下将文件划分为单词流的任务。我们最后使用到的是 <strong>FileToWordsRegexp.java</strong>，它的问题是需要将整个文件读入行列表中 —— 显然需要存储该列表。而我们真正想要的是创建一个不需要中间存储层的单词流。</p><p>下面，我们再使用 <code> flatMap()</code> 来解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FileToWords.java</span><br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileToWords</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;String&gt; <span class="hljs-title">stream</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> Files.lines(Paths.get(filePath))<br>        .skip(<span class="hljs-number">1</span>) <span class="hljs-comment">// First (comment) line</span><br>        .flatMap(line -&gt;<br>        Pattern.compile(<span class="hljs-string">&quot;\\W+&quot;</span>).splitAsStream(line));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><code>stream()</code> 现在是一个静态方法，因为它可以自己完成整个流创建过程。</p><p><strong>注意</strong>：<code>\\W+</code> 是一个正则表达式。他表示“非单词字符”，<code>+</code> 表示“可以出现一次或者多次”。小写形式的 <code>\\w</code> 表示“单词字符”。</p><p>我们之前遇到的问题是 <code>Pattern.compile().splitAsStream()</code> 产生的结果为流，这意味着当我们只是想要一个简单的单词流时，在传入的行流（stream of lines）上调用 <code>map()</code> 会产生一个单词流的流。幸运的是，<code>flatMap()</code>  可以将元素流的流扁平化为一个简单的元素流。或者，我们可以使用 <code>String.split()</code> 生成一个数组，其可以被 <code>Arrays.stream()</code> 转化成为流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">.flatMap(line -&gt; Arrays.stream(line.split(<span class="hljs-string">&quot;\\W+&quot;</span>))))<br>复制代码<br></code></pre></td></tr></table></figure><p>有了真正的、而非 <code>FileToWordsRegexp.java</code> 中基于集合存储的流，我们每次使用都必须从头创建，因为流并不能被复用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/FileToWordsTest.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileToWordsTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>        .limit(<span class="hljs-number">7</span>)<br>        .forEach(s -&gt; System.out.format(<span class="hljs-string">&quot;%s &quot;</span>, s));<br>        System.out.println();<br>        FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>        .skip(<span class="hljs-number">7</span>)<br>        .limit(<span class="hljs-number">2</span>)<br>        .forEach(s -&gt; System.out.format(<span class="hljs-string">&quot;%s &quot;</span>, s));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Not much <span class="hljs-keyword">of</span> a cheese shop really<br><span class="hljs-keyword">is</span> <span class="hljs-keyword">it</span><br>复制代码<br></code></pre></td></tr></table></figure><p>在 <code>System.out.format()</code> 中的 <code>%s</code> 表明参数为 <strong>String</strong> 类型。</p><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>在我们学习终端操作之前，我们必须考虑如果你在一个空流中获取元素会发生什么。我们喜欢为了“happy path”而将流连接起来，并假设流不会被中断。在流中放置 <code>null</code> 是很好的中断方法。那么是否有某种对象，可作为流元素的持有者，即使查看的元素不存在也能友好地提示我们（也就是说，不会发生异常）？</p><p><strong>Optional</strong> 可以实现这样的功能。一些标准流操作返回 <strong>Optional</strong> 对象，因为它们并不能保证预期结果一定存在。包括：</p><ul><li><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li><li><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li><li><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li></ul><p><code>reduce()</code> 不再以 <code>identity</code> 形式开头，而是将其返回值包装在 <strong>Optional</strong> 中。（<code>identity</code> 对象成为其他形式的 <code>reduce()</code> 的默认结果，因此不存在空结果的风险）</p><p>对于数字流 <strong>IntStream</strong>、<strong>LongStream</strong> 和 <strong>DoubleStream</strong>，<code>average()</code> 会将结果包装在 <strong>Optional</strong> 以防止流为空。</p><p>以下是对空流进行所有这些操作的简单测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/OptionalsFromEmptyStreams.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptionalsFromEmptyStreams</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Stream.&lt;String&gt;empty()<br>             .findFirst());<br>        System.out.println(Stream.&lt;String&gt;empty()<br>             .findAny());<br>        System.out.println(Stream.&lt;String&gt;empty()<br>             .max(String.CASE_INSENSITIVE_ORDER));<br>        System.out.println(Stream.&lt;String&gt;empty()<br>             .min(String.CASE_INSENSITIVE_ORDER));<br>        System.out.println(Stream.&lt;String&gt;empty()<br>             .reduce((s1, s2) -&gt; s1 + s2));<br>        System.out.println(IntStream.empty()<br>             .average());<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OptionalDouble</span>.</span></span>empty<br>复制代码<br></code></pre></td></tr></table></figure><p>当流为空的时候你会获得一个 <strong>Optional.empty</strong> 对象，而不是抛出异常。<strong>Optional</strong> 拥有 <code>toString()</code> 方法可以用于展示有用信息。</p><p>注意，空流是通过 <code>Stream.&lt;String&gt;empty()</code> 创建的。如果你在没有任何上下文环境的情况下调用 <code>Stream.empty()</code>，Java 并不知道它的数据类型；这个语法解决了这个问题。如果编译器拥有了足够的上下文信息，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; s = Stream.empty();<br>复制代码<br></code></pre></td></tr></table></figure><p>就可以在调用 <code>empty()</code> 时推断类型。</p><p>这个示例展示了 <strong>Optional</strong> 的两个基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/OptionalBasics.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptionalBasics</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(optString.isPresent())<br>            System.out.println(optString.get()); <br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;Nothing inside!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(Stream.of(<span class="hljs-string">&quot;Epithets&quot;</span>).findFirst());<br>        test(Stream.&lt;String&gt;empty().findFirst());<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Epithets<br>Nothing inside!<br>复制代码<br></code></pre></td></tr></table></figure><p>当你接收到 <strong>Optional</strong> 对象时，应首先调用 <code>isPresent()</code> 检查其中是否包含元素。如果存在，可使用 <code>get()</code> 获取。</p><h3 id="便利函数"><a href="#便利函数" class="headerlink" title="便利函数"></a>便利函数</h3><p>有许多便利函数可以解包 <strong>Optional</strong> ，这简化了上述“对所包含的对象的检查和执行操作”的过程：</p><ul><li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li><li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>。</li><li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li><li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li></ul><p>如下是针对不同便利函数的简单演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Optionals.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Optionals</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">basics</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(optString.isPresent())<br>            System.out.println(optString.get()); <br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;Nothing inside!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ifPresent</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> </span>&#123;<br>        optString.ifPresent(System.out::println);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orElse</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> </span>&#123;<br>        System.out.println(optString.orElse(<span class="hljs-string">&quot;Nada&quot;</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orElseGet</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> </span>&#123;<br>        System.out.println(<br>        optString.orElseGet(() -&gt; <span class="hljs-string">&quot;Generated&quot;</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orElseThrow</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(optString.orElseThrow(<br>            () -&gt; <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Supplied&quot;</span>)));<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Caught &quot;</span> + e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String testName, Consumer&lt;Optional&lt;String&gt;&gt; cos)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot; === &quot;</span> + testName + <span class="hljs-string">&quot; === &quot;</span>);<br>        cos.accept(Stream.of(<span class="hljs-string">&quot;Epithets&quot;</span>).findFirst());<br>        cos.accept(Stream.&lt;String&gt;empty().findFirst());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(<span class="hljs-string">&quot;basics&quot;</span>, Optionals::basics);<br>        test(<span class="hljs-string">&quot;ifPresent&quot;</span>, Optionals::ifPresent);<br>        test(<span class="hljs-string">&quot;orElse&quot;</span>, Optionals::orElse);<br>        test(<span class="hljs-string">&quot;orElseGet&quot;</span>, Optionals::orElseGet);<br>        test(<span class="hljs-string">&quot;orElseThrow&quot;</span>, Optionals::orElseThrow);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">=== basics ===</span><br>Epithets<br>Nothing inside!<br><span class="hljs-section">=== ifPresent ===</span><br>Epithets<br><span class="hljs-section">=== orElse ===</span><br>Epithets<br>Nada<br><span class="hljs-section">=== orElseGet ===</span><br>Epithets<br>Generated<br><span class="hljs-section">=== orElseThrow ===</span><br>Epithets<br>Caught java.lang.Exception: Supplied<br>复制代码<br></code></pre></td></tr></table></figure><p><code>test()</code> 通过传入所有方法都适用的 <strong>Consumer</strong> 来避免重复代码。</p><p><code>orElseThrow()</code> 通过 <strong>catch</strong> 关键字来捕获抛出的异常。更多细节，将在 <a href="./15-Exceptions.md">异常</a> 这一章节中学习。</p><h3 id="创建-Optional"><a href="#创建-Optional" class="headerlink" title="创建 Optional"></a>创建 Optional</h3><p>当我们在自己的代码中加入 <strong>Optional</strong> 时，可以使用下面 3 个静态方法：</p><ul><li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li><li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li><li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li></ul><p>下面来看看它是如何工作的。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/CreatingOptionals.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreatingOptionals</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String testName, Optional&lt;String&gt; opt)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot; === &quot;</span> + testName + <span class="hljs-string">&quot; === &quot;</span>);<br>        System.out.println(opt.orElse(<span class="hljs-string">&quot;Null&quot;</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(<span class="hljs-string">&quot;empty&quot;</span>, Optional.empty());<br>        test(<span class="hljs-string">&quot;of&quot;</span>, Optional.of(<span class="hljs-string">&quot;Howdy&quot;</span>));<br>        <span class="hljs-keyword">try</span> &#123;<br>            test(<span class="hljs-string">&quot;of&quot;</span>, Optional.of(<span class="hljs-keyword">null</span>));<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(e);<br>        &#125;<br>        test(<span class="hljs-string">&quot;ofNullable&quot;</span>, Optional.ofNullable(<span class="hljs-string">&quot;Hi&quot;</span>));<br>        test(<span class="hljs-string">&quot;ofNullable&quot;</span>, Optional.ofNullable(<span class="hljs-keyword">null</span>));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">=== empty ===</span><br>Null<br><span class="hljs-section">=== of ===</span><br>Howdy<br>java.lang.NullPointerException<br><span class="hljs-section">=== ofNullable ===</span><br>Hi<br><span class="hljs-section">=== ofNullable ===</span><br>Null<br>复制代码<br></code></pre></td></tr></table></figure><p>我们不能通过传递 <code>null</code> 到 <code>of()</code> 来创建 <code>Optional</code> 对象。最安全的方法是， 使用 <code>ofNullable()</code> 来优雅地处理 <code>null</code>。</p><h3 id="Optional-对象操作"><a href="#Optional-对象操作" class="headerlink" title="Optional 对象操作"></a>Optional 对象操作</h3><p>当我们的流管道生成了 <strong>Optional</strong> 对象，下面 3 个方法可使得 <strong>Optional</strong> 的后续能做更多的操作：</p><ul><li><code>filter(Predicate)</code>：将 <strong>Predicate</strong> 应用于 <strong>Optional</strong> 中的内容并返回结果。当 <strong>Optional</strong> 不满足 <strong>Predicate</strong> 时返回空。如果 <strong>Optional</strong> 为空，则直接返回。</li><li><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong>  于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。</li><li><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。</li></ul><p>以上方法都不适用于数值型 <strong>Optional</strong>。 一般来说，流的 <code>filter()</code> 会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。 而 <code>Optional.filter()</code> 在失败时不会删除 <strong>Optional</strong>，而是将其保留下来，并转化为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptionalFilter</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> String[] elements = &#123;<br>            <span class="hljs-string">&quot;Foo&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Bar&quot;</span>, <span class="hljs-string">&quot;Baz&quot;</span>, <span class="hljs-string">&quot;Bingo&quot;</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Stream&lt;String&gt; <span class="hljs-title">testStream</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(elements);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String descr, Predicate&lt;String&gt; pred)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot; ---( &quot;</span> + descr + <span class="hljs-string">&quot; )---&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= elements.length; i++) &#123;<br>            System.out.println(<br>                    testStream()<br>                            .skip(i)<br>                            .findFirst()<br>                            .filter(pred));<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(<span class="hljs-string">&quot;true&quot;</span>, str -&gt; <span class="hljs-keyword">true</span>);<br>        test(<span class="hljs-string">&quot;false&quot;</span>, str -&gt; <span class="hljs-keyword">false</span>);<br>        test(<span class="hljs-string">&quot;str != \&quot;\&quot;&quot;</span>, str -&gt; str != <span class="hljs-string">&quot;&quot;</span>);<br>        test(<span class="hljs-string">&quot;str.length() == 3&quot;</span>, str -&gt; str.length() == <span class="hljs-number">3</span>);<br>        test(<span class="hljs-string">&quot;startsWith(\&quot;B\&quot;)&quot;</span>,<br>                str -&gt; str.startsWith(<span class="hljs-string">&quot;B&quot;</span>));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">---( <span class="hljs-literal">true</span> )---<br>Optional<span class="hljs-literal">[F<span class="hljs-identifier">oo</span>]</span><br>Optional<span class="hljs-literal">[]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">ar</span>]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">az</span>]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">ingo</span>]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>---( <span class="hljs-literal">false</span> )---<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>---( str != <span class="hljs-string">&quot;&quot;</span> )---<br>Optional<span class="hljs-literal">[F<span class="hljs-identifier">oo</span>]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">ar</span>]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">az</span>]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">ingo</span>]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>---( str.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">3</span> )---<br>Optional<span class="hljs-literal">[F<span class="hljs-identifier">oo</span>]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">ar</span>]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">az</span>]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>---( starts<span class="hljs-constructor">With(<span class="hljs-string">&quot;B&quot;</span>)</span> )---<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">ar</span>]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">az</span>]</span><br>Optional<span class="hljs-literal">[B<span class="hljs-identifier">ingo</span>]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span>empty<br>复制代码<br></code></pre></td></tr></table></figure><p>即使输出看起来像流，特别是 <code>test()</code> 中的 for 循环。每一次的 for 循环时重新启动流，然后根据 for 循环的索引跳过指定个数的元素，这就是它最终在流中的每个连续元素上的结果。接下来调用 <code>findFirst()</code> 获取剩余元素中的第一个元素，结果会包装在 <strong>Optional</strong> 中。</p><p><strong>注意</strong>，不同于普通 for 循环，这里的索引值范围并不是 <code>i &lt; elements.length</code>， 而是 <code>i &lt;= elements.length</code>。所以最后一个元素实际上超出了流。方便的是，这将自动成为 <strong>Optional.empty</strong>，你可以在每一个测试的结尾中看到。</p><p>同 <code>map()</code> 一样 ， <code>Optional.map()</code> 应用于函数。它仅在 <strong>Optional</strong> 不为空时才应用映射函数，并将 <strong>Optional</strong> 的内容提取到映射函数。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/OptionalMap.java</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptionalMap</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> String[] elements = &#123;<span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-string">&quot;45&quot;</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Stream&lt;String&gt; <span class="hljs-title">testStream</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(elements);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String descr, Function&lt;String, String&gt; func)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot; ---( &quot;</span> + descr + <span class="hljs-string">&quot; )---&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= elements.length; i++) &#123;<br>            System.out.println(<br>                    testStream()<br>                            .skip(i)<br>                            .findFirst() <span class="hljs-comment">// Produces an Optional</span><br>                            .map(func));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// If Optional is not empty, map() first extracts</span><br>        <span class="hljs-comment">// the contents which it then passes</span><br>        <span class="hljs-comment">// to the function:</span><br>        test(<span class="hljs-string">&quot;Add brackets&quot;</span>, s -&gt; <span class="hljs-string">&quot;[&quot;</span> + s + <span class="hljs-string">&quot;]&quot;</span>);<br>        test(<span class="hljs-string">&quot;Increment&quot;</span>, s -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.parseInt(s) + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;&quot;</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>                <span class="hljs-keyword">return</span> s;<br>            &#125;<br>        &#125;);<br>        test(<span class="hljs-string">&quot;Replace&quot;</span>, s -&gt; s.replace(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>));<br>        test(<span class="hljs-string">&quot;Take last digit&quot;</span>, s -&gt; s.length() &gt; <span class="hljs-number">0</span> ?<br>                s.charAt(s.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;&quot;</span> : s);<br>    &#125;<br>    <span class="hljs-comment">// After the function is finished, map() wraps the</span><br>    <span class="hljs-comment">// result in an Optional before returning it:</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">---( Add brackets )---</span><br>Optional<span class="hljs-string">[[12]]</span><br>Optional<span class="hljs-string">[[]]</span><br>Optional<span class="hljs-string">[[23]]</span><br>Optional<span class="hljs-string">[[45]]</span><br>Optional.empty<br><span class="hljs-comment">---( Increment )---</span><br>Optional[<span class="hljs-number">13</span>]<br>Optional[]<br>Optional[<span class="hljs-number">24</span>]<br>Optional[<span class="hljs-number">46</span>]<br>Optional.empty<br><span class="hljs-comment">---( Replace )---</span><br>Optional[<span class="hljs-number">19</span>]<br>Optional[]<br>Optional[<span class="hljs-number">93</span>]<br>Optional[<span class="hljs-number">45</span>]<br>Optional.empty<br><span class="hljs-comment">---( Take last digit )---</span><br>Optional[<span class="hljs-number">2</span>]<br>Optional[]<br>Optional[<span class="hljs-number">3</span>]<br>Optional[<span class="hljs-number">5</span>]<br>Optional.empty<br>复制代码<br></code></pre></td></tr></table></figure><p>映射函数的返回结果会自动包装成为 <strong>Optional</strong>。<strong>Optional.empty</strong> 会被直接跳过。</p><p><strong>Optional</strong> 的 <code>flatMap()</code> 应用于已生成 <strong>Optional</strong> 的映射函数，所以 <code>flatMap()</code> 不会像 <code>map()</code> 那样将结果封装在 <strong>Optional</strong> 中。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/OptionalFlatMap.java</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Optional;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptionalFlatMap</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> String[] elements = &#123;<span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-string">&quot;45&quot;</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Stream&lt;String&gt; <span class="hljs-title">testStream</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(elements);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String descr,</span></span><br><span class="hljs-function"><span class="hljs-params">                     Function&lt;String, Optional&lt;String&gt;&gt; func)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot; ---( &quot;</span> + descr + <span class="hljs-string">&quot; )---&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= elements.length; i++) &#123;<br>            System.out.println(<br>                    testStream()<br>                            .skip(i)<br>                            .findFirst()<br>                            .flatMap(func));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        test(<span class="hljs-string">&quot;Add brackets&quot;</span>,<br>                s -&gt; Optional.of(<span class="hljs-string">&quot;[&quot;</span> + s + <span class="hljs-string">&quot;]&quot;</span>));<br>        test(<span class="hljs-string">&quot;Increment&quot;</span>, s -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> Optional.of(<br>                        Integer.parseInt(s) + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>                <span class="hljs-keyword">return</span> Optional.of(s);<br>            &#125;<br>        &#125;);<br>        test(<span class="hljs-string">&quot;Replace&quot;</span>,<br>                s -&gt; Optional.of(s.replace(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>)));<br>        test(<span class="hljs-string">&quot;Take last digit&quot;</span>,<br>                s -&gt; Optional.of(s.length() &gt; <span class="hljs-number">0</span> ?<br>                        s.charAt(s.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;&quot;</span><br>                        : s));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">---( Add brackets )---</span><br>Optional<span class="hljs-string">[[12]]</span><br>Optional<span class="hljs-string">[[]]</span><br>Optional<span class="hljs-string">[[23]]</span><br>Optional<span class="hljs-string">[[45]]</span><br>Optional.empty<br> <span class="hljs-comment">---( Increment )---</span><br>Optional[<span class="hljs-number">13</span>]<br>Optional[]<br>Optional[<span class="hljs-number">24</span>]<br>Optional[<span class="hljs-number">46</span>]<br>Optional.empty<br> <span class="hljs-comment">---( Replace )---</span><br>Optional[<span class="hljs-number">19</span>]<br>Optional[]<br>Optional[<span class="hljs-number">93</span>]<br>Optional[<span class="hljs-number">45</span>]<br>Optional.empty<br> <span class="hljs-comment">---( Take last digit )---</span><br>Optional[<span class="hljs-number">2</span>]<br>Optional[]<br>Optional[<span class="hljs-number">3</span>]<br>Optional[<span class="hljs-number">5</span>]<br>Optional.empty<br>复制代码<br></code></pre></td></tr></table></figure><p>同 <code>map()</code>，<code>flatMap()</code> 将提取非空 <strong>Optional</strong> 的内容并将其应用在映射函数。唯一的区别就是 <code>flatMap()</code> 不会把结果包装在 <strong>Optional</strong> 中，因为映射函数已经被包装过了。在如上示例中，我们已经在每一个映射函数中显式地完成了包装，但是很显然 <code>Optional.flatMap()</code> 是为那些自己已经生成 <strong>Optional</strong> 的函数而设计的。</p><h3 id="Optional-流"><a href="#Optional-流" class="headerlink" title="Optional 流"></a>Optional 流</h3><p>假设你的生成器可能产生 <code>null</code> 值，那么当用它来创建流时，你会自然地想到用  <strong>Optional</strong> 来包装元素。如下是它的样子，代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Signal.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Signal</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Signal</span><span class="hljs-params">(String msg)</span> </span>&#123; <span class="hljs-keyword">this</span>.msg = msg; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> msg; &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Signal(&quot;</span> + msg + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Signal <span class="hljs-title">morse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span>(rand.nextInt(<span class="hljs-number">4</span>)) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Signal(<span class="hljs-string">&quot;dot&quot;</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Signal(<span class="hljs-string">&quot;dash&quot;</span>);<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Optional&lt;Signal&gt;&gt; stream() &#123;<br>        <span class="hljs-keyword">return</span> Stream.generate(Signal::morse)<br>                .map(signal -&gt; Optional.ofNullable(signal));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>当我们使用这个流的时候，必须要弄清楚如何解包 <strong>Optional</strong>。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/StreamOfOptionals.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamOfOptionals</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Signal.stream()<br>                .limit(<span class="hljs-number">10</span>)<br>                .forEach(System.out::println);<br>        System.out.println(<span class="hljs-string">&quot; ---&quot;</span>);<br>        Signal.stream()<br>                .limit(<span class="hljs-number">10</span>)<br>                .filter(Optional::isPresent)<br>                .map(Optional::get)<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional[Signal(dash)]<br>Optional[Signal(dot)]<br>Optional[Signal(dash)]<br>Optional.empty<br>Optional.empty<br>Optional[Signal(dash)]<br>Optional.empty<br>Optional[Signal(dot)]<br>Optional[Signal(dash)]<br>Optional[Signal(dash)]<br>---<br>Signal(dot)<br>Signal(dot)<br>Signal(dash)<br>Signal(dash)<br><br></code></pre></td></tr></table></figure><p>在这里，我们使用 <code>filter()</code> 来保留那些非空 <strong>Optional</strong>，然后在 <code>map()</code> 中使用 <code>get()</code> 获取元素。由于每种情况都需要定义“空值”的含义，所以通常我们要为每个应用程序采用不同的方法。</p><h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><p>以下操作将会获取流的最终结果。至此我们无法再继续往后传递流。可以说，终端操作总是我们在流管道中所做的最后一件事。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><code>toArray()</code>：将流转换成适当类型的数组。</li><li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组。</li></ul><p>当我们需要得到数组类型的数据以便于后续操作时，上面的方法就很有用。假设我们需要复用流产生的随机数时，就可以这么使用。代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/RandInts.java</span><br><span class="hljs-keyword">package</span> streams;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandInts</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] rints = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>).ints(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>).limit(<span class="hljs-number">100</span>).toArray();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntStream <span class="hljs-title">rands</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(rints);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上例将100个数值范围在 0 到 1000 之间的随机数流转换成为数组并将其存储在 <code>rints</code> 中。这样一来，每次调用 <code>rands()</code> 的时候可以重复获取相同的整数流。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li><li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。</li></ul><p>第一种形式：无序操作，仅在引入并行流时才有意义。在 <a href="24-Concurrent-Programming.md">并发编程</a> 章节之前我们不会深入研究这个问题。这里简单介绍下 <code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。因为我们采用的是内部迭代，而不是外部迭代，所以这是可能实现的。</p><p><code>parallel()</code> 看似简单，实则棘手。更多内容将在稍后的 <a href="24-Concurrent-Programming.md">并发编程</a> 章节中学习。</p><p>下例引入 <code>parallel()</code> 来帮助理解 <code>forEachOrdered(Consumer)</code> 的作用和使用场景。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/ForEach.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> streams.RandInts.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForEach</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SZ = <span class="hljs-number">14</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        rands().limit(SZ)<br>                .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>        System.out.println();<br>        rands().limit(SZ)<br>                .parallel()<br>                .forEach(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>        System.out.println();<br>        rands().limit(SZ)<br>                .parallel()<br>                .forEachOrdered(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">258</span> <span class="hljs-number">555</span> <span class="hljs-number">693</span> <span class="hljs-number">861</span> <span class="hljs-number">961</span> <span class="hljs-number">429</span> <span class="hljs-number">868</span> <span class="hljs-number">200</span> <span class="hljs-number">522</span> <span class="hljs-number">207</span> <span class="hljs-number">288</span> <span class="hljs-number">128</span> <span class="hljs-number">551</span> <span class="hljs-number">589</span><br><span class="hljs-attribute">551</span> <span class="hljs-number">861</span> <span class="hljs-number">429</span> <span class="hljs-number">589</span> <span class="hljs-number">200</span> <span class="hljs-number">522</span> <span class="hljs-number">555</span> <span class="hljs-number">693</span> <span class="hljs-number">258</span> <span class="hljs-number">128</span> <span class="hljs-number">868</span> <span class="hljs-number">288</span> <span class="hljs-number">961</span> <span class="hljs-number">207</span><br><span class="hljs-attribute">258</span> <span class="hljs-number">555</span> <span class="hljs-number">693</span> <span class="hljs-number">861</span> <span class="hljs-number">961</span> <span class="hljs-number">429</span> <span class="hljs-number">868</span> <span class="hljs-number">200</span> <span class="hljs-number">522</span> <span class="hljs-number">207</span> <span class="hljs-number">288</span> <span class="hljs-number">128</span> <span class="hljs-number">551</span> <span class="hljs-number">589</span><br><br></code></pre></td></tr></table></figure><p>为了方便测试不同大小的数组，我们抽离出了 <code>SZ</code> 变量。结果很有趣：在第一个流中，未使用 <code>parallel()</code> ，所以 <code>rands()</code> 按照元素迭代出现的顺序显示结果；在第二个流中，引入<code>parallel()</code> ，即便流很小，输出的结果顺序也和前面不一样。这是由于多处理器并行操作的原因。多次运行测试，结果均不同。多处理器并行操作带来的非确定性因素造成了这样的结果。</p><p>在最后一个流中，同时使用了 <code>parallel()</code> 和 <code>forEachOrdered()</code> 来强制保持原始流顺序。因此，对非并行流使用 <code>forEachOrdered()</code> 是没有任何影响的。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li><li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素包含到结果中，第三个参数 <strong>BiConsumer</strong> 用于将两个值组合起来。</li></ul><p>在这里我们只是简单介绍了几个 <strong>Collectors</strong> 的运用示例。实际上，它还有一些非常复杂的操作实现，可通过查看 <code>java.util.stream.Collectors</code> 的 API 文档了解。例如，我们可以将元素收集到任意一种特定的集合中。</p><p>假设我们现在为了保证元素有序，将元素存储在 <strong>TreeSet</strong> 中。<strong>Collectors</strong> 里面没有特定的 <code>toTreeSet()</code>，但是我们可以通过将集合的构造函数引用传递给 <code>Collectors.toCollection()</code>，从而构建任何类型的集合。下面我们来将一个文件中的单词收集到 <strong>TreeSet</strong> 集合中。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/TreeSetOfWords.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeSetOfWords</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>    main(String[] args) <span class="hljs-keyword">throws</span> Exception &#123;<br>        Set&lt;String&gt; words2 =<br>                Files.lines(Paths.get(<span class="hljs-string">&quot;TreeSetOfWords.java&quot;</span>))<br>                        .flatMap(s -&gt; Arrays.stream(s.split(<span class="hljs-string">&quot;\\W+&quot;</span>)))<br>                        .filter(s -&gt; !s.matches(<span class="hljs-string">&quot;\\d+&quot;</span>)) <span class="hljs-comment">// No numbers</span><br>                        .map(String::trim)<br>                        .filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>                        .limit(<span class="hljs-number">100</span>)<br>                        .collect(Collectors.toCollection(TreeSet::<span class="hljs-keyword">new</span>));<br>        System.out.println(words2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">[Arrays, Collectors, Exception, Files, Output, Paths,<br>Set, String, System, TreeSet, TreeSetOfWords, args,<br>class, collect, file, filter, flatMap, get, import,<br>java, length, limit, lines, main, map, matches, new,<br>nio, numbers, out, println, public, split, static,<br>stream, streams, throws, toCollection, trim, util,<br>void, words2]<br><br></code></pre></td></tr></table></figure><p><strong>Files.</strong><code>lines()</code> 打开 <strong>Path</strong> 并将其转换成为行流。下一行代码将匹配一个或多个非单词字符（<code>\\w+</code>）行进行分割，然后使用 <strong>Arrays.</strong><code>stream()</code> 将其转化成为流，并将结果展平映射成为单词流。使用 <code>matches(\\d+)</code> 查找并移除全数字字符串（<strong>注意</strong>,<code>words2</code> 是通过的）。接下来我们使用 <strong>String.</strong><code>trim()</code> 去除单词两边的空白，<code>filter()</code> 过滤所有长度小于3的单词，紧接着只获取100个单词，最后将其保存到 <strong>TreeSet</strong> 中。</p><p>我们也可以在流中生成 <strong>Map</strong>。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/MapCollector.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Character c;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Integer i;<br>    Pair(Character c, Integer i) &#123;<br>        <span class="hljs-keyword">this</span>.c = c;<br>        <span class="hljs-keyword">this</span>.i = i;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Character <span class="hljs-title">getC</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> c; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getI</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> i; &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pair(&quot;</span> + c + <span class="hljs-string">&quot;, &quot;</span> + i + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomPair</span> </span>&#123;<br>    Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>    <span class="hljs-comment">// An infinite iterator of random capital letters:</span><br>    Iterator&lt;Character&gt; capChars = rand.ints(<span class="hljs-number">65</span>,<span class="hljs-number">91</span>)<br>            .mapToObj(i -&gt; (<span class="hljs-keyword">char</span>)i)<br>            .iterator();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Stream&lt;Pair&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> rand.ints(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>).distinct()<br>                .mapToObj(i -&gt; <span class="hljs-keyword">new</span> Pair(capChars.next(), i));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapCollector</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Integer, Character&gt; map =<br>                <span class="hljs-keyword">new</span> RandomPair().stream()<br>                        .limit(<span class="hljs-number">8</span>)<br>                        .collect(<br>                                Collectors.toMap(Pair::getI, Pair::getC));<br>        System.out.println(map);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">688</span>=W, <span class="hljs-attribute">309</span>=C, <span class="hljs-attribute">293</span>=B, <span class="hljs-attribute">761</span>=N, <span class="hljs-attribute">858</span>=N, <span class="hljs-attribute">668</span>=G, <span class="hljs-attribute">622</span>=F, <span class="hljs-attribute">751</span>=N&#125;<br><br></code></pre></td></tr></table></figure><p><strong>Pair</strong> 只是一个基础的数据对象。<strong>RandomPair</strong> 创建了随机生成的 <strong>Pair</strong> 对象流。在 Java 中，我们不能直接以某种方式组合两个流。所以这里创建了一个整数流，并且使用 <code>mapToObj()</code> 将其转化成为 <strong>Pair</strong> 流。 <strong>capChars</strong> 随机生成的大写字母迭代器从流开始，然后 <code>iterator()</code> 允许我们在 <code>stream()</code> 中使用它。就我所知，这是组合多个流以生成新的对象流的唯一方法。</p><p>在这里，我们只使用最简单形式的 <code>Collectors.toMap()</code>，这个方法值需要一个可以从流中获取键值对的函数。还有其他重载形式，其中一种形式是在遇到键值冲突时，需要一个函数来处理这种情况。</p><p>大多数情况下，<code>java.util.stream.Collectors</code> 中预设的 <strong>Collector</strong> 就能满足我们的要求。除此之外，你还可以使用第二种形式的 <code>collect()</code>。 我把它留作更高级的练习，下例给出基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/SpecialCollector.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecialCollector</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ArrayList&lt;String&gt; words =<br>                FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>                        .collect(ArrayList::<span class="hljs-keyword">new</span>,<br>                                ArrayList::add,<br>                                ArrayList::addAll);<br>        words.stream()<br>                .filter(s -&gt; s.equals(<span class="hljs-string">&quot;cheese&quot;</span>))<br>                .forEach(System.out::println);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cheese</span><br><span class="hljs-attribute">cheese</span><br><br></code></pre></td></tr></table></figure><p>在这里， <strong>ArrayList</strong> 的方法已经执行了你所需要的操作，但是似乎更有可能的是，如果你必须使用这种形式的 <code>collect()</code>，则必须自己创建特殊的定义。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul><li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li><li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li><li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li></ul><p>下面来看下 <code>reduce</code> 的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Reduce.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Frobnitz</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size;<br>    Frobnitz(<span class="hljs-keyword">int</span> sz) &#123; size = sz; &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Frobnitz(&quot;</span> + size + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// Generator:</span><br>    <span class="hljs-keyword">static</span> Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BOUND = <span class="hljs-number">100</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Frobnitz <span class="hljs-title">supply</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Frobnitz(rand.nextInt(BOUND));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reduce</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream.generate(Frobnitz::supply)<br>                .limit(<span class="hljs-number">10</span>)<br>                .peek(System.out::println)<br>                .reduce((fr0, fr1) -&gt; fr0.size &lt; <span class="hljs-number">50</span> ? fr0 : fr1)<br>                .ifPresent(System.out::println);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">58</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">55</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">93</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">61</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">61</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">29</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">68</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">22</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">7</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">Frobnitz</span><span class="hljs-params">(<span class="hljs-number">29</span>)</span></span><br><br></code></pre></td></tr></table></figure><p><strong>Frobnitz</strong> 包含了一个名为 <code>supply()</code> 的生成器；因为这个方法对于 <code>Supplier&lt;Frobnitz&gt;</code> 是签名兼容的，我们可以将其方法引用传递给 <code>Stream.generate()</code>（这种签名兼容性被称作结构一致性）。无“初始值”的 <code>reduce()</code>方法返回值是 <strong>Optional</strong> 类型。<code>Optional.ifPresent()</code> 只有在结果非空的时候才会调用 <code>Consumer&lt;Frobnitz&gt;</code> （<code>println</code> 方法可以被调用是因为 <strong>Frobnitz</strong> 可以通过 <code>toString()</code> 方法转换成 <strong>String</strong>）。</p><p>Lambda 表达式中的第一个参数 <code>fr0</code> 是上一次调用 <code>reduce()</code> 的结果。而第二个参数 <code>fr1</code> 是从流传递过来的值。</p><p><code>reduce()</code> 中的 Lambda 表达式使用了三元表达式来获取结果，当其长度小于 50 的时候获取 <code>fr0</code> 否则获取序列中的下一个值 <code>fr1</code>。当取得第一个长度小于 50 的 <code>Frobnitz</code>，只要得到结果就会忽略其他。这是个非常奇怪的约束， 也确实让我们对 <code>reduce()</code> 有了更多的了解。</p><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><ul><li><code>allMatch(Predicate)</code> ：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 true 时，结果返回为 true。在第一个 false 时，则停止执行计算。</li><li><code>anyMatch(Predicate)</code>：如果流中的任意一个元素根据提供的 <strong>Predicate</strong> 返回 true 时，结果返回为 true。在第一个 false 是停止执行计算。</li><li><code>noneMatch(Predicate)</code>：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</li></ul><p>我们已经在 <code>Prime.java</code> 中看到了 <code>noneMatch()</code> 的示例；<code>allMatch()</code> 和 <code>anyMatch()</code> 的用法基本上是等同的。下面我们来探究一下短路行为。为了消除冗余代码，我们创建了 <code>show()</code>。首先我们必须知道如何统一地描述这三个匹配器的操作，然后再将其转换为 <strong>Matcher</strong> 接口。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Matching.java</span><br><span class="hljs-comment">// Demonstrates short-circuiting of *Match() operations</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> streams.RandInts.*;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Matcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BiPredicate</span>&lt;<span class="hljs-title">Stream</span>&lt;<span class="hljs-title">Integer</span>&gt;, <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">Integer</span>&gt;&gt; </span>&#123;&#125;<br>        <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matching</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Matcher match, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        System.out.println(<br>                match.test(<br>                        IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>)<br>                                .boxed()<br>                                .peek(n -&gt; System.out.format(<span class="hljs-string">&quot;%d &quot;</span>, n)),<br>                        n -&gt; n &lt; val));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        show(Stream::allMatch, <span class="hljs-number">10</span>);<br>        show(Stream::allMatch, <span class="hljs-number">4</span>);<br>        show(Stream::anyMatch, <span class="hljs-number">2</span>);<br>        show(Stream::anyMatch, <span class="hljs-number">0</span>);<br>        show(Stream::noneMatch, <span class="hljs-number">5</span>);<br>        show(Stream::noneMatch, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> true<br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> false<br><span class="hljs-symbol">1 </span>true<br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> false<br><span class="hljs-symbol">1 </span>false<br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> true<br><br></code></pre></td></tr></table></figure><p><strong>BiPredicate</strong> 是一个二元谓词，它只能接受两个参数且只返回 true 或者 false。它的第一个参数是我们要测试的流，第二个参数是一个谓词 <strong>Predicate</strong>。<strong>Matcher</strong> 适用于所有的 <strong>Stream::*Match</strong> 方法，所以我们可以传递每一个到 <code>show()</code> 中。<code>match.test()</code> 的调用会被转换成 <strong>Stream::*Match</strong> 函数的调用。</p><p><code>show()</code> 获取两个参数，<strong>Matcher</strong> 匹配器和用于表示谓词测试 <strong>n &lt; val</strong> 中最大值的 <strong>val</strong>。这个方法生成一个1-9之间的整数流。<code>peek()</code> 是用于向我们展示测试在短路之前的情况。从输出中可以看到每次都发生了短路。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li><li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/SelectElement.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> streams.RandInts.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectElement</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(rands().findFirst().getAsInt());<br>        System.out.println(<br>                rands().parallel().findFirst().getAsInt());<br>        System.out.println(rands().findAny().getAsInt());<br>        System.out.println(<br>                rands().parallel().findAny().getAsInt());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">258<br>258<br>258<br>242<br><br></code></pre></td></tr></table></figure><p><code>findFirst()</code> 无论流是否为并行化的，总是会选择流中的第一个元素。对于非并行流，<code>findAny()</code>会选择流中的第一个元素（即使从定义上来看是选择任意元素）。在这个例子中，我们使用 <code>parallel()</code> 来并行流从而引入 <code>findAny()</code> 选择非第一个流元素的可能性。</p><p>如果必须选择流中最后一个元素，那就使用 <code>reduce()</code>。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/LastElement.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LastElement</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        OptionalInt last = IntStream.range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>                .reduce((n1, n2) -&gt; n2);<br>        System.out.println(last.orElse(-<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// Non-numeric object:</span><br>        Optional&lt;String&gt; lastobj =<br>                Stream.of(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>)<br>                        .reduce((n1, n2) -&gt; n2);<br>        System.out.println(<br>                lastobj.orElse(<span class="hljs-string">&quot;Nothing there!&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">19</span><br><span class="hljs-literal">three</span><br><br></code></pre></td></tr></table></figure><p><code>reduce()</code>  的参数只是用最后一个元素替换了最后两个元素，最终只生成最后一个元素。如果为数字流，你必须使用相近的数字 <strong>Optional</strong> 类型（ numeric optional type），否则使用 <strong>Optional</strong> 类型，就像上例中的 <code>Optional&lt;String&gt;</code>。</p><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul><li><code>count()</code>：流中的元素个数。</li><li><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素。</li><li><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</li></ul><p><strong>String</strong> 类型有预设的 <strong>Comparator</strong> 实现。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Informational.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Informational</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>    main(String[] args) <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<br>                FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>).count());<br>        System.out.println(<br>                FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>                        .min(String.CASE_INSENSITIVE_ORDER)<br>                        .orElse(<span class="hljs-string">&quot;NONE&quot;</span>));<br>        System.out.println(<br>                FileToWords.stream(<span class="hljs-string">&quot;Cheese.dat&quot;</span>)<br>                        .max(String.CASE_INSENSITIVE_ORDER)<br>                        .orElse(<span class="hljs-string">&quot;NONE&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">32</span><br><span class="hljs-keyword">a</span><br>you<br><br></code></pre></td></tr></table></figure><p><code>min()</code> 和 <code>max()</code> 的返回类型为 <strong>Optional</strong>，这需要我们使用 <code>orElse()</code>来解包。</p><h3 id="数字流信息"><a href="#数字流信息" class="headerlink" title="数字流信息"></a>数字流信息</h3><ul><li><code>average()</code> ：求取流元素平均值。</li><li><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>。</li><li><code>sum()</code>：对所有流元素进行求和。</li><li><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/NumericStreamInfo.java</span><br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> streams.RandInts.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumericStreamInfo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(rands().average().getAsDouble());<br>        System.out.println(rands().max().getAsInt());<br>        System.out.println(rands().min().getAsInt());<br>        System.out.println(rands().sum());<br>        System.out.println(rands().summaryStatistics());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">507.94<br>998<br>8<br>50794<br>IntSummaryStatistics&#123;<span class="hljs-attribute">count</span>=100, <span class="hljs-attribute">sum</span>=50794, <span class="hljs-attribute">min</span>=8, <span class="hljs-attribute">average</span>=507.940000, <span class="hljs-attribute">max</span>=998&#125;<br><br></code></pre></td></tr></table></figure><p>上例操作对于 <strong>LongStream</strong> 和 <strong>DoubleStream</strong> 同样适用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java8</tag>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主流的四种限流策略都可以通过redis实现</title>
    <link href="/blog/2021/05/30/%E4%B8%BB%E6%B5%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5%E9%83%BD%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87redis%E5%AE%9E%E7%8E%B0/"/>
    <url>/blog/2021/05/30/%E4%B8%BB%E6%B5%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5%E9%83%BD%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87redis%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>在web开发中功能是基石，除了功能以外运维和防护就是重头菜了。因为在网站运行期间可能会因为突然的访问量导致业务异常、也有可能遭受别人恶意攻击</li><li>所以我们的接口需要对流量进行限制。俗称的QPS也是对流量的一种描述</li><li>针对限流现在大多应该是令牌桶算法，因为它能保证更多的吞吐量。除了令牌桶算法还有他的前身漏桶算法和简单的计数算法</li><li>下面我们来看看这四种算法</li></ul><h1 id="固定时间窗口算法"><a href="#固定时间窗口算法" class="headerlink" title="固定时间窗口算法"></a>固定时间窗口算法</h1><ul><li>固定时间窗口算法也可以叫做简单计数算法。网上有很多都将计数算法单独抽离出来。但是笔者认为计数算法是一种思想，而固定时间窗口算法是他的一种实现</li><li>包括下面滑动时间窗口算法也是计数算法的一种实现。因为计数如果不和时间进行绑定的话那么失去了限流的本质了。就变成了拒绝了</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6d0987a5f6de48eaa186711fbff0db74~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210508103957917"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>在固定的时间内出现流量溢出可以立即做出限流。每个时间窗口不会相互影响</li><li>在时间单元内保障系统的稳定。保障的时间单元内系统的吞吐量上限</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>正如图示一样，他的最大问题就是临界状态。在临界状态最坏情况会受到两倍流量请求</li><li>除了临界的情况，还有一种是在一个单元时间窗内前期如果很快的消耗完请求阈值。那么剩下的时间将会无法请求。这样就会因为一瞬间的流量导致一段时间内系统不可用。这在互联网高可用的系统中是不能接受的。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>好了，关于原理介绍及优缺点我们已经了解了。下面我们动手实现它</li><li>首先我们在实现这种计数时，采用redis是非常好的选择。这里我们通过redis实现</li></ul><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/start&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, Object&gt; paramMap)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> testService.startQps(paramMap);<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">startQps</span><span class="hljs-params">(Map&lt;String, Object&gt; paramMap)</span> </span>&#123;<br>    <span class="hljs-comment">//根据前端传递的qps上线</span><br>    Integer times = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span> (paramMap.containsKey(<span class="hljs-string">&quot;times&quot;</span>)) &#123;<br>        times = Integer.valueOf(paramMap.get(<span class="hljs-string">&quot;times&quot;</span>).toString());<br>    &#125;<br>    String redisKey = <span class="hljs-string">&quot;redisQps&quot;</span>;<br>    RedisAtomicInteger redisAtomicInteger = <span class="hljs-keyword">new</span> RedisAtomicInteger(redisKey, redisTemplate.getConnectionFactory());<br>    <span class="hljs-keyword">int</span> no = redisAtomicInteger.getAndIncrement();<br>    <span class="hljs-comment">//设置时间固定时间窗口长度 1S</span><br>    <span class="hljs-keyword">if</span> (no == <span class="hljs-number">0</span>) &#123;<br>        redisAtomicInteger.expire(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-comment">//判断是否超限  time=2 表示qps=3</span><br>    <span class="hljs-keyword">if</span> (no &gt; times) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;qps refuse request&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//返回成功告知</span><br>    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/e8d7b3347b7f4ba1b3012328e0377d17~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210508135718284"></p><ul><li><p>我们设置的qps=3 ，  我们可以看到五个并发进来后前三个正常访问，后面两个就失败了。稍等一段时间我们在并发访问，前三个又可以正常访问。说明到了下一个时间窗口</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/cbe866d8ab2f41b0a1b3ad7d24941370~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210508140028835"></p></li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/79c243b1ef2c4e37872f418ea999e375~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210508141549335"></p><h1 id="滑动时间窗口算法"><a href="#滑动时间窗口算法" class="headerlink" title="滑动时间窗口算法"></a>滑动时间窗口算法</h1><ul><li>针对固定时间窗口的缺点–临界值出现双倍流量问题。 我们的滑动时间窗口就产生了。</li><li>其实很好理解，就是针对固定时间窗口，将时间窗口统计从原来的固定间隔变成更加细度化的单元了。</li><li>在上面我们固定时间窗口演示中我们设置的时间单元是1S 。 针对1S我们将1S拆成时间戳。</li><li>固定时间窗口是统计单元随着时间的推移不断向后进行。而滑动时间窗口是我们认为的想象出一个时间单元按照相对论的思想将时间固定，我们的抽象时间单元自己移动。抽象的时间单元比实际的时间单元更小。</li><li>读者可以看下下面的动图，就可以理解了。</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/774e0952ddda4e4291f087890053ffed~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>实质上就是固定时间窗口算法的改进。所以固定时间窗口的缺点就是他的优点。</li><li>内部抽象一个滑动的时间窗，将时间更加小化。存在边界的问题更加小。客户感知更弱了。</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>不管是固定时间窗口算法还是滑动时间窗口算法，他们都是基于计数器算法进行优化，但是他们对待限流的策略太粗暴了。</li><li>为什么说粗暴呢，未限流他们正常放行。一旦达到限流后就会直接拒绝。这样我们会损失一部分请求。这对于一个产品来说不太友好</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li>滑动时间窗口是将时间更加细化，上面我们是通过redis#setnx实现的。这里我们就无法通过他统一记录了。我们应该加上更小的时间单元存储到一个集合汇总。然后根据集合的总量计算限流。redis的zsett数据结构就和符合我们的需求。</li><li>为什么选择zset呢，因为redis的zset中除了值以外还有一个权重。会根据这个权重进行排序。如果我们将我们的时间单元及时间戳作为我们的权重，那么我们获取统计的时候只需要按照一个时间戳范围就可以了。</li><li>因为zset内元素是唯一的，所以我们的值采用uuid或者雪花算法一类的id生成器</li></ul><h3 id="controller-1"><a href="#controller-1" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/startList&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">startList</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, Object&gt; paramMap)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> testService.startList(paramMap);<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">String redisKey = <span class="hljs-string">&quot;qpsZset&quot;</span>;<br>        Integer times = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">if</span> (paramMap.containsKey(<span class="hljs-string">&quot;times&quot;</span>)) &#123;<br>            times = Integer.valueOf(paramMap.get(<span class="hljs-string">&quot;times&quot;</span>).toString());<br>        &#125;<br>        <span class="hljs-keyword">long</span> currentTimeMillis = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> interMills = inter * <span class="hljs-number">1000L</span>;<br>        Long count = redisTemplate.opsForZSet().count(redisKey, currentTimeMillis - interMills, currentTimeMillis);<br>        <span class="hljs-keyword">if</span> (count &gt; times) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;qps refuse request&quot;</span>);<br>        &#125;<br>        redisTemplate.opsForZSet().add(redisKey, UUID.randomUUID().toString(), currentTimeMillis);<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="结果测试-1"><a href="#结果测试-1" class="headerlink" title="结果测试"></a>结果测试</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/71e8932b64d64367b048e9628aa6d7c4~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210508150557980"></p><ul><li>和固定时间窗口采用相同的并发。为什么上面也会出现临界状况呢。因为在代码里时间单元间隔比固定时间间隔采用还要大 。 上面演示固定时间窗口时间单元是1S出现了最坏情况。而滑动时间窗口设计上就应该间隔更短。而我设置成10S 也没有出现坏的情况</li><li>这里就说明滑动比固定的优处了。如果我们调更小应该更加不会出现临界问题，不过说到底他还是避免不了临界出现的问题</li></ul><h1 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h1><ul><li>滑动时间窗口虽然可以极大程度的规避临界值问题，但是始终还是避免不了</li><li>另外时间算法还有个致命的问题，他无法面对突如其来的大量流量，因为他在达到限流后直接就拒绝了其他额外流量</li><li>针对这个问题我们继续优化我们的限流算法。 漏桶算法应运而生</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/e374223ef38248fb8a30cc12de223adf~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210508154607271"></p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>面对限流更加的柔性，不在粗暴的拒绝。</li><li>增加了接口的接收性</li><li>保证下流服务接收的稳定性。均匀下发</li></ul><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>我觉得没有缺点。非要鸡蛋里挑骨头那我只能说漏桶容量是个短板</li></ul><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><h3 id="controller-2"><a href="#controller-2" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/startLoutong&quot;,method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">startLoutong</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, Object&gt; paramMap)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> testService.startLoutong(paramMap);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="service-2"><a href="#service-2" class="headerlink" title="service"></a>service</h3><ul><li>在service中我们通过redis的list的功能模拟出桶的效果。这里代码是实验室性质的。在真实使用中我们还需要考虑并发的问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">startLoutong</span><span class="hljs-params">(Map&lt;String, Object&gt; paramMap)</span> </span>&#123;<br>    String redisKey = <span class="hljs-string">&quot;qpsList&quot;</span>;<br>    Integer times = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span> (paramMap.containsKey(<span class="hljs-string">&quot;times&quot;</span>)) &#123;<br>        times = Integer.valueOf(paramMap.get(<span class="hljs-string">&quot;times&quot;</span>).toString());<br>    &#125;<br>    Long size = redisTemplate.opsForList().size(redisKey);<br>    <span class="hljs-keyword">if</span> (size &gt;= times) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;qps refuse request&quot;</span>);<br>    &#125;<br>    Long aLong = redisTemplate.opsForList().rightPush(redisKey, paramMap);<br>    <span class="hljs-keyword">if</span> (aLong &gt; times) &#123;<br>        <span class="hljs-comment">//为了防止并发场景。这里添加完成之后也要验证。  即使这样本段代码在高并发也有问题。此处演示作用</span><br>        redisTemplate.opsForList().trim(redisKey, <span class="hljs-number">0</span>, times-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;qps refuse request&quot;</span>);<br>    &#125;<br>    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="下游消费"><a href="#下游消费" class="headerlink" title="下游消费"></a>下游消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchedulerTask</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> String redisKey=<span class="hljs-string">&quot;qpsList&quot;</span>;<br><br>    <span class="hljs-meta">@Scheduled(cron=&quot;*/1 * * * * ?&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//一次性消费两个</span><br>        System.out.println(<span class="hljs-string">&quot;正在消费。。。。。。&quot;</span>);<br>        redisTemplate.opsForList().trim(redisKey, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>我们还是通过50并发循环10次访问。我们可以发现只有在一开始能达到比较高的吞吐量。在随后桶的容量满了之后。而下游水滴速率比上游请求速率慢的情况下。只能以下游恒定的速度接收访问。</li><li>他的问题也暴露的很明显。针对时间窗口的不足漏桶进行的不足，但是仍是不足。无法彻底避免请求溢出的问题。</li><li>请求溢出本身就是一种灾难性的问题。所有的算法目前都没有解决这个问题。只是在减缓他带来的问题</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4935f88aba314abb90655ba7be2264bb~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h1 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h1><ul><li>令牌桶和漏桶法是一样的。只不过将桶的作用方向改变了一下。</li><li>漏桶的出水速度是恒定的，如果流量突然增加的话我们就只能拒绝入池</li><li>但是令牌桶是将令牌放入桶中，我们知道正常情况下令牌就是一串字符当桶满了就拒绝令牌的入池，但是面对高流量的时候正常加上我们的超时时间就留下足够长的时间生产及消费令牌了。这样就尽可能的不会造成请求的拒绝</li><li>最后，不论是对于令牌桶拿不到令牌被拒绝，还是漏桶的水满了溢出，都是为了保证大部分流量的正常使用，而牺牲掉了少部分流量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">startLingpaitong</span><span class="hljs-params">(Map&lt;String, Object&gt; paramMap)</span> </span>&#123;<br>        String redisKey = <span class="hljs-string">&quot;lingpaitong&quot;</span>;<br>        String token = redisTemplate.opsForList().leftPop(redisKey).toString();<br>        <span class="hljs-comment">//正常情况需要验证是否合法，防止篡改</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;令牌桶拒绝&quot;</span>);<br>        &#125;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>复制代码<br><span class="hljs-meta">@Scheduled(cron=&quot;*/1 * * * * ?&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//一次性生产两个</span><br>        System.out.println(<span class="hljs-string">&quot;正在消费。。。。。。&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            redisTemplate.opsForList().rightPush(redisKey, i);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>限流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot优雅地实现接口参数校验</title>
    <link href="/blog/2021/05/29/SpringBoot%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <url>/blog/2021/05/29/SpringBoot%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>validation主要是校验用户提交的数据的合法性，比如是否为空，密码是否符合规则，邮箱格式是否正确等等，校验框架比较多，用的比较多的是hibernate-validator， 也支持国际化，也可以自定义校验类型的注解，这里只是简单地演示校验框架在Spring Boot中的简单集成，要想了解更多可以参考 hibernate-validator。</p><h1 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1. pom.xml"></a><strong>1. pom.xml</strong></h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-dto"><a href="#2-dto" class="headerlink" title="2. dto"></a><strong>2. dto</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoIDto</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-meta">@Length(min=3, max=10)</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-meta">@Email</span><br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-meta">@Pattern(regexp=&quot;^((13[0-9])|(15[^4,\\D])|(18[0,3-9]))\\d&#123;8&#125;$&quot;, message=&quot;手机号格式不正确&quot;)</span><br>    <span class="hljs-keyword">private</span> String phone;<br><br>    <span class="hljs-meta">@Min(value=18)</span><br>    <span class="hljs-meta">@Max(value = 200)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-meta">@NotBlank</span><br>    <span class="hljs-meta">@Length(min=6, max=12, message=&quot;昵称长度为6到12位&quot;)</span><br>    <span class="hljs-keyword">private</span> String nickname;<br><br>     <span class="hljs-comment">// Getter &amp; Setter</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-controller"><a href="#3-controller" class="headerlink" title="3. controller"></a><strong>3. controller</strong></h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.springframework.validation.BindingResult;<br><span class="hljs-keyword">import</span> org.springframework.validation.FieldError;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleController</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/users&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"><span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> UserInfoIDto userInfoIDto, BindingResult result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            FieldError fieldError = result.getFieldError();<br>            <span class="hljs-built_in">String</span> field = fieldError.getField();<br>            <span class="hljs-built_in">String</span> msg = fieldError.getDefaultMessage();<br><br>            <span class="hljs-keyword">return</span> field + <span class="hljs-string">&quot;:&quot;</span> + msg;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;开始注册用户...&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/p80hag.png"></p><h1 id="4-去掉BindingResult参数"><a href="#4-去掉BindingResult参数" class="headerlink" title="4. 去掉BindingResult参数"></a><strong>4. 去掉BindingResult参数</strong></h1><p>每个接口都需要BindingResult参数，而且每个接口都需要处理错误信息，这样增加一个参数也不优雅，处理错误信息代码量也很重复。如果去掉BindingResult参数，系统就会报错MethodArgumentNotValidException，我们只需要使用全局异常来捕获该错误，处理一下就可以省略传BindingResult参数了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleController</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-meta-string">&quot;/users&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String register(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> UserInfoIDto userInfoIDto)&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;开始注册用户...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@RestControllerAdvice 用于拦截所有的@RestController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandlerAdvice</span> </span>&#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span><br>    <span class="hljs-keyword">public</span> String methodArgumentNotValidException(MethodArgumentNotValidException e) &#123;<br>        <span class="hljs-comment">// 从异常对象中拿到ObjectError对象</span><br>        ObjectError objectError = e.getBindingResult().getAllErrors().<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 然后提取错误提示信息进行返回</span><br>        <span class="hljs-keyword">return</span> objectError.getDefaultMessage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/de4c834b26844f0588dffbd6b5c5c3b5~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h1 id="5-统一返回格式"><a href="#5-统一返回格式" class="headerlink" title="5. 统一返回格式"></a><strong>5. 统一返回格式</strong></h1><p>错误码枚举</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> ErrorCodeEnum &#123;<br>    SUCCESS(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;成功&quot;</span>),<br>    FAILED(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;响应失败&quot;</span>),<br>    VALIDATE_FAILED(<span class="hljs-number">1002</span>, <span class="hljs-string">&quot;参数校验失败&quot;</span>),<br>    ERROR(<span class="hljs-number">5000</span>, <span class="hljs-string">&quot;未知错误&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> msg;<br><br>    <span class="hljs-function"><span class="hljs-title">ErrorCodeEnum</span>(<span class="hljs-params">int code, <span class="hljs-built_in">String</span> msg</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义异常。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Getter</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">APIException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> int code;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> msg;<br><br>    public <span class="hljs-type">APIException</span>(<span class="hljs-type">ErrorCodeEnum</span> errorCodeEnum) &#123;<br>        <span class="hljs-keyword">super</span>(errorCodeEnum.getMsg());<br>        <span class="hljs-keyword">this</span>.code = errorCodeEnum.getCode();<br>        <span class="hljs-keyword">this</span>.msg = errorCodeEnum.getMsg();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义返回格式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Response</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 状态码，比如1000代表响应成功</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> int code;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 响应信息，用来说明响应情况</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String msg;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 响应的具体数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">data</span>;<br><br>    <span class="hljs-keyword">public</span> Response(T <span class="hljs-keyword">data</span>) &#123;<br>        <span class="hljs-keyword">this</span>.code = ErrorCodeEnum.SUCCESS.getCode();<br>        <span class="hljs-keyword">this</span>.msg = ErrorCodeEnum.SUCCESS.getMsg();<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Response(int code, String msg) &#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>全局异常处理器增加对APIException的拦截，并修改异常时返回的数据格式。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@RestControllerAdvice<br>public <span class="hljs-keyword">class</span> GlobalExceptionHandlerAdvice &#123;<br><br>    @<span class="hljs-constructor">ExceptionHandler(MethodArgumentNotValidException.<span class="hljs-params">class</span>)</span><br>    public Response&lt;String&gt; <span class="hljs-keyword">method</span><span class="hljs-constructor">ArgumentNotValidException(MethodArgumentNotValidException <span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-comment">// 从异常对象中拿到ObjectError对象</span><br>        ObjectError objectError = e.get<span class="hljs-constructor">BindingResult()</span>.get<span class="hljs-constructor">AllErrors()</span>.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 然后提取错误提示信息进行返回</span><br>        return <span class="hljs-keyword">new</span> Response&lt;&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ErrorCodeEnum</span>.</span><span class="hljs-module"><span class="hljs-identifier">VALIDATE_FAILED</span>.</span></span>get<span class="hljs-constructor">Code()</span>, objectError.get<span class="hljs-constructor">DefaultMessage()</span>);<br>    &#125;<br><br>    @<span class="hljs-constructor">ExceptionHandler(APIException.<span class="hljs-params">class</span>)</span><br>    public Response&lt;String&gt; <span class="hljs-constructor">APIExceptionHandler(APIException <span class="hljs-params">e</span>)</span> &#123;<br>        return <span class="hljs-keyword">new</span> Response&lt;&gt;(e.get<span class="hljs-constructor">Code()</span>, e.get<span class="hljs-constructor">Msg()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SimpleController 增加一个抛出异常的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleController</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/users&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"><span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> UserInfoIDto userInfoIDto</span>)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始注册用户...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/users&quot;</span>)<br>    <span class="hljs-keyword">public</span> Response&lt;UserInfoIDto&gt; <span class="hljs-function"><span class="hljs-title">list</span>(<span class="hljs-params"></span>)</span> &#123;<br>        UserInfoIDto userInfoIDto = <span class="hljs-keyword">new</span> UserInfoIDto();<br>        userInfoIDto.setUsername(<span class="hljs-string">&quot;monday&quot;</span>);<br>        userInfoIDto.setAge(<span class="hljs-number">30</span>);<br>        userInfoIDto.setPhone(<span class="hljs-string">&quot;123456789&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> APIException(ErrorCodeEnum.ERROR);<br>        &#125;<br>        <span class="hljs-comment">// 为了保持数据格式统一，必须使用Response包装一下</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response&lt;&gt;(userInfoIDto);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/45e974e9f5a14fac8a7bb4bc475539cc~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>报错返回的格式。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/822679e70b524691af1b98402428dfbd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>不报错，返回的格式。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8e4fb6d102fd45dc83c98668aca504bf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h1 id="6-去掉接口中的Response包装"><a href="#6-去掉接口中的Response包装" class="headerlink" title="6. 去掉接口中的Response包装"></a><strong>6. 去掉接口中的Response包装</strong></h1><p>@RestControllerAdvice既可以全局拦截异常也可拦截指定包下正常的返回值，可以对返回值进行修改。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestControllerAdvice</span>(basePackages = &#123;<span class="hljs-string">&quot;com.example.validator.controller&quot;</span>&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseControllerAdvice</span> <span class="hljs-title">implements</span> <span class="hljs-title">ResponseBodyAdvice</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对那些方法需要包装，如果接口直接返回Response就没有必要再包装了</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-variable">returnType</span></span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-variable">aClass</span></span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return </span>如果为true才会执行beforeBodyWrite</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">supports</span>(<span class="hljs-params">MethodParameter returnType, Class&lt;? <span class="hljs-keyword">extends</span> HttpMessageConverter&lt;?&gt;&gt; aClass</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> !returnType.getParameterType().equals(Response.class);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">beforeBodyWrite</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> data, MethodParameter returnType, MediaType mediaType, Class&lt;? <span class="hljs-keyword">extends</span> HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest request, ServerHttpResponse response</span>)</span> &#123;<br>        <span class="hljs-comment">// String类型不能直接包装，所以要进行些特别的处理</span><br>        <span class="hljs-keyword">if</span> (returnType.getGenericParameterType().equals(<span class="hljs-built_in">String</span>.class)) &#123;<br>            ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 将数据包装在Response里后，再转换为json字符串响应给前端</span><br>                <span class="hljs-keyword">return</span> objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> Response&lt;&gt;(data));<br>            &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> APIException(ErrorCodeEnum.ERROR);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 这里统一包装</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response&lt;&gt;(data);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleController</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/users&quot;</span>)<br>    <span class="hljs-keyword">public</span> UserInfoIDto <span class="hljs-function"><span class="hljs-title">list</span>(<span class="hljs-params"></span>)</span> &#123;<br>        UserInfoIDto userInfoIDto = <span class="hljs-keyword">new</span> UserInfoIDto();<br>        userInfoIDto.setUsername(<span class="hljs-string">&quot;monday&quot;</span>);<br>        userInfoIDto.setAge(<span class="hljs-number">30</span>);<br>        userInfoIDto.setPhone(<span class="hljs-string">&quot;123456789&quot;</span>);<br>        <span class="hljs-comment">// 直接返回值，不需要再使用Response包装</span><br>        <span class="hljs-keyword">return</span> userInfoIDto;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6d82f14a5b654c1fb2d737daf6ec4b8b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h1 id="7-每个校验错误都对应不同的错误码"><a href="#7-每个校验错误都对应不同的错误码" class="headerlink" title="7. 每个校验错误都对应不同的错误码"></a><strong>7. 每个校验错误都对应不同的错误码</strong></h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(&#123;ElementType.FIELD&#125;)<br>public <span class="hljs-variable">@interface</span> ValidateErrorCode &#123;<br>    <span class="hljs-comment">/** 校验错误码 code */</span><br>    <span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">value</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">100000</span>;<br>&#125;<br><br>复制代码<br>@<span class="hljs-selector-tag">Data</span><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">UserInfoIDto</span> &#123;<br>    <span class="hljs-variable">@NotBlank</span><br>    <span class="hljs-variable">@Email</span><br>    <span class="hljs-variable">@ValidateErrorCode</span>(value = <span class="hljs-number">20000</span>)<br>    private String email;<br><br>    <span class="hljs-variable">@NotBlank</span><br>    <span class="hljs-variable">@Pattern</span>(regexp=<span class="hljs-string">&quot;^((13[0-9])|(15[^4,\\D])|(18[0,3-9]))\\d&#123;8&#125;$&quot;</span>, message=<span class="hljs-string">&quot;手机号格式不正确&quot;</span>)<br>    <span class="hljs-variable">@ValidateErrorCode</span>(value = <span class="hljs-number">30000</span>)<br>    private String phone;<br>&#125;<br></code></pre></td></tr></table></figure><p>校验异常获取注解中的错误码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">ExceptionHandler(MethodArgumentNotValidException.<span class="hljs-params">class</span>)</span><br>    public Response&lt;String&gt; <span class="hljs-keyword">method</span><span class="hljs-constructor">ArgumentNotValidException(MethodArgumentNotValidException <span class="hljs-params">e</span>)</span> throws NoSuchFieldException &#123;<br>        <span class="hljs-comment">// 从异常对象中拿到ObjectError对象</span><br>        ObjectError objectError = e.get<span class="hljs-constructor">BindingResult()</span>.get<span class="hljs-constructor">AllErrors()</span>.get(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 参数的Class对象，等下好通过字段名称获取Field对象</span><br>        Class&lt;?&gt; parameterType = e.get<span class="hljs-constructor">Parameter()</span>.get<span class="hljs-constructor">ParameterType()</span>;<br>        <span class="hljs-comment">// 拿到错误的字段名称</span><br>        String fieldName = e.get<span class="hljs-constructor">BindingResult()</span>.get<span class="hljs-constructor">FieldError()</span>.get<span class="hljs-constructor">Field()</span>;<br>        Field field = parameterType.get<span class="hljs-constructor">DeclaredField(<span class="hljs-params">fieldName</span>)</span>;<br>        <span class="hljs-comment">// 获取Field对象上的自定义注解</span><br>        ValidateErrorCode annotation = field.get<span class="hljs-constructor">Annotation(ValidateErrorCode.<span class="hljs-params">class</span>)</span>;<br>        <span class="hljs-keyword">if</span> (annotation != null) &#123;<br>            return <span class="hljs-keyword">new</span> Response&lt;&gt;(annotation.value<span class="hljs-literal">()</span>,objectError.get<span class="hljs-constructor">DefaultMessage()</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 然后提取错误提示信息进行返回</span><br>        return <span class="hljs-keyword">new</span> Response&lt;&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ErrorCodeEnum</span>.</span><span class="hljs-module"><span class="hljs-identifier">VALIDATE_FAILED</span>.</span></span>get<span class="hljs-constructor">Code()</span>, objectError.get<span class="hljs-constructor">DefaultMessage()</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a1b041884421458e9668814a5ca9c62d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/71dcc393adb441e78c28da919f7fbbdb~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h1 id="8-个别接口不统一包装响应"><a href="#8-个别接口不统一包装响应" class="headerlink" title="8. 个别接口不统一包装响应"></a><strong>8. 个别接口不统一包装响应</strong></h1><p>有时候第三方接口回调我们的接口，我们的接口必须按照第三方定义的返回格式来，此时第三方不一定和我们自己的返回格式一样，所以要提供一种可以绕过统一包装的方式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NotResponseWrap &#123;<br>&#125;<br><br>复制代码<br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleController</span> </span>&#123;<br><br>    <span class="hljs-meta">@NotResponseWrap</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-meta-string">&quot;/users&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String register(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> UserInfoIDto userInfoIDto)&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;开始注册用户...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ResponseControllerAdvice 增加一个不包装的条件，配置了@NotResponseWrap注解就跳过包装。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">@Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> supports(MethodParameter returnType, <span class="hljs-class"><span class="hljs-keyword">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpMessageConverter</span>&lt;?&gt;&gt; <span class="hljs-title">aClass</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> !(returnType.getParameterType().equals(Response.<span class="hljs-keyword">class</span>) || returnType.hasMethodAnnotation(NotResponseWrap.<span class="hljs-keyword">class</span>));<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4727801ce2674245ad3e1d8755246568~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>校验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL优化原理</title>
    <link href="/blog/2021/05/28/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    <url>/blog/2021/05/28/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>ySQL逻辑架构</strong><br> 如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1645ac4363d74142842ea6db503bf2f7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a79749b0dc46457e8b7592483403db7e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p><p>MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。<br> 最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p><p><strong>MySQL查询过程</strong><br> 我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。<br> 当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/01034bb2591f4e97b1c47cda4035f9af~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/be0aa000e60b475fa5c4e50cbb8a3f9e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><strong>客户端/服务端通信协议</strong><br> MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。</p><p>一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p><p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p><p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。</p><p><strong>查询缓存</strong><br> 在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p><p>MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p><p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p><p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p><p>正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存<br><span class="hljs-bullet">2.</span> 如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗<br></code></pre></td></tr></table></figure><p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 用多个小表代替一个大表，注意不要过度设计<br><span class="hljs-bullet">2.</span> 批量插入代替循环单条插入<br><span class="hljs-bullet">3.</span> 合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适<br><span class="hljs-bullet">4.</span> 可以通过SQL<span class="hljs-emphasis">_CACHE和SQL_</span>NO<span class="hljs-emphasis">_CACHE来控制某个查询语句是否需要进行缓存</span><br></code></pre></td></tr></table></figure><p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p><p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p><p><strong>语法解析和预处理</strong><br> MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等。</p><p><strong>查询优化</strong><br> 经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p><p>MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_message limit <span class="hljs-number">10</span>;<br><br>...省略结果集<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;last_query_cost&#x27;</span>;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------------+</span><br><br><span class="hljs-operator">|</span> Variable_name   <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span>       <span class="hljs-operator">|</span><br><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------------+</span><br><br><span class="hljs-operator">|</span> Last_query_cost <span class="hljs-operator">|</span> <span class="hljs-number">6391.799000</span> <span class="hljs-operator">|</span><br><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------------+</span><br></code></pre></td></tr></table></figure><p>示例中的结果表示优化器认为大概需要做6391个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p><p>有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p><p>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：<br> 重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</p><p>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）</p><p>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</p><p>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）</p><p>随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p><p><strong>查询执行引擎</strong><br> 在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一张表由一个handler实例表示。</p><p>实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p><p><strong>返回结果给客户端</strong><br> 查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等。</p><p>如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。<br> 结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。</p><p>需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。</p><p>回头总结一下MySQL整个查询执行过程，总的来说分为6个步骤：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">客户端向MySQL服务器发送一条查询请求<br>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段<br>服务器进行<span class="hljs-keyword">SQL</span>解析、预处理、再由优化器生成对应的执行计划<br>MySQL根据执行计划，调用存储引擎的API来执行查询<br>将结果返回给客户端，同时缓存查询结果<br></code></pre></td></tr></table></figure><p><strong>性能优化建议</strong><br> 看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：不要听信你看到的关于优化的“绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。</p><p><strong>1、Scheme设计与数据类型优化</strong><br> 选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串。<br> 这里总结几个可能容易理解错误的技巧：</p><ol><li>通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。</li><li>对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。</li><li>UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。</li><li>通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。</li><li>TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。</li><li>大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。</li><li>schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。</li><li>大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。</li></ol><p><strong>2、创建高性能索引</strong><br> 索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p><p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p><p><strong>3、索引相关的数据结构和算法</strong><br> 通常我们所说的索引是指B-Tree索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MySQL在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如InnoDB就是使用的B+Tree。</p><p>B+Tree中的B是指balance，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p><p>在介绍B+Tree前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。</p><p>所以二叉查找树的平均查找次数为(3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/39bb7fdbbda743f2bbb28ea36233b4ee~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/fccabab05f22414bb66e51eafc6299eb~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>由于二叉查找树可以任意构造，同样的值，可以构造出如图②的二叉查找树，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即平衡二叉树（AVL树）。<br> 平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于1。显然图②不满足平衡二叉树的定义，而图①是一课平衡二叉树。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。比如图①的平衡二叉树，当用户需要插入一个新的值9的节点时，就需要做出如下变动。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/771cd567cd3a480684e16226d6fdd73d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/3f07a0e25e4d4d6090cf6efeac91f069~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么MySQL索引不直接使用平衡二叉树？</p><p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。</p><p>可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的I/O读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的I/O存取次数?</p><p>一种行之有效的解决方法是减少树的深度，将二叉树变为m叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为2的简化了的B+Tree。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6daac28f9e144b00ab34d21953f578de~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/08a14c03d41243f2b880685d5505d876~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>怎么理解这两个特征？MySQL将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。</p><p>所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，如果查找大于20而小于30的记录，只需要找到节点20，就可以遍历指针依次找到25、30。如果没有链接指针的话，就无法进行区间查找。这也是MySQL使用B+Tree作为索引存储结构的重要原因。</p><p>MySQL为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘I/O，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。</p><p>页是计算机管理存储器的逻辑块，硬件及OS往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多OS中，页的大小通常为4K）。主存和磁盘以页为单位交换数据。</p><p>当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后一起返回，程序继续运行。</p><p>MySQL巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点只需一次I/O。</p><p>假设B+Tree的高度为h，一次检索最多需要h-1I/O（根节点常驻内存），复杂度O(h)=O(logMN)。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。</p><p>最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p><p>仍以上面的树为例，我们假设每个节点只能存储4个内节点。首先要插入第一个节点28，如下图所示。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2b808c79ad6748c597453f40db8f31a6~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a3cc1efead72420b9c646a54aa3bd6c4~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>接着插入下一个节点70，在Index Page中查询后得知应该插入到50 - 70之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为50，所以根据中间值来拆分叶子节点，如下图所示。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f7d920b54a414adea15ad753ac819f8e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ab795be406644dbdb216abacdcc7112b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>最后插入一个节点95，这时候Index Page和Leaf Page都满了，就需要做两次拆分，如下图所示。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ab8142a981c34d399617216c6441081b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2c6487833f01429985a6eabf638a9491~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>拆分后最终形成了这样一颗树。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/cec96fd604fd474ba257c0914675790b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/00ea5cc9b545428385caf617d4f9bb86~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要I/O操作，为了尽可能的减少页的拆分操作，B+Tree也提供了类似于平衡二叉树的旋转功能。</p><p>当Leaf Page已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入70的时候，并不会去做页拆分，而是左旋操作。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/acd740a5d87a4fec923746e9ad8543aa~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/29925f1e0cbe4663ad9ad0b14e7035c4~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。</p><p><strong>高性能策略</strong><br> 通过上文，相信你对B+Tree的数据结构已经有了大致的了解，但MySQL中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> People(<br><br>    last_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    first_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    dob <span class="hljs-type">date</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    gender enum(`m`,`f`) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    key(last_name,first_name,dob)<br><br>);<br></code></pre></td></tr></table></figure><p>对于表中每一行数据，索引中包含了last_name、first_name、dob列的值，下图展示了索引是如何组织数据存储的。<br> <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8b88a92154cb4c5091c1d8c97d0e8aaf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f31ba9c868254d8abc4176374bf52faf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的“最左原则”。</p><p><strong>1、MySQL不会使用索引的情况：非独立的列</strong><br> “独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：<br> <code>select * from where id + 1 = 5</code><br> 我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，使用函数是同样的道理。</p><p><strong>2、前缀索引</strong><br> 如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p><p><strong>3、多列索引和索引顺序</strong><br> 在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，所以在老版本，比如MySQL5.0之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在actor_id和film_id两个列上都建立了独立的索引，然后有如下查询：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> film_id,actor_id <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> actor_id = <span class="hljs-number">1</span> or film_id = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>老版本的MySQL会随机选择一个索引，但新版本做如下的优化：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> film_id,actor_id <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> actor_id = <span class="hljs-number">1</span> <br><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><br><span class="hljs-keyword">select</span> film_id,actor_id <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> actor_id &lt;&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。</p><p>当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</p><p>因此explain时如果发现有索引合并（Extra字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</p><p>前面我们提到过索引如何组织数据存储的，从图中可以看到多列索引时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p><p>索引选择性是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。</p><p>理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> payment <span class="hljs-keyword">where</span> staff_id = <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> customer_id = <span class="hljs-number">584</span><br></code></pre></td></tr></table></figure><p>是应该创建(staff_id,customer_id)的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近1就把哪个字段索引前面就好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> staff_id)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> staff_id_selectivity,<br><br>       <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> customer_id)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> customer_id_selectivity,<br><br>       <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> payment<br></code></pre></td></tr></table></figure><p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> user_id <span class="hljs-keyword">from</span> trade <span class="hljs-keyword">where</span> user_group_id = <span class="hljs-number">1</span> and trade_amount &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>MySQL为这个查询选择了索引(user_group_id,trade_amount)，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</p><p>推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</p><p><strong>4、避免多个范围条件</strong><br> 实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>.* <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> login_time &gt; <span class="hljs-string">&#x27;2017-04-01&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">18</span> <span class="hljs-keyword">and</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p>这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</p><p><strong>5、覆盖索引</strong><br> 如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</p><p>索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量<br> 索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多</p><p><strong>6、使用索引扫描来排序</strong><br> MySQL有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。如果explain的结果中type列的值为index表示使用了索引扫描来做排序。</p><p>扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。<br> 在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好的。</p><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。</p><p>ORDER BY子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其它情况下都需要执行排序操作，而无法利用索引排序。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 最左列为常数，索引：(date,staff_id,customer_id)</span><br><br><span class="hljs-keyword">select</span>  staff_id,customer_id <span class="hljs-keyword">from</span> demo <span class="hljs-keyword">where</span> <span class="hljs-built_in">date</span> = <span class="hljs-string">&#x27;2015-06-01&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> staff_id,customer_id<br></code></pre></td></tr></table></figure><p><strong>7、冗余和重复索引</strong><br> 冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。</p><p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p><p><strong>8、删除长期未使用的索引</strong><br> 定期删除一些长时间未使用过的索引是一个非常好的习惯。<br> 关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。</p><p>对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，explain后再提测是一种美德。</p><p><strong>特定类型查询优化</strong></p><p><strong>优化COUNT()查询</strong><br> COUNT()可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p><p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用COUNT(*)，意义清晰，且性能更好。<br> 有时候某些业务场景并不需要完全精确的COUNT值，可以用近似值来代替，EXPLAIN出来的行数就是一个不错的近似值，而且执行EXPLAIN并不需要真正地去执行查询，所以成本非常低。通常来说，执行COUNT()都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用redis这样的外部缓存系统。</p><p><strong>优化关联查询</strong><br> 在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</p><ol><li>确保ON和USING字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么就不需要在A表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化。</li></ol><p>要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行嵌套循环关联操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p><p>太抽象了？以上面的示例来说明，比如有这样的一个查询：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">SELECT <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>xx,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>yy<br><br>FROM A INNER JOIN B <span class="hljs-constructor">USING(<span class="hljs-params">c</span>)</span><br><br>WHERE <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>xx IN (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>复制代码<br></code></pre></td></tr></table></figure><p>假设MySQL按照查询中的关联顺序A、B来进行关联操作，那么可以用下面的伪代码表示MySQL如何完成这个查询：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">outer_iterator = SELECT <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>xx,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>c FROM A WHERE <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>xx IN (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br><br>outer_row = outer_iterator.next;<br><br><span class="hljs-keyword">while</span>(outer_row) &#123;<br><br>    inner_iterator = SELECT <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>yy FROM B WHERE <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>c = outer_row.c;<br><br>    inner_row = inner_iterator.next;<br><br>    <span class="hljs-keyword">while</span>(inner_row) &#123;<br><br>        output<span class="hljs-literal">[<span class="hljs-identifier">inner_row</span>.<span class="hljs-identifier">yy</span>,<span class="hljs-identifier">outer_row</span>.<span class="hljs-identifier">xx</span>]</span>;<br><br>        inner_row = inner_iterator.next;<br><br>    &#125;<br><br>    outer_row = outer_iterator.next;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，最外层的查询是根据A.xx列来查询的，A.c上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显B.c上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p><p><strong>优化LIMIT分页</strong><br> 当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p><p>一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。</p><p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> film_id,description <span class="hljs-keyword">FROM</span> film <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">title</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">50</span>,<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>如果这张表非常大，那么这个查询最好改成下面的样子：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> film.film_id,film.description<br><br><span class="hljs-keyword">FROM</span> film <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<br><br>    <span class="hljs-keyword">SELECT</span> film_id <span class="hljs-keyword">FROM</span> film <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">title</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">50</span>,<span class="hljs-number">5</span><br><br>) <span class="hljs-keyword">AS</span> tmp <span class="hljs-keyword">USING</span>(film_id);<br></code></pre></td></tr></table></figure><p>这里的延迟关联将大大提升查询效率，让MySQL扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p><p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：<br> <code>SELECT id FROM t LIMIT 10000, 10;</code><br> 改为：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id &gt; <span class="hljs-number">10000</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>其它优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p><p><strong>优化UNION</strong><br> MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。</p><p>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用ALL关键字，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p><p><strong>结语</strong><br> 理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p><p>其他也没啥说的了，给大家留两个思考题吧，可以在脑袋里想想答案，这也是大家经常挂在嘴边的，但很少有人会思考为什么？</p><ol><li>有非常多的程序员在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</li><li>JOIN本身也挺方便的，直接查询就好了，为什么还需要视图呢？</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序数组的三种方式</title>
    <link href="/blog/2021/05/24/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/blog/2021/05/24/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>这是 LeetCode 上的 <strong><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/gong-shui-san-xie-yi-ti-san-jie-shuang-z-47gj/">88. 合并两个有序数组</a></strong> 。</p><p>Tag : 「双指针」、「排序」</p><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</p><p>你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">nums2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>复制代码<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums1</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">m</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">nums2</span> = [], <span class="hljs-attr">n</span> = <span class="hljs-number">0</span><br><br>输出：[<span class="hljs-number">1</span>]<br>复制代码<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>nums1.length == m + n</li><li>nums2.length == n</li><li>0 &lt;= m, n &lt;= 200</li><li>1 &lt;= m + n &lt;= 200</li><li>-10910^9109 &lt;= nums1[i], nums2[i] &lt;= 10910^9109</li></ul><hr><h3 id="双指针（额外空间）"><a href="#双指针（额外空间）" class="headerlink" title="双指针（额外空间）"></a>双指针（额外空间）</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/e248acc91ba9435d80739fd0f6505724~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>一个简单的做法是，创建一个和 nums1nums1nums1 等长的数组 arrarrarr，使用双指针将 num1num1num1 和 nums2nums2nums2 的数据迁移到 arrarrarr。</p><p>最后再将 arrarrarr 复制到 nums1nums1nums1 中。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> total = m + n;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[total];<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; m || j &lt; n;) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>                arr[idx++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; m) &#123;<br>                arr[idx++] = nums1[i++];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; n) &#123;<br>                arr[idx++] = nums2[j++];<br>            &#125;<br>        &#125;<br>        System.arraycopy(arr, <span class="hljs-number">0</span>, nums1, <span class="hljs-number">0</span>, total);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)O(m + n)O(m+n)</li><li>空间复杂度：O(m+n)O(m + n)O(m+n)</li></ul><hr><h2 id="先合并再排序"><a href="#先合并再排序" class="headerlink" title="先合并再排序"></a>先合并再排序</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/c4cc438310fe46a688ea5b21037eac62~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>我们还可以将 nums2nums2nums2 的内容先迁移到 nums1nums1nums1 去，再对 nums1nums1nums1 进行排序。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        System.arraycopy(nums2, <span class="hljs-number">0</span>, nums1, m, n);<br>        Arrays.sort(nums1);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O((m+n)log(m+n))O((m + n)log{(m + n)})O((m+n)log(m+n))</li><li>空间复杂度：O(1)O(1)O(1)</li></ul><p><strong>PS. Java 中的 sort 排序是一个综合排序。包含插入/双轴快排/归并/timsort，这里假定 <code>Arrays.sort</code> 使用的是「双轴快排」，并忽略递归带来的空间开销。</strong></p><hr><h3 id="原地合并（从前往后）"><a href="#原地合并（从前往后）" class="headerlink" title="原地合并（从前往后）"></a>原地合并（从前往后）</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6ea5db94c11c46849c3073410d84ac81~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>也可以直接在 nums1nums1nums1 进行合并操作，但是需要确保每次循环开始，nums2nums2nums2 的指针指向的必然是最小的元素。</p><p>因此，我们需要对 nums2nums2nums2 执行局部排序。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= m) &#123;<br>                nums1[i] = nums2[j++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> a = nums1[i], b = nums2[j];<br>                <span class="hljs-keyword">if</span> (a &gt; b) swap(nums1, i, nums2, j);<br>                sort(nums2, j, n - <span class="hljs-number">1</span>);<br>            &#125;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> x = nums[l], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (nums[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (nums[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) swap(nums, i, nums, j);<br>        &#125;<br>        sort(nums, l, j);<br>        sort(nums, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp = nums1[i];<br>        nums1[i] = nums2[j];<br>        nums2[j] = tmp;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n+m2logm)O(n + m^2 log{m})O(n+m2logm)</li><li>空间复杂度：忽略递归开销，复杂度为 O(1)O(1)O(1)</li></ul><hr><h3 id="原地合并（从后往前）"><a href="#原地合并（从后往前）" class="headerlink" title="原地合并（从后往前）"></a>原地合并（从后往前）</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/59720e362b38429f9e4823e78633ad81~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>思路和「方法一」是类似的，将遍历方向由「从前往后」调整为「从后往前」即可做到 O(1)O(1)O(1) 空间复杂度。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> idx = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>                nums1[idx--] = nums1[i] &gt;= nums2[j] ? nums1[i--] : nums2[j--];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                nums1[idx--] = nums1[i--];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums1[idx--] = nums2[j--];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)O(m + n)O(m+n)</li><li>空间复杂度：O(1)O(1)O(1)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis与MySQL双写一致性如何保证</title>
    <link href="/blog/2021/05/23/Redis%E4%B8%8EMySQL%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81/"/>
    <url>/blog/2021/05/23/Redis%E4%B8%8EMySQL%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="谈谈一致性"><a href="#谈谈一致性" class="headerlink" title="谈谈一致性"></a>谈谈一致性</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b1353d15b66d43eab2cf8fd9aceb61d9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。</p><ul><li><strong>强一致性</strong>：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</li><li><strong>弱一致性</strong>：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</li><li><strong>最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</li></ul><h2 id="三个经典的缓存模式"><a href="#三个经典的缓存模式" class="headerlink" title="三个经典的缓存模式"></a>三个经典的缓存模式</h2><p>缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据<strong>不一致性</strong>的问题。一般我们是如何使用缓存呢？有三种经典的缓存模式：</p><ul><li>Cache-Aside Pattern</li><li>Read-Through/Write through</li><li>Write behind</li></ul><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache-Aside Pattern"></a>Cache-Aside Pattern</h3><p>Cache-Aside Pattern，即<strong>旁路缓存模式</strong>，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。</p><h4 id="Cache-Aside读流程"><a href="#Cache-Aside读流程" class="headerlink" title="Cache-Aside读流程"></a>Cache-Aside读流程</h4><p><strong>Cache-Aside Pattern</strong>的读请求流程如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/16e4b4c301cc44a09b3fe1938d9c6d89~tplv-k3u1fbpfcp-zoom-1.image" alt="Cache-Aside读请求"></p><ol><li>读的时候，先读缓存，缓存命中的话，直接返回数据</li><li>缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。</li></ol><h4 id="Cache-Aside-写流程"><a href="#Cache-Aside-写流程" class="headerlink" title="Cache-Aside 写流程"></a>Cache-Aside 写流程</h4><p><strong>Cache-Aside Pattern</strong>的写请求流程如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b98a1c0f93cf442db57ac56b5b26c393~tplv-k3u1fbpfcp-zoom-1.image" alt="Cache-Aside写请求"></p><p>更新的时候，先<strong>更新数据库，然后再删除缓存</strong>。</p><h3 id="Read-Through-Write-Through（读写穿透）"><a href="#Read-Through-Write-Through（读写穿透）" class="headerlink" title="Read-Through/Write-Through（读写穿透）"></a>Read-Through/Write-Through（读写穿透）</h3><p><strong>Read/Write Through</strong>模式中，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过<strong>抽象缓存层</strong>完成的。</p><h4 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read-Through"></a>Read-Through</h4><p><strong>Read-Through</strong>的简要流程如下</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6eca809755b242119757201af531b3e2~tplv-k3u1fbpfcp-zoom-1.image" alt="Read Through简要流程"></p><ol><li>从缓存读取数据，读到直接返回</li><li>如果读取不到的话，从数据库加载，写入缓存后，再返回响应。</li></ol><p>这个简要流程是不是跟<strong>Cache-Aside</strong>很像呢？其实<strong>Read-Through</strong>就是多了一层<strong>Cache-Provider</strong>，流程如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/60d3de199b5f41daa0ad464596fd404d~tplv-k3u1fbpfcp-zoom-1.image" alt="Read-Through流程"></p><p>Read-Through实际只是在<strong>Cache-Aside</strong>之上进行了一层封装，它会让程序代码变得更简洁，同时也减少数据源上的负载。</p><h4 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write-Through"></a>Write-Through</h4><p><strong>Write-Through</strong>模式下，当发生写请求时，也是由<strong>缓存抽象层</strong>完成数据源和缓存数据的更新,流程如下： <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/bb1eaafc6ab14ca98fe603fad1fb7fc5~tplv-k3u1fbpfcp-zoom-1.image" alt="Write-Through流程"></p><h3 id="Write-behind-（异步缓存写入）"><a href="#Write-behind-（异步缓存写入）" class="headerlink" title="Write behind （异步缓存写入）"></a>Write behind （异步缓存写入）</h3><p><strong>Write behind</strong>跟<strong>Read-Through/Write-Through</strong>有相似的地方，都是由<code>Cache Provider</code>来负责缓存和数据库的读写。它两又有个很大的不同：<strong>Read/Write Through</strong>是同步更新缓存和数据的，<strong>Write Behind</strong>则是只更新缓存，不直接更新数据库，通过<strong>批量异步</strong>的方式来更新数据库。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/81197a8c7a164b0b9a76b8380ae29a4b~tplv-k3u1fbpfcp-watermark.image" alt="Write behind流程"></p><p>这种方式下，缓存和数据库的一致性不强，<strong>对一致性要求高的系统要谨慎使用</strong>。但是它适合频繁写的场景，MySQL的<strong>InnoDB Buffer Pool机制</strong>就使用到这种模式。</p><h2 id="操作缓存的时候，删除缓存呢，还是更新缓存？"><a href="#操作缓存的时候，删除缓存呢，还是更新缓存？" class="headerlink" title="操作缓存的时候，删除缓存呢，还是更新缓存？"></a>操作缓存的时候，删除缓存呢，还是更新缓存？</h2><p>一般业务场景，我们使用的就是<strong>Cache-Aside</strong>模式。 有些小伙伴可能会问， <strong>Cache-Aside</strong>在写入请求的时候，为什么是<strong>删除缓存而不是更新缓存</strong>呢？</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/75b7c68482364471a922b713b35128f6~tplv-k3u1fbpfcp-watermark.image" alt="Cache-Aside写入流程"></p><p>我们在操作缓存的时候，到底应该删除缓存还是更新缓存呢？我们先来看个例子：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/fbc52abea19746dd8db070253f3a4609~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ol><li>线程A先发起一个写操作，第一步先更新数据库</li><li>线程B再发起一个写操作，第二步更新了数据库</li><li>由于网络等原因，线程B先更新了缓存</li><li>线程A更新缓存。</li></ol><p>这时候，缓存保存的是A的数据（老数据），数据库保存的是B的数据（新数据），数据<strong>不一致</strong>了，脏数据出现啦。如果是<strong>删除缓存取代更新缓存</strong>则不会出现这个脏数据问题。</p><p><strong>更新缓存相对于删除缓存</strong>，还有两点劣势：</p><ul><li>如果你写入的缓存值，是经过复杂计算才得到的话。更新缓存频率高的话，就浪费性能啦。</li><li>在写数据库场景多，读数据场景少的情况下，数据很多时候还没被读取到，又被更新了，这也浪费了性能呢(实际上，写多的场景，用缓存也不是很划算了)</li></ul><h2 id="双写的情况下，先操作数据库还是先操作缓存？"><a href="#双写的情况下，先操作数据库还是先操作缓存？" class="headerlink" title="双写的情况下，先操作数据库还是先操作缓存？"></a>双写的情况下，先操作数据库还是先操作缓存？</h2><p><code>Cache-Aside</code>缓存模式中，有些小伙伴还是有疑问，在写入请求的时候，为什么是<strong>先操作数据库呢</strong>？为什么<strong>不先操作缓存</strong>呢？</p><p>假设有A、B两个请求，请求A做更新操作，请求B做查询读取操作。 <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a30ff3d1b8374d1b8508200566b4e1c6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol><li>线程A发起一个写操作，第一步del cache</li><li>此时线程B发起一个读操作，cache miss</li><li>线程B继续读DB，读出来一个老数据</li><li>然后线程B把老数据设置入cache</li><li>线程A写入DB最新的数据</li></ol><p>酱紫就有问题啦，<strong>缓存和数据库的数据不一致了。缓存保存的是老数据，数据库保存的是新数据</strong>。因此，<code>Cache-Aside</code>缓存模式，选择了先操作数据库而不是先操作缓存。</p><h3 id="缓存延时双删"><a href="#缓存延时双删" class="headerlink" title="缓存延时双删"></a>缓存延时双删</h3><p>有些小伙伴可能会说，不一定要先操作数据库呀，采用<strong>缓存延时双删</strong>策略就好啦？什么是延时双删呢？</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/dc942a69d367464d9e778faf635f6448~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol><li>先删除缓存</li><li>再更新数据库</li><li>休眠一会（比如1秒），再次删除缓存。</li></ol><p>这个休眠一会，一般多久呢？都是1秒？</p><blockquote><p>这个休眠时间 =  读业务逻辑数据的耗时 + 几百毫秒。 为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。</p></blockquote><h3 id="删除缓存重试机制"><a href="#删除缓存重试机制" class="headerlink" title="删除缓存重试机制"></a>删除缓存重试机制</h3><p>不管是<strong>延时双删</strong>还是<strong>Cache-Aside的先操作数据库再删除缓存</strong>，如果第二步的删除缓存失败呢，删除失败会导致脏数据哦~</p><blockquote><p>删除失败就多删除几次呀,保证删除缓存成功呀~ 所以可以引入<strong>删除缓存重试机制</strong></p></blockquote><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/85ce00ef5ad54984a0bbe183bd00b75e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol><li>写请求更新数据库</li><li>缓存因为某些原因，删除失败</li><li>把删除失败的key放到消息队列</li><li>消费消息队列的消息，获取要删除的key</li><li>重试删除缓存操作</li></ol><h3 id="读取biglog异步删除缓存"><a href="#读取biglog异步删除缓存" class="headerlink" title="读取biglog异步删除缓存"></a>读取biglog异步删除缓存</h3><p>重试删除缓存机制还可以，就是会造成好多业务代码入侵。其实，还可以通过<strong>数据库的binlog来异步淘汰key</strong>。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f94c4fb98d2f47948f522ddc3d3a10a5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>以mysql为例 可以使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK1.8新特性之Stream</title>
    <link href="/blog/2021/05/15/DK1.8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/blog/2021/05/15/DK1.8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<p>集合是Java中使用最多的API，几乎每个程序员天天都会和它打招呼，它可以让你把相同、相似、有关联的数据整合在一起，便于使用、提取以及运算等操作。在实际Java程序中，集合的使用往往随着业务需求、复杂度而变得更加复杂，在这其中将可能会涉及到更多的运算，如：求和、平均值、分组、过滤、排序等等。如何这些操作混合出现，又该如何实现？难道遍历、再遍历、再运算么？抛开性能因素，这些操作已经严重影响了代码的整洁，这种代码也没有几个人愿意来读。</p><p>那么，有没有什么好的办法来解决这种现状呢？毕竟集合最为最常用的操作，难道Java语言的设计者没有意识到这一点吗？如何能够帮助你节约宝贵的时间，让程序员活得更轻松一点呢？</p><p>你可能已经猜到了，答案就是流—<strong>Stream</strong>。</p><p>本文将从<code>JDK1.8</code>中<code>Stream API</code>讲起，让你觉得集合操作原来可以这么轻松使用。</p><h1 id="一、Stream是什么"><a href="#一、Stream是什么" class="headerlink" title="一、Stream是什么"></a>一、Stream是什么</h1><p><code>Stream</code>是<code>Java API</code>中的新成员，它允许你以声明的方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现），你可以把它看成是遍历数据集的<strong>高级迭代器</strong>。此外，Stream还可以透明地并行处理，而无需写任何多线程代码了。</p><p>我们先简单的对比使用下Stream的好处吧。下面两段代码都是实现筛选出名字中包含“xc”字符串的人，并按照其年龄进行排序。</p><p>传统方式(JDK1.8之前，非Stream流)：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">List&lt;People&gt; peoples = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br><span class="hljs-comment">// 遍历 + 判断</span><br><span class="hljs-keyword">for</span> (People people : allPeoples) &#123;<br>    <span class="hljs-keyword">if</span> (people.get<span class="hljs-constructor">Name()</span>.contains(<span class="hljs-string">&quot;xc&quot;</span>)) &#123;<br>        peoples.add(people);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对年龄排序</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>sort(peoples, <span class="hljs-keyword">new</span> Comparator&lt;People&gt;<span class="hljs-literal">()</span> &#123;<br>    @Override<br>    public <span class="hljs-built_in">int</span> compare(People p1, People p2) &#123;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>compare(p1.get<span class="hljs-constructor">Age()</span>, p2.get<span class="hljs-constructor">Age()</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Stream方式:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">List&lt;People&gt; peoples2 = allPeoples.stream<span class="hljs-literal">()</span><br>                .filter(people -&gt; people.get<span class="hljs-constructor">Name()</span>.contains(<span class="hljs-string">&quot;xc&quot;</span>))<br>                .sorted(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Comparator</span>.</span></span>comparing(People::getAge))<br>                .collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br></code></pre></td></tr></table></figure><p>没有对比就没有伤害，效果显而易见。从开发角度来看，Stream方式有以下显而易见的好处：</p><ul><li>代码以声明方式写的：说明想要完成什么（筛选出满足条件的数据）而不是说明如何实现一个操作（利用循环和if条件等控制流语句）。</li><li>多个基本操作链接起来：将多个基础操作链接起来，来表达复杂的数据处理流水线(如下图)，同时体现了代码的清晰、可读性。</li></ul><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/591b9bdf32584535bab881f93680853d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p><code>Stream API</code>功能非常强大，类似上面Stream处理流水线方式应用场景很多，理论上可以生成一个具有无穷长的流水线的。更重要的是，在复杂业务中你用不着为了让某些数据处理任务并行而去操心线程和锁了，<code>Stream API</code>都替你做好了！</p><p><strong><code>Stream</code>，即：”流“，通过将集合转换为一种叫做”流“的元素序列，通过声明方式，对集合中的每个元素进行一系列并行或串行的流水线操作。</strong></p><p>换句话说，你只需要告诉流你的要求，流便会在背后自行根据要求对元素进行处理，而你只需要 <strong>“坐享其成”</strong>。</p><h1 id="二、Stream操作"><a href="#二、Stream操作" class="headerlink" title="二、Stream操作"></a>二、Stream操作</h1><p>整个流操作就是一条流水线，将元素放在流水线上一个个地进行处理，如下图所示。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/47e0cab765f74703858ef19dc028b56f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>其中，数据源是原始集合数据，然后将如 <code>List&lt;T&gt; </code>的集合转换为<code>Stream&lt;T&gt;</code>类型的流，并对流进行一系列的操作，比如过滤保留部分元素、对元素进行排序、类型转换等，最后再进行一个终止操作，可以把 Stream 转换回集合类型，也可以直接对其中的各个元素进行处理，比如打印、比如计算总数、计算最大值等。</p><p>很多流操作本身就会返回一个流，所以多个操作可以直接连接起来，就如上面举例中Stream方式的代码一样。 <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/109e8c6bf1e2440a8a84454b0e25bef7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>如果是以前，进行这么一系列操作，你需要做个迭代器或者 foreach 循环，然后遍历，一步步地亲力亲为地去完成这些操作。但是如果使用流，你便可以直接声明式地下指令，流会帮你完成这些操作。</p><p>通过上面Stream操作流水线、实例，<strong>Stream操作大体上分为两种：中间操作符和终止操作符。</strong></p><h2 id="1-中间操作符"><a href="#1-中间操作符" class="headerlink" title="1. 中间操作符"></a>1. 中间操作符</h2><p>对于数据流来说，中间操作符在执行指定处理逻辑后，数据流依然可以传递给下一级的操作符。</p><p>中间操作符包含8种：</p><ul><li><code>map(mapToInt，mapToLong，mapToDouble)</code> 转换操作：把比如<code>A-&gt;B</code>，这里默认提供了转<code>int</code>，<code>long</code>，<code>double</code>的操作符。</li><li><code>flatmap(flatmapToInt，flatmapToLong,flatmapToDouble) </code>拍平操作：比如把<code>int[]&#123;2,3,4&#125;</code>拍平变成 <code>2，3，4 </code>,也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成<code>int</code>,<code>long</code>,<code>double</code>的操作。</li><li><code>limit </code>限流操作：比如数据流中有10个，我只要前3个就可以使用。</li><li><code>distinct</code>去重操作：重复元素去重。</li><li><code>filter</code>过滤操作：对集合数据进行过滤。</li><li><code>peek</code>消费操作：如果想对数据进行某些操作，如：读取、编辑修改等。</li><li><code>skip</code>跳过操作：跳过某些元素。</li><li><code>sorted</code>排序操作：对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。</li></ul><p>（具体可参照源码<code>java.util.stream.Stream</code>）</p><h2 id="2-终止操作符"><a href="#2-终止操作符" class="headerlink" title="2. 终止操作符"></a>2. 终止操作符</h2><p>数据经过一系列的中间操作，就轮到终止操作符上场了。终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。</p><ul><li><code>collect </code>收集操作：将所有数据收集起来，这个操作非常重要，官方的提供的Collectors 提供了非常多收集器，可以说Stream的核心在于Collectors。</li><li><code>count </code>统计操作：统计最终的数据个数。</li><li><code>findFirst、findAny </code>查找操作：查找第一个、查找任何一个，返回的类型为Optional。</li><li><code>noneMatch、allMatch、anyMatch</code>匹配操作：数据流中是否存在符合条件的元素，返回值为bool 值。</li><li><code>min、max</code>最值操作：需要自定义比较器，返回数据流中最大、最小的值。</li><li><code>reduce</code>规约操作：将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。</li><li><code>forEach、forEachOrdered</code>遍历操作：这里就是对最终的数据进行消费了。</li><li><code>toArray</code>数组操作：将数据流的元素转换成数组。</li></ul><p>说了这么多，心动不如行动，俗话说：实践出真理。那么，一起来实战吧。</p><h1 id="三、实战演练"><a href="#三、实战演练" class="headerlink" title="三、实战演练"></a>三、实战演练</h1><p>Stream的一系列操作，必须要使用终止操作符，否则整个数据流是不会执行起来的。</p><h2 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. map</h2><p>转换、映射操作，将元素转换成其他形式或提取一些信息。</p><p>比如，从People集合中获取所有人的年龄：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">allPeoples</span><span class="hljs-selector-class">.stream</span>()<br><span class="hljs-selector-class">.map</span>(<span class="hljs-selector-tag">People</span><span class="hljs-selector-pseudo">::getAge)</span><br><span class="hljs-selector-class">.forEach</span>(<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-pseudo">::println)</span>;<br></code></pre></td></tr></table></figure><h2 id="2-flatmap"><a href="#2-flatmap" class="headerlink" title="2. flatmap"></a>2. flatmap</h2><p>将元素拍平拍扁 ，将拍扁的元素重新组成Stream，并将这些Stream 串行合并成一条Stream。</p><p>比如，带有-字符的字符串进行拆分，并输出：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;x-c-b-e-y-o-n-d&quot;</span>,<span class="hljs-string">&quot;a-b-c-d&quot;</span>)<br>.flat<span class="hljs-constructor">Map(<span class="hljs-params">m</span> -&gt; Stream.<span class="hljs-params">of</span>(<span class="hljs-params">m</span>.<span class="hljs-params">split</span>(<span class="hljs-string">&quot;-&quot;</span>)</span>))<br>    .<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span><br><span class="hljs-keyword">c</span><br>b<br>e<br>y<br>o<br>n<br>d<br>a<br>b<br><span class="hljs-keyword">c</span><br>d<br></code></pre></td></tr></table></figure><h2 id="3-limit"><a href="#3-limit" class="headerlink" title="3. limit"></a>3. limit</h2><p>限流操作，限制集合元素的个数。</p><p>比如，集合中有10个元素，我只要前4个就可以使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Stream</span><span class="hljs-selector-class">.of</span>(1,2,3,4,5,6,7,8,9,10)<br><span class="hljs-selector-class">.limit</span>(4)<br><span class="hljs-selector-class">.forEach</span>(<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-pseudo">::println)</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><h2 id="4-distinct"><a href="#4-distinct" class="headerlink" title="4. distinct"></a>4. distinct</h2><p>去重操作，重复元素去重，类似数据库中的关键字<code>distinct</code>。</p><p>比如，集合中可能存在一些重复的数据，需要进行去重操作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;xcbeyond&quot;</span>,<span class="hljs-string">&quot;Niki&quot;</span>,<span class="hljs-string">&quot;Liky&quot;</span>,<span class="hljs-string">&quot;xcbeyond&quot;</span>)<br>.distinct<span class="hljs-literal">()</span><br>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">xcbeyond</span><br><span class="hljs-attribute">Niki</span><br><span class="hljs-attribute">Liky</span><br></code></pre></td></tr></table></figure><h2 id="5-filter"><a href="#5-filter" class="headerlink" title="5. filter"></a>5. filter</h2><p>过滤、筛选，对某些元素进行过滤，不符合筛选条件的将无法进入流的下游。</p><p>比如，筛选出一个数字集合中的所有偶数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Stream</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>)<br>.filter(n -&gt; <span class="hljs-number">0</span><span class="hljs-operator"> == </span>n%<span class="hljs-number">2</span>)<br>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(System.<span class="hljs-params">out</span>::<span class="hljs-params">println</span>)</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>4<br>6<br>8<br>10<br></code></pre></td></tr></table></figure><h2 id="6-peek"><a href="#6-peek" class="headerlink" title="6. peek"></a>6. peek</h2><p>消费操作，如果想对数据进行某些操作，如：读取、编辑修改等。</p><p>比如，将People集合中name统一修改为name+age的形式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">allPeoples.stream<span class="hljs-literal">()</span><br>.peek(people -&gt; people.set<span class="hljs-constructor">Name(<span class="hljs-params">people</span>.<span class="hljs-params">getName</span>()</span> + people.get<span class="hljs-constructor">Age()</span>))<br>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">people</span> -&gt; System.<span class="hljs-params">out</span>.<span class="hljs-params">println</span>(<span class="hljs-params">people</span>.<span class="hljs-params">getName</span>()</span>));<br></code></pre></td></tr></table></figure><h2 id="7-skip"><a href="#7-skip" class="headerlink" title="7. skip"></a>7. skip</h2><p>跳过操作，跳过某些元素。</p><p>比如，一个数字集合，跳过前4个元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Stream</span><span class="hljs-selector-class">.of</span>(1,2,3,4,5,6,7,8,9,10)<br><span class="hljs-selector-class">.skip</span>(4)<br><span class="hljs-selector-class">.forEach</span>(<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-pseudo">::println)</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br>6<br>7<br>8<br>9<br>10<br></code></pre></td></tr></table></figure><h2 id="8-sorted"><a href="#8-sorted" class="headerlink" title="8. sorted"></a>8. sorted</h2><p>排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。</p><p>比如，将People集合按照年龄排序：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">allPeoples</span><span class="hljs-selector-class">.stream</span>()<br><span class="hljs-selector-class">.sorted</span>(<span class="hljs-selector-tag">Comparator</span><span class="hljs-selector-class">.comparing</span>(<span class="hljs-selector-tag">People</span><span class="hljs-selector-pseudo">::getAge))</span><br><span class="hljs-selector-class">.forEach</span>(<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-pseudo">::println)</span>;<br></code></pre></td></tr></table></figure><h2 id="9-collect"><a href="#9-collect" class="headerlink" title="9. collect"></a>9. collect</h2><p>收集操作，终止操作符，用于将最终的数据收集到新的集合中，如，List、Set、Map等集合。</p><p>比如，将People集合按照年龄排序，并存放在一个新的集合中，供后续使用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">List&lt;People&gt; sortedPeople = allPeoples.stream<span class="hljs-literal">()</span><br>.sorted(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Comparator</span>.</span></span>comparing(People::getAge))<br>.collect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collectors</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br></code></pre></td></tr></table></figure><h2 id="10-count"><a href="#10-count" class="headerlink" title="10. count"></a>10. count</h2><p>统计操作，用于对集合元素个数的统计，返回类型是long。</p><p>比如，计算People集合中年龄大于30的人数：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span> = allPeoples.stream()<br>.filter(people -&gt; people.getAge() &gt; <span class="hljs-number">30</span>)<br>    .<span class="hljs-keyword">count</span>();<br></code></pre></td></tr></table></figure><h2 id="11-findFirst、findAny"><a href="#11-findFirst、findAny" class="headerlink" title="11. findFirst、findAny"></a>11. findFirst、findAny</h2><p>查找操作，查找第一个、任何一个，返回的类型为<code>Optional</code>。常用于查询集中符合条件的元素，并结合<code>Optional.isPresent()</code>进行判断，防止出现未找到而强制获取数据元素的异常情况。</p><p>比如，查找People集合中名字为xcbeyond的人：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">People <span class="hljs-attr">xcbeyondPeople</span> = <span class="hljs-literal">null</span>;<br>Optional&lt;People&gt; <span class="hljs-attr">optional</span> = allPeoples.stream()<br>.filter(people -&gt; <span class="hljs-string">&quot;xcbeyond&quot;</span>.equals(people.getName()))<br>.findFirst();<br><span class="hljs-keyword">if</span> (optional.isPresent()) &#123;<br><span class="hljs-attr">xcbeyondPeople</span> = optional.get();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-noneMatch、allMatch、anyMatch"><a href="#12-noneMatch、allMatch、anyMatch" class="headerlink" title="12. noneMatch、allMatch、anyMatch"></a>12. noneMatch、allMatch、anyMatch</h2><p>匹配操作，判断数据流中是否存在符合条件的元素，返回值为<code>boolean</code>值。</p><ul><li>noneMatch：没有匹配条件的元素</li><li>allMatch、anyMatch：全匹配</li></ul><p>比如，判断People集合中是否有名字为xcbeyond的人：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">boolean <span class="hljs-built_in">bool</span> = allPeoples.stream<span class="hljs-literal">()</span><br>.all<span class="hljs-constructor">Match(<span class="hljs-params">people</span> -&gt; <span class="hljs-string">&quot;xcbeyond&quot;</span>.<span class="hljs-params">equals</span>(<span class="hljs-params">people</span>.<span class="hljs-params">getName</span>()</span>));<br></code></pre></td></tr></table></figure><h2 id="13-min、max"><a href="#13-min、max" class="headerlink" title="13. min、max"></a>13. min、max</h2><p>最值操作，根据自定义比较器，返回数据流中最大、最小的元素。</p><p>比如，找到People集合中最大年龄的人：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">People <span class="hljs-keyword">max</span>AgePeople = null;<br>Optional<span class="hljs-variable">&lt;People&gt;</span> <span class="hljs-keyword">max</span>AgeOptional = <span class="hljs-literal">all</span>Peoples.stream()<br>.<span class="hljs-keyword">max</span>(Comparator.comparing(People::getAge));<br>if (<span class="hljs-keyword">max</span>AgeOptional.isPresent()) &#123;// 可能没有，则需要进行判断<br><span class="hljs-keyword">max</span>AgePeople = <span class="hljs-keyword">max</span>AgeOptional.get();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-reduce"><a href="#14-reduce" class="headerlink" title="14. reduce"></a>14. reduce</h2><p>规约操作：将整个数据流的值规约为一个值，其中count、min、max底层就是使用reduce。</p><p>比如，对一个整数集合进行求和：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">int sum = Stream.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,-<span class="hljs-number">1</span>)<br>.reduce<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>,(e1,e2)-&gt;e1+e2)</span>;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(sum)</span>;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">32<br></code></pre></td></tr></table></figure><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>本文就Stream的基础使用层面进行了全面的介绍、实战，告诉你该怎么用每种操作符，只有掌握了这些基本的操作，在面对实际复杂处理逻辑时，需要进一步配合使用，就会知道它的妙处了。这也让你对集合的操作更上一步，为你省去了不少麻烦。关于Stream更深入的说明，如：并行处理、是否高效等，将会在之后的章节进行详尽的阐述、验证，以消除使用中的疑惑与担忧。</p><p>下一篇，将会提到Stream的终极操作——<strong>Collectors</strong>，让集合也能像数据库SQL一样，来完成复杂的分组、连接、汇总等，真正让你好用到飞起来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Stream</tag>
      
      <tag>1.8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel快速入门</title>
    <link href="/blog/2021/05/09/Sentinel%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/blog/2021/05/09/Sentinel%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Sentinel-简介"><a href="#Sentinel-简介" class="headerlink" title="Sentinel 简介"></a>Sentinel 简介</h1><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>Sentinel 具有以下特征:</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><p>Sentinel 的主要特性：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/9b9449c803b4467c9421f31d7f9c3420~tplv-k3u1fbpfcp-watermark.image" alt="sentinel 特征.png"></p><p>Sentinel 的开源生态：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ac27750628f7401794375fef32c34652~tplv-k3u1fbpfcp-watermark.image" alt="sentinel 生态.png"></p><p>Sentinel 分为两个部分:</p><ul><li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li></ul><h1 id="Sentinel、Hystrix、resilience4j-对比"><a href="#Sentinel、Hystrix、resilience4j-对比" class="headerlink" title="Sentinel、Hystrix、resilience4j 对比"></a>Sentinel、Hystrix、resilience4j 对比</h1><p>功能对比</p><table><thead><tr><th></th><th>Sentinel</th><th>Hystrix</th><th>resilience4j</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离（并发控制）</td><td>线程池隔离/信号量隔离</td><td>信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于慢调用比例、异常比例、异常数</td><td>基于异常比例</td><td>基于异常比例、响应时间</td></tr><tr><td>实时统计实现</td><td>滑动窗口（LeapArray）</td><td>滑动窗口（基于 RxJava）</td><td>Ring Bit Buffer</td></tr><tr><td>动态规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td><td>有限支持</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td><td>接口的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td><td>Rate Limiter</td></tr><tr><td>流量整形</td><td>支持预热模式与匀速排队控制效果</td><td>不支持</td><td>简单的 Rate Limiter 模式</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>多语言支持</td><td>Java/Go/C++</td><td>Java</td><td>Java</td></tr><tr><td>Service Mesh 支持</td><td>支持 Envoy/Istio</td><td>不支持</td><td>不支持</td></tr><tr><td>控制台</td><td>提供开箱即用的控制台，可配置规则、实时监控、机器发现等</td><td>简单的监控查看</td><td>不提供控制台，可对接其它监控系统</td></tr></tbody></table><h1 id="Sentinel-名词"><a href="#Sentinel-名词" class="headerlink" title="Sentinel 名词"></a>Sentinel 名词</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。</p><p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="什么是流量控制"><a href="#什么是流量控制" class="headerlink" title="什么是流量控制"></a>什么是流量控制</h3><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/17f3ea9e95b64e8eba33d46f19e6b12a~tplv-k3u1fbpfcp-watermark.image" alt="sentinel 流控.gif"></p><h3 id="流量控制设计理念"><a href="#流量控制设计理念" class="headerlink" title="流量控制设计理念"></a>流量控制设计理念</h3><p>流量控制有以下几个角度:</p><ul><li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</li><li>运行指标，例如 QPS、线程池、系统负载等；</li><li>控制的效果，例如直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><h3 id="什么是熔断降级"><a href="#什么是熔断降级" class="headerlink" title="什么是熔断降级"></a>什么是熔断降级</h3><p>除了流量控制以外，及时对调用链路中的不稳定因素进行熔断也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，可能会导致请求发生堆积，进而导致级联错误。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/d6094c417c7f4ffeaf856b0ab0a396c4~tplv-k3u1fbpfcp-watermark.image" alt="sentinel 熔断降级.png"></p><p>Sentinel 和 Hystrix 的原则是一致的: 当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。</p><h3 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h3><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过 <a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池隔离</a> 的方式，来对依赖（在 Sentinel 的概念中对应 <em>资源</em>）进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（过多的线程池导致线程数目过多），还需要预先给各个资源做线程池大小的分配。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li>通过并发线程数进行限制</li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li>通过响应时间对资源进行降级</li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><h2 id="系统自适应保护"><a href="#系统自适应保护" class="headerlink" title="系统自适应保护"></a>系统自适应保护</h2><p>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h1 id="Sentinel-原理"><a href="#Sentinel-原理" class="headerlink" title="Sentinel 原理"></a>Sentinel 原理</h1><p>Sentinel 的主要工作机制如下：</p><ul><li>对主流框架提供适配或者显示的 API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。</li><li>根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel 提供开放的接口，方便您定义及改变规则。</li><li>Sentinel 提供实时的监控系统，方便您快速了解目前系统的状态。</li></ul><h1 id="Sentinel-使用"><a href="#Sentinel-使用" class="headerlink" title="Sentinel 使用"></a>Sentinel 使用</h1><h2 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h2><ol><li>如果应用使用 pom 工程，则在 <code>pom.xml</code> 文件中加入以下代码即可：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol><li>接下来，我们把需要控制流量的代码用 Sentinel API <code>SphU.entry(&quot;HelloWorld&quot;)</code> 和 <code>entry.exit()</code> 包围起来即可。在下面的例子中，我们将 <code>System.out.println(&quot;hello world&quot;);</code> 这端代码作为资源，用 API 包围起来（埋点）。参考代码如下:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>  Entry entry = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    entry = SphU.entry(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>    <span class="hljs-comment">/*您的业务逻辑 - 开始*/</span><br>    System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">/*您的业务逻辑 - 结束*/</span><br>  &#125; <span class="hljs-keyword">catch</span> (BlockException e1) &#123;<br>    <span class="hljs-comment">/*流控逻辑处理 - 开始*/</span><br>    System.out.println(<span class="hljs-string">&quot;block!&quot;</span>);<br>    <span class="hljs-comment">/*流控逻辑处理 - 结束*/</span><br>  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry != <span class="hljs-keyword">null</span>) &#123;<br>      entry.exit();<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>接下来，通过规则来指定允许该资源通过的请求次数，例如下面的代码定义了资源 <code>HelloWorld</code> 每秒最多只能通过 20 个请求。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 规则配置</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFlowRules</span><span class="hljs-params">()</span> </span>&#123;<br>  List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  FlowRule rule = <span class="hljs-keyword">new</span> FlowRule();<br>  rule.setResource(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>  rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>  <span class="hljs-comment">// Set limit QPS to 20.</span><br>  rule.setCount(<span class="hljs-number">20</span>);<br>  rules.add(rule);<br>  FlowRuleManager.loadRules(rules);<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>Demo 运行之后，我们可以在日志 <code>~/logs/csp/$&#123;appName&#125;-metrics.log.xxx</code> 里看到下面的输出:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">|--timestamp-|------date time----|-resource-|p |block|s |e|rt<br>1619954886000|2021-05-02 19:28:06|HelloWorld|20|1|20|0|12|0|0|0<br>1619954887000|2021-05-02 19:28:07|HelloWorld|20|3197|20|0|11|0|0|0<br>1619954888000|2021-05-02 19:28:08|HelloWorld|20|2857|20|0|11|0|0|0<br><br></code></pre></td></tr></table></figure><p>其中 <code>p</code> 代表通过的请求, <code>block</code> 代表被阻止的请求, <code>s</code> 代表成功执行完成的请求个数, <code>e</code> 代表用户自定义的异常, <code>rt</code> 代表平均响应时长。</p><p>可以看到，这个程序每秒稳定输出 “hello world” 20 次，和规则中预先设定的阈值是一样的。</p><h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><ol><li>Sentinel 提供了 <code>@SentinelResource</code> 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 <code>BlockException</code> 等。使用 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-annotation-aspectj">Sentinel Annotation AspectJ Extension</a> 的时候需要引入以下依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.y.z<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol><li>示例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对应的 `handleException` 函数需要位于 `ExceptionUtil` 类中，并且必须为 public static 函数.</span><br><span class="hljs-comment">// 对应的返回值也需要和当前方法一样</span><br><span class="hljs-meta">@SentinelResource(value = &quot;createOrder&quot;,</span><br><span class="hljs-meta">                  blockHandler = &quot;blockHandler&quot;,</span><br><span class="hljs-meta">                  blockHandlerClass = &#123;ExceptionUtils.class&#125;)</span><br><span class="hljs-meta">@GetMapping(&quot;/createOrder&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> OrderDto <span class="hljs-title">createOrder</span><span class="hljs-params">(OrderDto dto)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OrderDto();<br>&#125;<br><br><span class="hljs-comment">// ExceptionUtils</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionUtils</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OrderDto <span class="hljs-title">blockHandler</span><span class="hljs-params">(OrderDto dto, BlockException ex)</span> </span>&#123;<br>    ex.printStackTrace();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="SentinelResource-注解"><a href="#SentinelResource-注解" class="headerlink" title="@SentinelResource 注解"></a>@SentinelResource 注解</h2><blockquote><p>注意：注解方式埋点不支持 private 方法。</p></blockquote><p>@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：</p><ul><li>value：资源名称，必需项（不能为空）</li><li>entryType：entry 类型，可选项（默认为 EntryType.OUT）</li><li>blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li><li>fallback / fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：<ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</li><li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li>defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：<ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</li><li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li>exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。 1.8.0 版本开始，defaultFallback 支持在类级别进行配置。</li></ul><blockquote><p>注：1.6.0 之前的版本 fallback 函数只针对降级异常（DegradeException）进行处理，不能针对业务异常进行处理。</p></blockquote><p>特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。若未配置 blockHandler、fallback 和 defaultFallback，则被限流降级时会将 BlockException 直接抛出（若方法本身未定义 throws BlockException 则会被 JVM 包装一层 UndeclaredThrowableException）。</p><h2 id="Sentinel-控制台"><a href="#Sentinel-控制台" class="headerlink" title="Sentinel 控制台"></a>Sentinel 控制台</h2><ol><li>下载控制台程序地址：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/alibaba/</span>Sentinel<span class="hljs-regexp">/releases/</span>tag/<span class="hljs-number">1.8</span>.<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><ol><li>启动命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Dserver.port=8089 -Dcsp.sentinel.dashboard.server=127.0.0.1:8089 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.1.jar<br><br></code></pre></td></tr></table></figure><ol><li>登录账号，默认的登录帐号和密码都是：sentinel</li><li>登录控制台后我们可以通过右侧菜单对我们的服务进行配置</li></ol><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1746e587b48a47ed9538c277a5b1fed8~tplv-k3u1fbpfcp-watermark.image" alt="sentinel 监控.png"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA2021首个大版本发布</title>
    <link href="/blog/2021/05/08/IDEA2021%E9%A6%96%E4%B8%AA%E5%A4%A7%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/>
    <url>/blog/2021/05/08/IDEA2021%E9%A6%96%E4%B8%AA%E5%A4%A7%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器！</p><p>就在不久之前，Java领域的开发神器<code>IntelliJ IDEA</code>终于迎来2021年的一个重要的大版本更新：<code>IntelliJ IDEA 2021.1</code>。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/0d5b436c8f7b4d19b4a2c53f6d3abc23~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>现如今大量的Java开发者深度依赖着这款开发软件，正如网上的段子所言：“可以毫不夸张地说，多少Java程序员离开了IDEA就不会写代码了（狗头）”，由此可见其使用的广泛程度。</p><p>新版本一出来，我也迫不及待地想尝试一番。当然，主力开发机我是不敢乱升级的，所以这两天，我在一台平时用来做测试的老开发本子上更新了全新的IDEA。</p><p>软件启动界面打开的那一瞬间，我就知道事情并不简单。</p><h1 id="全新的启动页面"><a href="#全新的启动页面" class="headerlink" title="全新的启动页面"></a>全新的启动页面</h1><p>更新后，全新的启动页面更加花里胡哨了。</p><p>软件启动速度也是非常之快，就我这多年苦练的火箭般手速，都差点没截来下面这张启动页面图。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/0fbf04b10731427898ba772d5b975a05~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><h1 id="Space集成"><a href="#Space集成" class="headerlink" title="Space集成"></a>Space集成</h1><p>JetBrains提供的Space这个功能不知道大家有没有听说过，讲白了就是一套集成的团队协作环境，可以提供包括构建交付、聊天协作、团队管理以及项目管理等在内的一整套协作一体化解决方案。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/da4834e6c4a5462f81fc8111ff057fef~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>最新的IDEA 2021.1把Space环境给无缝地集成进来了，现在属于开箱即用的状态，软件的右上角就有快捷入口：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/53a7139bcaba476382779037c3ec2135~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><h1 id="支持WSL-2"><a href="#支持WSL-2" class="headerlink" title="支持WSL 2"></a>支持WSL 2</h1><p>这个功能相信对于很多依赖Windows系统以及WSL功能的用户来说，简直是喜大普奔！</p><p>以前WSL就算再好用，但是你的IDE并没有和它打通，多少总是一个遗憾。</p><p>这下好了，二者直接打通了，IDEA支持WSL 2。你可以直接在新版IDEA 2021.1中运行并开发WSL 2中的Java项目，包括Gradle类型项目和Maven类型等项目均支持。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/11e7a616543745b094f518e0833e0a23~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8d07b172800a46278435e57f24f8d900~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><h1 id="Run-Targets"><a href="#Run-Targets" class="headerlink" title="Run Targets"></a>Run Targets</h1><p>Run Targets这个功能的意思有点类似于上面刚聊过的WSL 2。它允许开发者直接在远程主机甚至在Docker容器上运行和调试项目。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/108245aa90ec4f52bba265fcc6f804a5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>所以到目前为止，新版IDEA 2021允许开发者可以在本地、WSL 2、SSH远程主机、Docker等目标上运行项目，可以说贼香了！</p><hr><h1 id="支持Java-16"><a href="#支持Java-16" class="headerlink" title="支持Java 16"></a>支持Java 16</h1><p>这也算是一个比较重磅的更新。</p><p>近两年来，Java版本的发布速度也是快如老狗，我还在用Java 8，它都淦到Java 16了。</p><p>关于Java 16的新特性，我还准备写篇文章来详细聊一聊呢，包括比如：</p><ul><li>Records特性转正</li><li>instanceof模式匹配转正</li><li>jpackage转正</li><li>Unix域套接字通道</li><li>弹性Metaspace</li><li>ZGC</li><li>矢量API</li><li>外部链接API</li><li>…</li></ul><p>这次IDEA 2021版的一个很重要的更新就是加入了对Java 16的基本支持，注意是基本支持。</p><p>除此之外IDEA还新增了几项检查机制，典型比如更加智能的数据流分析检查。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/77576024e84240a88339f60125f9bd01~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>链式构造方式的优化格式设置等等。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/5e9e57afa1114abaa70e646582f049d8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>目的都是为了帮助提升可读性，进一步提升用户体验。</p><hr><h1 id="Code-With-Me"><a href="#Code-With-Me" class="headerlink" title="Code With Me"></a>Code With Me</h1><p>Code With Me是一项用于协作开发与结对编程的服务，可以实现<code>Host-Guest</code>模式的“手摸手”（滑稽）结对编程和群体编程。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/bb9e5d49651b4c7ea0ff903b713cb15d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>目前，新版IDEA开箱即用地支持了Code With Me功能，同时它还具有音频通话和视频通话功能，可以满足随时随地的沟通需求，这操作简直骚到爆。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/975a2fe19c2c4ff192a4dfd38536b47a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/0487f917947149cf804fd11c8c33645e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/e5412ac81ee54d50824776bc8c1871c7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>版本控制这一块目前做了不少的更新，包括可以更快地完成PR的创建提交，支持PR模板。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/001caf51fe2a41e2b7d02e21ff134962~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>变更提交至代码库前的自定义代码检查配置。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/08ff5332c8664ffe98e9dad0190613c6~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>以及支持自定义Git提交模板等等。</p><hr><h1 id="其他用户体验提升"><a href="#其他用户体验提升" class="headerlink" title="其他用户体验提升"></a>其他用户体验提升</h1><h2 id="IDEA内置HTML网页预览"><a href="#IDEA内置HTML网页预览" class="headerlink" title="IDEA内置HTML网页预览"></a>IDEA内置HTML网页预览</h2><p>以前在IDEA中预览网页得跳到外部浏览器，而现如今IDE的编辑器内部就支持<code>Built-in</code>级别的网页预览，只需要在右上角点那个IDEA小图标即可激活，而且可以编辑网页源码时做到同步更新和预览。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/e9e57262a6a646798a34ea5bbe73af61~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="Windows版本任务栏增强"><a href="#Windows版本任务栏增强" class="headerlink" title="Windows版本任务栏增强"></a>Windows版本任务栏增强</h2><p>在Windows平台的新版IDEA上，可直接在任务栏（或开始菜单）上右键快捷呼出最近使用的项目。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/d38cc8879aa34c41b24806d750c1425c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="搜索时自定义外部依赖项"><a href="#搜索时自定义外部依赖项" class="headerlink" title="搜索时自定义外部依赖项"></a>搜索时自定义外部依赖项</h2><p>讲白了，就是使搜索范围更易于自定义，我们可以直接在设置中进行Scope定义，自行选择External Dependencies的范围是否包含。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b114d1f88ad848c789108dab8cc837a8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="窗口拆分优化"><a href="#窗口拆分优化" class="headerlink" title="窗口拆分优化"></a>窗口拆分优化</h2><p>当你对编辑器里的多个文件进行垂直窗口拆分时，双击某个Tab就可以将当前文件窗口最大化，再次双击Tab则会还原。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/69ccfa7fb5bf4638acee50b8237b973c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><p>当然除了这些之外，新版IDEA还新增了很多更新和增强，比如：对Kotlin、Scala、JavaScript等语言的开发优化、对常见框架与技术的优化和支持、对Kubernetes和Docker的更新支持和改进、数据库工具的更新支持等等，由于时间有限，在此就不一一赘述了，有需要的可以按需细究。</p><p>最后，让我们一起大喊一句：“IDEA，yyds！”</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/69e06fcd540e4009b7b75987e2498d76~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>作者：CodeSheep<br>链接：<a href="https://juejin.cn/post/6959729508786110494">https://juejin.cn/post/6959729508786110494</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>IDEA2021</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么不推荐使用BeanUtils属性转换工具</title>
    <link href="/blog/2021/05/07/BeanUtils%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7/"/>
    <url>/blog/2021/05/07/BeanUtils%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>之前在专栏中讲过“不推荐使用属性拷贝工具”，推荐直接定义转换类和方法使用 IDEA 插件自动填充 get / set 函数。</p><p><strong>不推荐的主要理由是：</strong></p><p>有些属性拷贝工具性能有点差 有些属性拷贝工具有“BUG” 使用属性拷贝工具容易存在一些隐患（后面例子会讲到）</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2 示例"></a>2 示例</h2><p>首先公司内部就遇到过 commons 包的 BeanUtils 进行属性拷贝性能较差的真实案例，然后该同事换成了 Spring 的 BeanUtils 性能好了很多，感兴趣大家可以使用性能测试框架或者基准测试框架去对比，这里就不对比了。</p><p>接下来我们看 Spring 的 BeanUtils 的属性拷贝会存在啥问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">`<span class="hljs-keyword">import</span> lombok.Data;`<br>`<span class="hljs-keyword">import</span> java.util.List;`<br>`<span class="hljs-meta">@Data</span>`<br>`<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;`<br> `<span class="hljs-keyword">private</span> String name;`<br> `<span class="hljs-keyword">private</span> List&lt;Integer&gt; ids;`<br>`&#125;`<br>`<span class="hljs-meta">@Data</span>`<br>`<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;`<br> `<span class="hljs-keyword">private</span> String name;`<br> `<span class="hljs-keyword">private</span> List&lt;String&gt; ids;`<br>`&#125;`<br>复制代码<br>`<span class="hljs-keyword">import</span> org.springframework.beans.BeanUtils;`<br>`<span class="hljs-keyword">import</span> java.util.Arrays;`<br>`<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanUtilDemo</span> </span>&#123;`<br> `<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;`<br> `A first = <span class="hljs-keyword">new</span> A();`<br> `first.setName(<span class="hljs-string">&quot;demo&quot;</span>);`<br> `first.setIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));`<br> `B second = <span class="hljs-keyword">new</span> B();`<br> `BeanUtils.copyProperties(first, second);`<br> `<span class="hljs-comment">// 类型转换异常`</span><br> `<span class="hljs-keyword">for</span> (String each : second.getIds()) &#123;`<br> `System.out.println(each);`<br> `&#125;`<br> `&#125;`<br>`&#125;`<br><br></code></pre></td></tr></table></figure><p>大家运行上述示例时，会发生类型转换异常。</p><p>打断点可以看到，属性拷贝之后 B 类型的 second 对象中 ids 仍然为 Integer 类型：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/cb821056275d46f48b3db29947f9c884~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>如果不转换为字符串，直接进行打印，并不会报错。</p><p>使用CGlib 在不定义Converter 的情况下也会遇到类似问题：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`import org.easymock.cglib.beans.BeanCopier<span class="hljs-comment">;`</span><br>`import java.util.Arrays<span class="hljs-comment">;`</span><br>`public class BeanUtilDemo &#123;`<br> `public static void main(String[] args) &#123;`<br> `A first = <span class="hljs-keyword">new</span> A()<span class="hljs-comment">;`</span><br> `first.setName(<span class="hljs-string">&quot;demo&quot;</span>)<span class="hljs-comment">;`</span><br> `first.setIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment">;`</span><br> `B second = <span class="hljs-keyword">new</span> B()<span class="hljs-comment">;`</span><br> `final BeanCopier beanCopier = BeanCopier.create(A.class, B.class, <span class="hljs-literal">false</span>)<span class="hljs-comment">;`</span><br> `beanCopier.copy(first,second,null)<span class="hljs-comment">;`</span><br><span class="hljs-title"> `for (String each :</span> second.getIds()) &#123;// 类型转换异常`<br> `System.out.println(each)<span class="hljs-comment">;`</span><br> `&#125;`<br> `&#125;`<br>`&#125;`<br><br></code></pre></td></tr></table></figure><p>同样，问题在运行时才暴露出来。</p><p>接下来我们看下 mapstruct：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`import org.mapstruct.Mapper<span class="hljs-comment">;`</span><br>`import org.mapstruct.factory.Mappers<span class="hljs-comment">;`</span><br>`@Mapper`<br>`public interface Converter &#123;`<br> `Converter INSTANCE = Mappers.getMapper(Converter.class)<span class="hljs-comment">;`</span><br> `B aToB(A car)<span class="hljs-comment">;`</span><br>`&#125;`<br>`import java.util.Arrays<span class="hljs-comment">;`</span><br>`public class BeanUtilDemo &#123;`<br> `public static void main(String[] args) &#123;`<br> `A first = <span class="hljs-keyword">new</span> A()<span class="hljs-comment">;`</span><br> `first.setName(<span class="hljs-string">&quot;demo&quot;</span>)<span class="hljs-comment">;`</span><br> `first.setIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment">;`</span><br> `B second = Converter.INSTANCE.aToB(first)<span class="hljs-comment">;`</span><br><span class="hljs-title"> `for (String each :</span> second.getIds()) &#123;// 正常`<br> `System.out.println(each)<span class="hljs-comment">;`</span><br> `&#125;`<br> `&#125;`<br>`&#125;`<br><br></code></pre></td></tr></table></figure><p>可以成功的将 A 中 List转为 B 中的 List类型。</p><p>我们看下编译生成的 Converter 实现类：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`import java.util.ArrayList<span class="hljs-comment">;`</span><br>`import java.util.List<span class="hljs-comment">;`</span><br>`import javax.annotation.Generated<span class="hljs-comment">;`</span><br>`import org.springframework.stereotype.Component<span class="hljs-comment">;`</span><br>`@Generated(`<br> `value = <span class="hljs-string">&quot;org.mapstruct.ap.MappingProcessor&quot;</span>,`<br> `comments = <span class="hljs-string">&quot;version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_202 (Oracle Corporation)&quot;</span>`<br>`)`<br>`@Component`<br>`public class ConverterImpl implements Converter &#123;`<br> `@Override`<br> `public B aToB(A car) &#123;`<br> `if ( car == null ) &#123;`<br> `return null<span class="hljs-comment">;`</span><br> `&#125;`<br> `B b = <span class="hljs-keyword">new</span> B()<span class="hljs-comment">;`</span><br> `b.setName( car.getName() )<span class="hljs-comment">;`</span><br> `b.setIds( integerListToStringList( car.getIds() ) )<span class="hljs-comment">;`</span><br> `return b<span class="hljs-comment">;`</span><br> `&#125;`<br> `protected List&lt;String&gt; integerListToStringList(List&lt;Integer&gt; list) &#123;`<br> `if ( list == null ) &#123;`<br> `return null<span class="hljs-comment">;`</span><br> `&#125;`<br> `List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;( list.size() )<span class="hljs-comment">;`</span><br><span class="hljs-title"> `for ( Integer integer :</span> list ) &#123;`<br> `list1.add( String.valueOf( integer ) )<span class="hljs-comment">;`</span><br> `&#125;`<br> `return list1<span class="hljs-comment">;`</span><br> `&#125;`<br>`&#125;`<br><br></code></pre></td></tr></table></figure><p>自动帮我们进行了转换，我们可能没有意识到类型并不一致。</p><p>如果我们在 A 类中添加一个 String number 属性，在 B 类中添加一个 Long number 属性，使用 mapstruect 当 number 设置为非数字类型时就会报 .NumberFormatException。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`@Override`<br>`public B aToB(A car) &#123;`<br> `if ( car == null ) &#123;`<br> `return null<span class="hljs-comment">;`</span><br> `&#125;`<br> `B b = <span class="hljs-keyword">new</span> B()<span class="hljs-comment">;`</span><br> `b.setName( car.getName() )<span class="hljs-comment">;`</span><br> `if ( car.getNumber() != null ) &#123; // 问题出在这里`<br> `b.setNumber( Long.parseLong( car.getNumber() ) )<span class="hljs-comment">;`</span><br> `&#125;`<br> `b.setIds( integerListToStringList( car.getIds() ) )<span class="hljs-comment">;`</span><br> `return b<span class="hljs-comment">;`</span><br>`&#125;`<br><br></code></pre></td></tr></table></figure><p>使用 cglib 默认则不会映射 number 属性，B 中的 number 为 null。</p><p>如果手动定义转换器，使用 IDEA 插件(如 generateO2O)自动转换：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`public final class A2BConverter &#123;`<br> `public static B from(A first) &#123;`<br> `B b = <span class="hljs-keyword">new</span> B()<span class="hljs-comment">;`</span><br> `b.setName(first.getName())<span class="hljs-comment">;`</span><br> `b.setIds(first.getIds())<span class="hljs-comment">;`</span><br> `return b<span class="hljs-comment">;`</span><br> `&#125;`<br>`&#125;`<br><br></code></pre></td></tr></table></figure><p>在编码阶段就可以非常明确地发现这个问题：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/eee57aceb1ae42599cf03fff6d8d5fee~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3 结论"></a>3 结论</h2><p>由于 Java 的泛型其实是编译期检查，编译后泛型擦除，导致运行时 List和 List都是 List 类型，可以正常赋值。这就导致在使用很多属性映射工具时，编译时不容易明显的错误。</p><p>mapstruct 自定义了注解处理器，在编译阶段可以读取映射双方的泛型类型，进而进行映射。但是这种映射也很可怕，有时候我们由于粗心等原因定义错了类型，自动帮助我们进行了转换，会带了很多副作用。</p><p>之前对各种属性映射工具的性能进行了简单的对比，结果如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/01dbea76a40048e9a81d277c391d6a92~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>因此慎用属性转换工具，如果可能建议自定义转换类，使用IDEA插件自动填充，效率也挺高， A 或 B 中任何属性类型不匹配，甚至删除一个属性，编译阶段即可报错，而且直接调用 get set 的效率也是非常高的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>BeanUtils</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何准确判断什么时候可以给大表加索引</title>
    <link href="/blog/2021/05/06/%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E7%BB%99%E5%A4%A7%E8%A1%A8%E5%8A%A0%E7%B4%A2%E5%BC%95/"/>
    <url>/blog/2021/05/06/%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E7%BB%99%E5%A4%A7%E8%A1%A8%E5%8A%A0%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><p>以社交平台的用户表为例，随着业务的快速增长，用户表user单表数据量越来越大，此时，如果我们想给user表添加索引，数据规模对添加过程的影响势必要考虑在内，但是，单表数据规模对添加索引会产生什么样的影响呢，我们在什么样的数据库请求状态下给大表添加索引比较好呢？</p><blockquote><p>今天，我就详细回答一下上面两个问题：</p><ol><li>单表数据规模对添加索引会产生什么样的业务影响？</li><li>在什么样的数据库请求状态下给大表添加索引比较好？</li></ol></blockquote><p>我们先来看下第一个问题，当我们回答了第一个问题，那么，第二个问题的答案也就浮出水面了。</p><h4 id="Row-Log"><a href="#Row-Log" class="headerlink" title="Row Log"></a>Row Log</h4><p>我们先来看一个结构，它叫<code>Row Log</code>，用于在DDL过程中记录DML操作的日志文件。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/13ee77835ae4471e96c3a5828df3749f~tplv-k3u1fbpfcp-watermark.image" alt="image-20210102173304826.png"></p><p>我以user表为例，讲解一下<code>Row Log</code>。它有如下特点：</p><ol><li>每个索引对应一个Row Log，如上图为user表的索引<code>index_age_birth</code>对应的Row Log。</li></ol><p>Row Log在逻辑上由多个Block组成，每个Block可以存储多个DML操作、一个DML操作也会落在多个Block中。如上图中的Log代表DML操作：</p><ol><li>最前面两个Log存在第二个Block中</li><li>第3个Log和第4个Log的前半部分存在第三个Block中</li><li>第4个Log的后半部分和第5个Log存在最后一个Block中</li></ol><p>在物理存储上<code>Row Log</code>分为两部分：</p><ol><li>内存日志：内存中会存放一个总大小等于<code>inndob_sort_buffer_size</code>的Block，用于写入DML操作</li><li>文件日志：当内存中的Block写满，也就是大小大于<code>innodb_sort_buffer_size</code>，且小于<code>innodb_online_alter_log_max_size</code>时，写满的Block会刷到磁盘上，空出内存中的Block给后续的Log写入，日志文件中，所有Block总大小如果超过<code>innodb_online_alter_log_max_size</code>，写入就会报错</li></ol><p><code>Row Log</code>的核心结构如下：</p><ol><li>Log：表示DML操作日志，它的结构为<code>操作flag + 事务id + 操作记录</code>，其中，操作flag包含两种：<code>INSERT和DELETE，UPDATE看作是先DELETE，再INSERT</code>。比如，上图第一个Log中包含一条记录<code>&lt;0x61 + 1234 + &lt;25, 1998-01-02, 1&gt;&gt;</code>，其中，<code>0x61</code>代表这是一个插入操作，<code>1234</code>表示这个操作的事务id，<code>&lt;25, 1998-01-02, 1&gt;</code>表示操作的记录。</li><li>head：这是用于将Block中的Log回放到索引树时，用来扫描Block中Log的指针，扫完一个Log，head指针向后移到下一个Log。如上图，因为从Block的头部开始扫描，head指针在回放前处在Block的第一个Log的位置。</li><li>tail：这是用于将DML操作写入一个Block时，用来定位Block中Log插入位置的指针，插入完一个Log，tail指针向后移动到新插入的Log。如上图，因为从Block的头部开始插入Log，所以，tail指针在插入前处在Block的第一个Log的位置。</li><li>blocks：无论是head还是tail指针，都包含一个blocks字段，表示Row Log日志文件中包含的Block数量</li></ol><h4 id="Row-Log追加"><a href="#Row-Log追加" class="headerlink" title="Row Log追加"></a>Row Log追加</h4><p>下面我们再来看下Log是如何追加到Row Log的？我以user表的<code>index_age_birth</code>索引的Row Log为例来说明：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/e4ed81de7ab54c4885b4e60350e52e33~tplv-k3u1fbpfcp-watermark.image" alt="image-20210102173453682.png"></p><p>见上图，从上到下，我们来看下这个追加的过程：</p><ol><li><p>如果内存中没有Block，创建一个<code>innodb_sort_buffer_size</code>大小的Block，tail指针指向Block中的第一个Log，如果有Block，tail指针指向Block中最后一个Log。如上图，内存中有Block，tail指向Block中最后一个Log，也就是虚线框前面那个Log</p></li><li><p>根据即将插入的DML操作日志大小，得到Block中下一个Log相对最后一个Log的偏移量。如上图中的offset，这里分两种情况：</p><p>(1) 如果<code>DML操作日志大小 &gt;= innodb_sort_buffer_size - 当前Block中已有Log的总大小，则偏移量为innodb_sort_buffer_size - 当前Block中已有Log的总大小</code></p><p>(2) 如果<code>DML操作日志大小 &lt; innodb_sort_buffer_size - 当前Block中已有Log的总大小，则偏移量为DML操作日志大小</code></p></li><li><p>根据tail指针和偏移量，将插入的DML操作日志拷贝到内存的Block。这里同样分两种情况：</p><p>(1) 全拷贝</p><ul><li>如果<code>DML操作日志大小 &lt; innodb_sort_buffer_size - 当前Block中已有Log的总大小</code>，将DML操作日志全部拷贝到Block中末尾Log。如上图，全拷贝最右侧，将DML日志<code>&lt;0x61 + 3355 + &lt;25, 1998-01-02, 1&gt;&gt;</code>完整拷贝到末尾Log，然后，将tail移到被拷贝的Log上</li></ul><p>(2) 半拷贝</p><ul><li>如果<code>DML操作日志大小 &gt;= innodb_sort_buffer_size - 当前Block中已有Log的总大小</code>，拷贝DML操作日志的前面部分到tail后面偏移量大小的空间。如上图半拷贝里的上半部分，将DML日志<code>&lt;0x61 + 3355 + &lt;25, 1998-01-02, 1&gt;&gt;</code>的前半部分拷贝到末尾Log，然后，将tail移到被拷贝的Log上</li><li>将内存中整个Block写入Row Log日志文件。如上图，半拷贝里上半部分大括号包含了整个Block，同时将该Block通过箭头，写入<code>row_log_file</code></li><li>重新将tail移到内存空Block的头部，将DML操作的后半部分拷贝到tail后面偏移量大小的空间。如上图半拷贝里的下半部分，将DML日志<code>&lt;0x61 + 3355 + &lt;25, 1998-01-02, 1&gt;&gt;</code>的后半部分拷贝到Block的头部</li><li>如上图，tail.blocks + 1，代表Row Log日志文件中新增了一个Block。</li></ul></li></ol><h4 id="Row-Log回放"><a href="#Row-Log回放" class="headerlink" title="Row Log回放"></a>Row Log回放</h4><p>MySQL将DML日志写到Row Log只是为了在执行DDL期间，可以并行执行DML，最后，这些DML日志还是要更新(回放)到索引树上的，所以，同样以索引<code>index_age_birth</code>为例，我们再来看下Row Log中的日志是如何更新到索引树的？</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b3ecf4add8134aa8a9a1192f5bea16c0~tplv-k3u1fbpfcp-watermark.image" alt="image-20210102173617242.png"></p><p>从上到下，我们来看上面这张图：</p><ol><li><p>MySQL先扫描磁盘上的Row Log文件，遍历文件中的Block，如上图，文件扫描部分为一个Block的遍历：</p><p>(1) head指针指向Block的头部Log，从该Log开始，将头部Log写入索引树。如上图，文件扫描中的最上面部分，将DML日志<code>0x61 + 3355 + &lt;25, 1998-01-02, 1&gt;&gt;</code>中的记录写入索引树<code>index_age_birth</code>的第一个叶子节点。</p><p>(2) 头部Log清空，将head指针移到后面一个Log。如上图，文件扫描中的第二块长方框。</p><p>(3) 重复(1)和(2)两步，直到head指针移到Block中最后一个Log，然后，将该Log中的记录写入索引树<code>index_age_birth</code>。如上图，文件扫描中的第三个长方框及方框中最后一个Log中的记录写入索引树<code>index_age_birth</code>的第二个叶子节点。。</p></li><li><p>重复步骤1，将Row Log文件中所有Block内的Log全部写入索引树<code>index_age_birth</code>，至此，Row Log文件清空。如上图，文件扫描中最后一个虚线长方框，表示Row Log文件清空。</p></li><li><p>由于DML日志写Row Log和DDL同时进行，结合《Row Log追加》中的过程，我们会发现大部分Block写入了Row Log文件，但是，还会存在小部分DML日志留存在内存的Block中，所以，MySQL需要将这部分留存的Log再写入索引树中，具体过程如下：</p><p>(1) 对数据字典加排它锁，禁止新的DML操作，<strong>ps：如果不加锁，会导致内存中Block不断更新，无法判断DML操作何时结束</strong>。</p><p>(2) 执行步骤1，将内存Block中的Log全部写入索引树<code>index_age_birth</code>，如上图，内存扫描部分。</p></li></ol><h4 id="Bulk-Load"><a href="#Bulk-Load" class="headerlink" title="Bulk Load"></a>Bulk Load</h4><p>在讲解添加索引的过程之前，还有一个概念再讲解一下，这就是<code>Bulk Load</code>，在添加索引的过程中，会将已排序的记录批量插入索引树的叶子节点中，这个批量插入的过程就叫做<code>Bulk Load</code>，我以索引<code>index_age_birth</code>为例，讲解一下这个过程，见下图：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/f91e90d283084d53bd4d815f705c3048~tplv-k3u1fbpfcp-watermark.image" alt="image-20210102173655135.png"></p><ol><li>从已排序的记录集中分多批写入内存的bulk中。如上图，MySQL将最左边已排序的记录集拆分成两批写入2个bulk中，上面的bulk包含<code>15, 2008-02-03, 2</code>和<code>15, 2008-02-06, 5</code>两条记录，下面的bulk包含<code>16, 2007-06-06, 6</code>、<code>17, 2006-03-03, 4</code>和<code>18, 2002-06-07, 3</code> 三条记录。</li><li>以bulk为单位，将bulk中的记录集一次插入索引树中。如上图，上面的bulk记录集插入到索引树<code>index_age_birth</code>的第三个叶子节点，下面的bulk记录集插入到索引树<code>index_age_birth</code>的倒数第二个叶子节点。</li></ol><h4 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h4><p>Row Log的追加和回放，以及Bulk Load是添加索引过程中的核心步骤，讲完这三个步骤，下面我再来看一下InnoDB引擎中MySQL添加索引的过程就比较容易理解了，该过程主要分三个阶段，我以user表为例详细讲解一下：</p><p><strong>Prepare阶段</strong>：</p><ol><li>根据旧表user的表结构文件frm，创建一个副本表结构frm文件，将新索引添加到副本中</li><li>获得MDL排他锁，禁止读写数据字典及旧user表，关于MDL锁，我会在《MySQL锁全解析》详细讲解</li><li>根据alter类型，确定执行方式，一共两种执行方式：COPY、INPLACE</li><li>更新内存中的数据字典，标记user表所有索引<code>online_status</code>为<code>ONLINE_INDEX_CREATION</code>，表示该表索引都处在在线DDL状态。关于数据字典的结构，我在《我们可以干预MySQL选择正确的执行计划吗？》中有讲解过。</li><li>根据旧表user的ibd文件，创建副本ibd文件</li></ol><p><strong>DDL执行阶段：</strong></p><ol><li><p>降级MDL锁为共享锁，允许读写数据字典及旧user表</p></li><li><p>扫描旧表user的聚集索引中叶子节点每一条记录</p><p>(1) 申请一个<code>sort_buffer</code>，大小为<code>innodb_sort_buffer_size/索引叶子节点中最小的记录的大小</code></p><p>(2) 将每一条记录写入<code>sort_buffer</code></p><p>(3) <code>sort_buffer</code>写满后对里面的记录进行升序排序</p><p>(4) <code>sort_buffer</code>写满了，如果临时文件不存在，就创建一个临时文件</p><p>(5) 遍历<code>sort_buffer</code>记录，将<code>sort_buffer</code>中的记录写入文件中</p><p>​     a. 生成一个block，将记录添加到block</p><p>(6) 将block写入临时文件</p></li><li><p>遍历旧表聚簇索引的记录完成后，临时文件中就包含多个block，每个block包含已排序的记录</p></li><li><p>使用归并排序对临时文件中的block内记录进行排序</p></li><li><p>遍历副本frm中的聚集索引和辅助索引</p><p>(1) 搜索索引树，定位到树种最右边的叶子节点</p><p>(2) 判断该节点是否可以有足够空间批量插入记录，如果没有就创建一个新的叶子节点，执行步骤(3)，否则，执行步骤(4)</p><p>(3) 将新节点接到索引树的右下角，执行步骤(4)</p><p>(4) 遍历临时文件中的记录，将记录通过bulk load方式写入叶子节点</p><p>(5) 调整插入记录的叶子节点内记录的slot信息，关于slot，我在《InnoDB是顺序查找B-Tree叶子节点的吗？》中详细讲解过。</p></li><li><p>在这个阶段，与此同时，user表的所有DML操作日志写入Row Log，即《Row Log追加》中讲解的过程</p></li><li><p>重放该阶段产生的user表的Row Log日志到索引中，直到Row Log中的最后一个block，即《Row Log回放》中讲解的过程。</p></li></ol><p><strong>Commit阶段</strong>：</p><ol><li>升级MDL锁为排它锁，禁止读写数据字典及旧user表</li><li>将Row Log中最后一个block，即内存中Block对应的DML日志插入索引树，过程参见<strong>DDL执行阶段</strong>中的步骤(7)</li><li>更新内存中的数据字典，关于数据字典的结构，我在《我们可以干预MySQL选择正确的执行计划吗？》中有讲解过。</li><li>将DDL执行操作记录redo日志</li><li>rename副本ibd文件和frm文件为旧表名，即原user表的frm和ibd文件名</li></ol><p>在讲解完添加索引的过程后，我们发现影响业务DML操作的环节包含：</p><ol><li>循环遍历旧表聚簇索引叶子节点的所有记录，如果表记录非常多，非常消耗CPU，如果DDL长时间占用CPU资源，势必会影响MySQL的连接数，导致MySQL处理DML操作的并发请求数下降</li><li>归并排序使用的磁盘临时文件做记录排序，如果文件中的已排序记录集非常多，那么，归并排序过程中产生大量的磁盘IO，在MySQL处理查询时，如果内存中没有查询的结果，此时，<code>buffer pool</code>又满了，触发刷脏行为，这时就会出现查询请求等待刷脏结束，查询响应变慢。</li></ol><p>可能这时候你会问，Prepare阶段和Commit阶段都加了排它锁，为什么这两个环节不影响DML操作呢？因为虽然这两个阶段都加了排它锁，但是，加锁后的操作都是小数据规模的操作，所以，加锁时间很短，对DML的影响不大，所以，可以忽略不计。</p><blockquote><p>那么，我们看看上面两个问题怎么解决呢？</p><p>针对第一个问题，由于表中的原有记录的数量是由业务发展决定的，业务发展快，记录数就会多，这点我们无法控制，所以，针对表数据量大导致扫描聚簇索引变慢，我们只能规避DDL带来的风险，规避方法如下：</p><ol><li>评估表中的数据量</li><li>观察MySQL的CPU使用率</li></ol><p>结合上面两个因素，如果数据量不大，那么，只要在非极端高峰期执行DDL，对DML的 影响是不大的。如果数据量很大，建议找到MySQL的CPU使用率比较低的情况下做DDL，保证不影响DML操作.。</p><p>针对第二个问题，我们可以通过调整参数<code>innodb_sort_buffer_size</code>，将其调大，使归并排序来源的临时文件中已排序的block数量尽可能少，减少大量block的合并，从而降低磁盘IO</p></blockquote><h4 id="主从模式下的问题"><a href="#主从模式下的问题" class="headerlink" title="主从模式下的问题"></a>主从模式下的问题</h4><p>平时我们用的最多的MySQL架构就是主从模式，所以，我们来看一下在这种模式下，在线DDL的过程是怎么样的呢？</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/3403ff7b515b482c8eac458b6127353d~tplv-k3u1fbpfcp-watermark.image" alt="image-20210102165130582.png"></p><ol><li>结合《添加索引》中的过程，我们知道DDL和DML并行阶段，DDL一边执行，DML一边写入Row Log。如上图，左边在master中，DDL和INSERT，以及UPDATE并行执行，DDL在执行的同时，INSERT和UPDATE并行写入Row Log</li><li>DDL和DML并行过程中，将DDL操作和并行的DML按序写入binlog。如上图，左边master将DDL和INSERT、UPDATE操作按序写入binlog，DDL第一、其次是INSERT，最后是UPDATE</li><li>DDL执行结束，将master的binlog同步到slave上。如上图，将左边master的binlog中的三条操作同步到slave上</li><li>在slave上依次回放DDL和DML。如上图，右边在slave中依次执行DDL、INSERT和UPDATE</li></ol><p>通过上面这个过程，你应该已经想到，在DDL和DML并行的阶段，如果产生大量的DML操作，那么，在slave端回放这些DML操作会耗费大量的时间，会影响从库读的数据一致性。所以，这就是主从模式下，在线DDL的问题和风险。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过本章的讲解，我想你应该对MySQL的在线DDL的机制有了清晰的认识，同时，通过在线DDL机制的讲解，我们也发现了一些优化的方法：</p><table><thead><tr><th>目的</th><th>解决方法</th></tr></thead><tbody><tr><td>减少业务影响</td><td>调大<code>innodb_sort_buffer_size</code>，降低磁盘IO</td></tr><tr><td>避免DDL过程中写Row Log溢出</td><td>调大<code>innodb_online_alter_log_max_size</code></td></tr><tr><td>一定要在高峰期做DDL</td><td>建议使用第三方工具，比如，gh-ost，它是通过binlog完成DDL的，避免了扫描聚簇索引带来的CPU开销</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 设计模式之单例模式</title>
    <link href="/blog/2021/05/05/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/05/05/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/61076ca4e6e542f78055b8e1db68effc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p></blockquote><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><p>单例模式有 3 个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><p>一般来说，系统中只需要有一个实例就能满足系统需要时，那么就可以设计成单例模式。</p><p>比如 Windows 的回收站，数据库的连接池，系统中的日志对象等等。（当然，如果你非要设计成多个，我也没有办法是不是）</p><h2 id="2-优点和缺点"><a href="#2-优点和缺点" class="headerlink" title="2. 优点和缺点"></a>2. 优点和缺点</h2><p>单例模式的优点：</p><ol><li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li><li>可以避免对资源的多重占用。</li><li>单例模式设置全局访问点，可以优化和共享资源的访问。</li></ol><p>单例模式的缺点：</p><ol><li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li><li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li></ol><h2 id="3-结构"><a href="#3-结构" class="headerlink" title="3. 结构"></a>3. 结构</h2><p>单例模式的 UML 类图如下图所示，非常简单，只有一个类。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/930e26b803944d9e8caffffb94e2e2f1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>上述类图很好地体现了单例模式的3个特点。</p><ol><li>一个私有实例常量 <code>INSTANCE</code>，保证只有一个实例对象；</li><li>一个私有的构造器 <code>private Singleton()&#123;&#125;</code> 保证外部无法实例化，只能由自身创建；</li><li>通过公共的 <code>getInstance()</code> 方法提供一个访问该单例的全局访问点。</li></ol><h2 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h2><p>单例模式可以按不同维度对其进行分类：</p><ul><li>线程安全维度：线程安全的单例模式、线程不安全的单例模式</li><li>对象创建时机：饿汉式的单例模式、懒汉式的单例模式<ul><li>饿汉式 - 第一次调用前（或说类被 JVM 加载时）就已经被实例化了。</li><li>懒汉式 - 只有在第一次调用的时候才会被实例化。</li></ul></li></ul><h3 id="4-1-枚举类单例"><a href="#4-1-枚举类单例" class="headerlink" title="4.1 枚举类单例"></a>4.1 枚举类单例</h3><p>因为 Java 保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可，而且它是<strong>线程安全</strong>的。</p><p>枚举类也完全可以像其他类那样定义自己的字段、方法，如下方实例代码中的 <code>name</code> 参数，<code>getName()</code> 及 <code>setName()</code> 方法等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.junmoyu.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举的单例实现 - 线程安全</span><br><span class="hljs-comment"> * 绝对防止多实例化，即使是在面反序列化和反射攻击时</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumSingleton</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 唯一实例</span><br><span class="hljs-comment">     */</span><br>    INSTANCE;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果没有初始化的内容，可删除此方法</span><br><span class="hljs-comment">     */</span><br>    EnumSingleton() &#123;<br>        System.out.println(getClass().getCanonicalName() + <span class="hljs-string">&quot; 被实例化，内存地址为：&quot;</span> + hashCode());<br>        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot;莫语&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>Effective Java</code> 书中也推荐使用这种单例模式。因为它足够简单，线程安全，且天然可以防止多实例化，即使是在面反序列化和反射攻击时。</p></blockquote><p>如果需要在单例中做初始化操作，可以使用构造方法实现，否则是不需要构造方法的。使用时可以直接用 <code>EnumSingleton.INSTANCE.getName()</code> 来调用单例中的方法。</p><p>在类中添加一个 <code>main()</code> 方法测试一下看看，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumSingleton</span> </span>&#123;<br>    INSTANCE;<br><br>    <span class="hljs-comment">// ... 省略其他代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 延迟加载测试</span><br>        System.out.println(<span class="hljs-string">&quot;测试代码启动&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 方法调用测试</span><br>        System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + EnumSingleton.INSTANCE.getName());<br>        EnumSingleton.INSTANCE.setName(<span class="hljs-string">&quot;junmoyu.com&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + EnumSingleton.INSTANCE.getName());<br><br>        <span class="hljs-comment">// 反射测试</span><br>        <span class="hljs-comment">// 枚举天然防止反射攻击</span><br>        Class&lt;EnumSingleton&gt; clazz = (Class&lt;EnumSingleton&gt;) Class.forName(<span class="hljs-string">&quot;com.junmoyu.singleton.EnumSingleton&quot;</span>);<br>        Constructor&lt;EnumSingleton&gt; constructor = clazz.getDeclaredConstructor(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 这里将直接抛出异常</span><br>        EnumSingleton singleton = constructor.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.EnumSingleton</span> 被实例化，<span class="hljs-selector-tag">hashCode</span>：460141958<br>代码启动<br><span class="hljs-selector-tag">name</span>: 莫语<br><span class="hljs-selector-tag">name</span>: <span class="hljs-selector-tag">junmoyu</span><span class="hljs-selector-class">.com</span><br><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> &quot;<span class="hljs-selector-tag">main</span>&quot; <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NoSuchMethodException</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.EnumSingleton</span>.&lt;<span class="hljs-selector-tag">init</span>&gt;()<br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Class</span><span class="hljs-selector-class">.getConstructor0</span>(<span class="hljs-selector-tag">Class</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:3082)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Class</span><span class="hljs-selector-class">.getDeclaredConstructor</span>(<span class="hljs-selector-tag">Class</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:2178)</span><br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.EnumSingleton</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">EnumSingleton</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:51)</span><br></code></pre></td></tr></table></figure><p>从结果中可以看出，枚举类的单例模式不是延迟加载的，且可以防止反射创建多个实例。关于反射的话题会在后面的章节专门讲解。</p><h3 id="4-2-饿汉式单例"><a href="#4-2-饿汉式单例" class="headerlink" title="4.2 饿汉式单例"></a>4.2 饿汉式单例</h3><p>饿汉式单例，其创建对象的时机是在第一次调用之前，在类被 JVM 加载时就会被创建。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.junmoyu.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式单例模式 - 线程安全</span><br><span class="hljs-comment"> * 该类在程序加载时就已经初始化完成了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerlySingleton</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化静态实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> EagerlySingleton INSTANCE = <span class="hljs-keyword">new</span> EagerlySingleton();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有构造函数，保证无法从外部进行实例化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EagerlySingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(getClass().getCanonicalName() + <span class="hljs-string">&quot; 被实例化，hashCode：&quot;</span> + hashCode());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 可被用户调用以获取类的实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerlySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 延迟加载测试</span><br>        System.out.println(<span class="hljs-string">&quot;测试代码启动&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 多线程测试</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;多线程测试：hashCode：&quot;</span> + <span class="hljs-string">&quot;@&quot;</span> + EagerlySingleton.getInstance().hashCode())).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>饿汉式单例</strong>提供了已被实例化的静态实例 <code>INSTANCE</code>，所以不存在多个线程创建多个实例的情况，所以它是<strong>线程安全</strong>的。</p><p>这种单例模式的缺点是即使单例没有被使用，对象也会被创建，占用资源（但其实并不会占用太多资源，视具体业务情况而定）。运行<code>main()</code>方法测试一下。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.junmoyu.singleton.EagerlySingleton 被实例化，hashCode：<span class="hljs-number">460141958</span><br>测试代码启动<br>多线程测试：hashCode：<span class="hljs-subst">@460141958</span><br>多线程测试：hashCode：<span class="hljs-subst">@460141958</span><br>多线程测试：hashCode：<span class="hljs-subst">@460141958</span><br>多线程测试：hashCode：<span class="hljs-subst">@460141958</span><br>多线程测试：hashCode：<span class="hljs-subst">@460141958</span><br></code></pre></td></tr></table></figure><p>可以看到<strong>饿汉式单例</strong>的确是<strong>延迟加载</strong>的，而且<strong>线程安全</strong>。其实线程安全问题比较难以测试，因为此类的确是线程安全的，所以仅做演示，后面会出现线程安全问题的单例方式会着重说明。反射的问题后面也会有专门的章节进行说明。</p><h3 id="4-3-静态内部类单例"><a href="#4-3-静态内部类单例" class="headerlink" title="4.3 静态内部类单例"></a>4.3 静态内部类单例</h3><p>静态内部类实现的单例与上面的饿汉式单例有点相似，这种单例模式也是 <strong>线程安全</strong>的，但它却是延迟加载的，所以对于一些需要延迟加载的单例来说，这种方式是一种非常不错的选择。其代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.junmoyu.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静态内部类 - 线程安全，延迟加载</span><br><span class="hljs-comment"> * 写法简单，且可延迟加载，较推荐此种实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClassSingleton</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用静态内部类来实现延迟加载</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelperHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> StaticInnerClassSingleton INSTANCE = <span class="hljs-keyword">new</span> StaticInnerClassSingleton();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有构造方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">StaticInnerClassSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(getClass().getCanonicalName() + <span class="hljs-string">&quot; 被实例化，hashCode：&quot;</span> + hashCode());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取单例实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StaticInnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> HelperHolder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 延迟加载测试</span><br>        System.out.println(<span class="hljs-string">&quot;测试代码启动&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 多线程测试</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;多线程测试：hashCode：&quot;</span> + <span class="hljs-string">&quot;@&quot;</span> + StaticInnerClassSingleton.getInstance().hashCode())).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与饿汉式单例不同的是，静态内部类单例是延迟加载的，对于一些占用资源多且使用频率不高的单例来说是个非常不错的实现，而且它也是线程安全的，如果你的业务需要线程安全且延迟加载的单例模式，那么静态内部类是个非常不错的选择。同样运行 <code>main()</code> 进行测试，结果如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">测试代码启动<br><span class="hljs-keyword">com</span>.junmoyu.singleton.StaticInnerClassSingleton 被实例化，hashCode：<span class="hljs-number">1251394951</span><br>多线程测试：hashCode：<span class="hljs-subst">@1251394951</span><br>多线程测试：hashCode：<span class="hljs-subst">@1251394951</span><br>多线程测试：hashCode：<span class="hljs-subst">@1251394951</span><br>多线程测试：hashCode：<span class="hljs-subst">@1251394951</span><br>多线程测试：hashCode：<span class="hljs-subst">@1251394951</span><br></code></pre></td></tr></table></figure><p>通过日志可以明显发现，当主线程 <code>main()</code>启动之后，且睡眠等待一分钟，在调用了 <code>StaticInnerClassSingleton.getInstance().hashCode()</code> 方法时该类才被实例化，且在多线程中，仅被实例化了一次。</p><h3 id="4-4-懒汉式单例-线程不安全"><a href="#4-4-懒汉式单例-线程不安全" class="headerlink" title="4.4 懒汉式单例 - 线程不安全"></a>4.4 懒汉式单例 - 线程不安全</h3><p>懒汉式的特点就是<strong>延迟加载</strong>，即对象会在第一次调用时才会被实例化，避免资源消耗。</p><p>如下方代码所示，这是最简单的一种写法，但这是 <strong>线程不安全</strong> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.junmoyu.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式 - 线程不安全</span><br><span class="hljs-comment"> * 非常不推荐使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafeLazyLoadedSingleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadUnsafeLazyLoadedSingleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有构造方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThreadUnsafeLazyLoadedSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(getClass().getCanonicalName() + <span class="hljs-string">&quot; 被实例化，hashCode：&quot;</span> + hashCode());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 可被用户调用以获取类的实例 - 线程不安全</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadUnsafeLazyLoadedSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> ThreadUnsafeLazyLoadedSingleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 延迟加载测试</span><br>        System.out.println(<span class="hljs-string">&quot;测试代码启动&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 多线程测试</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;多线程测试：hashCode：&quot;</span> + <span class="hljs-string">&quot;@&quot;</span> + ThreadUnsafeLazyLoadedSingleton.getInstance().hashCode())).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接运行 <code>main()</code> 测试一下，结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">测试代码启动<br>com<span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.ThreadUnsafeLazyLoadedSingleton</span> 被实例化，hashCode：<span class="hljs-number">847507483</span><br>多线程测试：hashCode：@<span class="hljs-number">847507483</span><br>com<span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.ThreadUnsafeLazyLoadedSingleton</span> 被实例化，hashCode：<span class="hljs-number">319699154</span><br>多线程测试：hashCode：@<span class="hljs-number">319699154</span><br>com<span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.ThreadUnsafeLazyLoadedSingleton</span> 被实例化，hashCode：<span class="hljs-number">758108352</span><br>多线程测试：hashCode：@<span class="hljs-number">758108352</span><br>多线程测试：hashCode：@<span class="hljs-number">847507483</span><br>多线程测试：hashCode：@<span class="hljs-number">847507483</span><br>复制代码<br></code></pre></td></tr></table></figure><p>从结果可以明显的看到，该类虽然是延迟加载的，但是在多线程中，被实例化多次，这是线程不安全，非常不推荐使用！</p><h3 id="4-5-懒汉式单例-线程安全"><a href="#4-5-懒汉式单例-线程安全" class="headerlink" title="4.5 懒汉式单例 - 线程安全"></a>4.5 懒汉式单例 - 线程安全</h3><p>既然上一种方式是线程不安全的，那么基于上面的写法，做一些修改，让它线程安全不就可以嘛。比较简单的一种做法是在<code>getInstance()</code>方法上加锁，添加 <code>synchronized</code> 关键字即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.junmoyu.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式 - 线程安全，延迟加载</span><br><span class="hljs-comment"> * 但因为 getInstance() 方法加锁，导致多线程下性能较差，不推荐使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeLazyLoadedSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadSafeLazyLoadedSingleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有构造方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ThreadSafeLazyLoadedSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(getClass().getCanonicalName() + <span class="hljs-string">&quot; 被实例化，hashCode：&quot;</span> + hashCode());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 可被用户调用以获取类的实例 - 线程安全</span><br><span class="hljs-comment">     * 使用 synchronized 加锁以实现线程安全</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> ThreadSafeLazyLoadedSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> ThreadSafeLazyLoadedSingleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过加锁，每次只有一个线程允许访问 <code>getInstance()</code>，实例化对象，当实例化完成后，这个线程才会解锁，其他线程就没办法创建实例了，也就实现了线程安全。</p><p>但是这种方式有一个很大的缺点，就是每次使用时都会因为<strong>锁</strong>而非常消耗性能，因为每次调用 <code>getInstance()</code> 都只有一个线程可以访问，其他线程只能干等着。所以这种方式也是不推荐的。测试代码大家可自己运行看看结果。</p><h3 id="4-6-懒汉式单例-双重校验锁"><a href="#4-6-懒汉式单例-双重校验锁" class="headerlink" title="4.6 懒汉式单例 - 双重校验锁"></a>4.6 懒汉式单例 - 双重校验锁</h3><p>到这里，我们可以看到以上两种懒汉式单例都有非常明显的缺陷，那么怎么解决呢？</p><p>基于上一种方式的代码，既然在方法上加锁会影响性能，那么我们把锁加在方法里面，加锁之前先判断一下是否已经实例化了是不是就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeLazyLoadedSingleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadSafeLazyLoadedSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 1 号位置</span><br>            <span class="hljs-keyword">synchronized</span> (ThreadSafeLazyLoadedSingleton.class) &#123;<br>                <span class="hljs-comment">// 2 号位置</span><br>                INSTANCE = <span class="hljs-keyword">new</span> ThreadSafeLazyLoadedSingleton();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上方代码所示，这样就不会出现每次调用 <code>getInstance()</code>都只能有一个线程访问导致性能问题了是不是。</p><p>但是仔细想一想上面是不是在多线程的环境下还是会有问题呢？比如此时有线程A和线程B两个线程，两个线程同时访问 <code>getInstance()</code>方法，同时到达 <strong>1 号位置</strong>，此时他们会争抢锁，因为只能有一个线程进入下面的代码块。</p><p>假设线程A此时抢到了锁，线程B未抢到锁，在1号位置等待。当线程A在 <strong>2 号位置</strong> 创建完实例，返回之后解锁，此时对象已经被实例化了。解锁之后，线程B就可以获取锁了，获取锁之后，线程B也可以再创建一个实例。</p><p>针对上面这种情况，还需要再进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeLazyLoadedSingleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadSafeLazyLoadedSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 1 号位置</span><br>            <span class="hljs-keyword">synchronized</span> (ThreadSafeLazyLoadedSingleton.class) &#123;<br>                <span class="hljs-comment">// 2 号位置</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> ThreadSafeLazyLoadedSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <strong>2 号位置</strong> 同样加上非空判断，这样即使出现上述的情况，当实例化之后，其他线程获取锁，进入到 <strong>2 号位置</strong>，也无法再创建实例了。这种方式就是懒汉式单例的最终解决方案：<strong>双重校验锁</strong>。</p><p>至于为什么要双重校验，答案就在上面的那个例子里面了。<strong>双重校验锁</strong> 单例模式完整的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.junmoyu.singleton;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式最终解决方案 - 线程安全，延迟加载</span><br><span class="hljs-comment"> * 也叫双重校验锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleCheckLockingSingleton</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入 volatile 保证线程可见性，防止指令重排导致实例被多次实例化</span><br><span class="hljs-comment">     * 否则线程不安全</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> DoubleCheckLockingSingleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 私有构造方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DoubleCheckLockingSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(getClass().getCanonicalName() + <span class="hljs-string">&quot; 被实例化，hashCode：&quot;</span> + hashCode());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程安全的实例获取，使用双重检查，避免每次获取实例时都加锁</span><br><span class="hljs-comment">     * 但这种模式依然是有隐患的，INSTANCE 常量必须添加 volatile 关键字才能避免指令重排，保持线程可见性</span><br><span class="hljs-comment">     * 而 volatile 在 JDK 1.5 之后才支持</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleCheckLockingSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckLockingSingleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> DoubleCheckLockingSingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法与之前一样，在此就不演示了。</p><p>要注意的事，这种实现方式，<code>INSTANCE</code> 常量是必须要加上 <code>volatile</code> 关键字的，不然还是不能保证完全的线程安全，不加 <code>volatile</code>  可能会因为 JVM 指令重排而出现问题。具体原因在下一个章节详细说明。</p><h2 id="5-进阶"><a href="#5-进阶" class="headerlink" title="5. 进阶"></a>5. 进阶</h2><h3 id="5-1-volatile-关键字解析"><a href="#5-1-volatile-关键字解析" class="headerlink" title="5.1 volatile 关键字解析"></a>5.1 volatile 关键字解析</h3><p>首先来看一下 <strong>双重校验锁</strong> 会出现什么问题。我们先要了解对象的创建过程(new 关键字)，它简单的分为三个阶段:</p><p>1.分配对象内存空间。 2.初始化对象。 3.设置对象指向内存空间。</p><p>但是实际上第二步和第三步的顺序是可以互换的，在 JVM 的优化中存在一种指令重排序的机制，可以加快 JVM 的运行速度。</p><p>那么现在我们来做个实验，运行 <code>DoubleCheckLockingSingleton.main()</code> 方法后，在 <code>target</code> 目录下找到它的 <code>DoubleCheckLockingSingleton.class</code> 文件，然后使用 <code>javap -c DoubleCheckLockingSingleton.class &gt; DCL.txt</code> 来生成字节码文件。</p><p>打开文件可以在 <code>public static com.junmoyu.singleton.DoubleCheckLockingSingleton getInstance();</code> 下方看到 <code>getInstance()</code> 方法整个字节码执行过程。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span>           <span class="hljs-meta">#9      <span class="hljs-comment">// class com/junmoyu/singleton/ThreadSafeLazyLoadedSingleton</span></span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-number">21</span>: invokespecial <span class="hljs-meta">#10     <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="hljs-number">24</span>: putstatic     <span class="hljs-meta">#5      <span class="hljs-comment">// Field INSTANCE:Lcom/junmoyu/singleton/ThreadSafeLazyLoadedSingleton;</span></span><br></code></pre></td></tr></table></figure><p>上面四个步骤是节选了 <code>new DoubleCheckLockingSingleton()</code> 的执行过程。</p><ul><li>17 : new 指令在 java 堆上为 ThreadSafeLazyLoadedSingleton 对象分配内存空间，并将地址压入操作栈顶</li><li>20 : dup 指令为复制操作栈顶值，并将其压入栈顶，这时操作栈上有连续相同的两个对象地址</li><li>21 : 调用实例的构造函数，实例化对象，这一步会弹出一个之前入栈的对象地址</li><li>24 : 将对象地址赋值给常量 <code>INSTANCE</code></li></ul><p>由上可看到创建一个对象并非原子操作，而是分成了多个步骤，如果 JVM 重排序后，21 在 24 之后，此时分配完了对象的内存空间，且把内存地址复制给了常量 <code>INSTANCE</code>，那么此时 <code>INSTANCE != null</code>。</p><p>如果此时有另外一个线程调用 <code>getInstance()</code> 就会直接返回 <code>INSTANCE</code> 常量，然而对象其实还没有实例化完成，返回的将是一个空的对象。执行过程如下：</p><table><thead><tr><th>执行步骤</th><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>step1</td><td>分配对象内存空间</td><td></td></tr><tr><td>step2</td><td>将对象内存地址赋值给常量 INSTANCE</td><td></td></tr><tr><td>step3</td><td></td><td>判断对象是否为 null</td></tr><tr><td>step4</td><td></td><td>对象不为 null, 返回 INSTANCE</td></tr><tr><td>step5</td><td></td><td>访问 INSTANCE 对象</td></tr><tr><td>step6</td><td>初始化对象</td><td></td></tr></tbody></table><p>如果出现上表所示的情况，那么线程2将获取到一个空的对象，访问对象的参数或方法都将出现异常。所以需要加上 <strong>volatile</strong> 关键字。<strong>volatile</strong> 关键字有两个作用：</p><ol><li>保证对象的可见性。</li><li>防止指令重排序。</li></ol><blockquote><p>对象的创建可能发生指令的重排序，使用 volatile 可以禁止指令的重排序，保证多线程环境下的线程安全。</p></blockquote><p>那么至此，相信你对 <strong>双重校验锁</strong> 的单例为什么要使用 volatile 关键字的原因已经了解清楚了。</p><p>但是你可能还有一个疑惑，为什么之前在 <code>public static synchronized LazyLoadedSingleton getInstance()</code> 方法上加锁时并未提到需要加 volatile 关键字呢。</p><p>其实原因也很简单，因为这里锁的是方法，即使出现了指令重排，其他的线程在调用 <code>getInstance()</code> 时也无法获取实例，因为方法被加锁了，自然也不会出现问题，只是方法加锁性能损耗较大而已。</p><p>在 <code>Spring</code> 源码中也可以看到类似的例子，如 <code>org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver</code> 类中的 <code>private volatile Map&lt;String, Object&gt; handlerMappings;</code> 参数与 <code>private Map&lt;String, Object&gt; getHandlerMappings()</code> 方法就是使用 <strong>双重校验锁</strong> 的方式编写的。感兴趣的可以自行查看。</p><h3 id="5-2-反射会导致单例失效嘛？"><a href="#5-2-反射会导致单例失效嘛？" class="headerlink" title="5.2 反射会导致单例失效嘛？"></a>5.2 反射会导致单例失效嘛？</h3><p>至于反射会不会导致单例失效，我们不妨测试一下。在各个单例类的 <code>main()</code> 方法中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerlySingleton</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 反射测试</span><br>        <span class="hljs-comment">// 通过反射的方式直接调用私有构造器（通过在构造器里抛出异常可以解决此问题）</span><br>        Class&lt;EagerlySingleton&gt; clazz = (Class&lt;EagerlySingleton&gt;) Class.forName(<span class="hljs-string">&quot;com.junmoyu.singleton.EagerlySingleton&quot;</span>);<br>        Constructor&lt;EagerlySingleton&gt; constructor = clazz.getDeclaredConstructor(<span class="hljs-keyword">null</span>);<br><br>        EagerlySingleton singleton1 = constructor.newInstance();<br>        EagerlySingleton singleton2 = constructor.newInstance();<br><br>        System.out.println(<span class="hljs-string">&quot;反射测试：singleton1 hashCode：&quot;</span> + <span class="hljs-string">&quot;@&quot;</span> + singleton1.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;反射测试：singleton2 hashCode：&quot;</span> + <span class="hljs-string">&quot;@&quot;</span> + singleton2.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后查看日志可以发现，两个对象的 hashCode 是不一样的。除了枚举实现的单例模式外，其他拥有私有构造器的实现方式均可通过反射来创建多个实例。</p><p>要解决的话也很简单。饿汉式单例模式的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式单例模式 - 线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerlySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EagerlySingleton INSTANCE = <span class="hljs-keyword">new</span> EagerlySingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EagerlySingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 防止通过反射进行实例化从而破坏单例</span><br>        <span class="hljs-comment">// 最好放在开头，如不需要删除即可</span><br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Already initialized.&quot;</span>);<br>        &#125;<br>        System.out.println(getClass().getCanonicalName() + <span class="hljs-string">&quot; 被实例化，hashCode：&quot;</span> + hashCode());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerlySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他方式实现的单例和饿汉式单例一样，在此就不一一说明了。再次运行 <code>main()</code> 方法测试反射。可以打印日志如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">...<br><span class="hljs-selector-tag">Caused</span> <span class="hljs-selector-tag">by</span>: <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalStateException</span>: <span class="hljs-selector-tag">Already</span> <span class="hljs-selector-tag">initialized</span>.<br><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.StaticInnerClassSingleton</span>.&lt;<span class="hljs-selector-tag">init</span>&gt;(<span class="hljs-selector-tag">StaticInnerClassSingleton</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:27)</span><br>... 5 <span class="hljs-selector-tag">more</span><br></code></pre></td></tr></table></figure><p>可以看到想要通过反射实例化的时候，直接抛出了异常，并没有进行实例化的操作。</p><h3 id="5-3-反序列化问题"><a href="#5-3-反序列化问题" class="headerlink" title="5.3 反序列化问题"></a>5.3 反序列化问题</h3><p>除了反射以外，使用反序列化也同样会破坏单例。</p><p>还是以 <code>EagerlySingleton</code> 类来测试，先让其实现 <code>Serializable</code> 接口，然后在 <code>main()</code> 方法里面添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.junmoyu.singleton.serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerlySingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EagerlySingleton INSTANCE = <span class="hljs-keyword">new</span> EagerlySingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EagerlySingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerlySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 反序列化测试</span><br>        <span class="hljs-comment">// 将对象写入文件</span><br>        ObjectOutputStream os = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;tempFile&quot;</span>));<br>        EagerlySingleton osInstance = EagerlySingleton.getInstance();<br>        System.out.println(<span class="hljs-string">&quot;反序列化测试：osInstance hashCode：&quot;</span> + <span class="hljs-string">&quot;@&quot;</span> + osInstance.hashCode());<br>        os.writeObject(osInstance);<br><br>        <span class="hljs-comment">// 从文件中读取对象</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;tempFile&quot;</span>);<br>        ObjectInputStream is = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));<br>        EagerlySingleton isInstance = (EagerlySingleton) is.readObject();<br>        <span class="hljs-comment">// 查看 hashCode 是否相同</span><br>        System.out.println(<span class="hljs-string">&quot;反序列化测试：isInstance hashCode：&quot;</span> + <span class="hljs-string">&quot;@&quot;</span> + isInstance.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main()</code>方法测试一下，查看日志结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.serializable</span><span class="hljs-selector-class">.DoubleCheckLockingSingleton</span> 被实例化，<span class="hljs-selector-tag">hashCode</span>：460141958<br>反序列化测试：<span class="hljs-selector-tag">osInstance</span> <span class="hljs-selector-tag">hashCode</span>：<span class="hljs-keyword">@460141958</span><br>反序列化测试：isInstance hashCode：@<span class="hljs-number">81628611</span><br></code></pre></td></tr></table></figure><p>可以看到序列化对象和反序列化之后的对象 hashCode 并不相同。</p><p>想要解决反序列化的问题，只需要添加一个 <code>readResolve()</code> 方法即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerlySingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果有序列化需求，需要添加此方法以防止反序列化时重新创建新实例</span><br><span class="hljs-comment">     * 如无序列化需求可不加，同时去除 implements Serializable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行 <code>main()</code>方法测试一下，查看日志结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.junmoyu</span><span class="hljs-selector-class">.singleton</span><span class="hljs-selector-class">.serializable</span><span class="hljs-selector-class">.EagerlySingleton</span> 被实例化，<span class="hljs-selector-tag">hashCode</span>：460141958<br>反序列化测试：<span class="hljs-selector-tag">osInstance</span> <span class="hljs-selector-tag">hashCode</span>：<span class="hljs-keyword">@460141958</span><br>反序列化测试：isInstance hashCode：@<span class="hljs-number">460141958</span><br></code></pre></td></tr></table></figure><p>可以发现两个对象的 hashCode 已经是一致的了。</p><blockquote><p>枚举类的单例，是天然可以绝对防止多实例化的，反射及反序列化都无效。</p></blockquote><p>至于为什么加了 <code>readResolve()</code>就可以防止反序列化重新创建实例，就要深入源码解析了。这里就不详细叙述了，简单说一下。</p><p>反序列化的对象获取是通过方法 ObjectInputStream#readObject()，进入源码，可以看到 <code>Object obj = readObject0(false);</code> 这行代码最终返回的对象。继续进入源码，在 ObjectInputStream#readObject0()方法中可以看到一个 switch 选择器，找到下面这块重点代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ObjectInput</span>, <span class="hljs-title">ObjectStreamConstants</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readObject0</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span> (tc) &#123;<br>                <span class="hljs-comment">// ...</span><br>                <span class="hljs-keyword">case</span> TC_ENUM:<br>                    <span class="hljs-comment">// 单例中为什么枚举最安全，感兴趣的同学可以看一下这里的实现</span><br>                    <span class="hljs-keyword">return</span> checkResolve(readEnum(unshared));<br>                <span class="hljs-keyword">case</span> TC_OBJECT:<br>                    <span class="hljs-comment">// 这里的 readOrdinaryObject 就是读取对象的方法了</span><br>                    <span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        &#125;<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure><p>进入 <code>readOrdinaryObject()</code> 方法，最终的答案都在这里了。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6c7edce20db04cf587705a5f3a731994~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这个方法里面，最重要的两块代码，我圈出来了。第一块其实就是我们在没有加入 <code>readResolve()</code> 方法时，它通过反射创建了一个新的实例，在第二块代码的判断里 <code>desc.hasReadResolveMethod() == false</code> 将不会执行 if 里面的语句。它返回就是之前创建的新实例了。</p><p>if 中的代码其实就是调用 <code>readResolve()</code> 方法，然后将获取到的对象替换掉第一块代码里面创建的新实例，而<code>readResolve()</code> 方法不正是返回了单例的实例嘛。所以如果加了这个方法，就会执行 if 里面的代码，用单例的实例去替换掉反射创建的实例。</p><p>所以现在你知道为什么加入 <code>readResolve()</code> 方法就可以防止反序列化了吧。</p><h3 id="5-4-你以为这就结束了？"><a href="#5-4-你以为这就结束了？" class="headerlink" title="5.4 你以为这就结束了？"></a>5.4 你以为这就结束了？</h3><p>虽然不想再啰嗦了（对不住了！），但是还有一个<strong>重点</strong>！</p><p>如果有两个类加载器（class loader）的存在，那是两个类加载器可能各自创建自己的单例模式。</p><p>因为每个类加载器都定义了一个命名空间，如果有两个或以上的类加载器，不同的类加载器可能会加载同一个类，那么从整个程序来看，同一个类就被加载多次了。也就是会有多个单例的实例并存。</p><p>所以，如果你的程序有多个类加载器又同时使用了单例模式，那么就要小心了。有一个解决方法就是<strong>你可以自行指定类加载器，并指定同一个类加载器。</strong></p><h2 id="6-拓展"><a href="#6-拓展" class="headerlink" title="6. 拓展"></a>6. 拓展</h2><p>另外其实还有一种稍微特殊一点的 “单例” 模式，可以称之为 <strong>线程单例</strong>，那就是使用 ThreadLocal 使每一个线程拥有自己的单例。</p><p>比如 mybatis 3.5.x 版本中的 <code>org.apache.ibatis.executor.ErrorContext</code> 类，就是使用了此种方式实现的，感兴趣的可以自行研究，在此不再赘述。简单贴下代码感受下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.ibatis.executor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorContext</span> </span>&#123;<br>    <span class="hljs-comment">// 这里使用了函数式接口 Supplier&lt;T&gt;，更优雅的初始化 ThreadLocal</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = ThreadLocal.withInitial(ErrorContext::<span class="hljs-keyword">new</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ErrorContext</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ErrorContext <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LOCAL.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>至此，我们讨论了六种单例模式的实现方式。</p><ol><li>枚举实现 - 线程安全</li><li>饿汉式单例 - 线程安全</li><li>静态内部类实现 - 线程安全、延迟加载</li><li>普通懒汉式 - 线程不安全、延迟加载</li><li>方法加锁懒汉式 - 线程安全、延迟加载，但性能差</li><li>双重校验锁懒汉式 - 线程安全、延迟加载</li></ol><p>且除了枚举实现的单例外，其他均有反射及序列化会破坏单例的情况。那么综合来看的话，枚举实现的单例是最优的方案，也是 <code>Effective Java</code> 书中推荐的方案。然而在 Java 及一些框架的源码中使用枚举单例的例子很少，不知道是为什么，可能是我看的源码还不够多吧。</p><p>因为枚举实现的单例模式其实也属于饿汉式，所以如果在实例化时需要执行耗时操作的话，则不建议使用。</p><p>那么除此之外较好的单例实现还有<strong>静态内部类</strong>的实现，以及<strong>双重校验锁</strong>的实现，可以根据自己的业务需要灵活选择。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql优化groupBy</title>
    <link href="/blog/2021/05/03/mysql%E4%BC%98%E5%8C%96groupBy/"/>
    <url>/blog/2021/05/03/mysql%E4%BC%98%E5%8C%96groupBy/</url>
    
    <content type="html"><![CDATA[<p>当我们交友平台在线上运行一段时间后，为了给平台用户在搜索好友时，在搜索结果中推荐并置顶他感兴趣的好友，这时候，我们会对用户的行为做数据分析，根据分析结果给他推荐其感兴趣的好友。</p><blockquote><p>这里，我采用最简单的SQL分析法：对用户过去查看好友的性别和年龄进行统计，按照年龄进行分组得到统计结果。依据该结果，给用户推荐计数最高的某个性别及年龄的好友。</p></blockquote><p>那么，假设我们现在有一张用户浏览好友记录的明细表<code>t_user_view</code>，该表的表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user_view` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;自增id&#x27;</span>,<br>  `user_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>  `viewed_user_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;被查看用户id&#x27;</span>,<br>  `viewed_user_sex` tinyint(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;被查看用户性别&#x27;</span>,<br>  `viewed_user_age` <span class="hljs-type">int</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;被查看用户年龄&#x27;</span>,<br>  `create_time` datetime(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">3</span>),<br>  `update_time` datetime(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">3</span>),<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `idx_user_viewed_user` (`user_id`,`viewed_user_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br></code></pre></td></tr></table></figure><p>为了方便使用SQL统计，见上面的表结构，我冗余了被查看用户的性别和年龄字段。</p><p>我们再来看看这张表里的记录：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/95ce656e6ade41e992f24f54974e209c~tplv-k3u1fbpfcp-watermark.image" alt="image-20210321202431004.png"></p><p>现在结合上面的表结构和表记录，我以<code>user_id=1</code>的用户为例，分组统计该用户查看的年龄在18 ~ 22之间的女性用户的数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> viewed_user_age <span class="hljs-keyword">as</span> age, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <span class="hljs-keyword">FROM</span> t_user_view <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> viewed_user_age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">22</span> <span class="hljs-keyword">AND</span> viewed_user_sex <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> viewed_user_age<br><br></code></pre></td></tr></table></figure><p>得到统计结果如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/a99d2932bcdb464a842f8bcfd98e0682~tplv-k3u1fbpfcp-watermark.image" alt="image-20210321172324495.png"></p><p>可见：</p><ul><li>该用户查看年龄为18的女性用户数为2</li><li>该用户查看年龄为19的女性用户数为1</li><li>该用户查看年龄为20的女性用户数为3</li></ul><p>所以，<code>user_id=1</code>的用户对年龄为20的女性用户更感兴趣，可以更多推荐20岁的女性用户给他。</p><blockquote><p>如果此时，<code>t_user_view</code>这张表的记录数达到千万规模，想必这条SQL的查询效率会直线下降，为什么呢？有什么办法优化呢？</p></blockquote><p>想要知道原因，不得不先看一下这条SQL执行的过程是怎样的？</p><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><p>我们先用<code>explain</code>看一下这条SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> viewed_user_age <span class="hljs-keyword">as</span> age, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> num <span class="hljs-keyword">FROM</span> t_user_view <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> viewed_user_age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">22</span> <span class="hljs-keyword">AND</span> viewed_user_sex <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> viewed_user_age<br><br></code></pre></td></tr></table></figure><p>执行完上面的<code>explain</code>语句，我们得到如下结果：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6488bd6356e240f9b47040261a6798c4~tplv-k3u1fbpfcp-watermark.image" alt="image-20210321200747868.png"></p><p>在<code>Extra</code>这一列中出现了三个<code>Using</code>，这3个<code>Using</code>代表了《导读》中的<code>groupBy</code>语句分别经历了3个执行阶段：</p><ol><li>Using where：通过搜索可能的<code>idx_user_viewed_user</code>索引树定位到满足部分条件的<code>viewed_user_id</code>，然后，回表继续查找满足其他条件的记录</li><li>Using temporary：使用临时表暂存待<code>groupBy</code>分组及统计字段信息</li><li>Using filesort：使用<code>sort_buffer</code>对分组字段进行排序</li></ol><p>这3个阶段中出现了一个名词：<code>临时表</code>。这个名词我在《MySQL分表时机：100w？300w？500w？都对也都不对！》一文中有讲到，这是MySQL连接线程可以独立访问和处理的内存区域，那么，这个临时表长什么样呢？</p><blockquote><p>下面我就先讲讲这张MySQL的临时表，然后，结合上面提到的3个阶段，详细讲解《导读》中SQL的执行过程。</p></blockquote><h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><p>我们还是先看看《导读》中的这条包含<code>groupBy</code>语句的SQL，其中包含一个分组字段<code>viewed_user_age</code>和一个统计字段<code>count(*)</code>，这两个字段是这条SQL中统计所需的部分，如果我们要做这样一个统计和分组，并把结果固化下来，肯定是需要一个内存或磁盘区域落下第一次统计的结果，然后，以这个结果做下一次的统计，因此，像这种存储中间结果，并以此结果做进一步处理的区域，MySQL叫它<code>临时表</code>。</p><p>刚刚提到既可以将中间结果落在内存，也可以将这个结果落在磁盘，因此，在MySQL中就出现了两种临时表：<code>内存临时表</code>和<code>磁盘临时表</code>。</p><h4 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h4><p>什么是内存临时表？在早期数据量不是很大的时候，以存储分组及统计字段为例，那么，基本上内存就可以完全存放下分组及统计字段对应的所有值，这个存放大小由<code>tmp_table_size</code>参数决定。这时候，这个存放值的内存区域，MySQL就叫它内存临时表。</p><p>此时，或许你已经觉得MySQL将中间结果存放在内存临时表，性能已经有了保障，但是，在《MySQL分表时机：100w？300w？500w？都对也都不对！》中，我提到过内存频繁的存取会产生碎片，为此，MySQL设计了一套新的内存分配和释放机制，可以减少甚至避免临时表内存碎片，提升内存临时表的利用率。</p><blockquote><p>此时，你可能会想，在《为什么我调大了sort_buffer_size，并发量一大，查询排序慢成狗？》一文中，我讲了用户态的内存分配器：<code>ptmalloc</code>和<code>tcmalloc</code>，无论是哪个分配器，它的作用就是避免用户进程频繁向Linux内核申请内存空间，造成<code>CPU</code>在用户态和内核态之间频繁切换，从而影响内存存取的效率。用它们就可以解决内存利用率的问题，为什么MySQL还要自己搞一套？</p></blockquote><p>或许MySQL的作者觉得无论哪个内存分配器，它的实现都过于复杂，这些复杂性会影响MySQL对于内存处理的性能，因此，MySQL自身又实现了一套内存分配机制：<code>MEM_ROOT</code>。它的内存处理机制相对比较简单，内存临时表的分配就是采用这样一种方式。</p><p>下面，我就以《导读》中的SQL为例，详细讲解一下分组统计是如何使用<code>MEM_ROOT</code>内存分配和释放机制的？</p><h5 id="MEM-ROOT"><a href="#MEM-ROOT" class="headerlink" title="MEM_ROOT"></a>MEM_ROOT</h5><p>我们先看看<code>MEM_ROOT</code>的结构，<code>MEM_ROOT</code>设计比较简单，主要包含这几部分，如下图：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2a4a62d15071443a9ecfdd816a410da7~tplv-k3u1fbpfcp-watermark.image" alt="image-20210322205718291.png"></p><p>free：一个单向链表，链表中每一个单元叫<code>block</code>，<code>block</code>中存放的是空闲的内存区，每个<code>block</code>包含3个元素：</p><ul><li>left：<code>block</code>中剩余的内存大小</li><li>size：<code>block</code>对应内存的大小</li><li>next：指向下一个<code>block</code>的指针</li></ul><p>如上图，<code>free</code>所在的行就是一个<code>free</code>链表，链表中每个箭头相连的部分就是<code>block</code>，<code>block</code>中有<code>left</code>和            <code>size</code>，每个<code>block</code>之间的箭头就是<code>next</code>指针</p><p>used：一个单向链表，链表中每一个单元叫<code>block</code>，<code>block</code>中存放已使用的内存区，同样，每个<code>block</code>包含上面3            个元素</p><p>min_malloc：控制一个 <code>block</code> 剩余空间还有多少的时候从<code>free</code>链表移除，加入到<code>used</code>链表中</p><p>block_size：<code>block</code>对应内存的大小</p><p>block_num：<code>MEM_ROOT</code> 管理的<code>block</code>数量</p><p>first_block_usage：<code>free</code>链表中第一个<code>block</code>不满足申请空间大小的次数</p><p>pre_alloc：当释放整个<code>MEM_ROOT</code>的时候可以通过参数控制，选择保留<code>pre_alloc</code>指向的<code>block</code></p><p>下面我就以《导读》中的分组统计SQL为例，看一下<code>MEM_ROOT</code>是如何分配内存的？</p><h6 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h6><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ccf3e23603a54fb1a3b820835ead6bd7~tplv-k3u1fbpfcp-watermark.image" alt="image-20210326002410273.png"></p><ol><li><p>初始化<code>MEM_ROOT</code>，见上图：</p><p><code>min_malloc = 32</code></p><p><code>block_num = 4</code></p><p><code>first_block_usage = 0</code></p><p><code>pre_alloc = 0</code></p><p><code>block_size = 1000</code></p><p><code>err_handler = 0</code></p><p><code>free = 0</code></p><p><code>used = 0</code></p></li><li><p>申请内存，见上图：</p><p>由于初始化<code>MEM_ROOT</code>时，<code>free = 0</code>，说明<code>free</code>链表不存在，故向Linux内核申请4个大小为<code>1000/4=250</code>的<code>block</code>，构造一个<code>free</code>链表，如上图，链表中包含4个<code>block</code> ，结合前面<code>free</code>链表结构的说明，每个<code>block</code>中<code>size</code>为250，<code>left</code>也为250</p></li><li><p>分配内存，见上图：</p><p>(1) 遍历<code>free</code>链表，从<code>free</code>链表头部取出第一个<code>block</code>，如上图向下的箭头</p><p>(2) 从取出的<code>block</code>中划分<code>220</code>大小的内存区，如上图向右的箭头上面<code>-220</code>，<code>block</code>中的<code>left</code>从<code>250</code>变成<code>30</code></p><p>(3) 将划分的<code>220</code>大小的内存区分配给SQL中的<code>groupby</code>字段<code>viewed_user_age</code>和统计字段<code>count(*)</code>，用于后面的统计分组数据收集到该内存区</p><p>(4) 由于第(2)步中，分配后的<code>block</code>中的<code>left</code>变成<code>30</code>，<code>30 &lt; 32</code>，即小于第(1)步中初始化的<code>min_malloc</code>，所以，结合上面<code>min_malloc</code>的含义的讲解，该<code>block</code>将插入<code>used</code>链表尾部，如上图底部，由于<code>used</code>链表在第(1)步初始化时为0，所以，该<code>block</code>插入<code>used</code>链表的尾部，即插入头部</p></li></ol><h6 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h6><p>下面还是以《导读》中的分组统计为例，我们再来看一下<code>MEM_ROOT</code>是如何释放内存的？</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b6569d6768e14a68a647161c0e6bea2c~tplv-k3u1fbpfcp-watermark.image" alt="image-20210323233158459.png"></p><p>如上图，<code>MEM_ROOT</code>释放内存的过程如下：</p><ol><li>遍历<code>used</code>链表中，找到需要释放的<code>block</code>，如上图，<code>block(30,250)</code>为之前已分配给分组统计用的<code>block</code></li><li>将<code>block(30,250)</code>中的<code>left + 220</code>，即<code>30 + 220 = 250</code>，释放该<code>block</code>已使用的<code>220</code>大小的内存区，得到释放后的<code>block(250,250)</code></li><li>将<code>block(250,250)</code>插入<code>free</code>链表尾部，如上图曲线箭头部分</li></ol><p>通过<code>MEM_ROOT</code>内存分配和释放的讲解，我们发现<code>MEM_ROOT</code>的内存管理方式是在每个<code>Block</code>上连续分配，内部碎片基本在每个<code>Block</code>的尾部，由<code>min_malloc</code>成员变量控制，但是<code>min_malloc</code>的值是在代码中写死的，有点不够灵活。所以，对一个<code>block</code>来说，当<code>left</code>小于<code>min_malloc</code>，从其申请的内存越大，那么<code>block</code>中的<code>left</code>值越小，那么，该<code>block</code>的内存利用率越高，碎片越少，反之，碎片越多。这个写死是MySQL的内存分配的一个缺陷。</p><h4 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h4><p>当分组及统计字段对应的所有值大小超过<code>tmp_table_size</code>决定的值，那么，MySQL将使用磁盘来存储这些值。这个存放值的磁盘区域，MySQL叫它磁盘临时表。</p><p>我们都知道磁盘存取的性能一定比内存存取的性能差很多，因为会产生磁盘IO，所以，一旦分组及统计字段不得不写入磁盘，那性能相对是很差的，所以，我们尽量调大参数<code>tmp_table_size</code>，使得组及统计字段可以在内存临时表中处理。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>无论是使用内存临时表，还是磁盘临时表，临时表对组及统计字段的处理的方式都是一样的。《导读》中我提到想要优化《导读》中的那条SQL，就需要知道SQL执行的原理，所以，下面我就结合上面讲解的临时表的概念，详细讲讲这条SQL的执行过程，见下图：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/3598cf4798b84fa0ad04348bc69db486~tplv-k3u1fbpfcp-watermark.image" alt="image-20210326002155314.png"></p><ol><li><p>创建临时表<code>temporary</code>，表里有两个字段<code>viewed_user_age</code>和<code>count(*)</code>，主键是<code>viewed_user_age</code>，如上图，倒数第二个框<code>temporary</code>表示临时表，框中包含两个字段<code>viewed_user_age</code>和<code>count(*)</code>，框内就是这两个字段对应的值，其中<code>viewed_user_age</code>就是这张临时表的主键</p></li><li><p>扫描表辅助索引树<code>idx_user_viewed_user</code>，依次取出叶子节点上的<code>id</code>值，即从索引树叶子节点中取到表的主键id。如上图中的<code>idx_user_viewed_user</code>框就是索引树，框右侧的箭头表示取到表的主键id</p></li><li><p>根据主键id到聚簇索引<code>cluster_index</code>的叶子节点中查找记录，即扫描<code>cluster_index</code>叶子节点：</p><p>(1) 得到一条记录，然后取到记录中的<code>viewed_user_age</code>字段值。如上图，<code>cluster_index</code>框，框中最右边的一列就是<code>viewed_user_age</code>字段的值</p><p>(2) 如果临时表中没有主键为<code>viewed_user_age</code>的行，就插入一条记录 (<code>viewed_user_age</code>, 1)。如上图的<code>temporary</code>框，其左侧箭头表示将<code>cluster_index</code>框中的<code>viewed_user_age</code>字段值写入<code>temporary</code>临时表</p><p>(3) 如果临时表中有主键为<code>viewed_user_age</code>的行，就将<code>viewed_user_age</code>这一行的<code>count(*)</code>值加 1。如上图的<code>temporary</code>框</p></li><li><p>遍历完成后，再根据字段<code>viewed_user_age</code>在<code>sort_buffer</code>中做排序，得到结果集返回给客户端。如上图中的最右边的箭头，表示将<code>temporary</code>框中的<code>viewed_user_age</code>和<code>count(*)</code>的值写入<code>sort_buffer</code>，然后，在<code>sort_buffer</code>中按<code>viewed_user_age</code>字段进行排序</p></li></ol><blockquote><p>通过《导读》中的SQL的执行过程的讲解，我们发现该过程经历了4个部分：<code>idx_user_viewed_user</code>、<code>cluster_index</code>、<code>temporary</code>和<code>sort_buffer</code>，对比上面<code>explain</code>的结果，其中前2个就对应结果中的<code>Using where</code>，<code>temporary</code>对应的是<code>Using temporary</code>，<code>sort_buffer</code>对应的是<code>Using filesort</code>。</p></blockquote><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>此时，我们有什么办法优化这条SQL呢？</p><blockquote><p>既然这条SQL执行需要经历4个部分，那么，我们可不可以去掉最后两部分呢，即去掉<code>temporary</code>和<code>sort_buffer</code>？</p></blockquote><p>答案是可以的，我们只要给SQL中的表<code>t_user_view</code>添加如下索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `t_user_view` <span class="hljs-keyword">ADD</span> INDEX `idx_user_age_sex` (`user_id`, `viewed_user_age`, `viewed_user_sex`);<br><br></code></pre></td></tr></table></figure><p>你可以自己尝试一下哦！用<code>explain</code>康康有什么改变！</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章围绕《导读》中的分组统计SQL，通过<code>explain</code>分析SQL的执行阶段，结合临时表的结构，进一步剖析了SQL的详细执行过程，最后，引出优化方案：<strong>新增索引，避免临时表对分组字段的统计，及<code>sort_buffer</code>对分组和统计字段排序</strong>。</p><p>当然，如果实在无法避免使用临时表，那么，<strong>尽量调大<code>tmp_table_size</code>，避免使用磁盘临时表统计分组字段。</strong></p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>为什么新增了索引<code>idx_user_age_sex</code>可以避免临时表对分组字段的统计，及<code>sort_buffer</code>对分组和统计字段排序？</p><p>提示：结合索引查找的原理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在项目中实现多数据源切换</title>
    <link href="/blog/2021/04/24/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/"/>
    <url>/blog/2021/04/24/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="一）场景"><a href="#一）场景" class="headerlink" title="(一）场景"></a>(一）场景</h1><p>在实际的应用场景中，我们经常会遇到一个系统要调用多个数据源的情况。可能是同一个mysql的不同库，也有可能是从不同的mysql中调用数据进行使用。这里提供一种十分高效的多数据源切换框架—<strong>dynamicdatasource</strong></p><h1 id="（二）介绍一下这个框架"><a href="#（二）介绍一下这个框架" class="headerlink" title="（二）介绍一下这个框架"></a>（二）介绍一下这个框架</h1><p>dynamicdatasource其实是Mybatis-plus生态圈中的其中一个框架，来自码云知名开源项目 Mybatis-Plus 运营组织，这个组织还有个奇怪的名字叫做苞米豆。这是个挺有传奇色彩的组织，大家有兴趣可以了解一下。</p><h1 id="（三）开始使用"><a href="#（三）开始使用" class="headerlink" title="（三）开始使用"></a>（三）开始使用</h1><h2 id="3-1-搭建项目"><a href="#3-1-搭建项目" class="headerlink" title="3.1 搭建项目"></a>3.1 搭建项目</h2><p>这一步就不需要多提了，搭建一个Springboot项目即可，引入基础的web依赖。</p><h2 id="3-2-引入依赖"><a href="#3-2-引入依赖" class="headerlink" title="3.2 引入依赖"></a>3.2 引入依赖</h2><p>动态数据源的核心依赖是下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;<br>    &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;<br>    &lt;version&gt;3.1.0&lt;/version&gt;<br>&lt;/dependency&gt;<br><br></code></pre></td></tr></table></figure><p>我们自己再引入JDBC三件套</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>    &lt;scope&gt;runtime&lt;/scope&gt;<br>&lt;/dependency&gt;<br>&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;<br>    &lt;version&gt;2.1.3&lt;/version&gt;<br>&lt;/dependency&gt;<br><br></code></pre></td></tr></table></figure><h2 id="3-3-配置文件编写"><a href="#3-3-配置文件编写" class="headerlink" title="3.3 配置文件编写"></a>3.3 配置文件编写</h2><p>在以前使用Mybatis的时候，我们只能配置一个数据源，现在可以通过动态数据源的方式配置多个数据源。</p><p>其中primary表示默认的数据源，strict表示设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:<br>  datasource:<br>    dynamic:<br>      primary: master<br>      strict: <span class="hljs-keyword">false</span><br>      datasource:<br>        master:<br>          url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/student</span><br>          username: root<br>          password: <span class="hljs-number">123456</span><br>          driver-class-name: com.mysql.jdbc.Driver<br>        slave:<br>          url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/books</span><br>          username: root<br>          password: <span class="hljs-number">123456</span><br>          driver-class-name: com.mysql.jdbc.Driver<br><br></code></pre></td></tr></table></figure><h2 id="3-4-代码中切换数据源"><a href="#3-4-代码中切换数据源" class="headerlink" title="3.4 代码中切换数据源"></a>3.4 代码中切换数据源</h2><p>通过一个注解就可以轻松切换数据源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@DS(&quot;master&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> BookMapper bookMapper;<br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> studentMapper.getNameById(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@DS(&quot;slave&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBookName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> bookMapper.getBookNameById(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>首先，我们可以给一个方法设置数据源，在内部的方法中也可以通过DS注解切换数据源，不用担心嵌套的问题。</p><h1 id="（四）完整项目"><a href="#（四）完整项目" class="headerlink" title="（四）完整项目"></a>（四）完整项目</h1><p>首先我建了两个库，一个叫student、另一个叫books</p><p>student库中有个student表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `grade` <span class="hljs-type">int</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br></code></pre></td></tr></table></figure><p>books库中有个book表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `book` (<br>  `ID` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `BOOKISBN` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `BOOKNAME` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `AUTHOR` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `PRICE` <span class="hljs-keyword">double</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `TYPEID` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `PUBLISHER` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`ID`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB  <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br></code></pre></td></tr></table></figure><p>项目结构很简单： <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/10af7580387444c48cba879449bc7475~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>首先是两个Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Select(&quot;select bookname from book where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">getBookNameById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>StudentMapper ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Select(&quot;select name from student where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">getNameById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后是一个service</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-variable">@Service</span><br><span class="hljs-variable">@DS</span>(&quot;master&quot;)<br>public class TestService &#123;<br>    <span class="hljs-variable">@Autowired</span>(required <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>)<br>    private BookMapper bookMapper;<br>    <span class="hljs-variable">@Autowired</span>(required <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>)<br>    private StudentMapper studentMapper;<br>    public String getName()&#123;<br>        <span class="hljs-keyword">return</span> studentMapper.getNameById(&quot;1&quot;);<br>    &#125;<br>    <span class="hljs-variable">@DS</span>(&quot;slave&quot;)<br>    public String getBookName()&#123;<br>        <span class="hljs-keyword">return</span> bookMapper.getBookNameById(&quot;1&quot;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后controller调用一下Service</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-variable">@RestController</span><br>public class IndexController &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    private TestService testService;<br>    <span class="hljs-variable">@GetMapping</span>(&quot;index&quot;)<br>    public String index()&#123;<br>        String studentName <span class="hljs-operator">=</span> testService.getName();<br>        String bookName <span class="hljs-operator">=</span> testService.getBookName();<br>        <span class="hljs-keyword">return</span> studentName<span class="hljs-operator">+</span>bookName;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>启动类中扫描一下Mapper</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@MapperScan</span>(&quot;com.javayz.mybatisplus.mapper&quot;)<br>public class MybatisplusApplication &#123;<br>    public static void main(String[] args) &#123;<br>        SpringApplication.run(MybatisplusApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样一个简单的项目就搭建完成了，访问一下/index，就可以发现两个数据源中的数据都被提取出来了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8中的Lambda表达式</title>
    <link href="/blog/2021/04/17/Java8%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/blog/2021/04/17/Java8%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Lambda表达式是一个可传递的代码块，可以在以后执行一次或多次；</p><p>下面贴个对比代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java8之前：旧的写法</span><br>Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;old run&quot;</span>);<br>  &#125;<br>&#125;;<br>Thread t = <span class="hljs-keyword">new</span> Thread(runnable);<br><br><span class="hljs-comment">// Java8之后：新的写法</span><br>Runnable runnable1 = ()-&gt;&#123;<br>  System.out.println(<span class="hljs-string">&quot;lambda run&quot;</span>);<br>&#125;;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(runnable1);<br><br></code></pre></td></tr></table></figure><p>可以看到，有了lambda，代码变得简洁多了</p><p>你可以把lambda当作一个语法糖</p><p>下面让我们一起来探索lambda的美好世界吧</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>下面列出本文的目录</p><ul><li>lambda的语法</li><li>为啥引入lambda</li><li>什么是函数式接口</li><li>什么是行为参数化</li><li>手写一个函数式接口</li><li>常用的函数式接口</li><li>什么是方法引用</li><li>什么是构造引用</li><li>lambda的组合操作</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-lambda的语法"><a href="#1-lambda的语法" class="headerlink" title="1. lambda的语法"></a>1. lambda的语法</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4af8cc96a8b940c78d041f470e4da014~tplv-k3u1fbpfcp-zoom-1.image" alt="lambda语法"></p><p>下面分别说下语法中的三个组成部分</p><ul><li><p>参数: </p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">( Dog dog )<br></code></pre></td></tr></table></figure><ul><li>参数类型可省略（当编译器可以自动推导时），比如<code>Comparator&lt;String&gt; comparatorTest = (a, b)-&gt;a.length()-b.length();</code>,可以推导出a,b都为String</li><li>当参数类型可省略，且只有一个参数时，括弧也可以省略（但是个人习惯保留）</li></ul></li><li><p>符号： <code>-&gt;</code></p></li><li><p>主体：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&#123; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;javalover&quot;); &#125;<br></code></pre></td></tr></table></figure><ul><li>如果是一条语句，则需要加大括号和分号<code>&#123;;&#125;</code>（比如上图所示）</li><li>如果是一个表达式，则直接写，啥也不加（比如<code>a.length()- b.length()</code>）</li></ul></li></ul><h3 id="2-为啥引入lambda"><a href="#2-为啥引入lambda" class="headerlink" title="2. 为啥引入lambda"></a>2. 为啥引入lambda</h3><p>为了简化代码</p><p>因为Java是面向对象语言，所以在lambda出现之前，我们需要先构造一个对象，然后在对象的方法中实现具体的内容，再把构造的对象传递给某个对象或方法</p><p>但是有了lambda以后，我们可以直接将代码块传递给对象或方法</p><p>现在再回头看下开头的例子</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ca93fa395a2e4015a4b202e55ce7c357~tplv-k3u1fbpfcp-zoom-1.image" alt="lambda减少了模板代码"></p><p>可以看到，用了lambda表达式后，少了很多模板代码，只剩下一个代码块（最核心的部分）</p><h3 id="3-什么是函数式接口"><a href="#3-什么是函数式接口" class="headerlink" title="3. 什么是函数式接口"></a>3. 什么是函数式接口</h3><p>就是只定义了一个抽象方法的接口</p><ul><li>正例：有多个<a href="https://mp.weixin.qq.com/s/NAO8W8YbnxWZpNEDh1xskQ">默认方法</a>，但是如果只有一个抽象方法，那它就是函数式接口，示例代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FunctionInterfaceDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">abstractFun</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;fun1&quot;</span>);    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;fun2&quot;</span>);<br>    &#125;   <br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>这里的注解@FunctionalInterface可以省略，但是建议加上，就是为了告诉编译器，这是一个函数式接口，此时如果该接口有多个抽象方法，那么编译器就会报错</p></blockquote><ul><li>反例：比如A extends B，A和B各有一个抽象方法，那么A就不是函数式接口，示例代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译器会报错，Multiple non-overriding abstract methods found in XXX</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NoFunctionInterfaceDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FunctionInterfaceDemo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">abstractFun2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>上面的父接口FunctionInterfaceDemo中已经有了一个抽象方法，此时NoFunctionInterfaceDemo又定义了一个抽象方法，结果编译器就提示了：存在多个抽象方法</p></blockquote><p>在Java8之前，其实我们已经接触过函数式接口</p><p>比如Runnable 和 Comparable</p><p>只是没有注解@FunctionalInterface。</p><blockquote><p>那这个函数式接口要怎么用呢？</p></blockquote><p>配合lambda食用，效果最佳（就是把lambda传递给函数式接口），示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;run&quot;</span>)).start();<br>复制代码<br></code></pre></td></tr></table></figure><p>其中用到的函数式接口是<code>Runnable</code></p><h3 id="4-什么是行为参数化"><a href="#4-什么是行为参数化" class="headerlink" title="4. 什么是行为参数化"></a>4. 什么是行为参数化</h3><p>就是把<strong>行为</strong>定义成<strong>参数</strong>，行为就是<strong>函数式接口</strong></p><p>类似<a href="https://mp.weixin.qq.com/s/NgqWzRbrHmO9iTBAQM-7zw">泛型</a>中的类型参数化<code>&lt;T&gt;</code>，类型参数化是把<strong>类型</strong>定义成<strong>参数</strong></p><p>行为参数化，通俗点来说：</p><ul><li>就是用<strong>函数式接口</strong>做<strong>形参</strong></li><li>然后传入接口的各种实现内容（即<strong>lambda表达式</strong>）作为<strong>实参</strong></li><li>最后在lambda内<strong>实现各种行为</strong>（好像又回到<a href="">多态</a>的那一节了？这也是为啥多态是Java的三大特性的原因之一，应用太广泛了）</li></ul><p>这样来看的话，<strong>行为参数化</strong>和设计模式中的<strong>策略模式</strong>有点像了（后面章节会分别讲常用的几种设计模式）</p><p>下面我们手写一个函数式接口来加深理解吧</p><h3 id="5-手写一个函数式接口"><a href="#5-手写一个函数式接口" class="headerlink" title="5. 手写一个函数式接口"></a>5. 手写一个函数式接口</h3><p>下面我们循序渐进，先从简单的需求开始</p><ul><li>第一步：比如我们想要<strong>读取某个文件</strong>，那可以有如下方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// Java7新增的语法，try()&#123;&#125;，可自动关闭资源，减少了代码的臃肿</span><br>    <span class="hljs-keyword">try</span>( BufferedReader bufferedReader = <br>        <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span>  FileReader(<span class="hljs-string">&quot;D:\\JavaProject\\JavaBasicDemo\\test.txt&quot;</span>)))&#123;<br>        <span class="hljs-keyword">return</span> bufferedReader.readLine();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，核心的行为动作就是 <code>return bufferedReader.readLine();</code>，表示读取第一行的数据并返回</p><p>那如果我们想要读取两行呢？三行？</p><ul><li>第二步：这时就需要用到上面的<strong>函数式接口</strong>了，下面就是我们自己编写的函数式接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FileReadInterface</span></span>&#123;<br>  <span class="hljs-comment">// 这里接受一个BufferedReader对象，返回一个String对象</span><br>    <span class="hljs-function">String <span class="hljs-title">process</span><span class="hljs-params">(BufferedReader reader)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，只有一个抽象方法<code>process() </code>，它就是用来处理第一步中的核心动作（读取文件内容）</p><p>至于想读取多少内容，那就需要我们在lambda表达式中定义了</p><ul><li>第三步：接下来我们定义多个<strong>lambda表达式</strong>，用来<strong>传递</strong>给<strong>函数式接口</strong>，其中每个lambda表达式就代表了一种不同的行为，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取一行</span><br>FileReadInterface fileReadInterface = reader -&gt; reader.readLine();<br><span class="hljs-comment">// 读取两行</span><br>FileReadInterface fileReadInterface2 = reader -&gt; reader.readLine() + reader.readLine();<br><br><br></code></pre></td></tr></table></figure><ul><li>第四步：我们需要修改第一步的<code>processFile()</code>，让其接受一个函数式接口，并调用其中的抽象方法，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数为第二步我们自己手写的函数式接口</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processFile</span><span class="hljs-params">(FileReadInterface fileReadInterface)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span>( BufferedReader bufferedReader =<br>                 <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;./test.txt&quot;</span>)))&#123;<br><span class="hljs-comment">// 这里我们不再自己定义行为，而是交给函数式接口的抽象方法来处理，然后通过lambda表达式的传入来实现多个行为</span><br>          <span class="hljs-keyword">return</span> fileReadInterface.process(bufferedReader);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><ul><li>第五步：拼接后，完整代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileReaderDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">// 第三步： </span><br>      <span class="hljs-comment">// lambda表达式1 传给 函数式接口：只读取一行</span><br>      FileReadInterface fileReadInterface = reader -&gt; reader.readLine();<br><span class="hljs-comment">// lambda表达式2 传给 函数式接口：只读取两行</span><br>      FileReadInterface fileReadInterface2 = reader -&gt; reader.readLine() + reader.readLine();<br>      <span class="hljs-comment">// 最后一步： 不同的函数式接口的实现，表现出不同的行为</span><br>        String str1 = processFile(fileReadInterface);<br>        String str2 = processFile(fileReadInterface2);<br>        System.out.println(str1);<br>        System.out.println(str2);<br>    &#125;<br>  <span class="hljs-comment">// 第四步： 读取文件方法，接受函数式接口作为参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processFile</span><span class="hljs-params">(FileReadInterface fileReadInterface)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span>( BufferedReader bufferedReader =<br>                 <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;./test.txt&quot;</span>)))&#123;<br><span class="hljs-comment">// 调用函数式接口中的抽象方法来处理数据</span><br>          <span class="hljs-keyword">return</span> fileReadInterface.process(bufferedReader);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 第一步：</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span>( BufferedReader bufferedReader =<br>                 <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;./test.txt&quot;</span>)))&#123;<br>          <span class="hljs-keyword">return</span> bufferReader.readLine();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-comment">// 第二步： 我们手写的函数式接口</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FileReadInterface</span></span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">process</span><span class="hljs-params">(BufferedReader reader)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>其实你会发现，我们手写的这个函数式接口，其实就是<code>Function&lt;T&gt;</code>去除泛型化后的接口，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br><span class="hljs-comment">// 都是接受一个参数，返回另一个参数</span><br>  <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面我们列出Java中常用的一些函数式接口，你会发现自带的已经够用了，基本不会需要我们自己去写</p><p>这里的手写只是为了自己实现一遍，可以加深理解程度</p><h3 id="6-常用的函数式接口"><a href="#6-常用的函数式接口" class="headerlink" title="6. 常用的函数式接口"></a>6. 常用的函数式接口</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4fb3fca88fc74b7a9d97a549ba183037~tplv-k3u1fbpfcp-zoom-1.image" alt="常用的函数式接口"></p><h3 id="7-什么是方法引用"><a href="#7-什么是方法引用" class="headerlink" title="7. 什么是方法引用"></a>7. 什么是方法引用</h3><p>我们先看一个例子</p><p>前面我们写的lambda表达式，其实还可以简化，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简化前</span><br>Function&lt;Cat, Integer&gt; function = c-&gt;c.getAge();<br><span class="hljs-comment">// 简化后</span><br>Function&lt;Cat, Integer&gt; function2 = Cat::getAge;<br><br></code></pre></td></tr></table></figure><p>其中简化后的<code>Cat::getAge</code>，我们就叫做<strong>方法引用</strong></p><p><strong>方法引用就是引用类或对象的方法</strong>；</p><p>下面我们列出方法引用的三种情况：</p><ol><li>Object::instanceMethod（对象的实例方法）</li><li>Class::staticMethod（类的静态方法）</li><li>Class::instanceMethod（类的实例方法）</li></ol><p>像我们上面举的例子就是第三种：类的实例方法</p><p>下面我们用代码演示上面的三种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 第一种:引用对象的实例方法</span><br>        Cat cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-number">1</span>);<br>        Function&lt;Cat, Integer&gt; methodRef1 = cat::getSum; <br>        <span class="hljs-comment">// 第二种:引用类的静态方法</span><br>        Supplier&lt;Integer&gt; methodRef2 = Cat::getAverageAge;<br>        <span class="hljs-comment">// 第三种：引用类的实例方法</span><br>        Function&lt;Cat, Integer&gt; methodRef3 = Cat::getAge;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取猫的平均年龄</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAverageAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取两只猫的年龄总和</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(Cat cat)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> cat.getAge() + <span class="hljs-keyword">this</span>.getAge();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>为啥要用这个方法引用呢？</p></blockquote><p>方法引用好比lambda表达式的语法糖，语法更加简洁，清晰</p><p>一看就知道是调用哪个类或对象的哪个方法</p><h3 id="8-什么是构造引用"><a href="#8-什么是构造引用" class="headerlink" title="8. 什么是构造引用"></a>8. 什么是构造引用</h3><p>上面介绍了方法引用，就是直接引用某个方法</p><p>这里的构造引用同理可得，就是引用某个类的构造方法</p><p>构造引用的表达式为：<code>Class::new</code>，仅此一种</p><p>如果你有多个构造函数，那编译器会自己进行推断参数（你看看，多好，多简洁）</p><p>比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里调用 new Cat()</span><br>Supplier&lt;Cat&gt; constructRef1 = Cat::<span class="hljs-keyword">new</span>;<br><span class="hljs-comment">// 这里调用 new Cat(Integer)</span><br>Function&lt;Integer, Cat&gt; constructRef2 = Cat::<span class="hljs-keyword">new</span>;<br><br></code></pre></td></tr></table></figure><h3 id="9-lambda表达式中引入外部变量的限制"><a href="#9-lambda表达式中引入外部变量的限制" class="headerlink" title="9. lambda表达式中引入外部变量的限制"></a>9. lambda表达式中引入外部变量的限制</h3><p>要求引入lambda表达式中的变量，必须是最终变量，即该变量不会再被修改</p><p>比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  String str = <span class="hljs-string">&quot;javalover.cc&quot;</span>;<br>  Runnable runnable = ()-&gt;&#123;<br>    str = <span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-comment">// 这里会报错，因为修改了str引用的指向</span><br>    System.out.println(str);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，lambda表达式引用了外面的str引用，但是又在表达式内部做了修改，结果就报错了</p><blockquote><p>为啥要有这个限制呢？</p></blockquote><p>为了线程安全，因为lambda表达式有一个好处就是只在需要的时候才会执行，而不是调用后立马执行</p><p>这样就会存在多个线程同时执行的并发问题</p><p>所以Java就从根源上解决：不让变量被修改，都是只读的</p><blockquote><p>那你可能好奇，我不把str的修改代码放到表达式内部可以吗？</p></blockquote><p>也不行，道理是一样的，只要lambda有用到这个变量，那这个变量不管是在哪里被修改，都是不允许的</p><p>不然的话，我这边先执行了一次lambda表达式，结果你就改了变量值，那我第二次执行lambda，不就乱了吗</p><h3 id="10-lambda的组合操作"><a href="#10-lambda的组合操作" class="headerlink" title="10. lambda的组合操作"></a>10. lambda的组合操作</h3><p>最后是lambda的必杀技：<strong>组合操作</strong></p><p>在这里叫组合或者复合都可以</p><blockquote><p>概述：组合操作就是先用一个lambda表达式，然后再在后面组合另一个lambda表达式，然后再在后面组合另另一个lambda表达式，然后。。。有点像是链式操作</p></blockquote><p>学过JS的都知道Promise，里面的链式操作就和这里的组合操作很像</p><p>用过Lombok的朋友，应该很熟悉@Builder注解，其实就是构造者模式</p><p>下面我们用代码演示下组合操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重点代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComposeDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Dog&gt; list = Arrays.asList(<span class="hljs-keyword">new</span> Dog(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> Dog(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 1. 先按年龄排序（默认递增）</span><br>      <span class="hljs-comment">// Dog::getAge, 上面介绍的方法引用</span><br>      <span class="hljs-comment">// comparingInt, 是Comparator的一个静态方法，返回Comparator&lt;T&gt;</span><br>      Comparator&lt;Dog&gt; comparableAge = Comparator.comparingInt(Dog::getAge);<br>        <span class="hljs-comment">// 2. 如果有相同的年龄，则年龄相同的再按体重排序（如果年龄已经比较出大小，则下面的体重就不会再去比较）</span><br>        Comparator&lt;Dog&gt; comparableWeight = Comparator.comparingInt(Dog::getWeight);;<br>        <span class="hljs-comment">// 3. 调用list对象的sort方法排序，参数是Comparator&lt;? super Dog&gt;</span><br>        list.sort(comparableAge.thenComparing(comparableWeight));<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 非重点代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> weight;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> weight)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.weight = weight;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, weight=&quot;</span> + weight +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：<code>[Dog&#123;age=1, weight=1&#125;, Dog&#123;age=1, weight=2&#125;]</code></p><p>比较的流程如下所示：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/95d889dd6f084a11982c9e5986621e30~tplv-k3u1fbpfcp-zoom-1.image" alt="组合操作"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>lambda的语法:  参数+符合+表达式或语句，比如<code>(a,b)-&gt;&#123;System.out.println(&quot;javalover.cc&quot;);&#125;</code></li><li>函数式接口：只有一个抽象方法，最好加@FunctionalInterface，这样编译器可及时发现错误，javadoc也说明这是一个函数式接口（可读性）</li><li>行为参数化：就是函数式接口作为参数，然后再将lambda表达式传给函数式接口，通过不同的lambda内容实现不同的行为</li><li>方法引用：lambda的语法糖，总共有三种:<ul><li>Object::instanceMethod（对象的实例方法）</li><li>Class::staticMethod（类的静态方法）</li><li>Class::instanceMethod（类的实例方法）</li></ul></li><li>构造引用：就一种，编译器自己可判断是哪个构造函数，语法为<code>Class::new</code></li><li>在lambda中引入外部变量，必须保证这个变量是最终变量，即不再被修改</li><li>lambda的组合操作，就是链式操作，组合是通过函数式接口的静态方法来组合（静态方法会返回另一个函数式接口的对象）</li></ol><p>比如<code>list.sort(comparableAge.thenComparing(comparableWeight));</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java8</tag>
      
      <tag>Lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring奇技淫巧之扩展点的应用</title>
    <link href="/blog/2021/04/10/Spring%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8B%E6%89%A9%E5%B1%95%E7%82%B9%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/blog/2021/04/10/Spring%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8B%E6%89%A9%E5%B1%95%E7%82%B9%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>首先先介绍下Bean的生命周期」</strong></p><p>我们知道Bean的生命周期分为几个主干流程</p><ul><li>Bean（单例非懒加载）的实例化阶段</li><li>Bean的属性注入阶段</li><li>Bean的初始化阶段</li><li>Bean的销毁阶段</li></ul><p>下面是整个Spring容器的启动流程，可以看到除了上述几个主干流程外，Spring还提供了很多扩展点</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/94786824dcf94545862fdd0dfa6d5407~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>下面详细介绍下Spring的常见的扩展点</p><h1 id="Spring常见扩展点"><a href="#Spring常见扩展点" class="headerlink" title="Spring常见扩展点"></a>Spring常见扩展点</h1><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/fc8a26e6e5334f5d92d36d9acdf65026~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><strong>「BeanFactoryPostProcessor#postProcessBeanFactory」</strong></p><p>有时候整个项目工程中bean的数量有上百个，而大部分单测依赖都是整个工程的xml，导致单测执行时需要很长时间（大部分时间耗费在xml中数百个单例非懒加载的bean的实例化及初始化过程）</p><p>解决方法：利用Spring提供的扩展点将xml中的bean设置为懒加载模式，省去了Bean的实例化与初始化时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyBeanFactoryProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        DefaultListableBeanFactory fac = (DefaultListableBeanFactory) beanFactory;<br>        Map&lt;String, AbstractBeanDefinition&gt; map = (Map&lt;String, AbstractBeanDefinition&gt;) ReflectionTestUtils.getField(fac, <span class="hljs-string">&quot;beanDefinitionMap&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : map.entrySet()) &#123;<br>            <span class="hljs-comment">//设置为懒加载</span><br>            entry.getValue().setLazyInit(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>「InstantiationAwareBeanPostProcessor#postProcessPropertyValues」</strong></p><p>非常规的配置项比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;context:component-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;com.zhou&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>Spring提供了与之对应的特殊解析器</p><p>正是通过这些特殊的解析器才使得对应的配置项能够生效</p><p>而针对这个特殊配置的解析器为 ComponentScanBeanDefinitionParser</p><p>在这个解析器的解析方法中，注册了很多特殊的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">parse</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>  registerComponents(parserContext.getReaderContext(), beanDefinitions, element);<br>    <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>复制代码<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">registerAnnotationConfigProcessors</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">   BeanDefinitionRegistry registry, Object source)</span> </span>&#123;<br><br>  Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="hljs-keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(<span class="hljs-number">4</span>);<br>  <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//@Autowire</span><br>  <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;<br>   RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);<br>   def.setSource(source);<br>   beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));<br>  &#125;<br><br>  <span class="hljs-comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><br>   <span class="hljs-comment">//@Resource</span><br>  <span class="hljs-keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;<br>      <span class="hljs-comment">//特殊的Bean</span><br>   RootBeanDefinition def = <span class="hljs-keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);<br>   def.setSource(source);<br>   beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> beanDefs;<br> &#125;<br></code></pre></td></tr></table></figure><p>以@Resource为例，看看这个特殊的bean做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonAnnotationBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InitDestroyAnnotationBeanPostProcessor</span></span><br><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>     <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessPropertyValues</span><span class="hljs-params">(PropertyValues pvs, PropertyDescriptor[] pds, </span></span><br><span class="hljs-function"><span class="hljs-params">      Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>          InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass());<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//属性注入</span><br>            metadata.inject(bean, beanName, pvs);<br>          &#125;<br>          <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">&quot;Injection of resource dependencies failed&quot;</span>, ex);<br>          &#125;<br>          <span class="hljs-keyword">return</span> pvs;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到在postProcessPropertyValues方法中，进行了属性注入</p><p><strong>「invokeAware」</strong></p><p>实现BeanFactoryAware接口的类，会由容器执行setBeanFactory方法将当前的容器BeanFactory注入到类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactoryHolder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryAware</span></span>&#123;<br>   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanFactory beanFactory;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>「BeanPostProcessor#postProcessBeforeInitialization」</strong></p><p>实现ApplicationContextAware接口的类，会由容器执行setApplicationContext方法将当前的容器applicationContext注入到类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextAwareProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConfigurableApplicationContext applicationContext;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApplicationContextAwareProcessor</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.applicationContext = applicationContext;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>      <span class="hljs-comment">//...</span><br>      invokeAwareInterfaces(bean);<br>      <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware) &#123;<br>          ((ApplicationContextAware) bean).setApplicationContext(<span class="hljs-keyword">this</span>.applicationContext);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到是在BeanPostProcessor的postProcessBeforeInitialization中进行了setApplicationContext方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextHolder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span></span>&#123;<br>   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">this</span>.applicationContext = applicationContext;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>「afterPropertySet()和init-method」</strong></p><p>目前很多Java中间件都是基本Spring Framework搭建的，而这些中间件经常把入口放到afterPropertySet或者自定义的init中</p><p><strong>「BeanPostProcessor#postProcessAfterInitialization」</strong></p><p>熟悉aop的同学应该知道，aop底层是通过动态代理实现的</p><p>当配置了<code>&lt;aop:aspectj-autoproxy/&gt;</code>时候，默认开启aop功能，相应地调用方需要被aop织入的对象也需要替换为动态代理对象</p><p>不知道大家有没有思考过动态代理是如何<strong>「在调用方无感知情况下替换原始对象」</strong>的？</p><blockquote><p>❝</p><p>根据上文的讲解，我们知道：</p><p>❞</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;aop:aspectj-autoproxy/&gt;<br></code></pre></td></tr></table></figure><p>Spring也提供了特殊的解析器，和其他的解析器类似，在核心的parse方法中注册了特殊的bean</p><p>这里是一个BeanPostProcessor类型的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAutoProxyBeanDefinitionParser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionParser</span> </span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">parse</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> </span>&#123;<br>    <span class="hljs-comment">//注册特殊的bean</span><br>  AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);<br>  extendBeanDefinition(element, parserContext);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将于当前bean对应的动态代理对象返回即可，该过程对调用方全部透明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>          Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>          <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.earlyProxyReferences.containsKey(cacheKey)) &#123;<br>            <span class="hljs-comment">//如果该类需要被代理，返回动态代理对象；反之，返回原对象</span><br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正是利用Spring的这个扩展点实现了动态代理对象的替换</p><p><strong>「destroy()和destroy-method」</strong></p><p>bean生命周期的最后一个扩展点，该方法用于执行一些bean销毁前的准备工作，比如将当前bean持有的一些资源释放掉</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作四年，分享50个让你代码更好的小建议</title>
    <link href="/blog/2021/04/04/%E5%88%86%E4%BA%AB50%E4%B8%AA%E8%AE%A9%E4%BD%A0%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%B0%8F%E5%BB%BA%E8%AE%AE/"/>
    <url>/blog/2021/04/04/%E5%88%86%E4%BA%AB50%E4%B8%AA%E8%AE%A9%E4%BD%A0%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%B0%8F%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-仅是判断是否存在时，select-count-比-select-具体的列，更好。"><a href="#1-仅是判断是否存在时，select-count-比-select-具体的列，更好。" class="headerlink" title="1. 仅是判断是否存在时，select count 比 select 具体的列，更好。"></a>1. 仅是判断是否存在时，select count 比 select 具体的列，更好。</h3><p>我们经常遇到类似的业务场景，如，判断某个用户<code>userId</code>是否是会员。</p><p><strong>（反例）：</strong>  一些小伙伴会这样实现，先查从用户信息表查出用户记录，然后再去判断是否是会员:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;selectUserByUserId&quot;</span> resultMap=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;<br>     selct user_id , vip_flag <span class="hljs-keyword">from</span>  user_info <span class="hljs-keyword">where</span> user_id =<span class="hljs-meta">#&#123;userId&#125;;</span><br> &lt;/<span class="hljs-keyword">select</span>&gt;<br><br><span class="hljs-function">boolean <span class="hljs-title">isVip</span> (<span class="hljs-params">String userId</span>)</span>&#123;<br>  UserInfo userInfo = userInfoDAp.selectUserByUserId(userId);<br>  <span class="hljs-keyword">return</span> UserInfo!=<span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-string">&quot;Y&quot;</span>.<span class="hljs-keyword">equals</span>(userInfo.getVipFlag())<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>（正例）：</strong> 针对这种业务场景，其实更好的实现，是直接<code>select count</code>一下，如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;countVipUserByUserId&quot;</span> resultType=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;<br>     selct <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span>  user_info <span class="hljs-keyword">where</span> user_id =#&#123;userId&#125; <span class="hljs-keyword">and</span> vip_flag =<span class="hljs-string">&#x27;Y&#x27;</span>;<br> &lt;/<span class="hljs-keyword">select</span>&gt;<br> <br> <span class="hljs-keyword">boolean</span> isVip (<span class="hljs-keyword">String</span> userId)&#123;<br>  int vipNum = userInfoDAp.countVipUserByUserId(userId);<br>  return vipNum&gt;0<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="2-复杂的if逻辑条件，可以调整顺序，让程序更高效"><a href="#2-复杂的if逻辑条件，可以调整顺序，让程序更高效" class="headerlink" title="2. 复杂的if逻辑条件，可以调整顺序，让程序更高效"></a>2. 复杂的if逻辑条件，可以调整顺序，让程序更高效</h3><p>假设业务需求是这样：如果用户是会员，并且第一次登陆时，需要发一条通知的短信。假如没有经过思考，代码很可能直接这样写了。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">isUserVip</span> &amp;&amp; <span class="hljs-variable">isFirstLogin</span>)&#123;</span><br><span class="hljs-function">    <span class="hljs-title">sendMsgNotify</span>();</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">复制代码</span><br></code></pre></td></tr></table></figure><p>假设总共有5个请求进来，isUserVip通过的有3个请求，isFirstLogin通过的有1个请求。 那么以上代码，isUserVip执行的次数为5次，isFirstLogin执行的次数也是3次，如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/b30c2899d10f4258bf1fc94a9ebf324c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如果调整一下isUserVip和isFirstLogin的顺序呢？</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">isFirstLogin</span> &amp;&amp; <span class="hljs-variable">isUserVip</span> )&#123;</span><br><span class="hljs-function">    <span class="hljs-title">sendMsg</span>();</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">复制代码</span><br></code></pre></td></tr></table></figure><p>isFirstLogin执行的次数是5次，isUserVip执行的次数是1次，如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/103a20c642e04ea899d74c4cb8187b28~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如果你的isFirstLogin，判断逻辑只是select count 一下数据库表，isUserVip也是select count 一下数据库表的话，显然，把isFirstLogin放在前面更高效。</p><h3 id="3-写查询Sql的时候，只查你需要用到的字段，还有通用的字段，拒绝反手的select"><a href="#3-写查询Sql的时候，只查你需要用到的字段，还有通用的字段，拒绝反手的select" class="headerlink" title="3. 写查询Sql的时候，只查你需要用到的字段，还有通用的字段，拒绝反手的select *"></a>3. 写查询Sql的时候，只查你需要用到的字段，还有通用的字段，拒绝反手的select *</h3><p><strong>反例：</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">where</span> user_id =<span class="hljs-meta">#&#123;userId&#125;;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> selct user_id , vip_flag <span class="hljs-keyword">from</span>  user_info <span class="hljs-keyword">where</span> user_id =<span class="hljs-comment">#&#123;userId&#125;;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>节省资源、减少网络开销。</li><li>可能用到覆盖索引，减少回表，提高查询效率。</li></ul><h3 id="4-优化你的程序，拒绝创建不必要的对象"><a href="#4-优化你的程序，拒绝创建不必要的对象" class="headerlink" title="4. 优化你的程序，拒绝创建不必要的对象"></a>4. 优化你的程序，拒绝创建不必要的对象</h3><p>如果你的变量，后面的逻辑判断，一定会被赋值；或者说，只是一个字符串变量，直接初始化字符串常量就可以了，没有必要愣是要new String().</p><p>反例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span> (<span class="hljs-string">&quot;欢迎关注公众号：捡田螺的小男孩&quot;</span>);<br>复制代码<br></code></pre></td></tr></table></figure><p>正例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">String s=  <span class="hljs-string">&quot;欢迎关注公众号：捡田螺的小男孩 ”;</span><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="5-初始化集合时，指定容量"><a href="#5-初始化集合时，指定容量" class="headerlink" title="5. 初始化集合时，指定容量"></a>5. 初始化集合时，指定容量</h3><p>阿里的开发手册，也明确提到这个点： </p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/image-20210404075408639.png" alt="image-20210404075408639"></p><p>假设你的map要存储的元素个数是15个左右，最优写法如下</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"> <span class="hljs-comment">//initialCapacity = 15/0.75+1=21</span><br> <span class="hljs-built_in">Map</span> <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> HashMap(<span class="hljs-number">21</span>);<br> 又因为hashMap的容量跟<span class="hljs-number">2</span>的幂有关，所以可以取<span class="hljs-number">32</span>的容量<br> <span class="hljs-built_in">Map</span> <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> HashMap(<span class="hljs-number">32</span>);<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="6-catch了异常，需要打印出具体的exception，方便更好定位问题"><a href="#6-catch了异常，需要打印出具体的exception，方便更好定位问题" class="headerlink" title="6.catch了异常，需要打印出具体的exception，方便更好定位问题"></a>6.catch了异常，需要打印出具体的exception，方便更好定位问题</h3><p><strong>反例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;捡田螺的小男孩，你的程序有异常啦&quot;</span>);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;捡田螺的小男孩，你的程序有异常啦：&quot;</span>,e); <span class="hljs-comment">//把exception打印出来</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>反例中，并没有把exception出来，到时候排查问题就不好查了啦，到底是SQl写错的异常还是IO异常，还是其他呢？所以应该把exception打印到日志中哦~</li></ul><h3 id="7-打印日志的时候，对象没有覆盖Object的toString的方法，直接把类名打印出来了。"><a href="#7-打印日志的时候，对象没有覆盖Object的toString的方法，直接把类名打印出来了。" class="headerlink" title="7. 打印日志的时候，对象没有覆盖Object的toString的方法，直接把类名打印出来了。"></a>7. 打印日志的时候，对象没有覆盖Object的toString的方法，直接把类名打印出来了。</h3><p>我们在打印日志的时候，经常想看下一个请求参数对象request是什么。于是很容易有类似以下这些代码：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">publick <span class="hljs-built_in">Response</span> dealWithRequest(<span class="hljs-built_in">Request</span> <span class="hljs-built_in">request</span>)&#123;<br>   log.info(<span class="hljs-string">&quot;请求参数是：&quot;</span>.<span class="hljs-built_in">request</span>.toString)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">请求参数是：<span class="hljs-keyword">local</span>.Request<span class="hljs-symbol">@49476842</span><br>复制代码<br></code></pre></td></tr></table></figure><p>这是因为对象的toString方法，默认的实现是“类名@散列码的无符号十六进制”。所以你看吧，这样子打印日志就没啥意思啦，你都不知道打印的是什么内容。</p><p>所以一般对象(尤其作为传参的对象），<strong>都覆盖重写toString()方法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> age;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Request&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br>publick Response <span class="hljs-function"><span class="hljs-title">dealWithRequest</span>(<span class="hljs-params">Request request</span>)</span>&#123;<br>   log.info(<span class="hljs-string">&quot;请求参数是：&quot;</span>.request.toString)<br>&#125;<br><br><br>复制代码<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">请求参数是：Request&#123;<span class="hljs-attribute">age</span>=<span class="hljs-string">&#x27;26&#x27;</span>, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;公众号：捡田螺的小男孩&#x27;</span>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="8-一个方法，拒绝过长的参数列表。"><a href="#8-一个方法，拒绝过长的参数列表。" class="headerlink" title="8. 一个方法，拒绝过长的参数列表。"></a>8. 一个方法，拒绝过长的参数列表。</h3><p>假设有这么一个公有方法，形参有四个。。。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> getUserInfo（<span class="hljs-keyword">String</span> name,<span class="hljs-keyword">String</span> age,<span class="hljs-keyword">String</span> sex,<span class="hljs-keyword">String</span> mobile)&#123;<br>  <span class="hljs-comment">// do something ...</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>如果现在需要多传一个version参数进来，并且你的公有方法是类似dubbo这种对外提供的接口的话，那么你的接口是不是需要兼容老版本啦？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> getUserInfo（<span class="hljs-keyword">String</span> name,<span class="hljs-keyword">String</span> age,<span class="hljs-keyword">String</span> sex,<span class="hljs-keyword">String</span> mobile)&#123;<br>  <span class="hljs-comment">// do something ...</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新接口调这里</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> getNewUserInfo（<span class="hljs-keyword">String</span> name,<span class="hljs-keyword">String</span> age,<span class="hljs-keyword">String</span> sex,<span class="hljs-keyword">String</span> mobile，<span class="hljs-keyword">String</span> version)&#123;<br>  <span class="hljs-comment">// do something ...</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>所以呢，一般一个方法的参数，一般不宜过长。过长的参数列表，不仅看起来不优雅，并且接口升级时，可能还要考虑新老版本兼容。如果参数实在是多怎么办呢？可以用个DTO对象包装一下这些参数呢~如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> getUserInfo（UserInfoParamDTO userInfoParamDTO)&#123;<br>  <span class="hljs-comment">// do something ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoParamDTO</span>&#123;</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> age; <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> sex;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> mobile;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>用个DTO对象包装一下，即使后面有参数变动，也可以不用动对外接口了，好处杠杠的。</p><h3 id="9-使用缓冲流，减少IO操作"><a href="#9-使用缓冲流，减少IO操作" class="headerlink" title="9. 使用缓冲流，减少IO操作"></a>9. 使用缓冲流，减少IO操作</h3><p><strong>反例：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  公众号：捡田螺的小男孩</span><br><span class="hljs-comment"> *  @desc: 复制一张图片文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-built_in">begin</span> = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> (FileInputStream input = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:/456.png&quot;</span>);<br>             FileOutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:/789.png&quot;</span>)) &#123;<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> i;<br>            <span class="hljs-keyword">while</span> ((i = input.<span class="hljs-built_in">read</span>(bytes)) != <span class="hljs-number">-1</span>) &#123;<br>                output.<span class="hljs-built_in">write</span>(bytes,<span class="hljs-number">0</span>,i);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-built_in">log</span>.error(<span class="hljs-string">&quot;复制文件发生异常&quot;</span>,e);<br>        &#125;<br>        <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;常规流读写，总共耗时ms：&quot;</span>+(System.currentTimeMillis() - <span class="hljs-built_in">begin</span>));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">常规流读写，总共耗时<span class="hljs-selector-tag">ms</span><span class="hljs-selector-pseudo">:52</span><br>复制代码<br></code></pre></td></tr></table></figure><p>使用<code>FileInputStream</code>、<code>FileOutputStream</code>实现文件读写功能，是没有什么问题的。但是呢，可以使用缓冲流<code>BufferedReader</code>、<code>BufferedWriter</code>、<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>等，减少IO次数，提高读写效率。</p><blockquote><p>如果是不带缓冲的流，读取到一个字节或者字符的，就会直接输出数据了。而带缓冲的流，读取到一个字节或者字符时，先不输出，而是等达到缓冲区的最大容量，才一次性输出。</p></blockquote><p><strong>正例：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  公众号：捡田螺的小男孩</span><br><span class="hljs-comment"> *  @desc: 复制一张图片文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws FileNotFoundException </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-built_in">begin</span> = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:/456.png&quot;</span>));<br>        BufferedOutputStream  bufferedOutputStream = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:/789.png&quot;</span>))) &#123;<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> i;<br>            <span class="hljs-keyword">while</span> ((i = input.<span class="hljs-built_in">read</span>(bytes)) != <span class="hljs-number">-1</span>) &#123;<br>                output.<span class="hljs-built_in">write</span>(bytes,<span class="hljs-number">0</span>,i);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-built_in">log</span>.error(<span class="hljs-string">&quot;复制文件发生异常&quot;</span>,e);<br>        &#125;<br>        <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;总共耗时ms&quot;</span>+(System.currentTimeMillis() - <span class="hljs-built_in">begin</span>));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">缓冲流读写，总共耗时<span class="hljs-selector-tag">ms</span><span class="hljs-selector-pseudo">:12</span><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="10-优化你的程序逻辑，比如前面已经查到的数据，在后面的方法也用到的话，是可以把往下传参的，减少方法调用-查表"><a href="#10-优化你的程序逻辑，比如前面已经查到的数据，在后面的方法也用到的话，是可以把往下传参的，减少方法调用-查表" class="headerlink" title="10. 优化你的程序逻辑，比如前面已经查到的数据，在后面的方法也用到的话，是可以把往下传参的，减少方法调用/查表"></a>10. 优化你的程序逻辑，比如前面已经查到的数据，在后面的方法也用到的话，是可以把往下传参的，减少方法调用/查表</h3><p><strong>反例：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Response deal<span class="hljs-constructor">Request(Request <span class="hljs-params">request</span>)</span>&#123;<br>    <br>    UserInfo userInfo = userInfoDao.select<span class="hljs-constructor">UserByUserId(<span class="hljs-params">request</span>.<span class="hljs-params">getUserId</span>)</span>;<br>     <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">request</span>)</span>)&#123;<br>       return ;<br>     &#125;<br>   <br>    insert<span class="hljs-constructor">UserVip(<span class="hljs-params">request</span>.<span class="hljs-params">getUserId</span>)</span>;<br>   <br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> insertUserVip（String userId）&#123;<br>      <span class="hljs-comment">//又查了一次 </span><br>      UserInfo userInfo = userInfoDao.select<span class="hljs-constructor">UserByUserId(<span class="hljs-params">request</span>.<span class="hljs-params">getUserId</span>)</span>;<br>      <span class="hljs-comment">//插入用户vip流水</span><br>      insert<span class="hljs-constructor">UserVipFlow(<span class="hljs-params">userInfo</span>)</span>;<br>      ....<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>很显然，以上程序代码，已经查到 userInfo，然后又把userId传下去，又查多了一次。。。实际上，可以把userInfo传下去的，这样可以省去一次查表操作，程序更高效。</p><p><strong>正例：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Response deal<span class="hljs-constructor">Request(Request <span class="hljs-params">request</span>)</span>&#123;<br>    <br>    UserInfo userInfo = userInfoDao.select<span class="hljs-constructor">UserByUserId(<span class="hljs-params">request</span>.<span class="hljs-params">getUserId</span>)</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>is<span class="hljs-constructor">Null(<span class="hljs-params">request</span>)</span>)&#123;<br>       return ;<br>     &#125;<br>   <br>    insert<span class="hljs-constructor">UserVip(<span class="hljs-params">userInfo</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> insertUserVip（UserInfo userInfo）&#123;<br>      <span class="hljs-comment">//插入用户vip流水</span><br>      insert<span class="hljs-constructor">UserVipFlow(<span class="hljs-params">userInfo</span>)</span>;<br>      ....<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="11-不要为了方便，直接在代码中使用0-1等魔法值，应该要用enum枚举代替。"><a href="#11-不要为了方便，直接在代码中使用0-1等魔法值，应该要用enum枚举代替。" class="headerlink" title="11. 不要为了方便，直接在代码中使用0,1等魔法值，应该要用enum枚举代替。"></a>11. 不要为了方便，直接在代码中使用0,1等魔法值，应该要用enum枚举代替。</h3><p><strong>反例：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;0&quot;</span>.equals(userInfo.getVipFlag))&#123;<br>    <span class="hljs-regexp">//</span>非会员，提示去开通会员<br>    tipOpenVip(userInfo);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;1&quot;</span>.equals(userInfo.getVipFlag))&#123;<br>    <span class="hljs-regexp">//</span>会员，加勋章返回<br>    addMedal（userInfo）;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserVipEnum</span>.</span><span class="hljs-module"><span class="hljs-identifier">NOT_VIP</span>.</span></span>getCode.equals(userInfo.getVipFlag))&#123;<br>    <span class="hljs-comment">//非会员，提示去开通会员</span><br>    tip<span class="hljs-constructor">OpenVip(<span class="hljs-params">userInfo</span>)</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserVipEnum</span>.</span><span class="hljs-module"><span class="hljs-identifier">VIP</span>.</span></span>getCode.equals(userInfo.getVipFlag))&#123;<br>    <span class="hljs-comment">//会员，加勋章返回</span><br>    addMedal（userInfo）;<br>&#125;<br><br>public enum UserVipEnum &#123;<br><br>    <span class="hljs-constructor">VIP(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;会员&quot;</span>)</span>,<br>    <span class="hljs-constructor">NOT_VIP(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;非会员&quot;</span>)</span>,:;<br><br>    <span class="hljs-keyword">private</span> String code; <br>    <span class="hljs-keyword">private</span> String desc;<br><br>    <span class="hljs-constructor">UserVipEnum(String <span class="hljs-params">code</span>, String <span class="hljs-params">desc</span>)</span> &#123;<br>        this.code = code;<br>        this.desc = desc;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>写代码的时候，不要一时兴起，就直接使用魔法值哈。使用魔法值，维护代码起来很难受的。</p><h3 id="12-当成员变量值不会改变时，优先定义为静态常量"><a href="#12-当成员变量值不会改变时，优先定义为静态常量" class="headerlink" title="12. 当成员变量值不会改变时，优先定义为静态常量"></a>12. 当成员变量值不会改变时，优先定义为静态常量</h3><p><strong>反例：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Task</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> long timeout = <span class="hljs-number">10</span>L;<br>    ...<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> TIMEOUT = <span class="hljs-number">10L</span>;<br>    ...<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>因为如果定义为static，即类静态常量，在每个实例对象中，它只有一份副本。如果是成员变量，每个实例对象中，都各有一份副本。显然，如果这个变量不会变的话，定义为静态常量更好一些。</p></blockquote><h3 id="13-注意检验空指针，不要轻易相信业务，说正常逻辑某个参数不可能为空。"><a href="#13-注意检验空指针，不要轻易相信业务，说正常逻辑某个参数不可能为空。" class="headerlink" title="13. 注意检验空指针，不要轻易相信业务，说正常逻辑某个参数不可能为空。"></a>13. 注意检验空指针，不要轻易相信业务，说正常逻辑某个参数不可能为空。</h3><p>NullPointerException 在我们日常开发中非常常见，我们代码开发过程中，一定要对空指针保持灵敏的嗅觉。</p><p>主要有这几类空指针问题：</p><ul><li>包装类型的空指针问题</li><li>级联调用的空指针问题</li><li>Equals方法左边的空指针问题</li><li>ConcurrentHashMap 类似容器不支持 k-v为 null。</li><li>集合，数组直接获取元素</li><li>对象直接获取属性</li></ul><p><strong>反例：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NullPointTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;666&quot;</span>)) &#123; <span class="hljs-comment">//s可能为空，会导致空指针问题</span><br>            System.out.println(<span class="hljs-string">&quot;公众号：捡田螺的小男孩，干货满满&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="14，捕获到的异常，不能忽略它，至少打点日志。"><a href="#14，捕获到的异常，不能忽略它，至少打点日志。" class="headerlink" title="14，捕获到的异常，不能忽略它，至少打点日志。"></a>14，捕获到的异常，不能忽略它，至少打点日志。</h3><p><strong>反例：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testIgnoreException</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;       <br>        <span class="hljs-comment">// 搞事情</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <br>        <span class="hljs-comment">//捕获了异常，啥事情不做，日志也不打？？</span><br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">testIgnoreException</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 搞事情</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;     <br>        log.error(<span class="hljs-string">&quot;异常了，联系开发小哥哥看看哈&quot;</span>,e); <br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="15-采用Lambda表达式替换内部匿名类，使代码更优雅"><a href="#15-采用Lambda表达式替换内部匿名类，使代码更优雅" class="headerlink" title="15. 采用Lambda表达式替换内部匿名类，使代码更优雅"></a>15. 采用Lambda表达式替换内部匿名类，使代码更优雅</h3><p>JDK8出现了新特性-Lambda表达式。Lambda表达式不仅比匿名内部类更加优雅，并且在大多数虚拟机中，都是采用invokeDynamic指令实现，相对于匿名内部类，效率也更高</p><p><strong>反例：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortUserInfoList</span><span class="hljs-params">(List&lt;UserInfo&gt; userInfoList)</span></span>&#123;<br>      userInfoList.sort(<span class="hljs-keyword">new</span> Comparator&lt;UserInfo&gt;() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(UserInfo user1, UserInfo user2)</span> </span>&#123;<br>              Long userId1 = user1.getUserId();<br>              Long userId2 = user2.getUserId();<br>              <span class="hljs-function"><span class="hljs-keyword">return</span> userId1.<span class="hljs-title">compareTo</span><span class="hljs-params">(userId2)</span></span>;<br>          &#125;&#125;);<br>      &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">   public <span class="hljs-literal">void</span> sortUserInfoList(List&lt;UserInfo&gt; userInfoList)&#123;<br>       userInfoList.sort<span class="hljs-function"><span class="hljs-params">((user1, user2) -&gt; &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">           Long userId1 = user1.getUserId();</span></span><br><span class="hljs-function"><span class="hljs-params">           Long userId2 = user2.getUserId();</span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">return</span> userId1.compareTo(userId2);</span></span><br><span class="hljs-function"><span class="hljs-params">       &#125;)</span>;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function">复制代码</span><br></code></pre></td></tr></table></figure><h3 id="16-通知类（如发邮件，有短信）的代码，建议异步处理。"><a href="#16-通知类（如发邮件，有短信）的代码，建议异步处理。" class="headerlink" title="16. 通知类（如发邮件，有短信）的代码，建议异步处理。"></a>16. 通知类（如发邮件，有短信）的代码，建议异步处理。</h3><p>假设业务流程这样：需要在用户登陆时，添加个短信通知它的粉丝。 很容易想到的实现流程如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/image-20210404075450152.png" alt="image-20210404075450152"></p><p>假设提供sendMsgNotify服务的系统挂了，或者调用sendMsgNotify失败了，那么用户登陆就失败了。。。 一个通知功能导致了登陆主流程不可用，明显的捡了芝麻丢西瓜。那么有没有鱼鱼熊掌兼得的方法呢？有的，给发短信接口捕获异常处理，或者另开线程异步处理，如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/image-20210404075509515.png" alt="image-20210404075509515"></p><p>因此，添加通知类等不是非主要，可降级的接口时，应该静下心来考虑是否会影响主要流程，思考怎么处理最好。</p><h3 id="17-处理Java日期时，当心YYYY格式设置的问题。"><a href="#17-处理Java日期时，当心YYYY格式设置的问题。" class="headerlink" title="17. 处理Java日期时，当心YYYY格式设置的问题。"></a>17. 处理Java日期时，当心YYYY格式设置的问题。</h3><p>日常开发中，我们经常需要处理日期。我们要当时日期格式化的时候，年份是大写<code>YYYY</code>的坑。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Calendar calendar = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Calendar</span>.</span></span>get<span class="hljs-constructor">Instance()</span>;<br>calendar.set(<span class="hljs-number">2019</span>, Calendar.DECEMBER, <span class="hljs-number">31</span>);<br><br>Date testDate = calendar.get<span class="hljs-constructor">Time()</span>;<br><br>SimpleDateFormat dtf = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleDateFormat(<span class="hljs-string">&quot;YYYY-MM-dd&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;2019-12-31 转 YYYY-MM-dd 格式后 &quot;</span> + dtf.format(testDate));<br>复制代码<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2019<span class="hljs-string">-12</span><span class="hljs-string">-31</span> 转 YYYY-MM-dd 格式后 2020<span class="hljs-string">-12</span><span class="hljs-string">-31</span><br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>为什么明明是2019年12月31号，就转了一下格式，就变成了2020年12月31号了？因为YYYY是基于周来计算年的，它指向当天所在周属于的年份，一周从周日开始算起，周六结束，只要本周跨年，那么这一周就算下一年的了。正确姿势是使用yyyy格式。</p></blockquote><p><img src="/Users/cuixiaoyan/Library/Application%20Support/typora-user-images/image-20210404075903220.png" alt="image-20210404075903220"></p><h3 id="18-如果一个类确定不会被继承，不会拿来搞AOP骚操作，可以指定final修饰符，如用final修饰一个工具类。"><a href="#18-如果一个类确定不会被继承，不会拿来搞AOP骚操作，可以指定final修饰符，如用final修饰一个工具类。" class="headerlink" title="18. 如果一个类确定不会被继承，不会拿来搞AOP骚操作，可以指定final修饰符，如用final修饰一个工具类。"></a>18. 如果一个类确定不会被继承，不会拿来搞AOP骚操作，可以指定final修饰符，如用final修饰一个工具类。</h3><p><strong>正例：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFinal</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;工具类方法&quot;</span>);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>一个类指定了final修饰符，它不会被继承了，并且其所有方法都是final的了。Java编译器会找机会内联所有的final方法，提升了Java运行效率。</p><h3 id="19-static静态变量不要依赖spring实例化变量，可能会导致初始化出错"><a href="#19-static静态变量不要依赖spring实例化变量，可能会导致初始化出错" class="headerlink" title="19. static静态变量不要依赖spring实例化变量，可能会导致初始化出错"></a>19. static静态变量不要依赖spring实例化变量，可能会导致初始化出错</h3><p>之前看到项目有类似的代码。静态变量依赖于spring容器的bean。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">private</span> static SmsService smsService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SpringContextUtils</span>.</span></span>get<span class="hljs-constructor">Bean(SmsService.<span class="hljs-params">class</span>)</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p>这个静态的smsService有可能获取不到的，因为类加载顺序不是确定的，而以上的代码，静态的smsService初始化强制依赖spring容器的实例了。正确的写法可以这样，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SmsService  smsService =<span class="hljs-literal">null</span>;<br> <br> <span class="hljs-comment">//使用到的时候采取获取</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SmsService <span class="hljs-function"><span class="hljs-title">getSmsService</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">if</span>(smsService==<span class="hljs-literal">null</span>)&#123;<br>      smsService = SpringContextUtils.getBean(SmsService.class);<br>   &#125;<br>   <span class="hljs-keyword">return</span> smsService;<br> &#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="20-与类成员变量无关的方法，应当声明成静态方法"><a href="#20-与类成员变量无关的方法，应当声明成静态方法" class="headerlink" title="20. 与类成员变量无关的方法，应当声明成静态方法"></a>20. 与类成员变量无关的方法，应当声明成静态方法</h3><p>有些方法，与实例成员变量无关，就可以声明为静态方法。这一点，工具类用得很多。<strong>反例如下</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BigDecimal的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigDecimalUtils</span> </span>&#123;<br> <br>    <span class="hljs-keyword">public</span>  BigDecimal <span class="hljs-function"><span class="hljs-title">ifNullSetZERO</span>(<span class="hljs-params">BigDecimal <span class="hljs-keyword">in</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span> ？ <span class="hljs-keyword">in</span> : BigDecimal.ZERO;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params">BigDecimal ...<span class="hljs-keyword">in</span></span>)</span>&#123;<br>        BigDecimal result = BigDecimal.ZERO;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">in</span>.length; i++)&#123;<br>            result = result.add(ifNullSetZERO(<span class="hljs-keyword">in</span>[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>因为BigDecimalUtils工具类的方法都没有static修饰，所以，你要使用的时候，每次都要new一下啦,那不就耗资源去<strong>反复创建对象</strong>了嘛！！</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BigDecimalUtils </span><span class="hljs-keyword">bigDecimalUtils </span>= new <span class="hljs-keyword">BigDecimalUtils（）;</span><br><span class="hljs-keyword">bigDecimalUtils.sum(a,b);</span><br><span class="hljs-keyword">复制代码</span><br></code></pre></td></tr></table></figure><p>所以可以声明成静态变量，使用的时候，直接<code>类名.方法</code>调用即可，正例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BigDecimal的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigDecimalUtils</span> </span>&#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  BigDecimal <span class="hljs-function"><span class="hljs-title">ifNullSetZERO</span>(<span class="hljs-params">BigDecimal <span class="hljs-keyword">in</span></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span> ？ <span class="hljs-keyword">in</span> : BigDecimal.ZERO;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigDecimal <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params">BigDecimal ...<span class="hljs-keyword">in</span></span>)</span>&#123;<br>        BigDecimal result = BigDecimal.ZERO;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">in</span>.length; i++)&#123;<br>            result = result.add(ifNullSetZERO(<span class="hljs-keyword">in</span>[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="21-不要用一个Exception捕捉所有可能的异常。"><a href="#21-不要用一个Exception捕捉所有可能的异常。" class="headerlink" title="21. 不要用一个Exception捕捉所有可能的异常。"></a>21. 不要用一个Exception捕捉所有可能的异常。</h3><p><strong>反例:</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test()&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//…抛出 IOException 的代码调用</span><br>        <span class="hljs-comment">//…抛出 SQLException 的代码调用</span><br>    &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> e)&#123;<br>        <span class="hljs-comment">//用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦</span><br>        log.info(“<span class="hljs-built_in">Exception</span> in test,<span class="hljs-built_in">exception</span>:&#123;&#125;”, e);<br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">test</span>()&#123;<br>    <span class="hljs-selector-tag">try</span>&#123;<br>        <span class="hljs-comment">//…抛出 IOException 的代码调用</span><br>        <span class="hljs-comment">//…抛出 SQLException 的代码调用</span><br>    &#125;<span class="hljs-selector-tag">catch</span>(IOException e)&#123;<br>        <span class="hljs-comment">//仅仅捕捉 IOException</span><br>        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(“IOException in test,<span class="hljs-attribute">exception</span>:&#123;&#125;”, e);<br>    &#125;<span class="hljs-selector-tag">catch</span>(SQLException e)&#123;<br>        <span class="hljs-comment">//仅仅捕捉 SQLException</span><br>        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(“SQLException in test,<span class="hljs-attribute">exception</span>:&#123;&#125;”, e);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="22-函数不要过度封装，言简意赅即可。"><a href="#22-函数不要过度封装，言简意赅即可。" class="headerlink" title="22. 函数不要过度封装，言简意赅即可。"></a>22. 函数不要过度封装，言简意赅即可。</h3><p><strong>反例：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 函数封装</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isUserVip</span>(<span class="hljs-params"><span class="hljs-built_in">Boolean</span> isVip</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>.TRUE.equals(isVip);<br>&#125;<br><br><span class="hljs-comment">// 使用代码</span><br><span class="hljs-built_in">boolean</span> isVip = isVip(user.getUserVip());<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">boolean</span> isVip = <span class="hljs-built_in">Boolean</span>.<span class="hljs-literal">TRUE</span>.<span class="hljs-keyword">equals</span>(user.getUserVip());<br>复制代码<br></code></pre></td></tr></table></figure><p>函数不要过度封装，把意思表达清楚即可。并且，方法调用会引起入栈和出栈，导致消耗更多的CPU和内存，过度封装，会损耗性能的！</p><h3 id="23-如果变量的初值一定会被覆盖，就没有必要给变量赋初值。"><a href="#23-如果变量的初值一定会被覆盖，就没有必要给变量赋初值。" class="headerlink" title="23. 如果变量的初值一定会被覆盖，就没有必要给变量赋初值。"></a>23. 如果变量的初值一定会被覆盖，就没有必要给变量赋初值。</h3><p><strong>反例:</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">List<span class="hljs-variable">&lt;UserInfo&gt;</span> <span class="hljs-keyword">user</span>List = new ArrayList<span class="hljs-variable">&lt;&gt;</span>();<br>if (isAll) &#123;<br>    <span class="hljs-keyword">user</span>List = <span class="hljs-keyword">user</span>InfoDAO.queryAll();<br>&#125; else &#123;<br>    <span class="hljs-keyword">user</span>List = <span class="hljs-keyword">user</span>InfoDAO.queryActive();<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">List<span class="hljs-variable">&lt;UserInfo&gt;</span> <span class="hljs-keyword">user</span>List ;<br>if (isAll) &#123;<br>    <span class="hljs-keyword">user</span>List = <span class="hljs-keyword">user</span>InfoDAO.queryAll();<br>&#125; else &#123;<br>    <span class="hljs-keyword">user</span>List = <span class="hljs-keyword">user</span>InfoDAO.queryActive();<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="24-金额数值计算要使用BigDecimal"><a href="#24-金额数值计算要使用BigDecimal" class="headerlink" title="24.金额数值计算要使用BigDecimal"></a>24.金额数值计算要使用BigDecimal</h3><p>看下这个浮点数计算的例子吧：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DoubleTest &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">1.0</span><span class="hljs-number">-0.8</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">4.015</span>*<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-number">123.3</span>/<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">double</span> amount1 = <span class="hljs-number">3.15</span>;<br>        <span class="hljs-type">double</span> amount2 = <span class="hljs-number">2.10</span>;<br>        <span class="hljs-keyword">if</span> (amount1 - amount2 == <span class="hljs-number">1.05</span>)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;OK&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">0.30000000000000004<br>0.19999999999999996<br>401.49999999999994<br>1.2329999999999999<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>因为计算机是以二进制存储数值的，对于浮点数也是。对于计算机而言，0.1无法精确表达，这就是为什么浮点数会导致精确度缺失的。因此，金额计算，一般都是用BigDecimal 类型</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(0.1)</span>.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">BigDecimal(0.2)</span>));<br><span class="hljs-comment">//output:</span><br><span class="hljs-number">0.3000000000000000166533453693773481063544750213623046875</span><br>复制代码<br></code></pre></td></tr></table></figure><p>其实，使用 BigDecimal 表示和计算浮点数，必须使用字符串的构造方法来初始化 BigDecimal，并且，还要关注BigDecimal的几位小数点，它有八种舍入模式等</p><h3 id="25-注意Arrays-asList的几个坑"><a href="#25-注意Arrays-asList的几个坑" class="headerlink" title="25.  注意Arrays.asList的几个坑"></a>25.  注意Arrays.asList的几个坑</h3><ul><li><strong>基本类型不能作为 Arrays.asList方法的参数，否则会被当做一个参数。</strong></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayAsListTest</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        List <span class="hljs-built_in">list</span> = Arrays.asList(<span class="hljs-built_in">array</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-number">1</span><br>复制代码<br></code></pre></td></tr></table></figure><ul><li><strong>Arrays.asList 返回的 List 不支持增删操作。</strong></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ArrayAsListTest &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        String<span class="hljs-literal">[]</span> <span class="hljs-built_in">array</span> = &#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>&#125;;<br>        List <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">array</span>)</span>;<br>        <span class="hljs-built_in">list</span>.add(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-built_in">list</span>.size<span class="hljs-literal">()</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 运行结果</span><br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.UnsupportedOperationException<br>at java.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractList</span>.</span></span>add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractList</span>.</span></span>java:<span class="hljs-number">148</span>)<br>at java.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractList</span>.</span></span>add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractList</span>.</span></span>java:<span class="hljs-number">108</span>)<br>at <span class="hljs-keyword">object</span>.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayAsListTest</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayAsListTest</span>.</span></span>java:<span class="hljs-number">11</span>)<br><br>复制代码<br></code></pre></td></tr></table></figure><p>Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类ArrayList。内部类的ArrayList没有实现add方法，而是父类的add方法的实现，是会抛出异常的呢。</p><ul><li><strong>使用Arrays.asLis的时候，对原始数组的修改会影响到我们获得的那个List</strong></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ArrayAsListTest &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        String<span class="hljs-literal">[]</span> arr = &#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>&#125;;<br>        List <span class="hljs-built_in">list</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">arr</span>)</span>;<br>        arr<span class="hljs-literal">[<span class="hljs-number">1</span>]</span> = <span class="hljs-string">&quot;4&quot;</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;原始数组&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">arr</span>)</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;list数组&quot;</span> + <span class="hljs-built_in">list</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果</span><br>原始数组<span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]</span><br><span class="hljs-built_in">list</span>数组<span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]</span><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="26，及时关闭IO资源流"><a href="#26，及时关闭IO资源流" class="headerlink" title="26，及时关闭IO资源流"></a>26，及时关闭IO资源流</h3><p>应该大家都有过这样的经历，windows系统桌面如果打开太多文件或者系统软件，就会觉得电脑很卡。当然，我们linux服务器也一样，平时操作文件，或者数据库连接，IO资源流如果没关闭，那么这个IO资源就会被它占着，这样别人就没有办法用了，这就造成资源浪费。</p><p>所以使用完IO流，记得关闭哈。可以使用try-with-resource关闭的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 关注公众号，捡田螺的小男孩</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">try</span> (FileInputStream inputStream = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">FileInputStream</span>(<span class="hljs-params"><span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;jay.txt&quot;</span>)</span>)</span> &#123;<br>    <span class="hljs-comment">// use resources   </span><br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    log.error(e);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    log.error(e);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="27-尽量使用函数内的基本类型临时变量"><a href="#27-尽量使用函数内的基本类型临时变量" class="headerlink" title="27. 尽量使用函数内的基本类型临时变量"></a>27. 尽量使用函数内的基本类型临时变量</h3><blockquote><ul><li>在方法函数内，基本类型参数以及临时变量，都是保存在栈中的，访问速度比较快。</li><li>对象类型的参数和临时变量的引用都保存在栈中，内容都保存在堆中，访问速度较慢。</li><li>在类中，任何类型的成员变量都保存在堆（Heap）中，访问速度较慢。</li></ul></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccumulatorUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> result = <span class="hljs-number">0.0</span>D;<br>    <span class="hljs-comment">//反例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> addAllOne( <span class="hljs-built_in">double</span>[] values) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">double</span> value : values) &#123;<br>            result += value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//正例，先在方法内声明一个局部临时变量，累加完后，再赋值给方法外的成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> addAll1Two(<span class="hljs-built_in">double</span>[] values) &#123;<br>        <span class="hljs-built_in">double</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0.0</span>D;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">double</span> value : values) &#123;<br>            <span class="hljs-keyword">sum</span> += value;<br>        &#125;<br>        result += <span class="hljs-keyword">sum</span>;<br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="28-如果数据库一次查询的数量过多，建议分页处理。"><a href="#28-如果数据库一次查询的数量过多，建议分页处理。" class="headerlink" title="28. 如果数据库一次查询的数量过多，建议分页处理。"></a>28. 如果数据库一次查询的数量过多，建议分页处理。</h3><p>如果你的Sql一次性查出来的数据量比较多，建议分页处理。</p><p><strong>反例：</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> user_id,name,age <span class="hljs-keyword">from</span> user_info ;<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> user_id,name,age <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">limit</span> #&#123;<span class="hljs-keyword">offset</span>&#125;,#&#123;pageSize&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><p>如果偏移量特别大的时候，查询效率就变得低下。可以这接种方式优化：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//方案一 ：返回上次查询的最大记录(偏移量)<br><span class="hljs-keyword">select</span> id，<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">where</span> id&gt;<span class="hljs-number">10000</span> <span class="hljs-keyword">limit</span> #&#123;pageSize&#125;.<br><br>//方案二：<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> + 索引<br><span class="hljs-keyword">select</span> id，<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id  <span class="hljs-keyword">limit</span> #&#123;<span class="hljs-keyword">offset</span>&#125;,#&#123;pageSize&#125;<br><br>//方案三：在业务允许的情况下限制页数：<br><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="29-尽量减少对变量的重复计算"><a href="#29-尽量减少对变量的重复计算" class="headerlink" title="29. 尽量减少对变量的重复计算"></a>29. 尽量减少对变量的重复计算</h3><p>一般我们写代码的时候，会以以下的方式实现遍历：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>; i++)&#123;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>如果list数据量比较小那还好。如果list比较大时，可以优化成这样：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">length</span> = list.size; i &lt; <span class="hljs-built_in">length</span>; i++)&#123;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>理由：</p><ul><li>对方法的调用，即使是只有一个语句，也是有有消耗的，比如创建栈帧。如果list比较大时，多次调用list.size也是会有资源消耗的。</li></ul><h3 id="30-修改对外老接口的时候，思考接口的兼容性。"><a href="#30-修改对外老接口的时候，思考接口的兼容性。" class="headerlink" title="30. 修改对外老接口的时候，思考接口的兼容性。"></a>30. 修改对外老接口的时候，思考接口的兼容性。</h3><p>很多bug都是因为修改了对外老接口，但是却不做兼容导致的。关键这个问题多数是比较严重的，可能直接导致系统发版失败的。新手程序员很容易就犯这个错误了哦~</p><p>所以，如果你的需求是在原来接口上修改，，尤其这个接口是对外提供服务的话，一定要考虑接口兼容。举个例子吧，比如dubbo接口，原本是只接收A，B参数，现在你加了一个参数C，就可以考虑这样处理。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//老接口</span><br>void old<span class="hljs-constructor">Service(A,B)</span>;&#123;<br>  <span class="hljs-comment">//兼容新接口，传个null代替C</span><br>  <span class="hljs-keyword">new</span><span class="hljs-constructor">Service(A,B,<span class="hljs-params">null</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//新接口，暂时不能删掉老接口，需要做兼容。</span><br>void <span class="hljs-keyword">new</span><span class="hljs-constructor">Service(A,B,C)</span>;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="31-代码采取措施避免运行时错误（如数组边界溢出，被零除等）"><a href="#31-代码采取措施避免运行时错误（如数组边界溢出，被零除等）" class="headerlink" title="31 代码采取措施避免运行时错误（如数组边界溢出，被零除等）"></a>31 代码采取措施避免运行时错误（如数组边界溢出，被零除等）</h3><p>日常开发中，我们需要采取措施规避数组边界溢出，被零整除，空指针等运行时错误。</p><p>类似代码比较常见:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> name = <span class="hljs-built_in">list</span>.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>).getName(); <span class="hljs-comment">//list可能越界，因为不一定有2个元素哈</span><br>复制代码<br></code></pre></td></tr></table></figure><p>所以，应该采取措施，预防一下数组边界溢出，<strong>正例：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CollectionsUtil</span>.</span></span>is<span class="hljs-constructor">NotEmpty(<span class="hljs-params">list</span>)</span>&amp;&amp; <span class="hljs-built_in">list</span>.size<span class="hljs-literal">()</span>&gt;<span class="hljs-number">1</span>)&#123;<br>  String name = <span class="hljs-built_in">list</span>.get(<span class="hljs-number">1</span>).get<span class="hljs-constructor">Name()</span>; <br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="32-注意-ArrayList-toArray-强转的坑"><a href="#32-注意-ArrayList-toArray-强转的坑" class="headerlink" title="32. 注意 ArrayList.toArray() 强转的坑"></a>32. 注意 ArrayList.toArray() 强转的坑</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        List&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-string">&quot;公众号：捡田螺的小男孩&quot;</span>);<br>        <span class="hljs-built_in">String</span>[] array21 = (<span class="hljs-built_in">String</span>[])list.toArray();<span class="hljs-comment">//类型转换异常</span><br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>因为返回的是Object类型，Object类型数组强转String数组，会发生ClassCastException。解决方案是，使用toArray()重载方法toArray(T[] a)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span>[] array1 = <span class="hljs-built_in">list</span>.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>[<span class="hljs-number">0</span>]);<span class="hljs-comment">//可以正常运行</span><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="33-尽量不在循环里远程调用、或者数据库操作，优先考虑批量进行。"><a href="#33-尽量不在循环里远程调用、或者数据库操作，优先考虑批量进行。" class="headerlink" title="33. 尽量不在循环里远程调用、或者数据库操作，优先考虑批量进行。"></a>33. 尽量不在循环里远程调用、或者数据库操作，优先考虑批量进行。</h3><p>程操作或者数据库操作都是比较耗网络、IO资源的，所以尽量不在循环里远程调用、不在循环里操作数据库，能批量一次性查回来尽量不要循环多次去查。（但是呢，也不要一次性查太多数据哈，要分批500一次酱紫）</p><p><strong>正例：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">remote<span class="hljs-constructor">BatchQuery(<span class="hljs-params">param</span>)</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>反例：</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-variable">int</span> <span class="hljs-variable">i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">i</span>&lt;<span class="hljs-variable">n</span>;<span class="hljs-variable">i</span>++)&#123;</span><br><span class="hljs-function">  <span class="hljs-title">remoteSingleQuery</span>(<span class="hljs-variable">param</span>)</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="34-写完代码，脑洞一下多线程执行会怎样，注意并发一致性问题"><a href="#34-写完代码，脑洞一下多线程执行会怎样，注意并发一致性问题" class="headerlink" title="34. 写完代码，脑洞一下多线程执行会怎样，注意并发一致性问题"></a>34. 写完代码，脑洞一下多线程执行会怎样，注意并发一致性问题</h3><p>我们经常见的一些业务场景，就是先查下有没有记录，再进行对应的操作（比如修改）。但是呢，(查询+修改)合在一起不是原子操作哦，脑洞下多线程，就会发现有问题了，</p><p><strong>反例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-function"><span class="hljs-title">isAvailable</span>(<span class="hljs-params">ticketId</span>)</span>&#123;  <span class="hljs-comment">//非原子操作</span><br>    <span class="hljs-number">1</span>、给现金增加操作<br>    <span class="hljs-number">2</span>、deleteTicketById(ticketId)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;没有可用现金券&quot;</span>;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>为了更容易理解它，看这个流程图吧：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/image-20210404075941431.png" alt="image-20210404075941431"></p><ul><li>1.线程A加现金</li><li>2.线程B加现金</li><li>3.线程A删除票标志</li><li>4.线程B删除票标志</li></ul><p>显然这样存在并发问题，正例应该利用数据库删除操作的原子性，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(deleteAvailableTicketById(ticketId)</span></span> == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//原子操作</span><br>    <span class="hljs-number">1</span>、给现金增加操作<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    return “没有可用现金券”<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="35-多线程异步优先考虑恰当的线程池，而不是new-thread-同时考虑线程池是否隔离"><a href="#35-多线程异步优先考虑恰当的线程池，而不是new-thread-同时考虑线程池是否隔离" class="headerlink" title="35 多线程异步优先考虑恰当的线程池，而不是new thread,同时考虑线程池是否隔离"></a>35 多线程异步优先考虑恰当的线程池，而不是new thread,同时考虑线程池是否隔离</h3><p>为什么优先使用线程池？使用线程池有这几点好处呀</p><ul><li>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。</li><li>提高响应速度。</li><li>重复利用。</li></ul><p>同时呢，尽量不要所有业务都共用一个线程池，需要考虑线程池隔离。就是不同的关键业务，分配不同的线程池，然后线程池参数也要考虑恰当哈。之前写过几篇线程池的，觉得还不错，有兴趣的朋友可以看一下哈</p><h3 id="36-优化程序结构，尽量减少方法的重复调用"><a href="#36-优化程序结构，尽量减少方法的重复调用" class="headerlink" title="36. 优化程序结构，尽量减少方法的重复调用"></a>36. 优化程序结构，尽量减少方法的重复调用</h3><p><strong>反例：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listDetail</span><span class="hljs-params">(List&lt;UserInfo&gt; userInfoList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; userInfoList.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">//重复调用userList.size()方法了</span><br>        &#125;<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listDetail</span><span class="hljs-params">(List&lt;UserInfo&gt; userInfoList)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = userInfoList.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">//减少调用userList.size()方法，只在length变量调了一次。</span><br>        &#125;<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="37，直接大文件或者一次性从数据库读取太多数据到内存，可能导致OOM问题"><a href="#37，直接大文件或者一次性从数据库读取太多数据到内存，可能导致OOM问题" class="headerlink" title="37，直接大文件或者一次性从数据库读取太多数据到内存，可能导致OOM问题"></a>37，直接大文件或者一次性从数据库读取太多数据到内存，可能导致OOM问题</h3><p>如果一次性把大文件或者数据库太多数据达到内存，是会导致OOM的。所以，为什么查询DB数据库，一般都建议分批。</p><p>读取文件的话，一般文件不会太大，才使用Files.readAllLines()。为什么呢？因为它是直接把文件都读到内存的，预估下不会OOM才使用这个吧，可以看下它的源码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-keyword">String</span>&gt; readAllLines(Path path, Charset cs) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-keyword">BufferedReader</span> reader = newBufferedReader(path, cs)) &#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">String</span> <span class="hljs-built_in">line</span> = reader.readLine();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">line</span> == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">break</span>;<br>            result.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">line</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>如果是太大的文件，可以使用Files.line()按需读取，当时读取文件这些，一般是使用完需要关闭资源流的哈。</p><h3 id="38-调用第三方接口，需要考虑异常处理，安全性，超时重试这几个点。"><a href="#38-调用第三方接口，需要考虑异常处理，安全性，超时重试这几个点。" class="headerlink" title="38. 调用第三方接口，需要考虑异常处理，安全性，超时重试这几个点。"></a>38. 调用第三方接口，需要考虑异常处理，安全性，超时重试这几个点。</h3><p>日常开发中，经常需要调用第三方服务，或者分布式远程服务的的话，需要考虑：</p><ul><li>异常处理（比如，你调别人的接口，如果异常了，怎么处理，是重试还是当做失败）</li><li>超时（没法预估对方接口一般多久返回，一般设置个超时断开时间，以保护你的接口）</li><li>重试次数（你的接口调失败，需不需要重试，需要站在业务上角度思考这个问题）</li></ul><blockquote><p>简单一个例子，你一个http请求调别人的服务，需要考虑设置connect-time，和retry次数。</p></blockquote><h3 id="39-不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合"><a href="#39-不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合" class="headerlink" title="39 不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合"></a>39 不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合</h3><blockquote><ul><li>JDK提供原生API方法，可以直接指定集合的容量，避免多次扩容损耗性能。</li><li>这些方法的底层调用System.arraycopy方法实现，进行数据的批量拷贝效率更高。</li></ul></blockquote><p><strong>反例：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pf">public List<span class="hljs-variable">&lt;UserInfo&gt;</span> copyMergeList(List<span class="hljs-variable">&lt;UserInfo&gt;</span> user1List, List<span class="hljs-variable">&lt;UserInfo&gt;</span> user2List) &#123;<br>     List<span class="hljs-variable">&lt;UserInfo&gt;</span> <span class="hljs-keyword">user</span>List = new ArrayList<span class="hljs-variable">&lt;&gt;</span>(user1List.size() + user2List.size());<br>     <span class="hljs-keyword">for</span> (UserInfo <span class="hljs-keyword">user</span> : user1List) &#123;<br>         <span class="hljs-keyword">user</span>List.add(<span class="hljs-keyword">user</span>);<br>     &#125;<br>     <span class="hljs-keyword">for</span> (UserInfo <span class="hljs-keyword">user</span> : user2List) &#123;<br>         <span class="hljs-keyword">user</span>List.add(<span class="hljs-keyword">user</span>);<br>     &#125;<br><br>     return user1List;<br> &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">public List<span class="hljs-variable">&lt;UserInfo&gt;</span> copyMergeList(List<span class="hljs-variable">&lt;UserInfo&gt;</span> user1List, List<span class="hljs-variable">&lt;UserInfo&gt;</span> user2List) &#123;<br>     List<span class="hljs-variable">&lt;UserInfo&gt;</span> <span class="hljs-keyword">user</span>List = new ArrayList<span class="hljs-variable">&lt;&gt;</span>(user1List.size() + user2List.size());<br>     <span class="hljs-keyword">user</span>List.addAll(user1List);<br>     <span class="hljs-keyword">user</span>List.addAll(user2List);<br>     return user1List;<br> &#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="40-对于复杂的代码逻辑，添加清楚的注释"><a href="#40-对于复杂的代码逻辑，添加清楚的注释" class="headerlink" title="40. 对于复杂的代码逻辑，添加清楚的注释"></a>40. 对于复杂的代码逻辑，添加清楚的注释</h3><p>写代码的时候，是没有必要写太多的注释的，好的方法变量命名就是最好的注释。但是，如果是业务逻辑很复杂的代码，真的非常有必要写清楚注释。清楚的注释，更有利于后面的维护。</p><h3 id="41-多线程情况下，考虑线性安全问题"><a href="#41-多线程情况下，考虑线性安全问题" class="headerlink" title="41. 多线程情况下，考虑线性安全问题"></a>41. 多线程情况下，考虑线性安全问题</h3><p>在高并发情况下，HashMap可能会出现死循环。因为它是非线性安全的，可以考虑使用ConcurrentHashMap。 所以这个也尽量养成习惯，不要上来反手就是一个new HashMap();</p><ul><li>Hashmap、Arraylist、LinkedList、TreeMap等都是线性不安全的；</li><li>Vector、Hashtable、ConcurrentHashMap等都是线性安全的</li></ul><h3 id="42-使用spring事务功能时，注意这几个事务未生效的坑"><a href="#42-使用spring事务功能时，注意这几个事务未生效的坑" class="headerlink" title="42. 使用spring事务功能时，注意这几个事务未生效的坑"></a>42. 使用spring事务功能时，注意这几个事务未生效的坑</h3><p>日常业务开发中，我们经常跟事务打交道，事务失效主要有以下几个场景：</p><ul><li>底层数据库引擎不支持事务</li><li>在非public修饰的方法使用</li><li>rollbackFor属性设置错误</li><li>本类方法直接调用</li><li>异常被try…catch吃了，导致事务失效。</li></ul><p><strong>反例：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionTest</span></span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//插入一条数据</span><br>    <span class="hljs-comment">//调用方法B (本地的类调用，事务失效了)</span><br>    B();<br>  &#125;<br>  <br>  <span class="hljs-meta">@Transactional</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">B</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//插入数据</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>注解的事务方法给本类方法直接调用，事务失效</strong></p><h3 id="43-使用Executors声明线程池，newFixedThreadPool的OOM问题"><a href="#43-使用Executors声明线程池，newFixedThreadPool的OOM问题" class="headerlink" title="43. 使用Executors声明线程池，newFixedThreadPool的OOM问题"></a>43. 使用Executors声明线程池，newFixedThreadPool的OOM问题</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> ExecutorService executor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(10)</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;<br>            executor.execute(<span class="hljs-literal">()</span> -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">10000</span>);<br>                &#125; catch (InterruptedException e) &#123;<br>                    <span class="hljs-comment">//do nothing</span><br>                &#125;<br>            &#125;);<br>        &#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>IDE指定JVM参数：-Xmx8m -Xms8m :</p><p><img src="/Users/cuixiaoyan/Library/Application%20Support/typora-user-images/image-20210404080311614.png" alt="image-20210404080311614"></p><p>运行结果：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/image-20210404080325825.png" alt="image-20210404080325825"></p><p>我们看下源码，其实newFixedThreadPool使用的是无界队列！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(int nThreads) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">AbstractQueue</span></span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">BlockingQueue</span></span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of</span><br><span class="hljs-comment">     * &#123;@link Integer#MAX_VALUE&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> LinkedBlockingQueue() &#123;<br>        <span class="hljs-built_in">this</span>(Integer.MAX_VALUE);<br>    &#125;<br>...<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>newFixedThreadPool线程池的核心线程数是固定的，它使用了近乎于无界的LinkedBlockingQueue阻塞队列。当核心线程用完后，任务会入队到阻塞队列，如果任务执行的时间比较长，没有释放，会导致越来越多的任务堆积到阻塞队列，最后导致机器的内存使用不停的飙升，造成JVM OOM。</p></blockquote><h3 id="44-catch住异常后，尽量不要使用e-printStackTrace-而是使用log打印。"><a href="#44-catch住异常后，尽量不要使用e-printStackTrace-而是使用log打印。" class="headerlink" title="44. catch住异常后，尽量不要使用e.printStackTrace(),而是使用log打印。"></a>44. catch住异常后，尽量不要使用e.printStackTrace(),而是使用log打印。</h3><p><strong>反例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// do what you want  </span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  e.printStackTrace();<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// do what you want  </span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;你的程序有异常啦&quot;</span>,e);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="45-接口需要考虑幂等性"><a href="#45-接口需要考虑幂等性" class="headerlink" title="45. 接口需要考虑幂等性"></a>45. 接口需要考虑幂等性</h3><p>接口是需要考虑幂等性的，尤其抢红包、转账这些重要接口。最直观的业务场景，就是用户连着点两次，你的接口有没有hold住。</p><p>一般幂等技术方案有这几种:</p><ul><li>查询操作</li><li>唯一索引</li><li>token机制，防止重复提交</li><li>数据库的delete/update操作</li><li>乐观锁</li><li>悲观锁</li><li>Redis、zookeeper 分布式锁（以前抢红包需求，用了Redis分布式锁）</li><li>状态机幂等</li></ul><h3 id="46-对于行数比较多的函数，建议划分小函数，增强可读性。"><a href="#46-对于行数比较多的函数，建议划分小函数，增强可读性。" class="headerlink" title="46. 对于行数比较多的函数，建议划分小函数，增强可读性。"></a>46. 对于行数比较多的函数，建议划分小函数，增强可读性。</h3><p><strong>反例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;<br>    private String <span class="hljs-type">name</span>;<br>    private Vector&lt;<span class="hljs-keyword">Order</span>&gt; orders = <span class="hljs-built_in">new</span> Vector&lt;<span class="hljs-keyword">Order</span>&gt;();<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> printOwing() &#123;<br>        //print banner<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;****************&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;*****customer Owes *****&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;****************&quot;);<br><br>        //calculate totalAmount<br>        Enumeration env = orders.elements();<br>        <span class="hljs-type">double</span> totalAmount = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">while</span> (env.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">Order</span> <span class="hljs-keyword">order</span> = (<span class="hljs-keyword">Order</span>) env.nextElement();<br>            totalAmount += <span class="hljs-keyword">order</span>.getAmout();<br>        &#125;<br><br>        //print details<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;name:&quot; + <span class="hljs-type">name</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;amount:&quot; + totalAmount);<br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;<br>    private String <span class="hljs-type">name</span>;<br>    private Vector&lt;<span class="hljs-keyword">Order</span>&gt; orders = <span class="hljs-built_in">new</span> Vector&lt;<span class="hljs-keyword">Order</span>&gt;();<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> printOwing() &#123;<br><br>        //print banner<br>        printBanner();<br>        //calculate totalAmount<br>        <span class="hljs-type">double</span> totalAmount = getTotalAmount();<br>        //print details<br>        printDetail(totalAmount);<br>    &#125;<br><br>    <span class="hljs-type">void</span> printBanner()&#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;****************&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;*****customer Owes *****&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;****************&quot;);<br>    &#125;<br><br>    <span class="hljs-type">double</span> getTotalAmount()&#123;<br>        Enumeration env = orders.elements();<br>        <span class="hljs-type">double</span> totalAmount = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">while</span> (env.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">Order</span> <span class="hljs-keyword">order</span> = (<span class="hljs-keyword">Order</span>) env.nextElement();<br>            totalAmount += <span class="hljs-keyword">order</span>.getAmout();<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalAmount;<br>    &#125;<br><br>    <span class="hljs-type">void</span> printDetail(<span class="hljs-type">double</span> totalAmount)&#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;name:&quot; + <span class="hljs-type">name</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;amount:&quot; + totalAmount);<br>    &#125;<br>    <br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>一个过于冗长的函数或者一段需要注释才能让人理解用途的代码，可以考虑把它切分成一个功能明确的函数单元，并定义清晰简短的函数名，这样会让代码变得更加优雅。</p><h3 id="47-你的关键业务代码，一般建议搞点日志保驾护航。"><a href="#47-你的关键业务代码，一般建议搞点日志保驾护航。" class="headerlink" title="47. 你的关键业务代码，一般建议搞点日志保驾护航。"></a>47. 你的关键业务代码，一般建议搞点日志保驾护航。</h3><p>关键业务代码无论身处何地，都应该有足够的日志保驾护航。</p><blockquote><p>比如：你实现转账业务，转个几百万，然后转失败了，接着客户投诉，然后你还没有打印到日志，想想那种水深火热的困境下，你却毫无办法。。。</p></blockquote><p>那么，你的转账业务都需要那些日志信息呢？至少，方法调用前，入参需要打印需要吧，接口调用后，需要捕获一下异常吧，同时打印异常相关日志吧，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(TransferDTO transferDTO)</span></span>&#123;<br>    <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;invoke tranfer begin&quot;</span>);<br>    <span class="hljs-comment">//打印入参</span><br>    <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;invoke tranfer,paramters:&#123;&#125;&quot;</span>,transferDTO);<br>    <span class="hljs-keyword">try</span> &#123;<br>      res=  transferService.<span class="hljs-built_in">transfer</span>(transferDTO);<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>     <span class="hljs-built_in">log</span>.error(<span class="hljs-string">&quot;transfer fail,cifno:&#123;&#125;，account：&#123;&#125;&quot;</span>,transferDTO.getCifno（），<br>     transferDTO.getaccount（）)<br>     <span class="hljs-built_in">log</span>.error(<span class="hljs-string">&quot;transfer fail,exception:&#123;&#125;&quot;</span>,e);<br>    &#125;<br>    <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;invoke tranfer end&quot;</span>);<br>    &#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>除了打印足够的日志，我们还需要注意一点是，日志级别别混淆使用，别本该打印info的日志，你却打印成error级别，告警半夜三更催你起来排查问题就不好了。</p><h3 id="48-某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。"><a href="#48-某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。" class="headerlink" title="48. 某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。"></a>48. 某些可变因素，如红包皮肤等等，做成配置化是否会更好呢。</h3><p>假如产品提了个红包需求，圣诞节的时候，红包皮肤为圣诞节相关的，春节的时候，红包皮肤等。</p><p>反例:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">if</span>(duringChristmas)&#123;<br>   img = redPacketChristmasSkin;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(duringSpringFestival)&#123;<br>   img =  redSpringFestivalSkin;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>如果到了元宵节的时候，运营小姐姐突然又有想法，红包皮肤换成灯笼相关的，这时候，是不是要去修改代码了，重新发布了？从一开始，实现一张红包皮肤的配置表，将红包皮肤做成配置化呢？更换红包皮肤，只需修改一下表数据就好了。</p><h3 id="49，-直接迭代需要使用的集合-无须在额外操作"><a href="#49，-直接迭代需要使用的集合-无须在额外操作" class="headerlink" title="49，.直接迭代需要使用的集合,无须在额外操作"></a>49，.直接迭代需要使用的集合,无须在额外操作</h3><p>直接迭代需要使用的集合，无需通过其它操作获取数据，比较典型就是Map的迭代遍历：</p><p><strong>反例：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">Map<span class="hljs-variable">&lt;Long, UserDO&gt;</span> <span class="hljs-keyword">user</span>Map = ...;<br><span class="hljs-keyword">for</span> (Long <span class="hljs-keyword">user</span>Id : <span class="hljs-keyword">user</span>Map.keySet()) &#123;<br>    UserDO <span class="hljs-keyword">user</span> = <span class="hljs-keyword">user</span>Map.get(<span class="hljs-keyword">user</span>Id);<br>    ...<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>正例：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">Map<span class="hljs-variable">&lt;Long, UserDO&gt;</span> <span class="hljs-keyword">user</span>Map = ...;<br><span class="hljs-keyword">for</span> (Map.Entry<span class="hljs-variable">&lt;Long, UserDO&gt;</span> <span class="hljs-keyword">user</span>Entry : <span class="hljs-keyword">user</span>Map.entrySet()) &#123;<br>    Long <span class="hljs-keyword">user</span>Id = <span class="hljs-keyword">user</span>Entry.getKey();<br>    UserDO <span class="hljs-keyword">user</span> = <span class="hljs-keyword">user</span>Entry.getValue();<br>    ...<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="50-策略模式-工厂方法优化冗余的if-else"><a href="#50-策略模式-工厂方法优化冗余的if-else" class="headerlink" title="50. 策略模式+工厂方法优化冗余的if else"></a>50. 策略模式+工厂方法优化冗余的if else</h3><p>反例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">    String medalType = <span class="hljs-string">&quot;guest&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;guest&quot;</span>.<span class="hljs-keyword">equals</span>(medalType)) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;嘉宾勋章&quot;</span>);<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;vip&quot;</span>.<span class="hljs-keyword">equals</span>(medalType)) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;会员勋章&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;guard&quot;</span>.<span class="hljs-keyword">equals</span>(medalType)) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;展示守护勋章&quot;</span>);<br>    &#125;<br>    ...<br><br>复制代码<br></code></pre></td></tr></table></figure><p>首先，我们把每个条件逻辑代码块，抽象成一个公共的接口，我们根据每个逻辑条件，定义相对应的策略实现类，可得以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//勋章接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMedalService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showMedal</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//守护勋章策略实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardMedalServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMedalService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMedal</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;展示守护勋章&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//嘉宾勋章策略实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuestMedalServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMedalService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMedal</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;嘉宾勋章&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//VIP勋章策略实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VipMedalServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMedalService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMedal</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;会员勋章&quot;</span>);<br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>接下来，我们再定义策略工厂类，用来管理这些勋章实现策略类，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//勋章服务工产类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedalServicesFactory</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;<span class="hljs-keyword">String</span>, IMedalService&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;guard&quot;</span>, <span class="hljs-keyword">new</span> GuardMedalServiceImpl());<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;vip&quot;</span>, <span class="hljs-keyword">new</span> VipMedalServiceImpl());<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;guest&quot;</span>, <span class="hljs-keyword">new</span> GuestMedalServiceImpl());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IMedalService <span class="hljs-title">getMedalService</span><span class="hljs-params">(<span class="hljs-keyword">String</span> medalType)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(medalType);<br>    &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>优化后，正例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">ublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">String</span> medalType = <span class="hljs-string">&quot;guest&quot;</span>;<br>        IMedalService medalService = MedalServicesFactory.getMedalService(medalType);<br>        medalService.showMedal();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/blog/2021/03/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/03/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>这里虚拟一个业务需求，让大家容易理解。假设有一个订单系统，里面的一个功能是根据订单的不同类型作出不同的处理。</p><p>订单实体：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/dd35d29f4a5c41b5bd8b03679bfcc0bf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>service接口：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6ff1cd688d7c42d0a739a0bfacad449f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="传统实现"><a href="#传统实现" class="headerlink" title="传统实现"></a>传统实现</h4><p>根据订单类型写一堆的if else：</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><h4 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h4><p>利用策略模式，只需要两行即可实现业务逻辑：</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>可以看到上面的方法中注入了HandlerContext，这是一个处理器上下文，用来保存不同的业务处理器，具体在下文会讲解。我们从中获取一个抽象的处理器AbstractHandler，调用其方法实现业务逻辑。</p><p>现在可以了解到，我们主要的业务逻辑是在处理器中实现的，因此有多少个订单类型，就对应有多少个处理器。以后需求变化，增加了订单类型，只需要添加相应的处理器就可以，上述OrderServiceV2Impl完全不需改动。</p><p>我们先看看业务处理器的写法：</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/e0f051a781254871b99822b8201a934e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>首先每个处理器都必须添加到spring容器中，因此需要加上@Component注解，其次需要加上一个自定义注解@HandlerType，用于标识该处理器对应哪个订单类型，最后就是继承AbstractHandler，实现自己的业务逻辑。</p><p>自定义注解 @HandlerType：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8032c90d458e48ec8af53cd379df9e97~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>抽象处理器 AbstractHandler：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/886e68e0466645b6a474a675c29cc872~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>自定义注解和抽象处理器都很简单，那么如何将处理器注册到spring容器中呢？</p><p><strong>具体思路是：</strong></p><p>1、扫描指定包中标有@HandlerType的类；</p><p>2、将注解中的类型值作为key，对应的类作为value，保存在Map中；</p><p>3、以上面的map作为构造函数参数，初始化HandlerContext，将其注册到spring容器中；</p><p>我们将核心的功能封装在HandlerProcessor类中，完成上面的功能。</p><p>HandlerProcessor：</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><h3 id="ClassScanner：扫描工具类源码"><a href="#ClassScanner：扫描工具类源码" class="headerlink" title="ClassScanner：扫描工具类源码"></a>ClassScanner：扫描工具类源码</h3><p>HandlerProcessor需要实现BeanFactoryPostProcessor，在spring处理bean前，将自定义的bean注册到容器中。</p><p>核心工作已经完成，现在看看HandlerContext如何获取对应的处理器：</p><p>HandlerContext：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2ca36049758a4e3cb87d2ce13c45f5f9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>BeanTool：获取bean工具类</p><p><code>#getInstance</code> 方法根据类型获取对应的class，然后根据class类型获取注册到spring中的bean。</p><p>最后请注意一点，HandlerProcessor和BeanTool必须能被扫描到，或者通过@Bean的方式显式的注册，才能在项目启动时发挥作用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>利用策略模式可以简化繁杂的if else代码，方便维护，而利用自定义注解和自注册的方式，可以方便应对需求的变更。本文只是提供一个大致的思路，还有很多细节可以灵活变化，例如使用枚举类型、或者静态常量，作为订单的类型，相信你能想到更多更好的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>策略模式</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗讲解分布式锁</title>
    <link href="/blog/2021/03/26/%E9%80%9A%E4%BF%97%E8%AE%B2%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/blog/2021/03/26/%E9%80%9A%E4%BF%97%E8%AE%B2%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>首先，分布式锁和我们平常讲到的锁原理基本一样，目的就是确保在多个线程并发时，只有一个线程在同一刻操作这个业务或者说方法、变量。</p><p>在一个进程中，也就是一个 jvm 或者说应用中，我们很容易去处理控制，在 jdk java.util 并发包中已经为我们提供了这些方法去加锁，比如 synchronized 关键字或者 Lock 锁，都可以处理。</p><p>但是我们现在的应用程序如果只部署一台服务器，那并发量是很差的，如果同时有上万的请求，很有可能造成服务器压力过大而瘫痪。想想双十一和大年三十晚上十点，瓜分支付宝红包等业务场景，自然需要用到多台服务器去同时处理这些业务，这些服务可能会有上百台同时处理。</p><p>但是我们想一想，如果有 100 台服务器要处理分红包的业务，现在假设有 1 亿的红包，1 千万个人分，金额随机，那么这个业务场景下，是不是必须确保这 1 千万个人最后分的红包金额总和等于 1 亿？</p><p>如果处理不好每人分到 100 万，那马云爸爸估计大年初一，就得宣布破产了</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/c7867412524a41bfa8f8ad3ff471f99a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="一、常规锁会造成什么情况？"><a href="#一、常规锁会造成什么情况？" class="headerlink" title="一、常规锁会造成什么情况？"></a>一、常规锁会造成什么情况？</h3><p>首先说一下我们为什么要搞集群。</p><p>简单理解就是，需求量（请求并发量）变大了，一个工人处理能力有限，那就多招一些工人来一起处理。</p><p>假设 1 千万个请求平均分配到 100 台服务器上，每个服务器接收 10w 的请求。这 10w 个请求并不是在同一秒中来的，可能是在 1,2 个小时内，可以联想下我们三十晚上开红包，等到 10：20 开始，有的人立马开了，有的人等到 12 点才想起来。</p><p>那这样的话，平均到每一秒上的请求也就不到 1 千个，这种压力一般的服务器还是可以承受的。</p><ul><li>第一个用户来分，请求到来后，需要在 1 亿里面给他分一部分钱，金额随机，假设第一个人分到了 100，那就要在这 1 亿中减去 100 块，剩下 99999900 块~</li><li>第二个用户再来分，金额随机，这次分 200 块，那就需要在剩下的 99999900 块中再减去 200 块，剩下 99999700 块。</li><li>等到第 10w 个用户来，一看还有 1000w，那这 1000w 全成他的了。</li></ul><p>等于是在每个服务器中去分 1 亿，也就是 10w 个用户分了一个亿，最后总计有 100 个服务器，要分 100 亿。</p><p>如果真这样了，虽说马云爸爸不会破产（据最新统计马云有 2300 亿人民币），那分红包的开发项目组，以及产品经理，可以 GG 了~</p><p>简化结构图如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/9b9bc469743c480aa3985bb95baa0ddf~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="二、分布式锁怎么去处理？"><a href="#二、分布式锁怎么去处理？" class="headerlink" title="二、分布式锁怎么去处理？"></a>二、分布式锁怎么去处理？</h3><p>那么为了解决这个问题，让 1000 万用户只分 1 亿，而不是 100 亿，这个时候分布式锁就派上用处了。</p><p>分布式锁可以把整个集群就当作是一个应用一样去处理，那么也就需要这个锁独立于每一个服务之外，而不是在服务里面。</p><p>假设第一个服务器接收到用户 1 的请求后，不能只在自己的应用中去判断还有多少钱可以分了，而需要去外部请求专门负责管理这 1 亿红包的人（服务），问他：哎，我这里要分 100 块，给我 100。</p><p>管理红包的妹子（服务）一看，还有 1 个亿，那好，给你 100 块，然后剩下 99999900 块。</p><p>第二个请求到来后，被服务器 2 获取，继续去询问，管理红包的妹子，我这边要分 10 块，管理红包的妹子先查了下还有 99999900，那就说：好，给你 10 块。那就剩下 99999890 块。</p><p>等到第 1000w 个请求到来后，服务器 100 拿到请求，继续去询问，管理红包的妹子，我要 100，妹子翻了翻白眼，对你说，就剩 1 块了，爱要不要，那这个时候就只能给你 1 块了（1 块也是钱啊，买根辣条还是可以的）。</p><p>这些请求编号 1,2 不代表执行的先后顺序，正式的场景下，应该是 100 台服务器每个服务器持有一个请求去访问负责管理红包的妹子（服务），那在管红包的妹子那里同时会接收到 100 个请求，这个时候就需要在负责红包的妹子那里加个锁就可以了（抛绣球），你们 100 个服务器谁拿到锁（抢到绣球），谁就进来和我谈，我给你分，其他人就等着去吧。</p><p>经过上面的分布式锁的处理后，马云爸爸终于放心了，决定给红包团队每人加一个鸡腿。</p><p>简化的结构图如下：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ded345e3baf24d21a402418bc78ac2c0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="三、分布式锁的实现有哪些？"><a href="#三、分布式锁的实现有哪些？" class="headerlink" title="三、分布式锁的实现有哪些？"></a>三、分布式锁的实现有哪些？</h3><p>说到分布式锁的实现，还是有很多的，有数据库方式的，有 Redis 分布式锁，有 Zookeeper 分布式锁等等。</p><p>我们如果采用 Redis 作为分布式锁，那么上图中负 “责红包的妹子（服务）”，就可以替换成 Redis，请自行脑补。</p><p><strong>1、为什么 Redis 可以实现分布式锁？</strong></p><p>首先 Redis 是单线程的，这里的单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><p>在实际的操作中过程大致是这样子的：</p><p>服务器 1 要去访问发红包的妹子，也就是 Redis，那么他会在 Redis 中通过 “setnx key value” 操作设置一个 key 进去，value 是啥不重要，重要的是要有一个 key，也就是一个标记，而且这个 key 你爱叫啥叫啥，只要所有的服务器设置的 key 相同就可以。</p><p>假设我们设置一个，如下图：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/ba01791955c4422d8d83124405591598~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>那么我们可以看到会返回一个 1，那就代表了成功。</p><p>如果再来一个请求去设置同样的 key，如下图：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/32b815d1f0f94cd9a563bd678a3dabc5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这个时候会返回 0，那就代表失败了。</p><p>那么我们就可以通过这个操作去判断是不是当前可以拿到锁，或者说可以去访问 “负责发红包的妹子”，如果返回 1，那我就开始去执行后面的逻辑，如果返回 0，那就说明已经被人占用了，我就要继续等待。</p><p>当服务器 1 拿到锁之后，进行了业务处理，完成后，还需要释放锁，如下图所示：</p><p>删除成功返回 1，那么其他的服务器就可以继续重复上面的步骤去设置这个 key，以达到获取锁的目的。</p><p>当然以上的操作是在 Redis 客户端直接进行的，通过程序调用的话，肯定就不能这么写，比如 java 就需要通过 jedis 去调用，但是整个处理逻辑基本都是一样的。</p><p>通过上面的方式，我们好像是解决了分布式锁的问题，但是想想还有没有什么问题呢？</p><p>对，问题还是有的，可能会有死锁的问题发生，比如服务器 1 设置完之后，获取了锁之后，忽然发生了宕机。</p><p>那后续的删除 key 操作就没法执行，这个 key 会一直在 Redis 中存在，其他服务器每次去检查，都会返回 0，他们都会认为有人在使用锁，我需要等。</p><p>为了解决这个死锁的问题，我们就需要给 key 设置有效期了。</p><p>设置的方式有 2 种：</p><ul><li>第一种就是在 set 完 key 之后，直接设置 key 的有效期 “expire key timeout” ，为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li></ul><p>这种方式相当于，把锁持有的有效期，交给了 Redis 去控制。如果时间到了，你还没有给我删除 key，那 Redis 就直接给你删了，其他服务器就可以继续去 setnx 获取锁。</p><ul><li>第二种方式，就是把删除 key 权利交给其他的服务器，那这个时候就需要用到 value 值了，比如服务器 1，设置了 value 也就是 timeout 为当前时间 + 1 秒 ，这个时候服务器 2 通过 get 发现时间已经超过系统当前时间了，那就说明服务器 1 没有释放锁，服务器 1 可能出问题了，服务器 2 就开始执行删除 key 操作，并且继续执行 setnx 操作。</li></ul><p>但是这块有一个问题，也就是不光你服务器 2 可能会发现服务器 1 超时了，服务器 3 也可能会发现，如果刚好服务器 2 setnx 操作完成，服务器 3 就接着删除，是不是服务器 3 也可以 setnx 成功了？</p><p>那就等于是服务器 2 和服务器 3 都拿到锁了，那就问题大了。这个时候怎么办呢？</p><p>这个时候需要用到 “GETSET  key value” 命令了。这个命令的意思就是获取当前 key 的值，并且设置新的值。</p><p>假设服务器 2 发现 key 过期了，开始调用 getset 命令，然后用获取的时间判断是否过期，如果获取的时间仍然是过期的，那就说明拿到锁了。</p><p>如果没有，则说明在服务 2 执行 getset 之前，服务器 3 可能也发现锁过期了，并且在服务器 2 之前执行了 getset 操作，重新设置了过期时间。</p><p>那么服务器 2 就需要放弃后续的操作，继续等待服务器 3 释放锁或者去监测 key 的有效期是否过期。</p><p>这块其实有一个小问题是，服务器 3 已经修改了有效期，拿到锁之后，服务器 2 也修改了有效期，但是没能拿到锁，但是这个有效期的时间已经被在服务器 3 的基础上有增加一些，但是这种影响其实还是很小的，几乎可以忽略不计。</p><p><strong>2、为什么 Zookeeper 可实现分布式锁？</strong></p><p>百度百科是这么介绍的：ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。</p><p>那对于我们初次认识的人，可以理解成 ZooKeeper 就像是我们的电脑文件系统，我们可以在 d 盘中创建文件夹 a，并且可以继续在文件夹 a 中创建文件夹 a1，a2。</p><p>那我们的文件系统有什么特点？那就是同一个目录下文件名称不能重复，同样 ZooKeeper 也是这样的。</p><p>在 ZooKeeper 所有的节点，也就是文件夹称作 Znode，而且这个 Znode 节点是可以存储数据的。</p><p>我们可以通过 “create /zkjjj nice” 来创建一个节点，这个命令就表示，在跟目录下创建一个 zkjjj 的节点，值是 nice。同样这里的值，和我在前面说的 Redis 中的一样，没什么意义，你随便给。</p><p>另外 ZooKeeper 可以创建 4 种类型的节点，分别是：</p><ul><li>持久性节点</li><li>持久性顺序节点</li><li>临时性节点</li><li>临时性顺序节点</li></ul><p>首先说下持久性节点和临时性节点的区别：</p><ul><li>持久性节点表示只要你创建了这个节点，那不管你 ZooKeeper 的客户端是否断开连接，ZooKeeper 的服务端都会记录这个节点；</li><li>临时性节点刚好相反，一旦你 ZooKeeper 客户端断开了连接，那 ZooKeeper 服务端就不再保存这个节点；</li><li>顺便也说下顺序性节点，顺序性节点是指，在创建节点的时候，ZooKeeper 会自动给节点编号比如 0000001，0000002 这种的。</li></ul><p>Zookeeper 有一个监听机制，客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）等，Zookeeper 会通知客户端。</p><h3 id="四、在-Zookeeper-中如何加锁？"><a href="#四、在-Zookeeper-中如何加锁？" class="headerlink" title="四、在 Zookeeper 中如何加锁？"></a>四、在 Zookeeper 中如何加锁？</h3><p>下面我们继续结合我们上面的分红包场景，描述下在 Zookeeper 中如何加锁。</p><p>假设服务器 1，创建了一个节点 /zkjjj，成功了，那服务器 1 就获取了锁，服务器 2 再去创建相同的锁，就会失败，这个时候就只能监听这个节点的变化。</p><p>等到服务器 1 处理完业务，删除了节点后，他就会得到通知，然后去创建同样的节点，获取锁处理业务，再删除节点，后续的 100 台服务器与之类似。</p><p>注意这里的 100 台服务器并不是挨个去执行上面的创建节点的操作，而是并发的，当服务器 1 创建成功，那么剩下的 99 个就都会注册监听这个节点，等通知，以此类推。</p><p>但是大家有没有注意到，这里还是有问题的，还是会有死锁的情况存在，对不对？</p><p>当服务器 1 创建了节点后挂了，没能删除，那其他 99 台服务器就会一直等通知，那就完蛋了。。。</p><p>这个时候就需要用到临时性节点了，我们前面说过了，临时性节点的特点是客户端一旦断开，就会丢失，也就是当服务器 1 创建了节点后，如果挂了，那这个节点会自动被删除，这样后续的其他服务器，就可以继续去创建节点，获取锁了。</p><p>但是我们可能还需要注意到一点，就是惊群效应：举一个很简单的例子，当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到…</p><p>就是当服务器 1 节点有变化，会通知其余的 99 个服务器，但是最终只有 1 个服务器会创建成功，这样 98 还是需要等待监听，那么为了处理这种情况，就需要用到临时顺序性节点。大致意思就是，之前是所有 99 个服务器都监听一个节点，现在就是每一个服务器监听自己前面的一个节点。</p><p>假设 100 个服务器同时发来请求，这个时候会在 / zkjjj 节点下创建 100 个临时顺序性节点<code>/zkjjj/000000001</code>，<code>/zkjjj/000000002</code>，一直到<code>/zkjjj/000000100</code>，这个编号就等于是已经给他们设置了获取锁的先后顺序了。</p><p>当 001 节点处理完毕，删除节点后，002 收到通知，去获取锁，开始执行，执行完毕，删除节点，通知 003~ 以此类推</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口调用失败的退避策略</title>
    <link href="/blog/2021/03/25/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%80%80%E9%81%BF%E7%AD%96%E7%95%A5/"/>
    <url>/blog/2021/03/25/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%80%80%E9%81%BF%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="退避策略简介"><a href="#退避策略简介" class="headerlink" title="退避策略简介"></a>退避策略简介</h2><p>在开发过程中我们经常会遇到调用接口失败的情况。遇到这种情况，我们有时候需要重试机制，常用的重试（退避）策略有：</p><ol><li>固定的时间间隔重试一次，最多重试N次：比如我现在一个接口调用失败了，不是立马返回失败，而是hold住线程，每隔2秒重新调下接口，最多调5次，只要其中一次成功了就直接返回。如果5次都没成功，接口返回失败。</li><li>指数时间间隔尝试策略：和上面策略一样，接口调用失败后也不是直接返回，但是重试的时间间隔呈指数增加。比如第一次时间间隔是2s，第二次次4s，依次增加。当然你也可以设置最大的尝试次数和最大的尝试时间。</li></ol><h3 id="Spring中的退避策略工具类"><a href="#Spring中的退避策略工具类" class="headerlink" title="Spring中的退避策略工具类"></a>Spring中的退避策略工具类</h3><h4 id="FixedBackOff"><a href="#FixedBackOff" class="headerlink" title="FixedBackOff"></a>FixedBackOff</h4><p>FixedBackOff是Spring自带的支持固定时间退避策略的工具类。这个类使用起来非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> interval = <span class="hljs-number">1000</span>;   <span class="hljs-comment">//重试间隔    1s重试一次</span><br><span class="hljs-keyword">long</span> maxAttempts = <span class="hljs-number">10</span>;  <span class="hljs-comment">//最大重试次数 最多重试10次</span><br>BackOff backOff = <span class="hljs-keyword">new</span> FixedBackOff(interval, maxAttempts);<br>BackOffExecution execution = backOff.start();<br> <br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>    <span class="hljs-keyword">long</span> value = execution.nextBackOff();<br>    <span class="hljs-keyword">if</span>(value == BackOffExecution.STOP)&#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//在这里写你的重试逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ExponentialBackOff"><a href="#ExponentialBackOff" class="headerlink" title="ExponentialBackOff"></a>ExponentialBackOff</h4><p>ExponentialBackOff是支持尝试间隔呈指数增加的工具类，使用方式和上面类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> initialInterval = <span class="hljs-number">100</span>;           <span class="hljs-comment">//初始间隔</span><br><span class="hljs-keyword">double</span> multiplier = <span class="hljs-number">2.0</span>;              <span class="hljs-comment">//递增倍数</span><br><span class="hljs-keyword">long</span> maxInterval = <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>;         <span class="hljs-comment">//最大间隔</span><br><span class="hljs-keyword">long</span> maxElapsedTime = <span class="hljs-number">50</span> * <span class="hljs-number">1000L</span>;     <span class="hljs-comment">//累计最大的时间间隔</span><br> <br>ExponentialBackOff backOff = <span class="hljs-keyword">new</span> ExponentialBackOff(initialInterval, multiplier);<br>backOff.setMaxInterval(maxInterval);<br>backOff.setMaxElapsedTime(maxElapsedTime);<br> <br>BackOffExecution execution = backOff.start();<br> <br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>    <span class="hljs-keyword">long</span> value = execution.nextBackOff();<br>    <span class="hljs-keyword">if</span>(value == BackOffExecution.STOP)&#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//在这里写你的重试逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义退避策略"><a href="#自定义退避策略" class="headerlink" title="自定义退避策略"></a>自定义退避策略</h4><p>如果你想要实现自己的退避策略，也非常简单。参考上面两个类中对于BackOffExecution接口的实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>接口调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python利用random生成一个列表内的随机数</title>
    <link href="/blog/2021/03/25/Python%E5%88%A9%E7%94%A8random%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%86%85%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/blog/2021/03/25/Python%E5%88%A9%E7%94%A8random%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%86%85%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>首先,需要导入random模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br></code></pre></td></tr></table></figure><p>随机取1-33之间的1个随机数，可能重复:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">random.choice(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">34</span>))<br></code></pre></td></tr></table></figure><p>print得到一系列随机数,执行一次得到一个随机数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(random.choice(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">34</span>)))<br></code></pre></td></tr></table></figure><p>随机取1-33之间的6个随机数，可能重复:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">random.choices(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">34</span>),k=<span class="hljs-number">6</span>,weights=<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">34</span>))<br></code></pre></td></tr></table></figure><p>其权重值表示该数或该范围内的数输出概率大,输出结果为列表 随机取1-33之间的6个随机数，不重复:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">random.sample(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">34</span>),<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>得到一个无序列表</p><p>random.uniform(a,b) 生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限</p><p>random.randint(a,b) 生成一个指定范围内的整数。其中参数a是下限，参数b是上限 PS:python 随机选取列表中的元素</p><p>使用random模块中的sample函数 功能：</p><p>random.sample(seq, k)实现从序列或集合seq中随机选取k个独立的的元素</p><p>参数：</p><p>seq：元组、列表或字符串</p><p>k：选取元素个数</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> random<br>In [<span class="hljs-number">2</span>]: f = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>In [<span class="hljs-number">3</span>]: f<br>Out[<span class="hljs-number">3</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>In [<span class="hljs-number">4</span>]: random.sample(f, <span class="hljs-number">5</span>)<br>Out[<span class="hljs-number">4</span>]: [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]<br> <br></code></pre></td></tr></table></figure><p>使用random模块中的choice函数 功能：</p><p>random.choice(seq)实现从序列或集合seq中随机选取一个元素</p><p>参数：</p><p>seq：元组、列表或字符串</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> random<br>In [<span class="hljs-number">2</span>]: f = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>In [<span class="hljs-number">3</span>]: f<br>Out[<span class="hljs-number">3</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>In [<span class="hljs-number">4</span>]: random.choice(f)<br>Out[<span class="hljs-number">4</span>]: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>random</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java使用zxing生成二维码(带有logo)</title>
    <link href="/blog/2021/03/25/Java%E4%BD%BF%E7%94%A8zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81(%E5%B8%A6%E6%9C%89logo)/"/>
    <url>/blog/2021/03/25/Java%E4%BD%BF%E7%94%A8zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81(%E5%B8%A6%E6%9C%89logo)/</url>
    
    <content type="html"><![CDATA[<h2 id="首先要添加zxing依赖"><a href="#首先要添加zxing依赖" class="headerlink" title="首先要添加zxing依赖"></a>首先要添加zxing依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 二维码生成依赖 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;<br>    &lt;artifactId&gt;core&lt;/artifactId&gt;<br>    &lt;version&gt;3.4.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;<br>    &lt;artifactId&gt;javase&lt;/artifactId&gt;<br>    &lt;version&gt;3.4.0&lt;/version&gt;<br>&lt;/dependency&gt;<br> <br></code></pre></td></tr></table></figure><p>下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xqd;<br> <br> <br><span class="hljs-keyword">import</span> com.google.zxing.BarcodeFormat;<br><span class="hljs-keyword">import</span> com.google.zxing.EncodeHintType;<br><span class="hljs-keyword">import</span> com.google.zxing.MultiFormatWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.common.BitMatrix;<br><span class="hljs-keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;<br> <br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.nio.file.Path;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span>: QRCodeUtil</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 二维码生成</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Authror</span>: XQD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/1/16 10:34</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QRCode</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <br>        <span class="hljs-comment">// 定义二维码的参数</span><br>        <span class="hljs-keyword">int</span> width = <span class="hljs-number">300</span>; <span class="hljs-comment">// 图片宽度</span><br>        <span class="hljs-keyword">int</span> height = <span class="hljs-number">300</span>; <span class="hljs-comment">// 图片高度</span><br>        String format = <span class="hljs-string">&quot;jpg&quot;</span>; <span class="hljs-comment">// 图片格式  如果是png类型，logo图变成黑白的，</span><br>        String content = <span class="hljs-string">&quot;https://blog.csdn.net/weixin_44467567/article/details/103876746&quot;</span>;<span class="hljs-comment">// 二维码内容</span><br> <br>        <span class="hljs-comment">// 1.定义HashMap hints</span><br>        HashMap hints = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-comment">// 2.hints调用put函数设置字符集、间距以及纠错度为M</span><br>        hints.put(EncodeHintType.CHARACTER_SET, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);<span class="hljs-comment">//纠错等级【L，M，Q，H】</span><br>        hints.put(EncodeHintType.MARGIN, <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 生成二维码</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            MultiFormatWriter multiFormatWriter = <span class="hljs-keyword">new</span> MultiFormatWriter();<br>            <span class="hljs-comment">// 3.最后用MultiformatWriter函数类调用echoed函数并返回一个值 然后写入文件</span><br>            BitMatrix bitMatrix = multiFormatWriter.encode(content, BarcodeFormat.QR_CODE, width, height, hints);<br>            <span class="hljs-comment">// 这里路径后面的img.png不可省略，前面是自己选取生成的图片地址</span><br>            Path file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;F:/生成的二维码/img.png&quot;</span>).toPath();<br>            MatrixToImageWriter.writeToPath(bitMatrix, format, file);<br>            <span class="hljs-comment">//*************添加logo*****************</span><br>            <span class="hljs-comment">//读取二维码图片</span><br>            BufferedImage bufferedImage = ImageIO.read(<span class="hljs-keyword">new</span> File(file.toString()));<br>            <span class="hljs-comment">//获取画笔</span><br>            Graphics2D graphics = bufferedImage.createGraphics();<br>            <span class="hljs-comment">//读取logo图片</span><br>            BufferedImage logo = ImageIO.read(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:/图片/Saved Pictures/头像/微信图片_20200109163054.jpg&quot;</span>));<br>            <span class="hljs-comment">//设置二维码大小，太大了会覆盖二维码，此处为20%</span><br>            <span class="hljs-keyword">int</span> logoWidth = logo.getWidth() &gt; bufferedImage.getWidth()*<span class="hljs-number">2</span> /<span class="hljs-number">10</span> ? (bufferedImage.getWidth()*<span class="hljs-number">2</span> /<span class="hljs-number">10</span>) : logo.getWidth();<br>            <span class="hljs-keyword">int</span> logoHeight = logo.getHeight() &gt; bufferedImage.getHeight()*<span class="hljs-number">2</span> /<span class="hljs-number">10</span> ? (bufferedImage.getHeight()*<span class="hljs-number">2</span> /<span class="hljs-number">10</span>) : logo.getHeight();<br>            <span class="hljs-comment">//设置logo图片放置的位置，中心</span><br>            <span class="hljs-keyword">int</span> x = (bufferedImage.getWidth() - logoWidth) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> y = (bufferedImage.getHeight() - logoHeight) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//开始合并并绘制图片</span><br>            graphics.drawImage(logo,x,y,logoWidth,logoHeight,<span class="hljs-keyword">null</span>);<br>            graphics.drawRoundRect(x,y,logoWidth,logoHeight,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>);<br>            <span class="hljs-comment">//logob边框大小</span><br>            graphics.setStroke(<span class="hljs-keyword">new</span> BasicStroke(<span class="hljs-number">2</span>));<br>            <span class="hljs-comment">//logo边框颜色</span><br>            graphics.setColor(Color.WHITE);<br>            graphics.drawRect(x,y,logoWidth,logoHeight);<br>            graphics.dispose();<br>            logo.flush();<br>            bufferedImage.flush();<br>            ImageIO.write(bufferedImage, format ,<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;F:/生成的二维码/img2.png&quot;</span>));<br> <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br> <br>    &#125;<br> <br> <br>&#125;<br> <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210325200119868.png" alt="202001171536554"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>zxing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中poi导出模板下拉框实现二级联动</title>
    <link href="/blog/2021/03/25/java%E4%B8%ADpoi%E5%AF%BC%E5%87%BA%E6%A8%A1%E6%9D%BF%E4%B8%8B%E6%8B%89%E6%A1%86%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/"/>
    <url>/blog/2021/03/25/java%E4%B8%ADpoi%E5%AF%BC%E5%87%BA%E6%A8%A1%E6%9D%BF%E4%B8%8B%E6%8B%89%E6%A1%86%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>代码实现如下： 需要加入的jar包:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>   &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;<br>   &lt;artifactId&gt;poi&lt;/artifactId&gt;<br>   &lt;version&gt;3.14&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>   &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;<br>   &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;<br>   &lt;version&gt;3.14&lt;/version&gt;<br>&lt;/dependency&gt;<br> <br></code></pre></td></tr></table></figure><p>二级联动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">package</span> com.test;<br> <br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Cell;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.DataValidation;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.DataValidationConstraint;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Name;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Row;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Sheet;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Workbook;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.util.CellRangeAddressList;<br><span class="hljs-keyword">import</span> org.apache.poi.util.IOUtils;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFDataValidation;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFDataValidationConstraint;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFDataValidationHelper;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFSheet;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoExport</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Cascade();<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Cascade</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个excel</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br>        Workbook workbook = <span class="hljs-keyword">new</span> XSSFWorkbook();<br> <br>        <span class="hljs-comment">// 创建需要用户填写的sheet</span><br>        XSSFSheet sheet = (XSSFSheet) workbook.createSheet(<span class="hljs-string">&quot;省市县&quot;</span>);<br>        Row row0 = sheet.createRow(<span class="hljs-number">0</span>);<br>        row0.createCell(<span class="hljs-number">5</span>).setCellValue(<span class="hljs-string">&quot;渠道类型&quot;</span>);<br>        row0.createCell(<span class="hljs-number">6</span>).setCellValue(<span class="hljs-string">&quot;渠道来源&quot;</span>);<br> <br>        <span class="hljs-comment">//得到第一级省名称，放在列表里</span><br>        String[] provinceArr = &#123;<span class="hljs-string">&quot;线上&quot;</span>,<span class="hljs-string">&quot;线下&quot;</span>&#125;;<br>        <span class="hljs-comment">//依次列出各省的市、各市的县</span><br>        String[] cityJiangSu = &#123;<span class="hljs-string">&quot;招标网站&quot;</span>,<span class="hljs-string">&quot;营销自动化ACRM&quot;</span>,<span class="hljs-string">&quot;门户网络媒体&quot;</span>,<span class="hljs-string">&quot;移动社交媒体&quot;</span>,<span class="hljs-string">&quot;移动社交媒体&quot;</span>,<span class="hljs-string">&quot;搜索引擎&quot;</span>,<span class="hljs-string">&quot;平面媒体&quot;</span>,<span class="hljs-string">&quot;户外媒体&quot;</span>,<span class="hljs-string">&quot;其他&quot;</span>&#125;;<br>        String[] cityAnHui = &#123;<span class="hljs-string">&quot;行业博览会&quot;</span>,<span class="hljs-string">&quot;行业峰会/论坛/沙龙&quot;</span>,<span class="hljs-string">&quot;产业级市场活动&quot;</span>,<span class="hljs-string">&quot;大区/公路港市场活动&quot;</span>,<span class="hljs-string">&quot;本部门市场活动&quot;</span>,<span class="hljs-string">&quot;存量客户上下游&quot;</span>,<span class="hljs-string">&quot;政府关系网络&quot;</span>,<span class="hljs-string">&quot;个人关系网络&quot;</span>,<span class="hljs-string">&quot;传化生态业务&quot;</span>,<span class="hljs-string">&quot;其他&quot;</span>&#125;;<br>        <span class="hljs-comment">//将有子区域的父区域放到一个数组中</span><br>        String[] areaFatherNameArr =&#123;<span class="hljs-string">&quot;线上&quot;</span>,<span class="hljs-string">&quot;线下&quot;</span>&#125;;<br>        Map&lt;String,String[]&gt; areaMap = <span class="hljs-keyword">new</span> HashMap&lt;String, String[]&gt;();<br>        areaMap.put(<span class="hljs-string">&quot;线上&quot;</span>, cityJiangSu);<br>        areaMap.put(<span class="hljs-string">&quot;线下&quot;</span>,cityAnHui);<br> <br>        <span class="hljs-comment">//创建一个专门用来存放地区信息的隐藏sheet页</span><br>        <span class="hljs-comment">//因此也不能在现实页之前创建，否则无法隐藏。</span><br>        Sheet hideSheet = workbook.createSheet(<span class="hljs-string">&quot;area&quot;</span>);<br>        <span class="hljs-comment">//这一行作用是将此sheet隐藏，功能未完成时注释此行,可以查看隐藏sheet中信息是否正确</span><br>        workbook.setSheetHidden(workbook.getSheetIndex(hideSheet), <span class="hljs-keyword">true</span>);<br> <br>        <span class="hljs-keyword">int</span> rowId = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 设置第一行，存省的信息</span><br>        Row provinceRow = hideSheet.createRow(rowId++);<br>        provinceRow.createCell(<span class="hljs-number">0</span>).setCellValue(<span class="hljs-string">&quot;渠道&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; provinceArr.length; i ++)&#123;<br>            Cell provinceCell = provinceRow.createCell(i + <span class="hljs-number">1</span>);<br>            provinceCell.setCellValue(provinceArr[i]);<br>        &#125;<br>        <span class="hljs-comment">// 将具体的数据写入到每一行中，行开头为父级区域，后面是子区域。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; areaFatherNameArr.length;i++)&#123;<br>            String key = areaFatherNameArr[i];<br>            String[] son = areaMap.get(key);<br>            Row row1 = hideSheet.createRow(rowId++);<br>            row1.createCell(<span class="hljs-number">0</span>).setCellValue(key);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; son.length; j ++)&#123;<br>                Cell cell0 = row1.createCell(j + <span class="hljs-number">1</span>);<br>                cell0.setCellValue(son[j]);<br>            &#125;<br> <br>            <span class="hljs-comment">// 添加名称管理器</span><br>            String range = getRange(<span class="hljs-number">1</span>, rowId, son.length);<br>            Name name = workbook.createName();<br>            <span class="hljs-comment">//key不可重复</span><br>            name.setNameName(key);<br>            String formula = <span class="hljs-string">&quot;area!&quot;</span> + range;<br>            name.setRefersToFormula(formula);<br>        &#125;<br> <br>        XSSFDataValidationHelper dvHelper = <span class="hljs-keyword">new</span> XSSFDataValidationHelper((XSSFSheet)sheet);<br>        <span class="hljs-comment">// 省规则</span><br>        DataValidationConstraint provConstraint = dvHelper.createExplicitListConstraint(provinceArr);<br>        <span class="hljs-comment">// 四个参数分别是：起始行、终止行、起始列、终止列</span><br>        CellRangeAddressList provRangeAddressList = <span class="hljs-keyword">new</span> CellRangeAddressList(<span class="hljs-number">2</span>, <span class="hljs-number">202</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br>        DataValidation provinceDataValidation = dvHelper.createValidation(provConstraint, provRangeAddressList);<br>        <span class="hljs-comment">//验证</span><br>        provinceDataValidation.createErrorBox(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;请选择正确的渠道&quot;</span>);<br>        provinceDataValidation.setShowErrorBox(<span class="hljs-keyword">true</span>);<br>        provinceDataValidation.setSuppressDropDownArrow(<span class="hljs-keyword">true</span>);<br>        sheet.addValidationData(provinceDataValidation);<br> <br>        <span class="hljs-comment">//对前20行设置有效性</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt; <span class="hljs-number">204</span>;i++)&#123;<br>            setDataValidation(<span class="hljs-string">&quot;F&quot;</span> ,sheet,i,<span class="hljs-number">7</span>);<br>        &#125;<br>        FileOutputStream os = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/test02.xlsx&quot;</span>);<br>            workbook.write(os);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            IOUtils.closeQuietly(os);<br>        &#125;<br>    &#125;<br> <br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置有效性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset 主影响单元格所在列，即此单元格由哪个单元格影响联动</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sheet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rowNum 行数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colNum 列数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataValidation</span><span class="hljs-params">(String offset,XSSFSheet sheet, <span class="hljs-keyword">int</span> rowNum,<span class="hljs-keyword">int</span> colNum)</span> </span>&#123;<br>        XSSFDataValidationHelper dvHelper = <span class="hljs-keyword">new</span> XSSFDataValidationHelper(sheet);<br>        DataValidation data_validation_list;<br>        data_validation_list = getDataValidationByFormula(<br>                <span class="hljs-string">&quot;INDIRECT($&quot;</span> + offset + (rowNum) + <span class="hljs-string">&quot;)&quot;</span>, rowNum, colNum,dvHelper);<br>        sheet.addValidationData(data_validation_list);<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载下拉列表内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> formulaString</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> naturalRowIndex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> naturalColumnIndex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dvHelper</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  DataValidation <span class="hljs-title">getDataValidationByFormula</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            String formulaString, <span class="hljs-keyword">int</span> naturalRowIndex, <span class="hljs-keyword">int</span> naturalColumnIndex,XSSFDataValidationHelper dvHelper)</span> </span>&#123;<br>        <span class="hljs-comment">// 加载下拉列表内容</span><br>        <span class="hljs-comment">// 举例：若formulaString = &quot;INDIRECT($A$2)&quot; 表示规则数据会从名称管理器中获取key与单元格 A2 值相同的数据，</span><br>        <span class="hljs-comment">//如果A2是江苏省，那么此处就是江苏省下的市信息。</span><br>        XSSFDataValidationConstraint dvConstraint = (XSSFDataValidationConstraint) dvHelper.createFormulaListConstraint(formulaString);<br>        <span class="hljs-comment">// 设置数据有效性加载在哪个单元格上。</span><br>        <span class="hljs-comment">// 四个参数分别是：起始行、终止行、起始列、终止列</span><br>        <span class="hljs-keyword">int</span> firstRow = naturalRowIndex -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lastRow = naturalRowIndex - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> firstCol = naturalColumnIndex - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lastCol = naturalColumnIndex - <span class="hljs-number">1</span>;<br>        CellRangeAddressList regions = <span class="hljs-keyword">new</span> CellRangeAddressList(firstRow,<br>                lastRow, firstCol, lastCol);<br>        <span class="hljs-comment">// 数据有效性对象</span><br>        <span class="hljs-comment">// 绑定</span><br>        XSSFDataValidation data_validation_list = (XSSFDataValidation) dvHelper.createValidation(dvConstraint, regions);<br>        data_validation_list.setEmptyCellAllowed(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">if</span> (data_validation_list <span class="hljs-keyword">instanceof</span> XSSFDataValidation) &#123;<br>            data_validation_list.setSuppressDropDownArrow(<span class="hljs-keyword">true</span>);<br>            data_validation_list.setShowErrorBox(<span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            data_validation_list.setSuppressDropDownArrow(<span class="hljs-keyword">false</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置输入信息提示信息</span><br>        data_validation_list.createPromptBox(<span class="hljs-string">&quot;下拉选择提示&quot;</span>, <span class="hljs-string">&quot;请使用下拉方式选择合适的值！&quot;</span>);<br>        <span class="hljs-comment">// 设置输入错误提示信息</span><br>        <span class="hljs-comment">//data_validation_list.createErrorBox(&quot;选择错误提示&quot;, &quot;你输入的值未在备选列表中，请下拉选择合适的值！&quot;);</span><br>        <span class="hljs-keyword">return</span> data_validation_list;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  计算formula</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset 偏移量，如果给0，表示从A列开始，1，就是从B列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rowId 第几行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colCount 一共多少列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果给入参 1,1,10. 表示从B1-K1。最终返回 $B$1:$K$1</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> rowId, <span class="hljs-keyword">int</span> colCount)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> start = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + offset);<br>        <span class="hljs-keyword">if</span> (colCount &lt;= <span class="hljs-number">25</span>) &#123;<br>            <span class="hljs-keyword">char</span> end = (<span class="hljs-keyword">char</span>)(start + colCount - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;$&quot;</span> + start + <span class="hljs-string">&quot;$&quot;</span> + rowId + <span class="hljs-string">&quot;:$&quot;</span> + end + <span class="hljs-string">&quot;$&quot;</span> + rowId;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">char</span> endPrefix = <span class="hljs-string">&#x27;A&#x27;</span>;<br>            <span class="hljs-keyword">char</span> endSuffix = <span class="hljs-string">&#x27;A&#x27;</span>;<br>            <span class="hljs-keyword">if</span> ((colCount - <span class="hljs-number">25</span>) / <span class="hljs-number">26</span> == <span class="hljs-number">0</span> || colCount == <span class="hljs-number">51</span>) &#123;<span class="hljs-comment">// 26-51之间，包括边界（仅两次字母表计算）</span><br>                <span class="hljs-keyword">if</span> ((colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 边界值</span><br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">25</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + (colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 51以上</span><br>                <span class="hljs-keyword">if</span> ((colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">0</span>) &#123;<br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">25</span>);<br>                    endPrefix = (<span class="hljs-keyword">char</span>)(endPrefix + (colCount - <span class="hljs-number">25</span>) / <span class="hljs-number">26</span> - <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + (colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> - <span class="hljs-number">1</span>);<br>                    endPrefix = (<span class="hljs-keyword">char</span>)(endPrefix + (colCount - <span class="hljs-number">25</span>) / <span class="hljs-number">26</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;$&quot;</span> + start + <span class="hljs-string">&quot;$&quot;</span> + rowId + <span class="hljs-string">&quot;:$&quot;</span> + endPrefix + endSuffix + <span class="hljs-string">&quot;$&quot;</span> + rowId;<br>        &#125;<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>效果如下：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/2020011711222348_1579401982569.png?x-oss-process=style/small" alt="2020011711222348">三级联动： 代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br> <br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Cell;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.DataValidation;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.DataValidationConstraint;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Name;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Row;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Sheet;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.Workbook;<br><span class="hljs-keyword">import</span> org.apache.poi.ss.util.CellRangeAddressList;<br><span class="hljs-keyword">import</span> org.apache.poi.util.IOUtils;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFDataValidation;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFDataValidationConstraint;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFDataValidationHelper;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFSheet;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Export</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Cascade();<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Cascade</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个excel</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br>        Workbook book = <span class="hljs-keyword">new</span> XSSFWorkbook();<br> <br>        <span class="hljs-comment">// 创建需要用户填写的sheet</span><br>        XSSFSheet sheetPro = (XSSFSheet) book.createSheet(<span class="hljs-string">&quot;省市县&quot;</span>);<br>        Row row0 = sheetPro.createRow(<span class="hljs-number">0</span>);<br>        row0.createCell(<span class="hljs-number">0</span>).setCellValue(<span class="hljs-string">&quot;省&quot;</span>);<br>        row0.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;市&quot;</span>);<br>        row0.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;区&quot;</span>);<br> <br>        <span class="hljs-comment">//得到第一级省名称，放在列表里</span><br>        String[] provinceArr = &#123;<span class="hljs-string">&quot;江苏省&quot;</span>,<span class="hljs-string">&quot;安徽省&quot;</span>&#125;;<br>        <span class="hljs-comment">//依次列出各省的市、各市的县</span><br>        String[] cityJiangSu = &#123;<span class="hljs-string">&quot;南京市&quot;</span>,<span class="hljs-string">&quot;苏州市&quot;</span>,<span class="hljs-string">&quot;盐城市&quot;</span>&#125;;<br>        String[] cityAnHui = &#123;<span class="hljs-string">&quot;合肥市&quot;</span>,<span class="hljs-string">&quot;安庆市&quot;</span>&#125;;<br>        String[] countyNanjing = &#123;<span class="hljs-string">&quot;六合县&quot;</span>,<span class="hljs-string">&quot;江宁县&quot;</span>&#125;;<br>        String[] countySuzhou = &#123;<span class="hljs-string">&quot;姑苏区&quot;</span>,<span class="hljs-string">&quot;园区&quot;</span>&#125;;<br>        String[] countyYancheng = &#123;<span class="hljs-string">&quot;响水县&quot;</span>,<span class="hljs-string">&quot;射阳县&quot;</span>&#125;;<br>        String[] countyLiuhe = &#123;<span class="hljs-string">&quot;瑶海区&quot;</span>,<span class="hljs-string">&quot;庐阳区&quot;</span>&#125;;<br>        String[] countyAnQing = &#123;<span class="hljs-string">&quot;迎江区&quot;</span>,<span class="hljs-string">&quot;大观区&quot;</span>&#125;;<br>        <span class="hljs-comment">//将有子区域的父区域放到一个数组中</span><br>        String[] areaFatherNameArr =&#123;<span class="hljs-string">&quot;江苏省&quot;</span>,<span class="hljs-string">&quot;安徽省&quot;</span>,<span class="hljs-string">&quot;南京市&quot;</span>,<span class="hljs-string">&quot;苏州市&quot;</span>,<span class="hljs-string">&quot;盐城市&quot;</span>,<span class="hljs-string">&quot;合肥市&quot;</span>,<span class="hljs-string">&quot;安庆市&quot;</span>&#125;;<br>        Map&lt;String,String[]&gt; areaMap = <span class="hljs-keyword">new</span> HashMap&lt;String, String[]&gt;();<br>        areaMap.put(<span class="hljs-string">&quot;江苏省&quot;</span>, cityJiangSu);<br>        areaMap.put(<span class="hljs-string">&quot;安徽省&quot;</span>,cityAnHui);<br>        areaMap.put(<span class="hljs-string">&quot;南京市&quot;</span>,countyNanjing);<br>        areaMap.put(<span class="hljs-string">&quot;苏州市&quot;</span>, countySuzhou);<br>        areaMap.put(<span class="hljs-string">&quot;盐城市&quot;</span>,countyYancheng);<br>        areaMap.put(<span class="hljs-string">&quot;合肥市&quot;</span>,countyYancheng);<br>        areaMap.put(<span class="hljs-string">&quot;合肥市&quot;</span>, countyLiuhe);<br>        areaMap.put(<span class="hljs-string">&quot;安庆市&quot;</span>,countyAnQing);<br> <br>        <span class="hljs-comment">//创建一个专门用来存放地区信息的隐藏sheet页</span><br>        <span class="hljs-comment">//因此也不能在现实页之前创建，否则无法隐藏。</span><br>        Sheet hideSheet = book.createSheet(<span class="hljs-string">&quot;area&quot;</span>);<br>        <span class="hljs-comment">//这一行作用是将此sheet隐藏，功能未完成时注释此行,可以查看隐藏sheet中信息是否正确</span><br>        <span class="hljs-comment">//book.setSheetHidden(book.getSheetIndex(hideSheet), true);</span><br> <br>        <span class="hljs-keyword">int</span> rowId = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 设置第一行，存省的信息</span><br>        Row provinceRow = hideSheet.createRow(rowId++);<br>        provinceRow.createCell(<span class="hljs-number">0</span>).setCellValue(<span class="hljs-string">&quot;省列表&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; provinceArr.length; i ++)&#123;<br>            Cell provinceCell = provinceRow.createCell(i + <span class="hljs-number">1</span>);<br>            provinceCell.setCellValue(provinceArr[i]);<br>        &#125;<br>        <span class="hljs-comment">// 将具体的数据写入到每一行中，行开头为父级区域，后面是子区域。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; areaFatherNameArr.length;i++)&#123;<br>            String key = areaFatherNameArr[i];<br>            String[] son = areaMap.get(key);<br>            Row row = hideSheet.createRow(rowId++);<br>            row.createCell(<span class="hljs-number">0</span>).setCellValue(key);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; son.length; j ++)&#123;<br>                Cell cell = row.createCell(j + <span class="hljs-number">1</span>);<br>                cell.setCellValue(son[j]);<br>            &#125;<br> <br>            <span class="hljs-comment">// 添加名称管理器</span><br>            String range = getRange(<span class="hljs-number">1</span>, rowId, son.length);<br>            Name name = book.createName();<br>            <span class="hljs-comment">//key不可重复</span><br>            name.setNameName(key);<br>            String formula = <span class="hljs-string">&quot;area!&quot;</span> + range;<br>            name.setRefersToFormula(formula);<br>        &#125;<br> <br>        XSSFDataValidationHelper dvHelper = <span class="hljs-keyword">new</span> XSSFDataValidationHelper((XSSFSheet)sheetPro);<br>        <span class="hljs-comment">// 省规则</span><br>        DataValidationConstraint provConstraint = dvHelper.createExplicitListConstraint(provinceArr);<br>        <span class="hljs-comment">// 四个参数分别是：起始行、终止行、起始列、终止列</span><br>        CellRangeAddressList provRangeAddressList = <span class="hljs-keyword">new</span> CellRangeAddressList(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        DataValidation provinceDataValidation = dvHelper.createValidation(provConstraint, provRangeAddressList);<br>        <span class="hljs-comment">//验证</span><br>        provinceDataValidation.createErrorBox(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;请选择正确的省份&quot;</span>);<br>        provinceDataValidation.setShowErrorBox(<span class="hljs-keyword">true</span>);<br>        provinceDataValidation.setSuppressDropDownArrow(<span class="hljs-keyword">true</span>);<br>        sheetPro.addValidationData(provinceDataValidation);<br> <br>        <span class="hljs-comment">//对前20行设置有效性</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; <span class="hljs-number">20</span>;i++)&#123;<br>            setDataValidation(<span class="hljs-string">&quot;A&quot;</span> ,sheetPro,i,<span class="hljs-number">2</span>);<br>            setDataValidation(<span class="hljs-string">&quot;B&quot;</span> ,sheetPro,i,<span class="hljs-number">3</span>);<br>        &#125;<br>        FileOutputStream os = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/test01.xlsx&quot;</span>);<br>            book.write(os);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            IOUtils.closeQuietly(os);<br>        &#125;<br>    &#125;<br> <br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置有效性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset 主影响单元格所在列，即此单元格由哪个单元格影响联动</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sheet</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rowNum 行数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colNum 列数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataValidation</span><span class="hljs-params">(String offset,XSSFSheet sheet, <span class="hljs-keyword">int</span> rowNum,<span class="hljs-keyword">int</span> colNum)</span> </span>&#123;<br>        XSSFDataValidationHelper dvHelper = <span class="hljs-keyword">new</span> XSSFDataValidationHelper(sheet);<br>        DataValidation data_validation_list;<br>        data_validation_list = getDataValidationByFormula(<br>                <span class="hljs-string">&quot;INDIRECT($&quot;</span> + offset + (rowNum) + <span class="hljs-string">&quot;)&quot;</span>, rowNum, colNum,dvHelper);<br>        sheet.addValidationData(data_validation_list);<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载下拉列表内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> formulaString</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> naturalRowIndex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> naturalColumnIndex</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dvHelper</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  DataValidation <span class="hljs-title">getDataValidationByFormula</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            String formulaString, <span class="hljs-keyword">int</span> naturalRowIndex, <span class="hljs-keyword">int</span> naturalColumnIndex,XSSFDataValidationHelper dvHelper)</span> </span>&#123;<br>        <span class="hljs-comment">// 加载下拉列表内容</span><br>        <span class="hljs-comment">// 举例：若formulaString = &quot;INDIRECT($A$2)&quot; 表示规则数据会从名称管理器中获取key与单元格 A2 值相同的数据，</span><br>        <span class="hljs-comment">//如果A2是江苏省，那么此处就是江苏省下的市信息。</span><br>        XSSFDataValidationConstraint dvConstraint = (XSSFDataValidationConstraint) dvHelper.createFormulaListConstraint(formulaString);<br>        <span class="hljs-comment">// 设置数据有效性加载在哪个单元格上。</span><br>        <span class="hljs-comment">// 四个参数分别是：起始行、终止行、起始列、终止列</span><br>        <span class="hljs-keyword">int</span> firstRow = naturalRowIndex -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lastRow = naturalRowIndex - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> firstCol = naturalColumnIndex - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lastCol = naturalColumnIndex - <span class="hljs-number">1</span>;<br>        CellRangeAddressList regions = <span class="hljs-keyword">new</span> CellRangeAddressList(firstRow,<br>                lastRow, firstCol, lastCol);<br>        <span class="hljs-comment">// 数据有效性对象</span><br>        <span class="hljs-comment">// 绑定</span><br>        XSSFDataValidation data_validation_list = (XSSFDataValidation) dvHelper.createValidation(dvConstraint, regions);<br>        data_validation_list.setEmptyCellAllowed(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">if</span> (data_validation_list <span class="hljs-keyword">instanceof</span> XSSFDataValidation) &#123;<br>            data_validation_list.setSuppressDropDownArrow(<span class="hljs-keyword">true</span>);<br>            data_validation_list.setShowErrorBox(<span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            data_validation_list.setSuppressDropDownArrow(<span class="hljs-keyword">false</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置输入信息提示信息</span><br>        data_validation_list.createPromptBox(<span class="hljs-string">&quot;下拉选择提示&quot;</span>, <span class="hljs-string">&quot;请使用下拉方式选择合适的值！&quot;</span>);<br>        <span class="hljs-comment">// 设置输入错误提示信息</span><br>        <span class="hljs-comment">//data_validation_list.createErrorBox(&quot;选择错误提示&quot;, &quot;你输入的值未在备选列表中，请下拉选择合适的值！&quot;);</span><br>        <span class="hljs-keyword">return</span> data_validation_list;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  计算formula</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset 偏移量，如果给0，表示从A列开始，1，就是从B列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rowId 第几行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colCount 一共多少列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果给入参 1,1,10. 表示从B1-K1。最终返回 $B$1:$K$1</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> rowId, <span class="hljs-keyword">int</span> colCount)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> start = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + offset);<br>        <span class="hljs-keyword">if</span> (colCount &lt;= <span class="hljs-number">25</span>) &#123;<br>            <span class="hljs-keyword">char</span> end = (<span class="hljs-keyword">char</span>)(start + colCount - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;$&quot;</span> + start + <span class="hljs-string">&quot;$&quot;</span> + rowId + <span class="hljs-string">&quot;:$&quot;</span> + end + <span class="hljs-string">&quot;$&quot;</span> + rowId;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">char</span> endPrefix = <span class="hljs-string">&#x27;A&#x27;</span>;<br>            <span class="hljs-keyword">char</span> endSuffix = <span class="hljs-string">&#x27;A&#x27;</span>;<br>            <span class="hljs-keyword">if</span> ((colCount - <span class="hljs-number">25</span>) / <span class="hljs-number">26</span> == <span class="hljs-number">0</span> || colCount == <span class="hljs-number">51</span>) &#123;<span class="hljs-comment">// 26-51之间，包括边界（仅两次字母表计算）</span><br>                <span class="hljs-keyword">if</span> ((colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 边界值</span><br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">25</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + (colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 51以上</span><br>                <span class="hljs-keyword">if</span> ((colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">0</span>) &#123;<br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">25</span>);<br>                    endPrefix = (<span class="hljs-keyword">char</span>)(endPrefix + (colCount - <span class="hljs-number">25</span>) / <span class="hljs-number">26</span> - <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    endSuffix = (<span class="hljs-keyword">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + (colCount - <span class="hljs-number">25</span>) % <span class="hljs-number">26</span> - <span class="hljs-number">1</span>);<br>                    endPrefix = (<span class="hljs-keyword">char</span>)(endPrefix + (colCount - <span class="hljs-number">25</span>) / <span class="hljs-number">26</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;$&quot;</span> + start + <span class="hljs-string">&quot;$&quot;</span> + rowI<br>            d + <span class="hljs-string">&quot;:$&quot;</span> + endPrefix + endSuffix + <span class="hljs-string">&quot;$&quot;</span> + rowId;<br>        &#125;<br>    &#125;<br> <br>&#125;<br> <br></code></pre></td></tr></table></figure><p>效果图如下:<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210325195718801.png" alt="20200117132617484"></p>]]></content>
    
    
    
    <tags>
      
      <tag>poi</tag>
      
      <tag>二级联动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Iterator迭代器解决为何禁止在foreach内增删</title>
    <link href="/blog/2021/03/25/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%A7%A3%E5%86%B3%E4%B8%BA%E4%BD%95%E7%A6%81%E6%AD%A2%E5%9C%A8foreach%E5%86%85%E5%A2%9E%E5%88%A0/"/>
    <url>/blog/2021/03/25/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%A7%A3%E5%86%B3%E4%B8%BA%E4%BD%95%E7%A6%81%E6%AD%A2%E5%9C%A8foreach%E5%86%85%E5%A2%9E%E5%88%A0/</url>
    
    <content type="html"><![CDATA[<p>迭代器的应用场景：</p><p>1、对集合进行增加删除，禁止使用foreach，循环的动态操作 2、倒序遍历 3、遍历循环</p><p>步入正题：为何禁止在foreach内进行增删？</p><p>先看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *         正例：</span><br><span class="hljs-comment"> *         Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="hljs-comment"> *         while (iterator.hasNext()) &#123;</span><br><span class="hljs-comment"> *             String item = iterator.next();</span><br><span class="hljs-comment"> *             if (删除元素的条件) &#123;</span><br><span class="hljs-comment"> *                 iterator.remove();</span><br><span class="hljs-comment"> *             &#125;</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *         反例：</span><br><span class="hljs-comment"> *         List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="hljs-comment"> *         list.add(&quot;1&quot;);</span><br><span class="hljs-comment"> *         list.add(&quot;2&quot;);</span><br><span class="hljs-comment"> *         for (String item : list) &#123;</span><br><span class="hljs-comment"> *             if (&quot;1&quot;.equals(item)) &#123;</span><br><span class="hljs-comment"> *                 list.remove(item);</span><br><span class="hljs-comment"> *             &#125;</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> */</span><br> <br> <br></code></pre></td></tr></table></figure><p>这段代码是，在阿里的开发手册中的一段代码。</p><p>我们先看下面场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 场景一：对集合进行删除，增加、for循环</span><br><span class="hljs-comment"> * 错误：这里会报出数据越界异常，</span><br><span class="hljs-comment"> * 因为：remove掉一个元素后，整个长度发生变化，所以发生异常</span><br><span class="hljs-comment"> * 改进：采用forList.size()动态</span><br><span class="hljs-comment"> */</span><br>List&lt;String&gt; forList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>forList.add(<span class="hljs-string">&quot;a&quot;</span>);<br>forList.add(<span class="hljs-string">&quot;b&quot;</span>);<br>forList.add(<span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-keyword">int</span> length = forList.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;a&quot;</span>.equals(forList.get(i))) &#123;<br>        forList.remove(i);<br>    &#125;<br>&#125;<br>System.out.println(forList);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 产生新问题：</span><br><span class="hljs-comment"> * 错误：运行便会发现：将b移除不完整，</span><br><span class="hljs-comment"> * 因为：删除后整个游标向下，数组向上，刚好空出1个位置，</span><br><span class="hljs-comment"> * 紧接着的第二位没有进行比对，所以产生问题</span><br><span class="hljs-comment"> * 解决：数据长度减一与游标保持统一</span><br><span class="hljs-comment"> */</span><br>List&lt;String&gt; forList1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>forList1.add(<span class="hljs-string">&quot;a&quot;</span>);<br>forList1.add(<span class="hljs-string">&quot;b&quot;</span>);<br>forList1.add(<span class="hljs-string">&quot;b&quot;</span>);<br>forList1.add(<span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; forList1.size(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;b&quot;</span>.equals(forList1.get(i))) &#123;<br>        forList1.remove(i);<br>        i--;<br>    &#125;<br>&#125;<br>System.out.println(forList1);<br> <br> <br></code></pre></td></tr></table></figure><p>通过上个场景，知道在for循环内，为啥不建议用remove/add</p><p>在foreach循环内，再接着看下面这个场景？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 场景二：</span><br><span class="hljs-comment"> * foreach循环，的remove/add操作</span><br><span class="hljs-comment"> */</span><br>List&lt;String&gt; forEach = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>forEach.add(<span class="hljs-string">&quot;a&quot;</span>);<br>forEach.add(<span class="hljs-string">&quot;b&quot;</span>);<br>forEach.add(<span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-keyword">for</span> (String each : forEach) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;a&quot;</span>.equals(each)) &#123;<br>        forEach.remove(each);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 产生的异常：</span><br><span class="hljs-comment"> *   Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="hljs-comment"> *     at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="hljs-comment"> *     at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 源码：Itr实现了Iterator接口（删减部分）</span><br><span class="hljs-comment"> *  private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="hljs-comment"> *         <span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment"> *         <span class="hljs-doctag">@SuppressWarnings</span>(&quot;unchecked&quot;)</span><br><span class="hljs-comment"> *         public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="hljs-comment"> *             Objects.requireNonNull(consumer);</span><br><span class="hljs-comment"> *             final int size = ArrayList.this.size;</span><br><span class="hljs-comment"> *             int i = cursor;</span><br><span class="hljs-comment"> *             if (i &gt;= size) &#123;</span><br><span class="hljs-comment"> *                 return;</span><br><span class="hljs-comment"> *             &#125;</span><br><span class="hljs-comment"> *             final Object[] elementData = ArrayList.this.elementData;</span><br><span class="hljs-comment"> *             if (i &gt;= elementData.length) &#123;</span><br><span class="hljs-comment"> *                 throw new ConcurrentModificationException();</span><br><span class="hljs-comment"> *             &#125;</span><br><span class="hljs-comment"> *             while (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="hljs-comment"> *                 consumer.accept((E) elementData[i++]);</span><br><span class="hljs-comment"> *             &#125;</span><br><span class="hljs-comment"> *             // update once at end of iteration to reduce heap write traffic</span><br><span class="hljs-comment"> *             cursor = i;</span><br><span class="hljs-comment"> *             lastRet = i - 1;</span><br><span class="hljs-comment"> *             checkForComodification();</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *          如果有更改则抛出ConcurrentModificationException异常，</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *         final void checkForComodification() &#123;</span><br><span class="hljs-comment"> *         之前的版本不等于，当前的版本，判断为数据更新了。</span><br><span class="hljs-comment"> *         那么？为什么产生这样的判断呢，因为你删除后变为新数组，来不及</span><br><span class="hljs-comment"> * 更新版本，jvm不知道你当前数据状态，是否变化，无法再进行遍历</span><br><span class="hljs-comment"> *             if (modCount != expectedModCount)</span><br><span class="hljs-comment"> *                 throw new ConcurrentModificationException();</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 改进：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br>List&lt;String&gt; forEachIterator = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>forEachIterator.add(<span class="hljs-string">&quot;a&quot;</span>);<br>forEachIterator.add(<span class="hljs-string">&quot;b&quot;</span>);<br>forEachIterator.add(<span class="hljs-string">&quot;c&quot;</span>);<br>java.util.Iterator&lt;String&gt; iterator = forEachIterator.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    String next = iterator.next();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;a&quot;</span>.equals(next)) &#123;<br>        iterator.remove();<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>这里：foreach实现的就是迭代器。</p><p>补充：倒序循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 场景三：</span><br><span class="hljs-comment">      * 应用：倒序遍历</span><br><span class="hljs-comment">      */</span><br>     List&lt;String&gt; forEachIteratorDown = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>     forEachIteratorDown.add(<span class="hljs-string">&quot;a&quot;</span>);<br>     forEachIteratorDown.add(<span class="hljs-string">&quot;b&quot;</span>);<br>     forEachIteratorDown.add(<span class="hljs-string">&quot;c&quot;</span>);<br>     ListIterator&lt;String&gt; item = forEachIteratorDown.listIterator();<br>     <span class="hljs-comment">//这里需要先将指针移向最后一位，再进行倒叙</span><br>     <span class="hljs-keyword">while</span> (item.hasNext()) &#123;<br>         item.next();<br>     &#125;<br>     <span class="hljs-keyword">while</span> (item.hasPrevious()) &#123;<br>         String previous = item.previous();<br>         System.out.println(previous);<br>     &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Iterator</tag>
      
      <tag>foreach</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索一个字符数组中是否存在某个字符</title>
    <link href="/blog/2021/03/24/%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6/"/>
    <url>/blog/2021/03/24/%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>请在一个类中编写一个方法，这个方法搜索一个字符数组中是否存在某个字符，如果存在，则返回这个字符在字符数组中第一次出现的位置（序号从0开始计算），否则，返回-1。要搜索的字符数组和字符都以参数形式传递传递给该方法，如果传入的数组为null，应抛出IllegalArgumentException异常。在类的main方法中以各种可能出现的情况测试验证该方法编写得是否正确，例如，字符不存在，字符存在，传入的数组为null等。</p><p>1.创建一个字符数组。 2.搜索该字符是否存在字符数组中，编写搜索方法。 3.判断字符数组中是否存在该字符</p><p>1.valueOf：方法用于返回给定参数的原生 Number 对象值。 如：char[] str = { ‘a’, ‘b’, ‘c’, ‘a’ }; String s = String.valueOf(str); // s的值是 abca 2.indexOf：返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 如：s.indexOf(“b”); // 表示：如果字符数组中存在b，则返回第一次出现b的下标索引，如果没有b，则返回-1</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eleven.csdn0110;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.请在一个类中编写一个方法，这个方法搜索一个字符数组中是否存在某个字符，如果存在，则返回这个字符在字符数组中第一次出现的位置（序号从0开始计算），否则，返回-1。</span><br><span class="hljs-comment"> * 2.要搜索的字符数组和字符都以参数形式传递传递给该方法，如果传入的数组为null，应抛出IllegalArgumentException异常。</span><br><span class="hljs-comment"> * 3.在类的main方法中以各种可能出现的情况测试验证该方法编写得是否正确，例如，字符不存在，字符存在，传入的数组为null等。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> sywangu</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneDay</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建一个字符数组</span><br><span class="hljs-keyword">char</span>[] str = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><span class="hljs-comment">// 搜索该字符是否存在字符数组中</span><br><span class="hljs-keyword">int</span> index = search(str,<span class="hljs-string">&#x27;-&#x27;</span>);<br><span class="hljs-comment">// 判断字符数组中是否存在该字符</span><br><span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// index为-1时，表示字符不存在</span><br>System.out.println(<span class="hljs-string">&quot;该字符不存在&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;字符在字符数组中第一次出现的位置&quot;</span> + index);<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// search方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] aStr, <span class="hljs-keyword">char</span> aIndex)</span> </span>&#123;<br><span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;<span class="hljs-comment">// 将index的值初始化为-1</span><br><span class="hljs-keyword">if</span> (aStr == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 如果str值为null，则抛出非法数据异常</span><br><span class="hljs-keyword">new</span> IllegalArgumentException().printStackTrace();<span class="hljs-comment">// IllegalArgumentException非法数据异常</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; aStr.length; i++) &#123;<br><span class="hljs-keyword">if</span> (aIndex == aStr[i]) &#123;<span class="hljs-comment">// 如果字符数组里面的字符和要搜索的字符一致</span><br>index = i;<span class="hljs-comment">// 就将i的值赋值给index</span><br><span class="hljs-keyword">break</span>;<span class="hljs-comment">// 满足条件，退出循环</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> index;<span class="hljs-comment">// 打印index的值</span><br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.eleven.test;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.请在一个类中编写一个方法，这个方法搜索一个字符数组中是否存在某个字符，如果存在，则返回这个字符在字符数组中第一次出现的位置（序号从0开始计算），否则，返回-1。</span><br><span class="hljs-comment"> * 2.要搜索的字符数组和字符都以参数形式传递传递给该方法，如果传入的数组为null，应抛出IllegalArgumentException异常。</span><br><span class="hljs-comment"> * 3.在类的main方法中以各种可能出现的情况测试验证该方法编写得是否正确，例如，字符不存在，字符存在，传入的数组为null等。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> sywangu</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneDemoTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 创建一个字符数组</span><br><span class="hljs-keyword">char</span>[] str = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><span class="hljs-comment">// // 如果str值为null，则抛出非法数据异常</span><br><span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br><span class="hljs-comment">// valueOf() 方法用于返回给定参数的原生 Number 对象值</span><br>String s = String.valueOf(str); <span class="hljs-comment">// s的值是 abca</span><br><span class="hljs-comment">// indexOf():返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</span><br>System.out.println(s.indexOf(<span class="hljs-string">&quot;b&quot;</span>));<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符数组</tag>
      
      <tag>包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中使用图片验证码</title>
    <link href="/blog/2021/03/24/Java%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <url>/blog/2021/03/24/Java%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/BufferImage&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferImage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WIDTH = <span class="hljs-number">120</span>;<span class="hljs-comment">//生成图片的宽度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEIGHT = <span class="hljs-number">30</span>;<span class="hljs-comment">//生成图片的高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WORDS_NUMBER = <span class="hljs-number">4</span>;<span class="hljs-comment">//验证码中字符的个数</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">this</span>.doPost(req, resp);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <br>    req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        String createTypeFlag = req.getParameter(<span class="hljs-string">&quot;createTypeFlag&quot;</span>);<span class="hljs-comment">//接收客户端传递的createTypeFlag标识</span><br>        <span class="hljs-comment">//在内存中创建一张图片</span><br>        BufferedImage bi = <span class="hljs-keyword">new</span> BufferedImage(WIDTH,HEIGHT,BufferedImage.TYPE_3BYTE_BGR);<br>        <span class="hljs-comment">//得到图片</span><br>        Graphics g = bi.getGraphics();<br>        <span class="hljs-comment">//设置图片的背景色</span><br>        setBackGround(g);<br>        <span class="hljs-comment">//设置图片的边框</span><br>        setBorder(g);<br>        <span class="hljs-comment">//在图片上画干扰线</span><br>        drawRandomLine(g);<br>        <span class="hljs-comment">//在图片上放上随机字符</span><br>        String randomString = <span class="hljs-keyword">this</span>.drawRandomNum((Graphics2D)g, createTypeFlag);<br>        System.out.println(randomString);<br>        <span class="hljs-comment">//将随机数存在session中</span><br>        req.getSession().setAttribute(<span class="hljs-string">&quot;checkcode&quot;</span>, randomString);<br>        <br>        <span class="hljs-comment">//设置响应头通知浏览器以图片的形式打开</span><br>        resp.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>        <br>        <span class="hljs-comment">//设置响应头控制浏览器不要缓存</span><br>        resp.setDateHeader(<span class="hljs-string">&quot;expries&quot;</span>, -<span class="hljs-number">1</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>        <br>        <span class="hljs-comment">//将图片传给浏览器</span><br>        ImageIO.write(bi, <span class="hljs-string">&quot;jpg&quot;</span>, resp.getOutputStream());<br>    &#125;<br>    <br>    <span class="hljs-comment">//设置图片背景色</span><br>    <span class="hljs-comment">//@param g</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBackGround</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        <span class="hljs-comment">//设置颜色</span><br>        g.setColor(Color.WHITE);<br>        <span class="hljs-comment">//填充区域</span><br>        g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, WIDTH, HEIGHT);<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 设置图片的边框</span><br><span class="hljs-comment">     * @param g</span><br><span class="hljs-comment">     * */</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBorder</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        <span class="hljs-comment">//设置边框颜色</span><br>        g.setColor(Color.BLUE);<br>        <span class="hljs-comment">//边框区域</span><br>        g.drawRect(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, WIDTH - <span class="hljs-number">2</span>, HEIGHT -<span class="hljs-number">2</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在图片上画随机线条 </span><br><span class="hljs-comment">     * @param g</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRandomLine</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        <span class="hljs-comment">//设置颜色</span><br>        g.setColor(Color.GREEN);<br>        <span class="hljs-comment">//设置线条个数并画线</span><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">7</span> ; i++ ) &#123;<br>            <span class="hljs-keyword">int</span> x1 = <span class="hljs-keyword">new</span> Random().nextInt(WIDTH);<br>            <span class="hljs-keyword">int</span> y1 = <span class="hljs-keyword">new</span> Random().nextInt(HEIGHT);<br>            <span class="hljs-keyword">int</span> x2 = <span class="hljs-keyword">new</span> Random().nextInt(WIDTH);<br>            <span class="hljs-keyword">int</span> y2 = <span class="hljs-keyword">new</span> Random().nextInt(HEIGHT);<br>            g.drawLine(x1, y1, x2, y2);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在图片上画随机字符</span><br><span class="hljs-comment">     * @param g</span><br><span class="hljs-comment">     * @param createTypeFlag</span><br><span class="hljs-comment">     * @return String</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">drawRandomNum</span><span class="hljs-params">(Graphics g,String createTypeFlag)</span> </span>&#123;<br>        <span class="hljs-comment">//设置颜色</span><br>        g.setColor(Color.BLUE);<br>        g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">&quot;宋体&quot;</span>,Font.BOLD,<span class="hljs-number">20</span>));<br>        <br>        <span class="hljs-comment">//数字字母的组合</span><br>        String baseNumLetter = <span class="hljs-string">&quot;0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ&quot;</span>;<br>        String baseNum = <span class="hljs-string">&quot;0123456789&quot;</span>;<br>        String baseLetter = <span class="hljs-string">&quot;ABCDEFGHJKLMNOPQRSTUVWXYZ&quot;</span>;<br>        <span class="hljs-keyword">if</span> ( createTypeFlag != <span class="hljs-keyword">null</span>  &amp;&amp; createTypeFlag.length() &gt; <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-keyword">if</span>( createTypeFlag.equals(<span class="hljs-string">&quot;nl&quot;</span>) ) &#123;<br>                <span class="hljs-comment">//截取数字和字母的组合</span><br>                <span class="hljs-keyword">return</span> createRandomChar((Graphics2D) g,baseNumLetter);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( createTypeFlag.equals(<span class="hljs-string">&quot;n&quot;</span>) ) &#123;<br>                <span class="hljs-comment">//截取数字的组合</span><br>                <span class="hljs-keyword">return</span> createRandomChar((Graphics2D) g,baseNum);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( createTypeFlag.equals(<span class="hljs-string">&quot;l&quot;</span>) ) &#123;<br>                <span class="hljs-comment">//截取字母的组合</span><br>                <span class="hljs-keyword">return</span> createRandomChar((Graphics2D) g,baseLetter);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//截取数字和字母的组合</span><br>            <span class="hljs-keyword">return</span> createRandomChar((Graphics2D) g,baseNumLetter);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 创建随机字符</span><br><span class="hljs-comment">     * @param g</span><br><span class="hljs-comment">     * @param baseChar</span><br><span class="hljs-comment">     * @return String</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">createRandomChar</span><span class="hljs-params">(Graphics2D g , String baseChar)</span> </span>&#123;<br>        StringBuffer b = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br>        String ch = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; WORDS_NUMBER ; i++ ) &#123;<br>            <span class="hljs-comment">//设置字体的旋转角度</span><br>            <span class="hljs-keyword">int</span> degree = <span class="hljs-keyword">new</span> Random().nextInt() % <span class="hljs-number">30</span>;<br>            ch = baseChar.charAt(<span class="hljs-keyword">new</span> Random().nextInt(baseChar.length())) + <span class="hljs-string">&quot;&quot;</span>;<br>            b.append(ch);<br>            <br>            <span class="hljs-comment">//正向角度</span><br>            g.rotate(degree  * Math.PI / <span class="hljs-number">180</span> , x,<span class="hljs-number">20</span>);<br>            g.drawString(ch, x, <span class="hljs-number">20</span>);<br>            <span class="hljs-comment">//反向角度</span><br>            g.rotate(-degree  * Math.PI / <span class="hljs-number">180</span> , x,<span class="hljs-number">20</span>);<br>            x+=<span class="hljs-number">30</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b.toString();<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@RequestMapping(value=&quot;/userLogin.do&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userLogin</span><span class="hljs-params">(String code,HttpSession session)</span></span>&#123;<br>String cht=(String)session.getAttribute(<span class="hljs-string">&quot;checkcode&quot;</span>);<br><span class="hljs-keyword">if</span>(code.equalsIgnoreCase(cht))&#123;<br>System.out.println(<span class="hljs-string">&quot;验证码正确&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;form&gt;<br>&lt;img src=<span class="hljs-string">&quot;BufferImage&quot;</span> οnclick=<span class="hljs-string">&quot;this.src=&#x27;BufferImage?&#x27;+new Date().getTime()&quot;</span>&gt;看不清换一张&lt;br&gt;&lt;br&gt;<br>验证码： &lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;verify&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;input-medium&quot;</span> placeholder=<span class="hljs-string">&quot;验证码&quot;</span>&gt;<br>&lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>&lt;/form&gt;<br> <br></code></pre></td></tr></table></figure><h2 id="第二种方式（Spring-Boot框架使用）"><a href="#第二种方式（Spring-Boot框架使用）" class="headerlink" title="第二种方式（Spring Boot框架使用）"></a>第二种方式（Spring Boot框架使用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhiyou.util;<br> <br> <br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.util.Random;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferImage</span> </span>&#123;<br> <br>    <span class="hljs-comment">// 验证码字符集</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] chars = &#123;<br>            <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>,<br>            <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>,<br>            <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>&#125;;<br>    <span class="hljs-comment">// 字符数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 干扰线数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LINES = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 宽度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WIDTH = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 高度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEIGHT = <span class="hljs-number">32</span>;<br>    <span class="hljs-comment">// 字体大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FONT_SIZE = <span class="hljs-number">25</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成随机验证码及图片</span><br><span class="hljs-comment">     * 数组中[验证码，图片]</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object[] createImage() &#123;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-comment">// 1.创建空白图片</span><br>        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(<br>                WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);<br>        <span class="hljs-comment">// 2.获取图片画笔</span><br>        Graphics graphic = image.getGraphics();<br>        <span class="hljs-comment">// 3.设置画笔颜色</span><br>        graphic.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">216</span>, <span class="hljs-number">172</span>, <span class="hljs-number">203</span>, <span class="hljs-number">241</span>));<br>        <span class="hljs-comment">// 4.绘制矩形背景</span><br>        graphic.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, WIDTH, HEIGHT);<br> <br>        <span class="hljs-comment">// 5.画随机字符</span><br>        Random ran = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;SIZE; i++) &#123;<br>            <span class="hljs-comment">// 取随机字符索引</span><br>            <span class="hljs-keyword">int</span> n = ran.nextInt(chars.length);<br>            <span class="hljs-comment">// 设置随机颜色</span><br>            graphic.setColor(getRandomColor());<br>            <span class="hljs-comment">// 设置字体大小</span><br>            graphic.setFont(<span class="hljs-keyword">new</span> Font(<br>                    <span class="hljs-keyword">null</span>, Font.BOLD + Font.ITALIC, FONT_SIZE));<br>            <span class="hljs-comment">// 画字符</span><br>            graphic.drawString(<br>                    chars[n] + <span class="hljs-string">&quot;&quot;</span>, i * WIDTH / SIZE, HEIGHT/<span class="hljs-number">2</span>+HEIGHT/<span class="hljs-number">8</span>);<br>            <span class="hljs-comment">// 记录字符</span><br>            sb.append(chars[n]);<br>        &#125;<br>        <span class="hljs-comment">// 6.画干扰线</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LINES; i++) &#123;<br> <br>            graphic.setColor(getRandomColor());<br>            <span class="hljs-comment">// 随机画线</span><br>            graphic.drawLine(ran.nextInt(WIDTH), ran.nextInt(HEIGHT),<br>                    ran.nextInt(WIDTH), ran.nextInt(HEIGHT));<br>        &#125;<br>        <span class="hljs-comment">// 7.返回验证码和图片</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object[]&#123;sb.toString(), image&#125;;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 随机取色</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Color <span class="hljs-title">getRandomColor</span><span class="hljs-params">()</span> </span>&#123;<br>        Random ran = <span class="hljs-keyword">new</span> Random();<br>        Color color = <span class="hljs-keyword">new</span> Color(ran.nextInt(<span class="hljs-number">256</span>),<br>                ran.nextInt(<span class="hljs-number">256</span>), ran.nextInt(<span class="hljs-number">256</span>));<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Object[] objs = createImage();<br>        BufferedImage image = (BufferedImage) objs[<span class="hljs-number">1</span>];<br>        OutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;src/main/resources/static/picture/eb1ccd3d99794795bc99553b0b762e73.gif&quot;</span>);<br>        ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);<br>        os.close();<br>    &#125;<br> <br>&#125;<br> <br> <br></code></pre></td></tr></table></figure><h2 id="后台controller"><a href="#后台controller" class="headerlink" title="后台controller"></a>后台controller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* **********************************图片验证码************************************* */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/BufferImage&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createImg</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><span class="hljs-comment">//1.生成随机的验证码及图片</span><br>Object[] objs = BufferImage.createImage();<br><span class="hljs-comment">//2.将验证码存入session</span><br>String imgcode = (String) objs[<span class="hljs-number">0</span>];<br>HttpSession session = req.getSession();<br>session.setAttribute(<span class="hljs-string">&quot;checkcode&quot;</span>, imgcode);<br><span class="hljs-comment">//3.将图片输出给浏览器</span><br>BufferedImage img = (BufferedImage) objs[<span class="hljs-number">1</span>];<br>res.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br><span class="hljs-comment">//服务器自动创建输出流，目标指向浏览器</span><br>OutputStream os = res.getOutputStream();<br>ImageIO.write(img, <span class="hljs-string">&quot;png&quot;</span>, os);<br>os.close();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>图片验证码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java常用工具类</title>
    <link href="/blog/2021/03/24/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB1/"/>
    <url>/blog/2021/03/24/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB1/</url>
    
    <content type="html"><![CDATA[<h2 id="统计段落中出现某一个词的次数"><a href="#统计段落中出现某一个词的次数" class="headerlink" title="统计段落中出现某一个词的次数"></a>统计段落中出现某一个词的次数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wordCount</span><span class="hljs-params">()</span></span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>,index = <span class="hljs-number">0</span>;<br>    System.out.println(<span class="hljs-string">&quot;请输入句子：&quot;</span>);<br>    String s = scanner.nextLine();<br>    System.out.println(<span class="hljs-string">&quot;请输入要查询的词：&quot;</span>);<br>    String card = scanner.next();<br>    <span class="hljs-keyword">while</span> ((index = s.indexOf(card,index)) != -<span class="hljs-number">1</span>)&#123;<br>        index = index + card.length();<br>        count++;<br>    &#125;<br>    System.out.println(card + <span class="hljs-string">&quot;在句子中出现了&quot;</span>+ count + <span class="hljs-string">&quot;次&quot;</span>);<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="一个随机字符串，判断有多少字母有多少数字"><a href="#一个随机字符串，判断有多少字母有多少数字" class="headerlink" title="一个随机字符串，判断有多少字母有多少数字"></a>一个随机字符串，判断有多少字母有多少数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">letterAndnum</span><span class="hljs-params">()</span></span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入随机字符串：&quot;</span>);<br>    String s = scanner.nextLine();<br>    <span class="hljs-keyword">int</span> length = s.length();<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>,let = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i)))&#123;<br>            num++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Character.isLetter(s.charAt(i)))&#123;<br>            let++;<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;数字：&quot;</span>+num+<span class="hljs-string">&quot;   字母：&quot;</span>+let);<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="根据特定日期格式拆分日期"><a href="#根据特定日期格式拆分日期" class="headerlink" title="根据特定日期格式拆分日期"></a>根据特定日期格式拆分日期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如：请输入一个日期（格式如：**月**日****年）经过处理得到： ****年**月**日</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">splitDate</span><span class="hljs-params">()</span></span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入日期：（格式如：**月**日****年）&quot;</span>);<br>    String s = scanner.nextLine();<br>    <span class="hljs-keyword">int</span> i = s.indexOf(<span class="hljs-string">&quot;日&quot;</span>);<br>    String substring = s.substring(i + <span class="hljs-number">1</span>);<br>    String substring1 = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);<br>    System.out.println(substring + substring1);<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="敏感词过滤程序"><a href="#敏感词过滤程序" class="headerlink" title="敏感词过滤程序"></a>敏感词过滤程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fitterWords</span><span class="hljs-params">()</span></span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入聊天内容：&quot;</span>);<br>    String str = scanner.nextLine();<br>    String ch[] = &#123;<span class="hljs-string">&quot;色情&quot;</span>,<span class="hljs-string">&quot;爆炸&quot;</span>,<span class="hljs-string">&quot;恐怖&quot;</span>,<span class="hljs-string">&quot;军火&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (String s:ch) &#123;<br>        str = str.replaceAll(s,<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;聊天内容：&quot;</span>+str);<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="计算某年、某月、某日和某年、某月、某日之间的天数间隔和周数"><a href="#计算某年、某月、某日和某年、某月、某日之间的天数间隔和周数" class="headerlink" title="计算某年、某月、某日和某年、某月、某日之间的天数间隔和周数"></a>计算某年、某月、某日和某年、某月、某日之间的天数间隔和周数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leadTime</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入第一个日期：&quot;</span>);<br>    String str = scanner.nextLine();<br>    System.out.println(<span class="hljs-string">&quot;请输入第二个日期：&quot;</span>);<br>    String str2 = scanner.nextLine();<br>    SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    Date parse = dateFormat.parse(str);<br>    Date parse1 = dateFormat.parse(str2);<br>    <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (parse.after(parse1))&#123;<br>        a = parse.getTime() - parse1.getTime();<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        a = parse1.getTime() - parse.getTime();<br>    &#125;<br>    <span class="hljs-keyword">long</span> oneDay = <span class="hljs-number">1000</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span>;<br>    <span class="hljs-keyword">long</span> day = a/oneDay;<br>    <span class="hljs-keyword">long</span> week = day/<span class="hljs-number">7</span>;<br>    System.out.println(<span class="hljs-string">&quot;相隔：&quot;</span>+day+<span class="hljs-string">&quot; 天&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;相隔：&quot;</span>+week+<span class="hljs-string">&quot; 周&quot;</span>);<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="设定一个有大小写字母的字符串，先将字符串的大写字符输出，再将字符串中的小写字符输出"><a href="#设定一个有大小写字母的字符串，先将字符串的大写字符输出，再将字符串中的小写字符输出" class="headerlink" title="设定一个有大小写字母的字符串，先将字符串的大写字符输出，再将字符串中的小写字符输出"></a>设定一个有大小写字母的字符串，先将字符串的大写字符输出，再将字符串中的小写字符输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">letterUpperLower</span><span class="hljs-params">()</span></span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入字符串：&quot;</span>);<br>    String str = scanner.nextLine();<br>    <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>    System.out.println(<span class="hljs-string">&quot;大写字母为：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> a:chars) &#123;<br>        <span class="hljs-keyword">if</span> (Character.isUpperCase(a))&#123;<br>            System.out.println(a);<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;小写字母为：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> a:chars) &#123;<br>        <span class="hljs-keyword">if</span> (Character.isLowerCase(a))&#123;<br>            System.out.println(a);<br>        &#125;<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="计算并输出21世纪的闰年，程序的执行时间"><a href="#计算并输出21世纪的闰年，程序的执行时间" class="headerlink" title="计算并输出21世纪的闰年，程序的执行时间"></a>计算并输出21世纪的闰年，程序的执行时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leapYeay21</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    GregorianCalendar calendar = <span class="hljs-keyword">new</span> GregorianCalendar();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2000</span>;i&lt;<span class="hljs-number">2100</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span> (calendar.isLeapYear(i))&#123;<br>            System.out.println(i + <span class="hljs-string">&quot;是闰年&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;程序的执行时间为：&quot;</span>+(end - start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="当以yyyy-MM-dd格式输入一个日期时，输出其该年是否为闰年，该月有几天，该日是星期几"><a href="#当以yyyy-MM-dd格式输入一个日期时，输出其该年是否为闰年，该月有几天，该日是星期几" class="headerlink" title="当以yyyy-MM-dd格式输入一个日期时，输出其该年是否为闰年，该月有几天，该日是星期几"></a>当以yyyy-MM-dd格式输入一个日期时，输出其该年是否为闰年，该月有几天，该日是星期几</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isLeapYeay</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入日期：(格式：yyyy-MM-dd)&quot;</span>);<br>    String str = scanner.nextLine();<br>    SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    Date parse = dateFormat.parse(str);<br>    Calendar instance = Calendar.getInstance();<br>    instance.setTime(parse);<br>    <span class="hljs-keyword">int</span> year = instance.get(Calendar.YEAR);<br>    <span class="hljs-keyword">int</span> month = instance.get(Calendar.MONTH)+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> week = instance.get(Calendar.DAY_OF_WEEK)-<span class="hljs-number">1</span>;<br>    GregorianCalendar calendar = <span class="hljs-keyword">new</span> GregorianCalendar();<br>    <span class="hljs-keyword">if</span> (calendar.isLeapYear(year))&#123;<br>        System.out.println(year + <span class="hljs-string">&quot;是闰年&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(year + <span class="hljs-string">&quot;是平年&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> max = instance.getActualMaximum(Calendar.DAY_OF_MONTH);<br>    String s = week == <span class="hljs-number">0</span>?<span class="hljs-string">&quot;周日&quot;</span>:<span class="hljs-string">&quot;周&quot;</span>+week;<br>    System.out.println(month + <span class="hljs-string">&quot;月有&quot;</span> + max + <span class="hljs-string">&quot;日，该日是&quot;</span> + s);<br>&#125;<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsp实现轮播图</title>
    <link href="/blog/2021/03/24/jsp%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <url>/blog/2021/03/24/jsp%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>背景</strong> 支持ie老版本没办法使用比较新的框架,只能使用原始js实现。 <a href="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/shufflingFigure.gif">演示地址</a> 实现功能如下:</p><ol><li>鼠标放在图上暂停。</li><li>点击下面圆点切换图片。</li><li>点击左右箭头切换。</li><li>自动进行轮播。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.*&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;<br>&lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">&quot;/context/mytags.jsp&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;商品信息查看&lt;/title&gt;<br>    &lt;style&gt;<br>        .ui-button &#123;<br>            display: inline-block;<br>            padding: 2px 2px;<br>            margin-bottom: <span class="hljs-number">0</span>;<br>            font-size: 8px;<br>            font-weight: normal;<br>            line-height: <span class="hljs-number">1.42857143</span>;<br>            text-align: center;<br>            white-space: nowrap;<br>            vertical-align: middle;<br>            -ms-touch-action: manipulation;<br>            touch-action: manipulation;<br>            cursor: pointer;<br>            -webkit-user-select: none;<br>            -moz-user-select: none;<br>            -ms-user-select: none;<br>            user-select: none;<br>            background-image: none;<br>            border: 1px solid transparent;<br>            border-radius: 4px;<br>        &#125;<br> <br>        body &#123;<br>            overflow: scroll;<br>        &#125;<br> <br>        <span class="hljs-comment">/* 轮播图样式表 */</span><br> <br>        #content #carousel_wrap &#123;<br>            position: relative;<br>            margin: <span class="hljs-number">0</span> auto;<br>            width: <span class="hljs-number">100</span>%; <span class="hljs-comment">/* 轮播图宽度 */</span><br>            overflow: hidden;<br>        &#125;<br> <br>        #content #carousel_wrap #carousel_images &#123;<br>            position: absolute;<br>            border: <span class="hljs-number">0</span>;<br>            outline: none;<br>            white-space: nowrap; <span class="hljs-comment">/* 将图片一行排列 */</span><br>            width: <span class="hljs-number">100</span>%;<br>            font-size: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 清除white-space间隙 */</span><br>            margin: 0px;<br>        &#125;<br> <br>        #content #carousel_wrap #carousel_images img &#123;<br>            width: <span class="hljs-number">100</span>%;<br>        &#125;<br> <br>        #content #carousel_wrap .arrow &#123;<br>            position: absolute;<br>            font-weight: bold;<br>            font-size: 50px;<br>            color: lightgray;<br>            top: <span class="hljs-number">50</span>%;<br>            transform: translateY(-<span class="hljs-number">50</span>%);<br>            cursor: pointer;<br>            transition-property: opacity;<br>            transition-duration: <span class="hljs-number">0.</span>5s;<br>        &#125;<br> <br>        #content #carousel_wrap .arrow:hover &#123;<br>            opacity: <span class="hljs-number">0.5</span>;<br>        &#125;<br> <br>        #content #carousel_wrap .left-arrow &#123;<br>            left: 20px;<br>        &#125;<br> <br>        #content #carousel_wrap .right-arrow &#123;<br>            right: 20px;<br>        &#125;<br> <br>        #content #carousel_wrap #dots &#123;<br>            position: absolute;<br>            bottom: 20px;<br>            left: <span class="hljs-number">50</span>%;<br>            transform: translateX(-<span class="hljs-number">50</span>%)<br>        &#125;<br> <br>        #content #carousel_wrap .dot &#123;<br>            background-color: white;<br>            display: inline-block;<br>            width: 10px;<br>            height: 10px;<br>            border-radius: <span class="hljs-number">50</span>%;<br>            margin: 4px;<br>            opacity: <span class="hljs-number">0.2</span>;<br>            cursor: pointer;<br>        &#125;<br> <br>        #content #carousel_wrap .active &#123;<br>            opacity: <span class="hljs-number">1</span>;<br>        &#125;<br> <br>        .transition &#123;<br>            transition-property: left;<br>            transition-duration: 1s;<br>        &#125;<br> <br>        <span class="hljs-comment">/* END 轮播图样式表 */</span><br> <br> <br>    &lt;/style&gt;<br> <br><span class="hljs-comment">/* 这里引入自己jquery就行 */</span><br>    &lt;t:base type=&quot;jquery,easyui,tools,DatePicker&quot;&gt;&lt;/t:base&gt;<br>    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>        $(document).ready(function () &#123;<br>            $(<span class="hljs-string">&#x27;#tt&#x27;</span>).tabs(&#123;<br>                onSelect: function (title) &#123;<br>                    $(<span class="hljs-string">&#x27;#tt .panel-body&#x27;</span>).css(<span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-string">&#x27;auto&#x27;</span>);<br>                &#125;<br>            &#125;);<br>            $(<span class="hljs-string">&quot;.tabs-wrap&quot;</span>).css(<span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-string">&#x27;100%&#x27;</span>);<br>        &#125;);<br>    &lt;/script&gt;<br> <br> <br> <br> <br>&lt;/head&gt;<br> <br>&lt;body&gt;<br> <br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br> <br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;<br>    &lt;title&gt;Lifeblog.com&lt;/title&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;js/friends.js&quot;&gt;&lt;/script&gt;<br>    &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> type=<span class="hljs-string">&quot;text/css&quot;</span> href=<span class="hljs-string">&quot;css/friends.css&quot;</span>/&gt;<br>&lt;/head&gt;<br> <br>&lt;body&gt;<br> <br> <br>&lt;!-- 轮播图 --&gt;<br>&lt;div id=<span class="hljs-string">&quot;content&quot;</span>&gt;<br>    &lt;div id=<span class="hljs-string">&quot;carousel_wrap&quot;</span>&gt;<br>        &lt;div id=<span class="hljs-string">&quot;carousel_images&quot;</span>&gt;<br>            &lt;!-- 前后分别加上一张图片，方便无缝过渡显示。可以使用JS DOM增加节点操作省去该步骤 --&gt;<br>            &lt;img src=<span class="hljs-string">&quot; &quot;</span> width=<span class="hljs-string">&#x27;675&#x27;</span> height=<span class="hljs-string">&#x27;380&#x27;</span> id=<span class="hljs-string">&quot;first&quot;</span>&gt;<br>            &lt;img src=<span class="hljs-string">&quot; &quot;</span> width=<span class="hljs-string">&#x27;675&#x27;</span> height=<span class="hljs-string">&#x27;380&#x27;</span> id=<span class="hljs-string">&quot;worst&quot;</span>&gt;<br>        &lt;/div&gt;<br>        &lt;span class=&quot;arrow left-arrow&quot;&gt;&amp;lt;&lt;/span&gt;<br>        &lt;span class=&quot;arrow right-arrow&quot;&gt;&amp;gt;&lt;/span&gt;<br>        &lt;div id=<span class="hljs-string">&quot;dots&quot;</span>&gt;<br>            &lt;!-- 使用小点标记实际多少张图片，要添加图片时需要修改carousel_images和此处 --&gt;<br>            &lt;span class=&quot;dot active&quot;&gt;&lt;/span&gt;<br>            &lt;%--&lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;--%&gt;<br>            &lt;%--&lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;--%&gt;<br> <br>        &lt;/div&gt;<br>    &lt;/div&gt;<br> <br>&lt;/div&gt;<br>&lt;!-- END 轮播图 --&gt;<br> <br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br> <br>&lt;script&gt;<br>    window.onload = function () &#123;<br><span class="hljs-comment">//动态从后台获取图片</span><br>        <span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;lpaArticlesController.do?getFiles&#x27;</span>;<br>        url += <span class="hljs-string">&#x27;&amp;id=&#x27;</span> + <span class="hljs-string">&#x27;$&#123;id&#125;&#x27;</span>;<br>        $.ajax(&#123;<br>            url: url,<br>            type: <span class="hljs-string">&#x27;post&#x27;</span>,<br>            cache: <span class="hljs-keyword">false</span>,<br>            success: function (data) &#123;<br>                <span class="hljs-keyword">var</span> d = $.parseJSON(data);<br>                console.log(d.obj);<br>                <span class="hljs-keyword">if</span> (d.obj.length &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">//增加图片</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.obj.length; i++) &#123;<br>                        $(<span class="hljs-string">&quot;#carousel_images&quot;</span>).append(<span class="hljs-string">&quot;&lt;img width=&#x27;675&#x27; height=&#x27;380&#x27; src=&quot;</span> + d.obj[i].path + <span class="hljs-string">&quot; &gt;&quot;</span>);<br>                        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                            $(<span class="hljs-string">&quot;#first&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, d.obj[<span class="hljs-number">0</span>].path);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            $(<span class="hljs-string">&quot;#worst&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, d.obj[d.obj.length - <span class="hljs-number">1</span>].path);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//增加小圆点</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.obj.length - <span class="hljs-number">1</span>; i++) &#123;<br>                        $(<span class="hljs-string">&quot;#dots&quot;</span>).append(<span class="hljs-string">&quot;&lt;span class=&#x27;dot&#x27;&gt;&lt;/span&gt;&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d.obj.length == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">//如果只有一张图片 不需要加圆点</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.obj.length; i++) &#123;<br>                        $(<span class="hljs-string">&quot;#first&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>                        $(<span class="hljs-string">&quot;#worst&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, d.obj[<span class="hljs-number">0</span>].path);<br>                        $(<span class="hljs-string">&quot;#carousel_images&quot;</span>).append(<span class="hljs-string">&quot;&lt;img width=&#x27;675&#x27; height=&#x27;380&#x27; src=&quot;</span> + d.obj[i].path + <span class="hljs-string">&quot; &gt;&quot;</span>);<br>                    &#125;<br> <br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//没有图片的时候 建议放一张空白图</span><br>                    $(<span class="hljs-string">&quot;#first&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;webpage/main/img/noPictures.jpg&quot;</span>);<br>                    $(<span class="hljs-string">&quot;#worst&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;webpage/main/img/noPictures.jpg&quot;</span>);<br>                    $(<span class="hljs-string">&quot;#carousel_images&quot;</span>).append(<span class="hljs-string">&quot;&lt;img width=&#x27;675&#x27; height=&#x27;380&#x27; src=&#x27;webpage/main/img/noPictures.jpg&#x27; &gt;&quot;</span>);<br> <br>                &#125;<br> <br> <br>                <span class="hljs-keyword">var</span> carouImg = document.getElementById(<span class="hljs-string">&quot;carousel_images&quot;</span>);<br>                <span class="hljs-keyword">var</span> carouWrap = document.getElementById(<span class="hljs-string">&quot;carousel_wrap&quot;</span>);<br>                <span class="hljs-keyword">var</span> img = carouImg.getElementsByTagName(<span class="hljs-string">&quot;img&quot;</span>)[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">var</span> leftArrow = document.getElementsByClassName(<span class="hljs-string">&quot;left-arrow&quot;</span>)[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">var</span> rightArrow = document.getElementsByClassName(<span class="hljs-string">&quot;right-arrow&quot;</span>)[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">var</span> oBtn = document.getElementsByClassName(<span class="hljs-string">&quot;dot&quot;</span>);<br>                <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//设置图片下面小点个数</span><br>                <span class="hljs-keyword">var</span> index_length = d.obj.length;<br>                <span class="hljs-comment">// var index_length = oBtn.length;</span><br> <br>                <span class="hljs-comment">// 给图片添加过渡效果</span><br>                carouImg.classList.add(<span class="hljs-string">&quot;transition&quot;</span>);<br> <br>                <span class="hljs-comment">// 动态获取绝对定位轮播图的高度，设置carousel_wrap的高度，宽度为整个main宽度</span><br>                <span class="hljs-comment">// 如果mystyle.css中使用overflow:auto-&gt;含有滚动条宽度; 故使用overflow:scroll</span><br>                carouImg.style.left = -img.clientWidth + <span class="hljs-string">&quot;px&quot;</span>;<br>                carouWrap.style.height = img.offsetHeight + <span class="hljs-string">&quot;px&quot;</span>;<br> <br>                <span class="hljs-comment">// 监听body大小变化，修改轮播图的图片位置和高度</span><br>                document.body.onresize = function () &#123;<br>                    carouImg.style.left = -img.clientWidth + <span class="hljs-string">&quot;px&quot;</span>;<br>                    carouWrap.style.height = img.offsetHeight + <span class="hljs-string">&quot;px&quot;</span>;<br>                &#125;<br> <br>                <span class="hljs-comment">// 点击右箭头</span><br>                rightArrow.onclick = function () &#123;<br>                    next_pic();<br>                    showCurrentDot(index);<br>                &#125;<br> <br>                <span class="hljs-comment">// 点击左箭头</span><br>                leftArrow.onclick = function () &#123;<br>                    pre_pic();<br>                    showCurrentDot(index);<br>                &#125;<br> <br>                <span class="hljs-comment">// 点击小点</span><br>                <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; oBtn.length; ++i) &#123;<br>                    oBtn[i].onclick = function () &#123;<br>                        <span class="hljs-keyword">var</span> newLeft = (-img.clientWidth) * (i + <span class="hljs-number">1</span>);<br>                        carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>;<br>                        console.log(i);<br>                        showCurrentDot(i);<br> <br> <br>                        <span class="hljs-keyword">var</span> left = parseInt(carouImg.style.left);<br>                        <span class="hljs-keyword">var</span> newLeft;<br> <br>                        <span class="hljs-comment">// 如果没有临界判断，当图片位于“替补图片”时，点击提示点会有错乱过渡</span><br>                        <span class="hljs-keyword">if</span> (left &lt;= (-img.clientWidth) * (index_length + <span class="hljs-number">1</span>)) &#123;<br>                            <span class="hljs-comment">// 临界情况判断</span><br>                            carouImg.classList.remove(<span class="hljs-string">&quot;transition&quot;</span>);<br>                            newLeft = -img.clientWidth * <span class="hljs-number">1</span>;<br>                            carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (left &gt;= -<span class="hljs-number">10</span>) &#123;<br>                            <span class="hljs-comment">// 临界情况判断</span><br>                            carouImg.classList.remove(<span class="hljs-string">&quot;transition&quot;</span>);<br>                            newLeft = -img.clientWidth * index_length;<br>                            carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>;<br>                        &#125;<br> <br>                        newLeft = (-img.clientWidth) * (i + <span class="hljs-number">1</span>);<br>                        carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>;<br>                        <span class="hljs-comment">// 注意click事件的执行过程，要在修改完left后添加transition类</span><br>                        carouImg.classList.add(<span class="hljs-string">&quot;transition&quot;</span>);<br>                        index = i;<br>                        showCurrentDot(i);<br> <br>                    &#125;<br>                &#125;<br> <br>                <span class="hljs-comment">// 下一张图片</span><br>                <span class="hljs-function">function <span class="hljs-title">next_pic</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">var</span> left = parseInt(carouImg.style.left);<br>                    <span class="hljs-keyword">if</span> (left &lt;= (-img.clientWidth) * (index_length + <span class="hljs-number">1</span>)) &#123;<br>                        <span class="hljs-comment">// 临界情况判断</span><br>                        carouImg.classList.remove(<span class="hljs-string">&quot;transition&quot;</span>);<br>                        <span class="hljs-keyword">var</span> newLeft = -img.clientWidth * <span class="hljs-number">1</span>;<br>                        carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>;<br>                        newLeft = -img.clientWidth * <span class="hljs-number">2</span>;<br>                        carouImg.classList.add(<span class="hljs-string">&quot;transition&quot;</span>);<br>                        index = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 一般情况</span><br>                        <span class="hljs-keyword">var</span> newLeft = parseInt(carouImg.style.left) - img.clientWidth;<br>                        (index == (index_length - <span class="hljs-number">1</span>)) ? index = <span class="hljs-number">0</span> : index += <span class="hljs-number">1</span>;<br>                    &#125;<br>                    carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// 不要忘记添加&#x27;px&#x27;</span><br>                &#125;<br> <br>                <span class="hljs-comment">// 上一张图片</span><br>                <span class="hljs-function">function <span class="hljs-title">pre_pic</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">var</span> left = parseInt(carouImg.style.left);<br>                    <span class="hljs-keyword">if</span> (left &gt;= -<span class="hljs-number">10</span>) &#123;<br>                        <span class="hljs-comment">// 临界情况判断</span><br>                        carouImg.classList.remove(<span class="hljs-string">&quot;transition&quot;</span>);<br>                        <span class="hljs-keyword">var</span> newLeft = -img.clientWidth * index_length;<br>                        carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>;<br>                        newLeft = -img.clientWidth * (index_length - <span class="hljs-number">1</span>);<br>                        carouImg.classList.add(<span class="hljs-string">&quot;transition&quot;</span>);<br>                        index = index_length - <span class="hljs-number">2</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 一般情况</span><br>                        <span class="hljs-keyword">var</span> newLeft = parseInt(carouImg.style.left) + img.clientWidth;<br>                        (index == <span class="hljs-number">0</span>) ? index = (index_length - <span class="hljs-number">1</span>) : index -= <span class="hljs-number">1</span>;<br>                    &#125;<br>                    carouImg.style.left = newLeft + <span class="hljs-string">&#x27;px&#x27;</span>;<br>                &#125;<br> <br>                <span class="hljs-function">function <span class="hljs-title">showCurrentDot</span><span class="hljs-params">(index)</span> </span>&#123;<br>                    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; oBtn.length; ++i) &#123;<br>                        (i == index) ? oBtn[i].classList.add(<span class="hljs-string">&quot;active&quot;</span>) : oBtn[i].classList.remove(<span class="hljs-string">&quot;active&quot;</span>);<br>                    &#125;<br>                &#125;<br> <br>                <span class="hljs-comment">// 设置轮播定时器 3秒</span><br>                <span class="hljs-keyword">var</span> timer = setInterval(function () &#123;<br>                    next_pic();<br>                    showCurrentDot(index);<br>                &#125;, <span class="hljs-number">3000</span>);<br> <br>                carouWrap.onmouseover = function () &#123;<br>                    clearInterval(timer);<br>                &#125;<br> <br>                carouWrap.onmouseout = function () &#123;<br>                    timer = setInterval(function () &#123;<br>                        next_pic();<br>                        showCurrentDot(index);<br>                    &#125;, <span class="hljs-number">3000</span>);<br>                &#125;<br> <br>            &#125;<br>        &#125;);<br> <br>    &#125;<br> <br>&lt;/script&gt;<br> <br>&lt;/body&gt;<br> <br> <br> <br> <br> <br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jsp</tag>
      
      <tag>轮播图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>forEach在集合中的使用</title>
    <link href="/blog/2021/03/24/forEach%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2021/03/24/forEach%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="迭代集合"><a href="#迭代集合" class="headerlink" title="迭代集合"></a>迭代集合</h2><p>任何类型Collection的可迭代 - 列表，集合，队列 等都具有使用forEach的相同语法。</p><p>因此，正如我们已经看到的，迭代列表的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Steve&quot;</span>, <span class="hljs-string">&quot;James&quot;</span>);<br> <br>names.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>同样对于一组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; uniqueNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Steve&quot;</span>, <span class="hljs-string">&quot;James&quot;</span>));<br> <br>uniqueNames.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>或者让我们说一个队列也是一个集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; namesQueue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;Larry&quot;</span>, <span class="hljs-string">&quot;Steve&quot;</span>, <span class="hljs-string">&quot;James&quot;</span>));<br> <br>namesQueue.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>迭代Map - 使用Map的forEach Map没有实现Iterable接口，但它提供了自己的forEach 变体，它接受BiConsumer。*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; namesMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>namesMap.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Larry&quot;</span>);<br>namesMap.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Steve&quot;</span>);<br>namesMap.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;James&quot;</span>);<br>namesMap.forEach((key, value) -&gt; System.out.println(key + <span class="hljs-string">&quot; &quot;</span> + value));<br></code></pre></td></tr></table></figure><p>迭代一个Map - 通过迭代entrySet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">namesMap.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + <span class="hljs-string">&quot; &quot;</span> + entry.getValue()));<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>forEach</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/2021/03/24/jsp%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE1/"/>
    <url>/blog/2021/03/24/jsp%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8中引入的forEach</title>
    <link href="/blog/2021/03/23/Java8%E4%B8%AD%E5%BC%95%E5%85%A5%E7%9A%84forEach/"/>
    <url>/blog/2021/03/23/Java8%E4%B8%AD%E5%BC%95%E5%85%A5%E7%9A%84forEach/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java 8中引入的forEach循环为程序员提供了一种新的，简洁而有趣的迭代集合的方式。</p><p>在本文中，我们将看到如何将forEach与集合一起使用，它采用何种参数以及此循环与增强的for循环的不同之处。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class"> </span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><p>Collection 接口实现了 Iterable 接口，而 Iterable 接口在 Java 8开始具有一个新的 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span><span class="hljs-comment">//对 Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>使用forEach，我们可以迭代一个集合并对每个元素执行给定的操作，就像任何其他迭代器一样。</p><p>例如，迭代和打印字符串集合的for循环版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String name : names) &#123;<br>    System.out.println(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用forEach写这个 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">names.forEach(name -&gt; &#123;<br>    System.out.println(name);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>我们使用 forEach迭代集合并对每个元素执行特定操作。要执行的操作包含在实现Consumer接口的类中，并作为参数传递给forEach 。</p><p>所述消费者接口是一个功能接口(具有单个抽象方法的接口）。它接受输入并且不返回任何结果。</p><p>Consumer 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>任何实现，例如，只是打印字符串的消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; printConsumer = <span class="hljs-keyword">new</span> Consumer&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(name);<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以作为参数传递给forEach：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">names.forEach(printConsumer);<br> <br></code></pre></td></tr></table></figure><p>但这不是通过消费者和使用forEach API 创建操作的唯一方法。让我们看看我们将使用forEach方法的另外2种最流行的方式：</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Java 8功能接口的主要优点是我们可以使用Lambda表达式来实例化它们，并避免使用庞大的匿名类实现。</p><p>由于 Consumer 接口属于函数式接口，我们可以通过以下形式在Lambda中表达它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(argument) -&gt; &#123; body &#125;<br>name -&gt; System.out.println(name)<br>names.forEach(name -&gt; System.out.println(name));<br></code></pre></td></tr></table></figure><p>方法参考 我们可以使用方法引用语法而不是普通的Lambda语法，其中已存在一个方法来对类执行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">names.forEach(System.out::println);<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java8</tag>
      
      <tag>forEach</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java生成二维码</title>
    <link href="/blog/2021/03/23/java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <url>/blog/2021/03/23/java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>使用开源的一维/二维码图形处理库zxing <a href="https://github.com/zxing/zxing">GayHub地址</a></p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/com.google.zxing/core --&gt;</span><br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;<br>    &lt;artifactId&gt;core&lt;/artifactId&gt;<br>    &lt;version&gt;3.3.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/com.google.zxing/javase --&gt;</span><br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;<br>    &lt;artifactId&gt;javase&lt;/artifactId&gt;<br>    &lt;version&gt;3.3.0&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.app.utils;<br> <br><span class="hljs-keyword">import</span> java.awt.Color;<br><span class="hljs-keyword">import</span> java.awt.Graphics2D;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br> <br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> com.google.zxing.BarcodeFormat;<br><span class="hljs-keyword">import</span> com.google.zxing.EncodeHintType;<br><span class="hljs-keyword">import</span> com.google.zxing.MultiFormatWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.client.j2se.MatrixToImageConfig;<br><span class="hljs-keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;<br><span class="hljs-keyword">import</span> com.google.zxing.common.BitMatrix;<br><span class="hljs-keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@title</span> 生成二维码工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@discribtion</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020年1月3日 下午4:26:05</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@vision</span> V1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QRCodeUtil</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">200</span>; <span class="hljs-comment">// 图像宽度</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">200</span>; <span class="hljs-comment">// 图像高度</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_COLOR = <span class="hljs-number">0xFF000001</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OFF_COLOR = <span class="hljs-number">0xFFFFFFFF</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@title</span> 生成二维码图片</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@discribtion</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> zch</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 2020年1月3日 下午3:27:21</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> width 二维码宽度，默认为200</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> height 二维码高度，默认为200</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> content 二维码内容，必填</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> logoPath logo图片路径，若为空则生成不带logo的二维码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> imgPath 生成二维码文件夹路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> imgName 生成二维码图片名称，必填</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> suffix 生成二维码图片后缀类型，例如：gif，必填</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@vision</span> V1.0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">generateQRImage</span><span class="hljs-params">(Integer width, Integer height, String content, String logoPath, String imgPath, String imgName, String suffix)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (content == <span class="hljs-keyword">null</span> || imgName == <span class="hljs-keyword">null</span> || suffix == <span class="hljs-keyword">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            width = width == <span class="hljs-keyword">null</span> ? QRCodeUtil.width : width;<br>            height = height == <span class="hljs-keyword">null</span> ? QRCodeUtil.height : height;<br>            <span class="hljs-keyword">if</span> (logoPath != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(logoPath.trim()))<br>            &#123;<br>                QREncode(width, height, content, logoPath, imgPath, imgName, suffix);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                QREncode(width, height, content, imgPath, imgName, suffix);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)<br>        &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@title</span> 生成二维码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@discribtion</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> zch</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 2020年1月3日 下午3:27:21</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@vision</span> V1.0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QREncode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, String content, String imgPath, String imgName, String suffix)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function">    </span>&#123;<br>        File filePath = <span class="hljs-keyword">new</span> File(imgPath);<br>        <span class="hljs-keyword">if</span> (!filePath.exists())<br>        &#123;<br>            filePath.mkdirs();<br>        &#125;<br>        File imageFile = <span class="hljs-keyword">new</span> File(imgPath, imgName);<br>        Map&lt;EncodeHintType, Object&gt; hints = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// 内容编码格式</span><br>        hints.put(EncodeHintType.CHARACTER_SET, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 指定纠错等级</span><br>        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);<br>        <span class="hljs-comment">// 设置二维码边的空度，非负数</span><br>        hints.put(EncodeHintType.MARGIN, <span class="hljs-number">1</span>);<br>        BitMatrix bitMatrix = <span class="hljs-keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, height, hints);<br>        MatrixToImageWriter.writeToPath(bitMatrix, suffix, imageFile.toPath());<span class="hljs-comment">// 输出原图片</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@title</span> 生成带logo的二维码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@discribtion</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> zch</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 2020年1月3日 下午3:27:21</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@vision</span> V1.0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QREncode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, String content, String logoPath, String imgPath, String imgName, String suffix)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function">    </span>&#123;<br>        File filePath = <span class="hljs-keyword">new</span> File(imgPath);<br>        <span class="hljs-keyword">if</span> (!filePath.exists())<br>        &#123;<br>            filePath.mkdirs();<br>        &#125;<br>        File imageFile = <span class="hljs-keyword">new</span> File(imgPath, imgName);<br>        Map&lt;EncodeHintType, Object&gt; hints = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">// 内容编码格式</span><br>        hints.put(EncodeHintType.CHARACTER_SET, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 指定纠错等级</span><br>        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);<br>        <span class="hljs-comment">// 设置二维码边的空度，非负数</span><br>        hints.put(EncodeHintType.MARGIN, <span class="hljs-number">1</span>);<br>        BitMatrix bitMatrix = <span class="hljs-keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, height, hints);<br>        MatrixToImageConfig matrixToImageConfig = <span class="hljs-keyword">new</span> MatrixToImageConfig(ON_COLOR, OFF_COLOR);<br>        BufferedImage bufferedImage = LogoMatrix(MatrixToImageWriter.toBufferedImage(bitMatrix, matrixToImageConfig), <span class="hljs-keyword">new</span> File(logoPath));<br>        ImageIO.write(bufferedImage, suffix, imageFile);<span class="hljs-comment">// 输出带logo图片</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@title</span> 二维码图片添加logo</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@discribtion</span>  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> zch</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Date</span> 2020年1月3日 下午3:27:21</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> matrixImage 源二维码图片</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> logoFile logo图片</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@vision</span> V1.0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BufferedImage <span class="hljs-title">LogoMatrix</span><span class="hljs-params">(BufferedImage matrixImage, File logoFile)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 读取二维码图片，并构建绘图对象</span><br>        Graphics2D gs = matrixImage.createGraphics();<br>        <span class="hljs-keyword">int</span> matrixWidth = matrixImage.getWidth();<br>        <span class="hljs-keyword">int</span> matrixHeigh = matrixImage.getHeight();<br>        <span class="hljs-keyword">int</span> ratioWidth = matrixWidth * <span class="hljs-number">2</span> / <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> ratioHeight = matrixHeigh * <span class="hljs-number">2</span> / <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// 读取Logo图片</span><br>        BufferedImage logo = ImageIO.read(logoFile);<br>        <span class="hljs-keyword">int</span> logoWidth = logo.getWidth(<span class="hljs-keyword">null</span>) &gt; ratioWidth ? ratioWidth : logo.getWidth(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">int</span> logoHeight = logo.getHeight(<span class="hljs-keyword">null</span>) &gt; ratioHeight ? ratioHeight : logo.getHeight(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">int</span> x = (matrixWidth - logoWidth) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> y = (matrixHeigh - logoHeight) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 绘制</span><br>        gs.drawImage(logo, x, y, logoWidth, logoHeight, <span class="hljs-keyword">null</span>);<br>        gs.setColor(Color.BLACK);<br>        gs.setBackground(Color.WHITE);<br> <br>        gs.dispose();<br>        matrixImage.flush();<br>        <span class="hljs-keyword">return</span> matrixImage;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试生成二维码"><a href="#测试生成二维码" class="headerlink" title="测试生成二维码"></a>测试生成二维码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">QRCodeUtil.generateQRImage(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;https://blog.csdn.net/qq_34928194&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;E:/&quot;</span>, <span class="hljs-string">&quot;test.gif&quot;</span>, <span class="hljs-string">&quot;gif&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>二维码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lamda表达式作用域(Lambda Scopes)</title>
    <link href="/blog/2021/03/23/Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/blog/2021/03/23/Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h2><p>我们可以直接在 lambda 表达式中访问外部的局部变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>Converter&lt;Integer, String&gt; stringConverter =<br>        (from) -&gt; String.valueOf(from + num);<br> <br>stringConverter.convert(<span class="hljs-number">2</span>);     <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>Converter&lt;Integer, String&gt; stringConverter =<br>        (from) -&gt; String.valueOf(from + num);<br> <br>stringConverter.convert(<span class="hljs-number">2</span>);     <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>Converter&lt;Integer, String&gt; stringConverter =<br>        (from) -&gt; String.valueOf(from + num);<br>num = <span class="hljs-number">3</span>;<span class="hljs-comment">//在lambda表达式中试图修改num同样是不允许的。</span><br></code></pre></td></tr></table></figure><h2 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h2><p>与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda4</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> outerStaticNum;<br>    <span class="hljs-keyword">int</span> outerNum;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testScopes</span><span class="hljs-params">()</span> </span>&#123;<br>        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;<br>            outerNum = <span class="hljs-number">23</span>;<br>            <span class="hljs-keyword">return</span> String.valueOf(from);<br>        &#125;;<br> <br>        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;<br>            outerStaticNum = <span class="hljs-number">72</span>;<br>            <span class="hljs-keyword">return</span> String.valueOf(from);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h2><p>还记得第一节中的 formula 示例吗？ Formula 接口定义了一个默认方法sqrt，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。</p><p>无法从 lambda 表达式中访问默认方法,故以下代码无法编译：</p><p>Formula formula = (a) -&gt; sqrt(a * 100);</p><h2 id="内置函数式接口-Built-in-Functional-Interfaces"><a href="#内置函数式接口-Built-in-Functional-Interfaces" class="headerlink" title="内置函数式接口(Built-in Functional Interfaces)"></a>内置函数式接口(Built-in Functional Interfaces)</h2><p>JDK 1.8 API包含许多内置函数式接口。 其中一些借口在老版本的 Java 中是比较常见的比如： Comparator 或Runnable，这些接口都增加了@FunctionalInterface注解以便能用在 lambda 表达式上。</p><p>但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 Google Guava 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h3 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h3><p>Predicate 接口是只有一个参数的返回布尔类型值的 断言型 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：</p><p>译者注： Predicate 接口源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br><span class="hljs-keyword">import</span> java.util.Objects;<br> <br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br> <br>    <span class="hljs-comment">// 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br> <br>    <span class="hljs-comment">//and方法与关系型运算符&quot;&amp;&amp;&quot;相似，两边都成立才返回true</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br>    <span class="hljs-comment">// 与关系运算符&quot;!&quot;相似，对判断进行取反</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>    &#125;<br>    <span class="hljs-comment">//or方法与关系型运算符&quot;||&quot;相似，两边只要有一个成立就返回true</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>    &#125;<br>   <span class="hljs-comment">// 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object targetRef)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">null</span> == targetRef)<br>                ? Objects::isNull<br>                : object -&gt; targetRef.equals(object);<br>    &#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="hljs-number">0</span>;<br> <br>predicate.test(<span class="hljs-string">&quot;foo&quot;</span>);              <span class="hljs-comment">// true</span><br>predicate.negate().test(<span class="hljs-string">&quot;foo&quot;</span>);     <span class="hljs-comment">// false</span><br> <br>Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;<br>Predicate&lt;Boolean&gt; isNull = Objects::isNull;<br> <br>Predicate&lt;String&gt; isEmpty = String::isEmpty;<br>Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();<br></code></pre></td></tr></table></figure><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>Function 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：</p><p>译者注： Function 接口源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util.function;<br> <br><span class="hljs-keyword">import</span> java.util.Objects;<br> <br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br> <br>    <span class="hljs-comment">//将Function对象应用到输入的参数上，然后返回计算结果。</span><br>    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br>    <span class="hljs-comment">//将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。</span><br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br> <br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Lamda</tag>
      
      <tag>作用域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式接口(Functional Interfaces)</title>
    <link href="/blog/2021/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <url>/blog/2021/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。 像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable 与 java.util.concurrent.Callable 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解@FunctionalInterface,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用@FunctionalInterface 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/@FunctionalInterface_1577755902803.png?x-oss-process=style/small" alt="@FunctionalInterface">示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">F</span>, <span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-function">T <span class="hljs-title">convert</span><span class="hljs-params">(F from)</span></span>;<br>&#125;<br> <br>  <span class="hljs-comment">// TODO 将数字字符串转换为整数类型</span><br>    Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);<br>    Integer converted = converter.convert(<span class="hljs-string">&quot;123&quot;</span>);<br>    System.out.println(converted.getClass()); <span class="hljs-comment">//class java.lang.Integer</span><br></code></pre></td></tr></table></figure><h3 id="方法和构造函数引用-Method-and-Constructor-References"><a href="#方法和构造函数引用-Method-and-Constructor-References" class="headerlink" title="方法和构造函数引用(Method and Constructor References)"></a>方法和构造函数引用(Method and Constructor References)</h3><p>前一节中的代码还可以通过静态方法引用来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Converter&lt;String, Integer&gt; converter = Integer::valueOf;<br>   Integer converted = converter.convert(<span class="hljs-string">&quot;123&quot;</span>);<br>   System.out.println(converted.getClass());   <span class="hljs-comment">//class java.lang.Integer</span><br></code></pre></td></tr></table></figure><p>Java 8允许您通过::关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">startsWith</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.valueOf(s.charAt(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br> <br>Something something = <span class="hljs-keyword">new</span> Something();<br>Converter&lt;String, String&gt; converter = something::startsWith;<br>String converted = converter.convert(<span class="hljs-string">&quot;Java&quot;</span>);<br>System.out.println(converted);    <span class="hljs-comment">// &quot;J&quot;</span><br></code></pre></td></tr></table></figure><p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String firstName;<br>    String lastName;<br> <br>    Person() &#123;&#125;<br> <br>    Person(String firstName, String lastName) &#123;<br>        <span class="hljs-keyword">this</span>.firstName = firstName;<br>        <span class="hljs-keyword">this</span>.lastName = lastName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonFactory</span>&lt;<span class="hljs-title">P</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>&gt; </span>&#123;<br>    <span class="hljs-function">P <span class="hljs-title">create</span><span class="hljs-params">(String firstName, String lastName)</span></span>;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PersonFactory&lt;Person&gt; personFactory = Person::<span class="hljs-keyword">new</span>;<br>Person person = personFactory.create(<span class="hljs-string">&quot;Peter&quot;</span>, <span class="hljs-string">&quot;Parker&quot;</span>);<br> <br></code></pre></td></tr></table></figure><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的参数类型来选择合适的构造函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>函数式接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8Tutorial</title>
    <link href="/blog/2021/03/23/Java8Tutorial/"/>
    <url>/blog/2021/03/23/Java8Tutorial/</url>
    
    <content type="html"><![CDATA[<p>接口的默认方法(Default Methods for Interfaces) Java 8使我们能够通过使用 default 关键字向接口添加非抽象方法实现。 此功能也称为虚拟扩展方法。</p><p>第一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Formula</span></span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.sqrt(a);<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>Formula 接口中除了抽象方法计算接口公式还定义了默认方法 sqrt。 实现该接口的类只需要实现抽象方法 calculate。 默认方法sqrt 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO 通过匿名内部类方式访问接口</span><br>    Formula formula = <span class="hljs-keyword">new</span> Formula() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> sqrt(a * <span class="hljs-number">100</span>);<br>        &#125;<br>    &#125;;<br> <br>    System.out.println(formula.calculate(<span class="hljs-number">100</span>));     <span class="hljs-comment">// 100.0</span><br>    System.out.println(formula.sqrt(<span class="hljs-number">16</span>));           <span class="hljs-comment">// 4.0</span><br> <br>  &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。</p><p>译者注： 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。</p><h2 id="Lambda表达式-Lambda-expressions"><a href="#Lambda表达式-Lambda-expressions" class="headerlink" title="Lambda表达式(Lambda expressions)"></a>Lambda表达式(Lambda expressions)</h2><p>首先看看在老版本的Java中是如何排列字符串的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;peter&quot;</span>, <span class="hljs-string">&quot;anna&quot;</span>, <span class="hljs-string">&quot;mike&quot;</span>, <span class="hljs-string">&quot;xenia&quot;</span>);<br> <br>Collections.sort(names, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b.compareTo(a);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>只需要给静态方法Collections.sort 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 sort 方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(names, (String a, String b) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> b.compareTo(a);<br>&#125;);<br></code></pre></td></tr></table></figure><p>可以看出，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));<br> <br></code></pre></td></tr></table></figure><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">names.sort((a, b) -&gt; b.compareTo(a));<br> <br></code></pre></td></tr></table></figure><p>List 类本身就有一个 sort 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/2021/03/23/java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%811/"/>
    <url>/blog/2021/03/23/java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%811/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BIO,NIO,AIO总结</title>
    <link href="/blog/2021/03/21/BIO,NIO,AIO%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2021/03/21/BIO,NIO,AIO%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。</p><p>在讲 BIO,NIO,AIO 之前先来回顾一下这样几个概念：同步与异步，阻塞与非阻塞。 同步与异步</p><ul><li>同步： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li><li>异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。 同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</li></ul><p>阻塞和非阻塞</p><ul><li>阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li>非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。 举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在那里傻等着水开（同步阻塞）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（同步非阻塞）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（异步非阻塞）。</li></ul><h2 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h2><p>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p><h3 id="传统-BIO"><a href="#传统-BIO" class="headerlink" title="传统 BIO"></a>传统 BIO</h3><p>BIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/2_1577323312632.png?x-oss-process=style/small" alt="2">采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p><p>如果要让 BIO 通信模型 能够同时处理多个客户端请求，就必须使用多线程（主要原因是socket.accept()、socket.read()、socket.write() 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 一请求一应答通信模型 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 线程池机制 改善，线程池还可以让线程的创建和回收成本相对较低。使用FixedThreadPool 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节”伪异步 BIO”中会详细介绍到。</p><p>我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？</p><p>在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p><h3 id="伪异步-IO"><a href="#伪异步-IO" class="headerlink" title="伪异步 IO"></a>伪异步 IO</h3><p>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><p>伪异步IO模型图(图源网络，原出处不明)：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210321160958899.png" alt="3">采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面代码中演示了BIO通信（一请求一应答）模型。我们会在客户端创建多个线程依次连接服务端并向其发送”当前时间+:hello world”，服务端会为每个客户端线程创建一个线程来处理。代码示例出自闪电侠的博客，原地址如下：</p><p><a href="https://www.jianshu.com/p/a4e03835921a">https://www.jianshu.com/p/a4e03835921a</a> 客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 闪电侠</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年10月14日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOClient</span> </span>&#123;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO 创建多个线程，模拟多个客户端连接服务端</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">3333</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            socket.getOutputStream().write((<span class="hljs-keyword">new</span> Date() + <span class="hljs-string">&quot;: hello world&quot;</span>).getBytes());<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      &#125;<br>    &#125;).start();<br> <br>  &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 闪电侠</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年10月14日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOServer</span> </span>&#123;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// TODO 服务端处理客户端连接请求</span><br>    ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">3333</span>);<br> <br>    <span class="hljs-comment">// 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 阻塞方法获取新的连接</span><br>          Socket socket = serverSocket.accept();<br> <br>          <span class="hljs-comment">// 每一个新的连接都创建一个线程，负责读取数据</span><br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">int</span> len;<br>              <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>              InputStream inputStream = socket.getInputStream();<br>              <span class="hljs-comment">// 按字节流方式读取数据</span><br>              <span class="hljs-keyword">while</span> ((len = inputStream.read(data)) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.println(<span class="hljs-keyword">new</span> String(data, <span class="hljs-number">0</span>, len));<br>              &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            &#125;<br>          &#125;).start();<br> <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br> <br>      &#125;<br>    &#125;).start();<br> <br>  &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><p><a href="https://bk.cuixiaoyan.xyz/archives/BIO#bio-blocking-io">BIO (Blocking I/O)</a><a href="https://bk.cuixiaoyan.xyz/archives/BIO#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">代码示例</a><a href="https://bk.cuixiaoyan.xyz/archives/BIO#%E6%80%BB%E7%BB%93">总结</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>乐观锁的缺点</title>
    <link href="/blog/2021/03/21/%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9/"/>
    <url>/blog/2021/03/21/%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p><p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h2 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h2><p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><h2 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h2><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p><h2 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h2><p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</p><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>乐观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>何谓悲观锁与乐观锁</title>
    <link href="/blog/2021/03/21/%E4%BD%95%E8%B0%93%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <url>/blog/2021/03/21/%E4%BD%95%E8%B0%93%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><h2 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h2><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><p>乐观锁常见的两种实现方式 乐观锁一般会使用版本号机制或CAS算法实现。</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（50（100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20 （20（100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</li></ol><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p><p>需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>乐观锁</tag>
      
      <tag>悲观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种常见的线程池详解</title>
    <link href="/blog/2021/03/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <url>/blog/2021/03/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>FixedThreadPool 被称为可重用固定线程数的线程池。通过 Executors 类中的相关源代码来看一下相关实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 创建一个可重用固定数量线程的线程池</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                     <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                     <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                     threadFactory);<br>   &#125;<br></code></pre></td></tr></table></figure><p>另外还有一个 FixedThreadPool 的实现方法，和上面的类似，所以这里不多做阐述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>  &#125;<br></code></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</p><h2 id="执行任务过程介绍"><a href="#执行任务过程介绍" class="headerlink" title="执行任务过程介绍"></a>执行任务过程介绍</h2><p>FixedThreadPool 的 execute() 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzcxMzc1OTYzLmpwZw_1577067898214.jpeg?x-oss-process=style/small" alt="aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzcxMzc1OTYzLmpwZw"></p><p>上图说明：</p><ol><li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li><li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；</li><li>线程池中的线程执行完 手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；</li></ol><h2 id="为什么不推荐使用FixedThreadPool"><a href="#为什么不推荐使用FixedThreadPool" class="headerlink" title="为什么不推荐使用FixedThreadPool"></a>为什么不推荐使用FixedThreadPool</h2><p>FixedThreadPool 使用无界队列 LinkedBlockingQueue（队列的容量为 Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</p><ol><li>当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li><li>由于使用无界队列时 maximumPoolSize 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 FixedThreadPool的源码可以看出创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 被设置为同一个值。</li><li>由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数；</li><li>运行中的 FixedThreadPool（未执行 shutdown()或 shutdownNow()）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li></ol><p><a href="https://bk.cuixiaoyan.xyz/archives/breakDown#fixedthreadpool">FixedThreadPool</a><a href="https://bk.cuixiaoyan.xyz/archives/breakDown#%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D">执行任务过程介绍</a><a href="https://bk.cuixiaoyan.xyz/archives/breakDown#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8fixedthreadpool">为什么不推荐使用FixedThreadPool</a></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/cuplogo-sm.png" alt="img">SupportShare</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池几个常见的对比</title>
    <link href="/blog/2021/03/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/blog/2021/03/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h2 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a>Runnable vs Callable</h2><p>Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p><p>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。</p><p>Runnable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 被线程执行，没有返回值也无法抛出异常</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Callable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算结果，或在无法这样做时抛出异常。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 计算得出的结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> 如果无法计算结果，则抛出异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a>execute() vs submit()</h2><ol><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 我们以AbstractExecutorService接口中的一个 submit 方法为例子来看看源代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>       <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>       execute(ftask);<br>       <span class="hljs-keyword">return</span> ftask;<br>   &#125;<br></code></pre></td></tr></table></figure><p>上面方法调用的 newTaskFor 方法返回了一个 FutureTask 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(runnable, value);<br>  &#125;<br></code></pre></td></tr></table></figure><p>我们再来看看execute()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>     ...<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a>shutdown()VSshutdownNow()</h2><ol><li>shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li>shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ol><h2 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a>isTerminated() VS isShutdown()</h2><ol><li>isShutDown 当调用 shutdown() 方法后返回为 true。</li><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadPoolExecutor使用示例</title>
    <link href="/blog/2021/03/19/ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <url>/blog/2021/03/19/ThreadPoolExecutor%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>我们上面讲解了 Executor框架以及 ThreadPoolExecutor 类，下面让我们实战一下，来通过写一个 ThreadPoolExecutor 的小 Demo 来回顾上面的内容。</p><h2 id="示例代码-Runnable-ThreadPoolExecutor"><a href="#示例代码-Runnable-ThreadPoolExecutor" class="headerlink" title="示例代码:Runnable+ThreadPoolExecutor"></a>示例代码:Runnable+ThreadPoolExecutor</h2><p>首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）</p><p>MyRunnable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> String command;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = s;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Start. Time = &quot;</span> + <span class="hljs-keyword">new</span> Date());<br>        processCommand();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; End. Time = &quot;</span> + <span class="hljs-keyword">new</span> Date());<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.command;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p><p>ThreadPoolExecutorDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutorDemo</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_CAPACITY = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long KEEP_ALIVE_TIME = <span class="hljs-number">1L</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <br>        <span class="hljs-comment">//使用阿里巴巴推荐的创建线程池的方式</span><br>        <span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_TIME,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<br> <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br>            Runnable worker = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">&quot;&quot;</span> + i);<br>            <span class="hljs-comment">//执行Runnable</span><br>            executor.execute(worker);<br>        &#125;<br>        <span class="hljs-comment">//终止线程池</span><br>        executor.shutdown();<br>        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Finished all threads&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li>corePoolSize: 核心线程数为 5。</li><li>maximumPoolSize ：最大线程数 10</li><li>keepAliveTime : 等待时间为 1L。</li><li>unit: 等待时间的单位为 TimeUnit.SECONDS。</li><li>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</li><li>handler:饱和策略为 CallerRunsPolicy。 Output：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br></code></pre></td></tr></table></figure><h2 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h2><p>我们通过代码输出结果可以看出：线程池每次会同时执行 5 个任务，这 5 个任务执行完之后，剩余的 5 个任务才会被执行。 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p><p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p><p>为了搞懂线程池的原理，我们需要首先分析一下 execute方法。在 5.1 节中的 Demo 中我们使用 executor.execute(worker)来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> c &amp; CAPACITY;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>       <span class="hljs-comment">// 如果任务为null，则抛出异常。</span><br>       <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>       <span class="hljs-comment">// ctl 中保存的线程池当前的一些状态信息</span><br>       <span class="hljs-keyword">int</span> c = ctl.get();<br><br>       <span class="hljs-comment">//  下面会涉及到 3 步 操作</span><br>       <span class="hljs-comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span><br>       <span class="hljs-comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span><br>       <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>           <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>               <span class="hljs-keyword">return</span>;<br>           c = ctl.get();<br>       &#125;<br>       <span class="hljs-comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span><br>       <span class="hljs-comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span><br>       <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>           <span class="hljs-keyword">int</span> recheck = ctl.get();<br>           <span class="hljs-comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span><br>           <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))<br>               reject(command);<br>               <span class="hljs-comment">// 如果当前线程池为空就新创建一个线程并执行。</span><br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>               addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>       &#125;<br>       <span class="hljs-comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span><br>       <span class="hljs-comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>           reject(command);<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>ThreadPoolExecutor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadPoolExecutor类简单介绍</title>
    <link href="/blog/2021/03/19/ThreadPoolExecutor%E7%B1%BB%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/blog/2021/03/19/ThreadPoolExecutor%E7%B1%BB%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类。</p><h2 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h2><p>ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="hljs-function"><span class="hljs-params">                              TimeUnit unit,//时间单位</span></span><br><span class="hljs-function"><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="hljs-function"><span class="hljs-params">                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="hljs-function"><span class="hljs-params">                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="hljs-function"><span class="hljs-params">                               )</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt; corePoolSize ||<br>            keepAliveTime &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>        <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>        <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>        <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>        <span class="hljs-keyword">this</span>.handler = handler;<br>    &#125;<br></code></pre></td></tr></table></figure><p>下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</p><p>ThreadPoolExecutor 3 个最重要的参数：</p><ol><li>corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。 ThreadPoolExecutor其他常见参数:</li><li>keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li>unit : keepAliveTime 参数的时间单位。</li><li>threadFactory :executor 创建新线程的时候会用到。</li><li>handler :饱和策略。关于饱和策略下面单独介绍一下。 下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java性能调优实战》）：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210319201705168.jpeg" alt="线程池各个参数的关系">ThreadPoolExecutor 饱和策略定义:</li></ol><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ol><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。 举个例子：</li></ol><p>Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。）</p><h2 id="推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>推荐使用 ThreadPoolExecutor 构造函数创建线程池</h2><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</p><p>为什么呢？</p><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p><p>另外《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回线程池对象的弊端如下：</p><p>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。 方式一：通过ThreadPoolExecutor构造函数实现（推荐）<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210319201705255.jpeg" alt="aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzE3ODU4MjMwLmpwZw"></p><p>方式二：通过 Executor 框架的工具类 Executors 来实现 我们可以创建三种类型的 ThreadPoolExecutor：</p><p>FixedThreadPool SingleThreadExecutor CachedThreadPool 对应 Executors 工具类中的方法如图所示：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210319201705406.jpeg" alt="aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzEzMjk2OTAxLmpwZw"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>ThreadPoolExecutor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用线程池的好处</title>
    <link href="/blog/2021/03/19/%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <url>/blog/2021/03/19/%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    
    <content type="html"><![CDATA[<p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。 线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h2 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h2><p>Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p><p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。</p><h3 id="Executor-框架结构-主要由三大部分组成"><a href="#Executor-框架结构-主要由三大部分组成" class="headerlink" title="Executor 框架结构(主要由三大部分组成)"></a>Executor 框架结构(主要由三大部分组成)</h3><ol><li>任务(Runnable /Callable) 执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</li><li>任务的执行(Executor) 如下图所示，包括任务执行机制的核心接口 Executor ，以及继承自 Executor 接口的 ExecutorService 接口。ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口。</li></ol><p>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 ThreadPoolExecutor 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</p><p>注意： 通过查看 ScheduledThreadPoolExecutor 源代码我们发现 ScheduledThreadPoolExecutor 实际上是继承了 ThreadPoolExecutor 并实现了 ScheduledExecutorService ，而 ScheduledExecutorService 又实现了 ExecutorService，正如我们下面给出的类关系图显示的一样。</p><p>ThreadPoolExecutor 类描述:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AbstractExecutorService实现了ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span></span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 类描述:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ScheduledExecutorService实现了ExecutorService接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span></span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">ScheduledExecutorService</span></span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><p><img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3_1576546630498.png?x-oss-process=style/small" alt="任务的执行相关接口">3) 异步计算的结果(Future) Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。</p><p>当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）</p><h3 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a>Executor 框架的使用示意图</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210319201441640.png" alt="aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw"></p><ol><li>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</li><li>把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: ExecutorService.execute（Runnable command））或者也可以把 Runnable 对象或Callable 对象提交给 ExecutorService 执行（ExecutorService.submit（Runnable task）或 ExecutorService.submit（Callable task））。</li><li>如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 execute()方法和 submit()方法的区别，submit()会返回一个 FutureTask 对象）。由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。</li><li>最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池原理分析</title>
    <link href="/blog/2021/03/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/blog/2021/03/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>我们通过代码输出结果可以看出：线程池每次会同时执行 5 个任务，这 5 个任务执行完之后，剩余的 5 个任务才会被执行。 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p><p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p><p>为了搞懂线程池的原理，我们需要首先分析一下 execute方法。在 4.6 节中的 Demo 中我们使用 executor.execute(worker)来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> c &amp; CAPACITY;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果任务为null，则抛出异常。</span><br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-comment">// ctl 中保存的线程池当前的一些状态信息</span><br>        <span class="hljs-keyword">int</span> c = ctl.get();<br> <br>        <span class="hljs-comment">//  下面会涉及到 3 步 操作</span><br>        <span class="hljs-comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span><br>        <span class="hljs-comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>            c = ctl.get();<br>        &#125;<br>        <span class="hljs-comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span><br>        <span class="hljs-comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>            <span class="hljs-keyword">int</span> recheck = ctl.get();<br>            <span class="hljs-comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span><br>            <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))<br>                reject(command);<br>                <span class="hljs-comment">// 如果当前线程池为空就新创建一个线程并执行。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>                addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>        &#125;<br>        <span class="hljs-comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span><br>        <span class="hljs-comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>            reject(command);<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过下图可以更好的对上面这 3 步做一个展示，下图<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_1576459366999.png?x-oss-process=style/small" alt="图解线程池实现原理">我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务之行完成后，才会之行剩下的 5 个任务。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何创建线程池</title>
    <link href="/blog/2021/03/18/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/blog/2021/03/18/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>《阿里巴巴Java开发手册》</strong>中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回线程池对象的弊端如下：</p><p>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</p><h3 id="方式一：通过构造方法实现"><a href="#方式一：通过构造方法实现" class="headerlink" title="方式一：通过构造方法实现"></a>方式一：通过构造方法实现</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210318200323238.jpeg" alt="ThreadPoolExecutor构造方法"></p><h3 id="方式二：通过Executor-框架的工具类Executors来实现-我们可以创建三种类型的ThreadPoolExecutor："><a href="#方式二：通过Executor-框架的工具类Executors来实现-我们可以创建三种类型的ThreadPoolExecutor：" class="headerlink" title="方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor："></a>方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor：</h3><p>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。 对应Executors工具类中的方法如图所示：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210318200323344.jpeg" alt="Executor框架的工具类"></p><h3 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h3><p>ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                              TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                              ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                              RejectedExecutionHandler handler)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>            maximumPoolSize &lt; corePoolSize ||<br>            keepAliveTime &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>        <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>        <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>        <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>        <span class="hljs-keyword">this</span>.handler = handler;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor构造函数重要参数分析"><a href="#ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="ThreadPoolExecutor构造函数重要参数分析"></a>ThreadPoolExecutor构造函数重要参数分析</h3><p>ThreadPoolExecutor 3 个最重要的参数：</p><ol><li>corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。 ThreadPoolExecutor其他常见参数:</li><li>keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li>unit : keepAliveTime 参数的时间单位。</li><li>threadFactory :executor 创建新线程的时候会用到。</li><li>handler :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><h3 id="ThreadPoolExecutor-饱和策略"><a href="#ThreadPoolExecutor-饱和策略" class="headerlink" title="ThreadPoolExecutor 饱和策略"></a>ThreadPoolExecutor 饱和策略</h3><p>ThreadPoolExecutor 饱和策略定义:</p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ol><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。 举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</li></ol><h3 id="一个简单的线程池Demo-Runnable-ThreadPoolExecutor"><a href="#一个简单的线程池Demo-Runnable-ThreadPoolExecutor" class="headerlink" title="一个简单的线程池Demo:Runnable+ThreadPoolExecutor"></a>一个简单的线程池Demo:Runnable+ThreadPoolExecutor</h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p><p>首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）</p><p>MyRunnable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> String command;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = s;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Start. Time = &quot;</span> + <span class="hljs-keyword">new</span> Date());<br>        processCommand();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; End. Time = &quot;</span> + <span class="hljs-keyword">new</span> Date());<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCommand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.command;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p><p>ThreadPoolExecutorDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutorDemo</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_CAPACITY = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long KEEP_ALIVE_TIME = <span class="hljs-number">1L</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <br>        <span class="hljs-comment">//使用阿里巴巴推荐的创建线程池的方式</span><br>        <span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_TIME,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<br> <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br>            Runnable worker = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">&quot;&quot;</span> + i);<br>            <span class="hljs-comment">//执行Runnable</span><br>            executor.execute(worker);<br>        &#125;<br>        <span class="hljs-comment">//终止线程池</span><br>        executor.shutdown();<br>        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Finished all threads&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li>corePoolSize: 核心线程数为 5。</li><li>maximumPoolSize ：最大线程数 10</li><li>keepAliveTime : 等待时间为 1L。</li><li>unit: 等待时间的单位为 TimeUnit.SECONDS。</li><li>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</li><li>handler:饱和策略为 CallerRunsPolicy。 Output：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">44</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> Start. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">49</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> End. Time = Tue Nov <span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2019</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要用线程池</title>
    <link href="/blog/2021/03/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/blog/2021/03/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong> 线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h2 id="实现Runnable接口和Callable接口的区别"><a href="#实现Runnable接口和Callable接口的区别" class="headerlink" title="实现Runnable接口和Callable接口的区别"></a>实现Runnable接口和Callable接口的区别</h2><p>Runnable自Java 1.0以来一直存在，但Callable仅在Java 1.5中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p><p>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。</p><p>Runnable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 被线程执行，没有返回值也无法抛出异常</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Callable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算结果，或在无法这样做时抛出异常。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 计算得出的结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> 如果无法计算结果，则抛出异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h2><ol><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 我们以AbstractExecutorService接口中的一个 submit 方法为例子来看看源代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>        execute(ftask);<br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面方法调用的 newTaskFor 方法返回了一个 FutureTask 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(runnable, value);<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们再来看看execute()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>     ...<br>   &#125;<br></code></pre></td></tr></table></figure><p><a href="https://bk.cuixiaoyan.xyz/archives/newTaskFor#%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3%E5%92%8Ccallable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB">实现Runnable接口和Callable接口的区别</a><a href="https://bk.cuixiaoyan.xyz/archives/newTaskFor#%E6%89%A7%E8%A1%8Cexecute%E6%96%B9%E6%B3%95%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2">执行execute()方法和submit()方法的区别是什么呢？</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/blog/2021/03/18/ThreadLocal/"/>
    <url>/blog/2021/03/18/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><p>再举个简单的例子：</p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Random;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br> <br>     <span class="hljs-comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyyMMdd HHmm&quot;</span>));<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadLocalExample obj = <span class="hljs-keyword">new</span> ThreadLocalExample();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(obj, <span class="hljs-string">&quot;&quot;</span>+i);<br>            Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>            t.start();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; default Formatter = &quot;</span>+formatter.get().toPattern());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span><br>        formatter.set(<span class="hljs-keyword">new</span> SimpleDateFormat());<br> <br>        System.out.println(<span class="hljs-string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot; formatter = &quot;</span>+formatter.get().toPattern());<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread Name= <span class="hljs-number">0</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">0</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">1</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">2</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">1</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">3</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">2</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">4</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">3</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">4</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">5</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">5</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">6</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">6</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">7</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">7</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">8</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">9</span> <span class="hljs-keyword">default</span> Formatter = yyyyMMdd HHmm<br>Thread Name= <span class="hljs-number">8</span> formatter = yy-M-d ah:mm<br>Thread Name= <span class="hljs-number">9</span> formatter = yy-M-d ah:mm<br></code></pre></td></tr></table></figure><p>从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。</p><p>上面有一段代码用到了创建 ThreadLocal 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法withInitial()，将Supplier功能接口作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="hljs-keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> SimpleDateFormat <span class="hljs-title">initialValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyyMMdd HHmm&quot;</span>);<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从 Thread类源代码入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br> ......<br><span class="hljs-comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br> <br><span class="hljs-comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br>ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-keyword">null</span>;<br> ......<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。</p><p>ThreadLocal类的set()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        Thread t = Thread.currentThread();<br>        ThreadLocalMap map = getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>            map.set(<span class="hljs-keyword">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>            createMap(t, value);<br>    &#125;<br>    <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> t.threadLocals;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过上面这些内容，我们足以通过猜测得出结论：最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。</p><p>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对。 比如我们在同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。ThreadLocal 是 map结构是为了让每个线程可以关联多个 ThreadLocal变量。这也就解释了 ThreadLocal 声明的变量为什么在每一个线程都有自己的专属本地变量。</p><p>ThreadLocalMap是ThreadLocal的静态内部类。<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/ThreadLocal%E5%86%85%E9%83%A8%E7%B1%BB_1575941927731.png?x-oss-process=style/small" alt="ThreadLocal内部类"></p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>            Object value;<br> <br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-keyword">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br> <br></code></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字</title>
    <link href="/blog/2021/03/18/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/blog/2021/03/18/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4_1575855805654.png?x-oss-process=style/small" alt="数据不一致">要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</p><p>说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210318200107505.jpeg" alt="volatile关键字的可见性"></p><h2 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h2><p>synchronized关键字和volatile关键字比较</p><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized和ReentrantLock的区别</title>
    <link href="/blog/2021/03/18/synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/03/18/synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>① 两者都是可重入锁</p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p>③ ReentrantLock 比 synchronized 增加了一些高级功能</p><p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p><p>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。 synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。</p><p>④ 性能已不是选择标准</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized关键字</title>
    <link href="/blog/2021/03/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/blog/2021/03/16/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h2 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h2><p>synchronized关键字最主要的三种使用方式：</p><p>修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p>双重校验锁实现对象单例（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><p>为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的生命周期和状态</title>
    <link href="/blog/2021/03/16/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81/"/>
    <url>/blog/2021/03/16/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210316195056031.png" alt="Java线程的状态"></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210316195056316.png" alt="a"></p><p>由上图可以看出：线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</p><p>操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210316195056428.png" alt="RUNNABLE-VS-RUNNING">当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>生命周期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是线程和进程</title>
    <link href="/blog/2021/03/16/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    <url>/blog/2021/03/16/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>1.1. 何为进程? 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210316194835966.png" alt="进程示例图片-Windows">1.2. 何为线程? 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiThread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取 Java 线程管理 MXBean</span><br>    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();<br>        <span class="hljs-comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span><br>        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span><br>        <span class="hljs-keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="hljs-string">&quot;] &quot;</span> + threadInfo.getThreadName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">5</span>] Attach Listener <span class="hljs-comment">//添加事件</span><br>[<span class="hljs-number">4</span>] Signal Dispatcher <span class="hljs-comment">// 分发处理给 JVM 信号的线程</span><br>[<span class="hljs-number">3</span>] Finalizer <span class="hljs-comment">//调用对象 finalize 方法的线程</span><br>[<span class="hljs-number">2</span>] Reference Handler <span class="hljs-comment">//清除 reference 线程</span><br>[<span class="hljs-number">1</span>] main <span class="hljs-comment">//main 线程,程序入口</span><br></code></pre></td></tr></table></figure><p>从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p><p>2.1. 图解进程和线程的关系 下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：《可能是把 Java 内存区域讲的最清楚的一篇文章》<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210316194836243.png" alt="JVM运行时数据区域">从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><p>总结： 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p><p>下面是该知识点的扩展内容！</p><p>下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><p>2.2. 程序计数器为什么是私有的? 程序计数器主要有下面两个作用：</p><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><p>2.3. 虚拟机栈和本地方法栈为什么是私有的? 虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p><p>2.4. 一句话简单了解堆和方法区 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap和HashSet区别</title>
    <link href="/blog/2021/03/16/HashMap%E5%92%8CHashSet%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/03/16/HashMap%E5%92%8CHashSet%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/QQ20191129-094719@2x_1574992056988.png?x-oss-process=style/small" alt="QQ20191129-094719@2x"></p><h2 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h2><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）</p><h3 id="hashCode（）与equals（）的相关规定："><a href="#hashCode（）与equals（）的相关规定：" class="headerlink" title="hashCode（）与equals（）的相关规定："></a>hashCode（）与equals（）的相关规定：</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><h3 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a>==与equals的区别</h3><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><h2 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h2><p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>HashSet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap和Hashtable的区别</title>
    <link href="/blog/2021/03/15/HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/03/15/HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ol><li>线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li>初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 HashMap 中带有初始容量的构造函数：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                              initialCapacity);<br>       <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>           initialCapacity = MAXIMUM_CAPACITY;<br>       <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                              loadFactor);<br>       <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>       <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>   &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>   &#125;<br></code></pre></td></tr></table></figure><p>下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>      n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>      n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>      n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>      n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>      n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>      <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>Hashtable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List,Set,Map三者的区别</title>
    <link href="/blog/2021/03/15/List,Set,Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/03/15/List,Set,Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ol><li>List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li>Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。</li><li>Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ol><h2 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h2><ol><li>是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。</li><li>是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</li><li>内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="补充内容-RandomAccess接口"><a href="#补充内容-RandomAccess接口" class="headerlink" title="补充内容:RandomAccess接口"></a>补充内容:RandomAccess接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RandomAccess</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 binarySearch（）方法中，它要判断传入的list 是否 RamdomAccess 的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(List&lt;? extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>            <span class="hljs-keyword">return</span> Collections.indexedBinarySearch(list, key);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> Collections.iteratorBinarySearch(list, key);<br>    &#125;<br></code></pre></td></tr></table></figure><p>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><h3 id="下面再总结一下-list-的遍历方式选择："><a href="#下面再总结一下-list-的遍历方式选择：" class="headerlink" title="下面再总结一下 list 的遍历方式选择："></a>下面再总结一下 list 的遍历方式选择：</h3><p>实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach, 未实现 RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环</p><h3 id="补充内容-双向链表和双向循环链表"><a href="#补充内容-双向链表和双向循环链表" class="headerlink" title="补充内容:双向链表和双向循环链表"></a>补充内容:双向链表和双向循环链表</h3><p>双向链表： 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8_1574818255138.png?x-oss-process=style/small" alt="双向链表">双向循环链表： 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210315204506653.png" alt="双向循环链表"></p>]]></content>
    
    
    
    <tags>
      
      <tag>List</tag>
      
      <tag>Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>get和post请求的区别</title>
    <link href="/blog/2021/03/15/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/03/15/get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href="https://www.cnblogs.com/logsharing/p/8448446.html%EF%BC%8C%E7%9F%A5%E4%B9%8E%E5%AF%B9%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%9Aget%E5%92%8Cpost%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%89%EF%BC%81%E6%88%91%E4%B8%8B%E9%9D%A2%E7%BB%99%E5%87%BA%E7%9A%84%E5%8F%AA%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82">https://www.cnblogs.com/logsharing/p/8448446.html，知乎对应的问题链接：get和post区别？）！我下面给出的只是一种常见的答案。</a></p><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p><p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p><p>③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p><p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p><p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p><p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p><p>还有另外一种回答。推荐大家看一下：</p><p><a href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a> <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd">https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</a> 什么情况下调用doGet()和doPost() Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p><p>转发(Forward)和重定向(Redirect)的区别 转发是服务器行为，重定向是客户端行为。</p><p>转发（Forward） 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">request</span>.getRequestDispatcher(<span class="hljs-string">&quot;login_success.jsp&quot;</span>).forward(<span class="hljs-built_in">request</span>, <span class="hljs-built_in">response</span>);<br></code></pre></td></tr></table></figure><p>重定向（Redirect） 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><p>从地址栏显示来说 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><p>从数据共享来说 forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</p><p>从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p><p>从效率来说 forward:高. redirect:低.</p>]]></content>
    
    
    
    <tags>
      
      <tag>get</tag>
      
      <tag>post</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet总结</title>
    <link href="/blog/2021/03/15/Servlet%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2021/03/15/Servlet%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在Java Web程序中，Servlet主要负责接收用户请求 HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用init()方法，销毁时调用destroy()方法。Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），一个Servlet可以设置多个URL访问。Servlet不是线程安全，因此要谨慎使用类变量。</p><h2 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a>阐述Servlet和CGI的区别?</h2><h3 id="CGI的不足之处"><a href="#CGI的不足之处" class="headerlink" title="CGI的不足之处:"></a>CGI的不足之处:</h3><p>1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。</p><p>2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销</p><p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p><h3 id="Servlet的优点"><a href="#Servlet的优点" class="headerlink" title="Servlet的优点:"></a>Servlet的优点:</h3><p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p><p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p><p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p><p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p><p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p><p>参考：《javaweb整合开发王者归来》P7</p><h3 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h3><p>Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, java.io.IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function">java.lang.String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>生命周期： Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><p>参考：《javaweb整合开发王者归来》P81</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型的实际应用</title>
    <link href="/blog/2021/03/15/%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <url>/blog/2021/03/15/%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="实现最小值函数"><a href="#实现最小值函数" class="headerlink" title="实现最小值函数"></a>实现最小值函数</h2><p>自己设计一个泛型的获取数组最小值的函数.并且这个方法只能接受Number的子类并且实现了Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：Number并没有实现Comparable</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T extends Number &amp; Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T[] values)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (values == <span class="hljs-keyword">null</span> || values.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    T min = values[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; values.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (min.compareTo(values[i]) &gt; <span class="hljs-number">0</span>) min = values[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> min;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> minInteger = min(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//result:1</span><br><span class="hljs-keyword">double</span> minDouble = min(<span class="hljs-keyword">new</span> Double[]&#123;<span class="hljs-number">1.2</span>, <span class="hljs-number">2.2</span>, -<span class="hljs-number">1d</span>&#125;);<span class="hljs-comment">//result:-1d</span><br>String typeError = min(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>&#125;);<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="使用数组实现栈"><a href="#使用数组实现栈" class="headerlink" title="使用数组实现栈"></a>使用数组实现栈</h2><p>自己实现一个栈，要求这个栈具有push()、pop()（返回栈顶元素并出栈）、peek() （返回栈顶元素不出栈）、isEmpty()、size()这些基本的方法。</p><p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用Arrays.copyOf()进行扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] storage;<span class="hljs-comment">//存放栈中元素的数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<span class="hljs-comment">//栈的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<span class="hljs-comment">//栈中元素数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GROW_FACTOR = <span class="hljs-number">2</span>;<br> <br>    <span class="hljs-comment">//TODO：不带初始容量的构造方法。默认容量为8</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">this</span>.storage=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//TODO：带初始容量的构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Capacity too small.&quot;</span>);<br> <br>        <span class="hljs-keyword">this</span>.capacity = initialCapacity;<br>        <span class="hljs-keyword">this</span>.storage = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[initialCapacity];<br>        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//TODO：入栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (count == capacity) &#123;<br>            ensureCapacity();<br>        &#125;<br>        storage[count++] = value;<br>    &#125;<br> <br>    <span class="hljs-comment">//TODO：确保容量大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> newCapacity = capacity * GROW_FACTOR;<br>        storage = Arrays.copyOf(storage, newCapacity);<br>        capacity = newCapacity;<br>    &#125;<br> <br>    <span class="hljs-comment">//TODO：返回栈顶元素并出栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        count--;<br>        <span class="hljs-keyword">if</span> (count == -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Stack is empty.&quot;</span>);<br> <br>        <span class="hljs-keyword">return</span> storage[count];<br>    &#125;<br> <br>    <span class="hljs-comment">//TODO：返回栈顶元素不出栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Stack is empty.&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> storage[count-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">//TODO：判断栈是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//TODO：返回栈中元素的个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">MyStack myStack = <span class="hljs-keyword">new</span> MyStack(<span class="hljs-number">3</span>);<br>myStack.push(<span class="hljs-number">1</span>);<br>myStack.push(<span class="hljs-number">2</span>);<br>myStack.push(<span class="hljs-number">3</span>);<br>myStack.push(<span class="hljs-number">4</span>);<br>myStack.push(<span class="hljs-number">5</span>);<br>myStack.push(<span class="hljs-number">6</span>);<br>myStack.push(<span class="hljs-number">7</span>);<br>myStack.push(<span class="hljs-number">8</span>);<br>System.out.println(myStack.peek());<span class="hljs-comment">//8</span><br>System.out.println(myStack.size());<span class="hljs-comment">//8</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>    System.out.println(myStack.pop());<br>&#125;<br>System.out.println(myStack.isEmpty());<span class="hljs-comment">//true</span><br>myStack.pop();<span class="hljs-comment">//报错：java.lang.IllegalArgumentException: Stack is empty.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection.toArray()</title>
    <link href="/blog/2021/03/14/Collection.toArray()/"/>
    <url>/blog/2021/03/14/Collection.toArray()/</url>
    
    <content type="html"><![CDATA[<p><strong>该方法是一个泛型方法： T[] toArray(T[] a); 如果toArray方法中没有传递任何参数的话返回的是Object类型数组。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String [] s= <span class="hljs-keyword">new</span> String[]&#123;<br>    <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;over&quot;</span>, <span class="hljs-string">&quot;jumps&quot;</span>, <span class="hljs-string">&quot;fox&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>, <span class="hljs-string">&quot;quick&quot;</span>, <span class="hljs-string">&quot;A&quot;</span><br>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s);<br>Collections.reverse(list);<br>s=list.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<span class="hljs-comment">//没有指定类型的话会报错</span><br></code></pre></td></tr></table></figure><p>由于JVM优化，new String[0]作为Collection.toArray()方法的参数现在使用更好，new String[0]就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><p><strong>不要在 foreach 循环里进行元素的 remove/add 操作</strong></p><p>如果要进行remove操作，可以调用迭代器的 remove方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove/add方法，迭代器都将抛出一个ConcurrentModificationException,这就是单线程状态下产生的 fail-fast 机制。</p><p>fail-fast 机制 ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p><p>java.util包下面的所有的集合类都是fail-fast的，而java.util.concurrent包下面的所有的类都是fail-safe的。</p><p>不要在 foreach 循环里进行元素的 remove/add 操作</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何正确的将数组转换为ArrayList</title>
    <link href="/blog/2021/03/14/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BAArrayList/"/>
    <url>/blog/2021/03/14/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BAArrayList/</url>
    
    <content type="html"><![CDATA[<h2 id="自己动手实现（教育目的）"><a href="#自己动手实现（教育目的）" class="headerlink" title="自己动手实现（教育目的）"></a>自己动手实现（教育目的）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.5+</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">arrayToList</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T[] array)</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> List&lt;T&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;(array.length);<br> <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> T s : array) &#123;<br>    l.add(s);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (l);<br>&#125;<br>Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>System.out.println(arrayToList(myArray).getClass());<span class="hljs-comment">//class java.util.ArrayList</span><br></code></pre></td></tr></table></figure><h2 id="最简便的方法-推荐"><a href="#最简便的方法-推荐" class="headerlink" title="最简便的方法(推荐)"></a>最简便的方法(推荐)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))<br> <br></code></pre></td></tr></table></figure><h2 id="使用-Java8-的Stream-推荐"><a href="#使用-Java8-的Stream-推荐" class="headerlink" title="使用 Java8 的Stream(推荐)"></a>使用 Java8 的Stream(推荐)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List myList = Arrays.stream(myArray).collect(Collectors.toList());<br><span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><br><span class="hljs-keyword">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h2 id="使用-Guava-推荐"><a href="#使用-Guava-推荐" class="headerlink" title="使用 Guava(推荐)"></a>使用 Guava(推荐)</h2><p>对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; il = ImmutableList.of(<span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;elements&quot;</span>);  <span class="hljs-comment">// from varargs</span><br>List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="hljs-comment">// from array</span><br></code></pre></td></tr></table></figure><p>对于可变集合，你可以使用Lists类及其newArrayList()工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="hljs-comment">// from collection</span><br>List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="hljs-comment">// from array</span><br>List&lt;String&gt; l3 = Lists.newArrayList(<span class="hljs-string">&quot;or&quot;</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;elements&quot;</span>); <span class="hljs-comment">// from varargs</span><br></code></pre></td></tr></table></figure><h2 id="使用-Apache-Commons-Collections"><a href="#使用-Apache-Commons-Collections" class="headerlink" title="使用 Apache Commons Collections"></a>使用 Apache Commons Collections</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>CollectionUtils.addAll(list, str);<br></code></pre></td></tr></table></figure><p>Collection.toArray()方法使用的坑&amp;如何反转数组 该方法是一个泛型方法： T[] toArray(T[] a); 如果toArray方法中没有传递任何参数的话返回的是Object类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String [] s= <span class="hljs-keyword">new</span> String[]&#123;<br>    <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;over&quot;</span>, <span class="hljs-string">&quot;jumps&quot;</span>, <span class="hljs-string">&quot;fox&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>, <span class="hljs-string">&quot;quick&quot;</span>, <span class="hljs-string">&quot;A&quot;</span><br>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s);<br>Collections.reverse(list);<br>s=list.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<span class="hljs-comment">//没有指定类型的话会报错</span><br></code></pre></td></tr></table></figure><p>由于JVM优化，new String[0]作为Collection.toArray()方法的参数现在使用更好，new String[0]就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><p><strong>不要在 foreach 循环里进行元素的 remove/add 操作</strong> 如果要进行remove操作，可以调用迭代器的 remove方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove/add方法，迭代器都将抛出一个ConcurrentModificationException,这就是单线程状态下产生的 fail-fast 机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">fail-fast 机制 ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。<br></code></pre></td></tr></table></figure><p>java.util包下面的所有的集合类都是fail-fast的，而java.util.concurrent包下面的所有的类都是fail-safe的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arrays.asList()使用指南</title>
    <link href="/blog/2021/03/14/Arrays.asList()%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/blog/2021/03/14/Arrays.asList()%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p><strong>最近使用Arrays.asList()遇到了一些坑，然后在网上看到这篇文章：Java Array to List Examples 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arrays.asList()在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] myArray = &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span> &#125;； <br>List&lt;String&gt; myList = Arrays.asList(myArray);<br><span class="hljs-comment">//上面两个语句等价于下面一条语句</span><br>List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br></code></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与           Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用时的注意事项总结"><a href="#使用时的注意事项总结" class="headerlink" title="使用时的注意事项总结"></a>使用时的注意事项总结</h2><p>传递的数组必须是对象数组，而不是基本类型。</p><p>Arrays.asList()是泛型方法，传入的对象必须是对象数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List myList = Arrays.asList(myArray);<br>System.out.println(myList.size());<span class="hljs-comment">//1</span><br>System.out.println(myList.get(<span class="hljs-number">0</span>));<span class="hljs-comment">//数组地址值</span><br>System.out.println(myList.get(<span class="hljs-number">1</span>));<span class="hljs-comment">//报错：ArrayIndexOutOfBoundsException</span><br><span class="hljs-keyword">int</span> [] array=(<span class="hljs-keyword">int</span>[]) myList.get(<span class="hljs-number">0</span>);<br>System.out.println(array[<span class="hljs-number">0</span>]);<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><p>Integer[] myArray = { 1, 2, 3 }; 使用集合的修改方法:add()、remove()、clear()会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List myList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>myList.add(<span class="hljs-number">4</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.clear();<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br></code></pre></td></tr></table></figure><p>Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List myList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>System.out.println(myList.getClass());<span class="hljs-comment">//class java.util.Arrays$ArrayList</span><br></code></pre></td></tr></table></figure><p>下图是java.util.Arrays$ArrayList的简易源码，我们可以看到这个类重写的方法有哪些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">       <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class">   </span>&#123;<br>       ...<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>         ...<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>         ...<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>         ...<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>          ...<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;<br>         ...<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;<br>         ...<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span> </span>&#123;<br>         ...<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>我们再看一下java.util.AbstractList的remove()方法，这样我们就明白为啥会抛出UnsupportedOperationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Arrays</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正确使用equals方法</title>
    <link href="/blog/2021/03/13/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8equals%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/03/13/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8equals%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span><br>String str = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;SnailClimb&quot;</span>)) &#123;<br>  ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  ..<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;SnailClimb&quot;</span>.equals(str);<span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>不过更推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Objects.equals(<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;SnailClimb&quot;</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>我们看一下java.util.Objects#equals的源码就知道原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<br>        <span class="hljs-comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span><br>        <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中null == null将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>equals</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中IO流分为几种</title>
    <link href="/blog/2021/03/13/Java%E4%B8%ADIO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D/"/>
    <url>/blog/2021/03/13/Java%E4%B8%ADIO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D/</url>
    
    <content type="html"><![CDATA[<ol><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ol><h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p><strong>问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul><li>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的异常处理</title>
    <link href="/blog/2021/03/13/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/blog/2021/03/13/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><p>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><p>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。</p><p>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</p><h2 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h2><p>public string getMessage():返回异常发生时的简要描述 public string toString():返回异常发生时的详细信息 public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印Throwable对象封装的异常信息</p><h2 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h2><p>try 块： 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch 块： 用于处理try捕获到的异常。 finally 块： 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。</p><p><strong>在以下4种特殊情况下，finally块不会被执行：</strong></p><p>在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行 程序所在的线程死亡。 关闭CPU。</p><p>注意： 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> value * value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果调用 f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>==与equals和hashCode与equals</title>
    <link href="/blog/2021/03/12/==%E4%B8%8Eequals%E5%92%8ChashCode%E4%B8%8Eequals/"/>
    <url>/blog/2021/03/12/==%E4%B8%8Eequals%E5%92%8ChashCode%E4%B8%8Eequals/</url>
    
    <content type="html"><![CDATA[<p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String a = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// a 为一个引用</span><br>        String b = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br>        String aa = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br>        String bb = <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>        <span class="hljs-keyword">if</span> (aa == bb) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;aa==bb&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-comment">// false，非同一对象</span><br>            System.out.println(<span class="hljs-string">&quot;a==b&quot;</span>);<br>        <span class="hljs-keyword">if</span> (a.equals(b)) <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;aEQb&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>) &#123; <span class="hljs-comment">// true</span><br>            System.out.println(<span class="hljs-string">&quot;true&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><h2 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h2><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p>为什么要有 hashCode 我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><p>hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>String和StringBuffer和StringBuilder的区别是什么</title>
    <link href="/blog/2021/03/12/String%E5%92%8CStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/blog/2021/03/12/String%E5%92%8CStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h1><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private　final　char　value[]，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。 <strong>AbstractStringBuilder.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] value;<br>    <span class="hljs-keyword">int</span> count;<br>    AbstractStringBuilder() &#123;<br>    &#125;<br>    AbstractStringBuilder(<span class="hljs-keyword">int</span> capacity) &#123;<br>        value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[capacity];<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h1 id="对于三者使用的总结"><a href="#对于三者使用的总结" class="headerlink" title="对于三者使用的总结"></a>对于三者使用的总结</h1><p>操作少量的数据: 适用String 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</p>]]></content>
    
    
    
    <tags>
      
      <tag>StringBuffer</tag>
      
      <tag>StringBuilder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java比较两个日期相差的天数</title>
    <link href="/blog/2021/03/12/java%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%B7%AE%E7%9A%84%E5%A4%A9%E6%95%B0/"/>
    <url>/blog/2021/03/12/java%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%B7%AE%E7%9A%84%E5%A4%A9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>判断两个Date类型的日期之间的天数</p><h2 id="通过计算毫秒数判断"><a href="#通过计算毫秒数判断" class="headerlink" title="通过计算毫秒数判断"></a>通过计算毫秒数判断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    Date date = df.parse(<span class="hljs-string">&quot;2019-11-04 20:23:31&quot;</span>);<br>    <span class="hljs-keyword">long</span> days = (<span class="hljs-keyword">new</span> Date().getTime() - date.getTime()) / <span class="hljs-number">1000</span> / <span class="hljs-number">3600</span> / <span class="hljs-number">24</span>;<br>    System.out.println(days);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式主要是通过计算两个时间之间的毫秒数来判断，如果相差不超过24小时，则说明是同一天</p><h2 id="也可以通过将时分秒设置为0来通过日期判断"><a href="#也可以通过将时分秒设置为0来通过日期判断" class="headerlink" title="也可以通过将时分秒设置为0来通过日期判断"></a>也可以通过将时分秒设置为0来通过日期判断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    Date date = df.parse(<span class="hljs-string">&quot;2019-11-04 20:23:31&quot;</span>);<br>    <span class="hljs-keyword">long</span> days = <span class="hljs-keyword">new</span> Date().getTime() / <span class="hljs-number">1000</span> / <span class="hljs-number">3600</span> / <span class="hljs-number">24</span> - date.getTime() / <span class="hljs-number">1000</span> / <span class="hljs-number">3600</span> / <span class="hljs-number">24</span>;<br>    System.out.println(days);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zuul自定义过滤器</title>
    <link href="/blog/2021/03/11/Zuul%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/blog/2021/03/11/Zuul%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>**Zuul 的核心技术就是过滤器，该框架提供了 ZuulFilter 接口让开发者可以自定义过滤规则。</p><p>我们以身份检验为例，自定义 ZuulFilter 过滤器实现该功能。**</p><h2 id="创建用户服务"><a href="#创建用户服务" class="headerlink" title="创建用户服务"></a>创建用户服务</h2><p>新建名为 user-server 的项目。</p><p>添加依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- common api --&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;com.extlight.springcloud&lt;/groupId&gt;<br>  &lt;artifactId&gt;common-api&lt;/artifactId&gt;<br>  &lt;version&gt;$&#123;parent-version&#125;&lt;/version&gt;<br>&lt;/dependency&gt;<br>  <br>&lt;!-- springmvc --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- eureka 客户端 --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="application-yml："><a href="#application-yml：" class="headerlink" title="application.yml："></a>application.yml：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>    port: <span class="hljs-number">8200</span><br> <br>spring:<br>  application:<br>    name: USER<br>    <br>eureka:<br>    instance:<br>        instance-id: user-api-<span class="hljs-number">8200</span><br>        prefer-ip-address: true # 访问路径可以显示 IP<br>    client:<br>        service-url:<br>            defaultZone: http:<span class="hljs-comment">//localhost:9000/eureka/  # 注册中心访问地址</span><br></code></pre></td></tr></table></figure><h2 id="登录接口："><a href="#登录接口：" class="headerlink" title="登录接口："></a>登录接口：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br> <br><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, HttpServletResponse response)</span> </span>&#123;<br><br><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="hljs-string">&quot;admin&quot;</span>.equals(password)) &#123;<br><span class="hljs-comment">// 模拟生成 token，实际开发中 token 应存放在数据库或缓存中</span><br>String token = <span class="hljs-string">&quot;123456&quot;</span>;<br>Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;token&quot;</span>, token);<br>cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>cookie.setMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">10</span>);<br>response.addCookie(cookie);<br><br><span class="hljs-keyword">return</span> Result.success();<br>&#125;<br><br><span class="hljs-keyword">return</span> Result.fail(<span class="hljs-number">401</span>, <span class="hljs-string">&quot;账号或密码错误&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="user-server-启动类："><a href="#user-server-启动类：" class="headerlink" title="user-server 启动类："></a>user-server 启动类：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServerApplication</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(UserServerApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建-ZuulFilter-过滤器"><a href="#创建-ZuulFilter-过滤器" class="headerlink" title="创建 ZuulFilter 过滤器"></a>创建 ZuulFilter 过滤器</h2><p>在 gateway-server 项目中，新建一个过滤器，需要继承 ZuulFilter 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 是否开启过滤</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>RequestContext context = RequestContext.getCurrentContext();<br>        HttpServletRequest request = context.getRequest();<br>        <br><span class="hljs-keyword">boolean</span> flag = request.getRequestURI().contains(<span class="hljs-string">&quot;/login&quot;</span>);<br><span class="hljs-comment">// 如果是登录请求不进行过滤</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>System.out.println(<span class="hljs-string">&quot;========不执行 zuul 过滤方法=======&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;========执行 zuul 过滤方法=======&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> !flag;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 过滤器执行内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;<br><br>RequestContext context = RequestContext.getCurrentContext();<br>        HttpServletRequest request = context.getRequest();<br>        String token = request.getParameter(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-comment">// 此处模拟获取数据库或缓存中的 token</span><br>        String dbToken = <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-comment">// 此处简单检验 token</span><br>        <span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(token) || !dbToken.equals(token)) &#123;<br>        context.setSendZuulResponse(<span class="hljs-keyword">false</span>);<br>        context.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());<br>        &#125;<br>        <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 过滤器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pre&quot;</span>;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 过滤器执行顺序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其中，filterType-有-4-种类型："><a href="#其中，filterType-有-4-种类型：" class="headerlink" title="其中，filterType 有 4 种类型："></a>其中，filterType 有 4 种类型：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">pre： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。<br> <br>routing：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用 Apache HttpClient 或 Netfilx Ribbon 请求微服务。<br> <br>post：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。<br> <br>error：在其他阶段发生错误时执行该过滤器。<br> <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210311213320401.jpeg" alt="zuul-04"></p><h2 id="运行所有项目，测试操作步骤如下："><a href="#运行所有项目，测试操作步骤如下：" class="headerlink" title="运行所有项目，测试操作步骤如下："></a>运行所有项目，测试操作步骤如下：</h2><p>请求用户服务的登录接口(<a href="http://localhost:9600/user/user/login)%EF%BC%8C%E8%AF%B7%E6%B1%82%E4%B8%8D%E6%89%A7%E8%A1%8C">http://localhost:9600/user/user/login)，请求不执行</a> zuul 过滤方法，并且请求响应返回的 cookie 包含 token</p><p>请求订单服务的下单接口(<a href="http://localhost:9600/extlight/order/place)%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%90%BA%E5%B8%A6">http://localhost:9600/extlight/order/place)，但不携带</a> token，请求需要执行 zuul 过滤方法，请求响应 401 权限不足</p><p>请求订单服务的下单接口(<a href="http://localhost:9600/extlight/order/place)%EF%BC%8C%E6%90%BA%E5%B8%A6%E4%B9%8B%E5%89%8D%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84">http://localhost:9600/extlight/order/place)，携带之前登录接口返回的</a> token，请求需要执行 zuul 过滤方法，校验通过后路由到订单服务执行之后的操作</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Zuul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea将项目提交到码云</title>
    <link href="/blog/2021/03/11/idea%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E5%88%B0%E7%A0%81%E4%BA%91/"/>
    <url>/blog/2021/03/11/idea%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E5%88%B0%E7%A0%81%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bk.cuixiaoyan.xyz/archives/github">首先先看idea提交到github</a> 我爱写代码 嘿嘿</p><p>先下载插件<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/QQ20191105-093954@2x_1572918288442.png?x-oss-process=style/small" alt="QQ20191105-093954@2x">然后再去码云弄公匙<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210311213144761.png" alt="QQ20191105-094104@2x">因为我的项目之前绑定了github 所以现在再绑定码云<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210311213145817.png" alt="QQ20191105-094203@2x">这里设置提交的路径<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210311213146647.png" alt="QQ20191105-094229@2x">如下<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210311213146872.png" alt="QQ20191105-094243@2x">最后push的时候<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/QQ20191105-094229@2x_1572918294237.png?x-oss-process=style/small" alt="QQ20191105-094229@2x">需要选择提交到哪里 是码云还是 github<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210311213147586.png" alt="QQ20191105-094315@2x"></p>]]></content>
    
    
    
    <tags>
      
      <tag>idea</tag>
      
      <tag>码云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud入门之Zuul篇</title>
    <link href="/blog/2021/03/11/SpringCloud%E5%85%A5%E9%97%A8Zuul%E7%AF%87/"/>
    <url>/blog/2021/03/11/SpringCloud%E5%85%A5%E9%97%A8Zuul%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>随着业务的扩展，微服务会不对增加，相应的其对外开放的 API 接口也势必增多，这不利于前端的调用以及不同场景下数据的返回，因此，我们通常都需要设计一个 API 网关作为一个统一的 API 入口，来组合一个或多个内部 API。</p><h2 id="API-网关使用场景"><a href="#API-网关使用场景" class="headerlink" title="API 网关使用场景"></a>API 网关使用场景</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">黑白名单： 实现通过 IP 地址控制请求的访问<br> <br>日志：实现访问日志的记录，进而实现日志分析，处理性能指标等<br> <br>协议适配：实现通信协议的校验、适配转换的功能<br> <br>身份认证：对请求进行身份认证<br> <br>计流限流：可以设计限流规则，记录访问流量<br> <br>路由：将请求进行内部（服务）转发<br></code></pre></td></tr></table></figure><h2 id="API-网关的实现"><a href="#API-网关的实现" class="headerlink" title="API 网关的实现"></a>API 网关的实现</h2><p>业界常用的 API 网关有很多方式，如：Spring Cloud Zuul、 Nginx、Tyk、Kong。本篇介绍的对象正是 Spring Cloud Zuul。</p><p>Zuul 是 Netflix 公司开源的一个 API 网关组件，提供了认证、鉴权、限流、动态路由、监控、弹性、安全、负载均衡、协助单点压测等边缘服务的框架。</p><p>Spring Cloud Zuul 是基于 Netflix Zuul 的微服务路由和过滤器的解决方案，也用于实现 API 网关。其中，路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入门的基础。而过滤功能是负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。</p><p>Spring Cloud Zuul 和 Eureka 进行整合时，Zuul 将自身注册到 Eureka 服务中，同时从 Eureka 中获取其他微服务信息，以便请求可以准确的通过 Zuul 转发到具体微服务上。</p><h2 id="当前的项目列表如下："><a href="#当前的项目列表如下：" class="headerlink" title="当前的项目列表如下："></a>当前的项目列表如下：</h2><p>服务实例 端口 描述 common-api - 公用的 api，如：实体类 eureka-server 9000 注册中心（Eureka 服务端） goods-server 8081 商品服务（Eureka 客户端） goods-server-02 8082 商品服务（Eureka 客户端） goods-server-03 8083 商品服务（Eureka 客户端） order-server 8100 订单服务（Eureka 客户端） 创建一个为名 gateway-server 的 Spring Boot 项目。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- eureka 客户端 --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- zuul 网关 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>    port: <span class="hljs-number">9600</span><br> <br>spring:<br>    application:<br>        name: gateway<br> <br>eureka:<br>    instance:<br>        instance-id: gateway-<span class="hljs-number">9600</span><br>        prefer-ip-address: <span class="hljs-keyword">true</span> <br>    client:<br>        service-url:<br>            defaultZone: http:<span class="hljs-comment">//localhost:9000/eureka/  # 注册中心访问地址</span><br></code></pre></td></tr></table></figure><h2 id="启动-Zuul"><a href="#启动-Zuul" class="headerlink" title="启动 Zuul"></a>启动 Zuul</h2><p>在启动类上添加 @EnableZuulProxy 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableZuulProxy</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewayApplication</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(GatewayApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动上边的所有项目，打开 Postman 请求订单下单接口，如下图：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/zuul-01_1572832302170.gif?x-oss-process=style/small" alt="zuul-01">图中，我们首先不经过网关直接访问 order-server 项目请求地址：<a href="http://localhost:8100/order/place">http://localhost:8100/order/place</a></p><p>之后再修改成访问 gateway-server 项目的请求地址：<a href="http://localhost:9600/order/order/place">http://localhost:9600/order/order/place</a></p><p>最终，响应结果都一样。</p><p>提示：<a href="http://localhost:9600/order/order/place">http://localhost:9600/order/order/place</a> 中第一个 order 表示的是注册在 Eureka 上的订单服务名称。</p><h2 id="zuul-常用配置"><a href="#zuul-常用配置" class="headerlink" title="zuul 常用配置"></a>zuul 常用配置</h2><p>修改路由：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">zuul:<br>  sensitive-headers: # 全局忽略敏感头，即允许接收 cookie 等请求头信息   <br>  routes:<br>    extlight: # 任意名字，保证唯一即可<br>      path: /extlight<span class="hljs-comment">/** # 自定义，真正用到的请求地址</span><br><span class="hljs-comment">      service-id: ORDER  # 路由到的目标服务名称</span><br><span class="hljs-comment"> </span><br></code></pre></td></tr></table></figure><p>将订单服务的路由名称改成 extlight。</p><p>使用 Postman 请求下单接口，运行结果：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210311213025395.jpeg" alt="zuul-02">请求成功。</p><h2 id="禁用路由："><a href="#禁用路由：" class="headerlink" title="禁用路由："></a>禁用路由：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">zuul:<br>  ignored-patterns:<br>  - /order/order<span class="hljs-comment">/**   </span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><p><a href="http://localhost:9600/order/order/place">http://localhost:9600/order/order/place</a> 无法被正常路由到订单服务，响应返回 404。</p><h2 id="路由加前缀："><a href="#路由加前缀：" class="headerlink" title="路由加前缀："></a>路由加前缀：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zuul:<br>  prefix: /api<br></code></pre></td></tr></table></figure><p>所有请求中的 path 需要添加 api 前缀。如: <a href="http://localhost:9600/extlight/order/place">http://localhost:9600/extlight/order/place</a> 需要改成 <a href="http://localhost:9600/api/extlight/order/place%E3%80%82">http://localhost:9600/api/extlight/order/place。</a></p><h2 id="设置敏感头："><a href="#设置敏感头：" class="headerlink" title="设置敏感头："></a>设置敏感头：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">zuul:<br>  sensitive-headers: # 设置全局敏感头，如果为空，表示接收所有敏感头信息<br>或者<br>zuul:<br>  routes:<br>    extlight: # 任意名字，保证唯一即可<br>      path: /extlight<span class="hljs-comment">/** # 自定义，真正用到的请求地址</span><br><span class="hljs-comment">      service-id: ORDER  # 路由到的目标服务名称</span><br><span class="hljs-comment">      sensitive-headers: # 针对 /extlight/ 的请求设置敏感头信息</span><br><span class="hljs-comment"> </span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/cuixiaoyan/zuul">源码下载</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Zuul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hystrix仪表盘</title>
    <link href="/blog/2021/03/10/Hystrix%E4%BB%AA%E8%A1%A8%E7%9B%98/"/>
    <url>/blog/2021/03/10/Hystrix%E4%BB%AA%E8%A1%A8%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p><strong>除了服务熔断、降级的功能外，Hystrix 还提供了准及时的调用监控。 Hystrix 会持续地记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表和图形方式展示给用户。</strong></p><h2 id="配置被监控方"><a href="#配置被监控方" class="headerlink" title="配置被监控方"></a>配置被监控方</h2><p>order-server 项目中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>修改 application.yml，开放端口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">management:<br>  endpoints:<br>    web:<br>      exposure:<br>        include: <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><h2 id="配置监控方"><a href="#配置监控方" class="headerlink" title="配置监控方"></a>配置监控方</h2><p>新建一个名为 hystrix-dashboard 项目，添加如下依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- hystrix-dashboard --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>新建 application.yml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>  port: <span class="hljs-number">9300</span><br>  <br>spring:<br>  application:<br>    name: Hystrix-Dashboard  <br></code></pre></td></tr></table></figure><p>开启监控功能 在启动类上添加 @EnableHystrixDashboard 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableHystrixDashboard</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixdashboardApplication</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(HystrixdashboardApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动,浏览器访问: <a href="http://localhost:9300/hystrix![hystrix-06](https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210310202348565.jpeg)">http://localhost:9300/hystrix![hystrix-06](https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210310202348565.jpeg)</a></p><h2 id="监控设置"><a href="#监控设置" class="headerlink" title="监控设置"></a>监控设置</h2><p>我们以监控 order-server 为例，在监控界面添加监控信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"># 需要监控的服务地址<br>http:<span class="hljs-comment">//localhost:8100/actuator/hystrix.stream</span><br> <br>delay: 请求间隔时间<br> <br>title: 监控名称<br> <br>点击 monitor stream<br> <br>批量访问 order-server 服务的下单接口。<br></code></pre></td></tr></table></figure><p>最终效果如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210310202348764.jpeg" alt="hystrix-07-01">通过批量访问下单接口，发现图中实心圆和曲线发生了变化。那我们如何根据这两个图形查看监控信息呢？</p><p>实心圆：通过颜色的变化代表实例的健康程度，健康度从绿色&gt;黄色&gt;橙色&gt;红色递减。其大小也会根据实例的请求流量发生变化，流量越大实心圆越大。</p><p>曲线：用来记录间隔时间内流量的相对变化，通常可以观察到流量的上升和下降趋势。 <a href="https://github.com/cuixiaoyan/hystrix">源码下载</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Hystrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量去除文件,文件夹的名称中指定的字符</title>
    <link href="/blog/2021/03/10/%E6%89%B9%E9%87%8F%E5%8E%BB%E9%99%A4%E6%96%87%E4%BB%B6,%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <url>/blog/2021/03/10/%E6%89%B9%E9%87%8F%E5%8E%BB%E9%99%A4%E6%96%87%E4%BB%B6,%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><strong>效果如下</strong></p><h2 id="执行前"><a href="#执行前" class="headerlink" title="执行前"></a>执行前</h2><p><img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/20191029095253196_1572490020008.png?x-oss-process=style/small" alt="20191029095253196"></p><h2 id="执行后"><a href="#执行后" class="headerlink" title="执行后"></a>执行后</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210310202248495.png" alt="20191029095319557">完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.we;<br><span class="hljs-keyword">import</span> java.io.File;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 批量去除文件、文件夹的名称中指定的字符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WalterWen</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClearAdvert</span> </span>&#123;<br><span class="hljs-comment">//AD为广告内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AD = <span class="hljs-string">&quot;要去除的字符&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fileNum = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//文件夹路径名</span><br>        String rootPath = <span class="hljs-string">&quot;指定的文件（夹）路径&quot;</span>;<br>        scanFile(rootPath);<br>        System.out.println(<span class="hljs-string">&quot;共去广告&quot;</span> + fileNum + <span class="hljs-string">&quot;个文件&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 递归调用查找指定文件夹下所有文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scanFile</span><span class="hljs-params">(String path)</span> </span>&#123;<br>        File dirFile = reName(<span class="hljs-keyword">new</span> File(path));<br>        System.out.println(dirFile.getAbsolutePath());<br>        <span class="hljs-keyword">if</span> (dirFile.isDirectory())&#123;<br>            String[] fileList = dirFile.list();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fileList.length; i++) &#123;<br>                path = dirFile.getAbsolutePath() + <span class="hljs-string">&quot;\\&quot;</span> + fileList[i];<br>                scanFile(path);<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> File <span class="hljs-title">reName</span><span class="hljs-params">(File oldFile)</span> </span>&#123;<br>        <span class="hljs-comment">//不带路径的文件名</span><br>        String originalName = oldFile.getName();        <br>        <span class="hljs-keyword">if</span> (originalName.contains(AD)) &#123;<br>            <span class="hljs-comment">//带路径的文件名</span><br>            String oldFilePath = oldFile.getAbsolutePath();<span class="hljs-comment">// 目录路径</span><br>            String newFilePath = oldFilePath.replace(AD, <span class="hljs-string">&quot;&quot;</span>);<br>            File newFile = <span class="hljs-keyword">new</span> File(newFilePath);<br>            <span class="hljs-keyword">if</span> (oldFile.renameTo(newFile)) &#123;<br>                fileNum++;<br>                <span class="hljs-keyword">return</span> newFile;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldFile;<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p><a href="https://bk.cuixiaoyan.xyz/archives/quzifu#%E6%89%A7%E8%A1%8C%E5%89%8D">执行前</a><a href="https://bk.cuixiaoyan.xyz/archives/quzifu#%E6%89%A7%E8%A1%8C%E5%90%8E">执行后</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud入门之Hystrix篇</title>
    <link href="/blog/2021/03/10/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BHystrix%E7%AF%87/"/>
    <url>/blog/2021/03/10/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BHystrix%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在微服务应用中，服务存在一定的依赖关系，如果某个目标服务调用慢或者有大量超时造成服务不可用，间接导致其他的依赖服务不可用，最严重的可能会阻塞整条依赖链，最终导致业务系统崩溃（又称雪崩效应）。</p><p>上述的问题将是本篇需要解决的问题。</p><h2 id="请求熔断"><a href="#请求熔断" class="headerlink" title="请求熔断"></a>请求熔断</h2><p>断路器是一种开关设置，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个符合预期的服务降级处理（fallback），而不是长时间的等待或者抛出调用方无法处理的异常，这样保证了服务调用方的线程不会长时间被占用，从而避免了故障在分布式系统的蔓延乃至崩溃。</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>fallback 相当于是降级操作。对于查询操作, 我们可以实现一个 fallback 方法, 当请求后端服务出现异常的时候, 可以使用 fallback 方法返回的值。 fallback 方法的返回值一般是设置的默认值或者来自缓存，告知后面的请求服务不可用了，不要再请求了。</p><h2 id="请求熔断和服务降级区别"><a href="#请求熔断和服务降级区别" class="headerlink" title="请求熔断和服务降级区别"></a>请求熔断和服务降级区别</h2><p>相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">目标一致：为了防止系统崩溃而实施的一种防御手段<br> <br>表现形式一致：当请求目标在一定时间内无响应时，返回或执行默认响应内容<br></code></pre></td></tr></table></figure><p>不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">触发条件不同：下游服务出现故障触发请求熔断。系统负荷超过阈值触发服务降级。<br> <br>管理目标层次不同：请求熔断针对所有微服务。服务降级针对整个系统中的外围服务。<br></code></pre></td></tr></table></figure><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>Spring Cloud Hystrix 实现了断路器、线程隔离等一系列服务保护功能。它是基于 Netflix 的开源框架 Hystrix 实现的，该框架的目的在于通过控制访问远程系统、服务和第三方库节点，从而对延迟和故障提供更强大的容错能力。</p><p>Hystrix 具备服务熔断、服务降级、线程和信号隔离、请求缓存、请求合并以及服务监控的能力。</p><h1 id="请求熔断实战"><a href="#请求熔断实战" class="headerlink" title="请求熔断实战"></a>请求熔断实战</h1><p>现在的项目列表如下： 服务实例 端口 描述 common-api - 公用的 api，如：实体类 eureka-server 9000 注册中心（Eureka 服务端） goods-server 8081 商品服务（Eureka 客户端） goods-server-02 8082 商品服务（Eureka 客户端） goods-server-03 8083 商品服务（Eureka 客户端） order-server 8100 订单服务（Eureka 客户端） 在 order-server 项目中：</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- hystrix --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="设置熔断策略"><a href="#设置熔断策略" class="headerlink" title="设置熔断策略"></a>设置熔断策略</h2><p>我们来修改获取下订单的方法，在 placeOrder 方法上加 @HystrixCommand 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span></span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-comment">//@Autowired</span><br><span class="hljs-comment">//private GoodsServiceClient goodsServiceClient;</span><br> <br><span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;defaultByPlaceOrder&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">placeOrder</span><span class="hljs-params">(Order order)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>Result result = <span class="hljs-keyword">this</span>.restTemplate.getForObject(<span class="hljs-string">&quot;http://GOODS/goods/goodsInfo/&quot;</span> + order.getGoodsId(), Result.class);<br><br><span class="hljs-comment">//Result result = this.goodsServiceClient.goodsInfo(order.getGoodsId());</span><br><br><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span> &amp;&amp; result.getCode() == <span class="hljs-number">200</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;=====下订单====&quot;</span>);<br>System.out.println(result.getData());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(result.getMsg());<br>&#125;<br>&#125;<br><br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultByPlaceOrder</span><span class="hljs-params">(Order order)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;商品服务系统异常&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用商品服务超时或出现异常时，Hystrix 会调用 @HystrixCommand 中指定的 fallbackMethod 方法获取返回值或执行异常处理。</p><p>注意：fallbackMethod 方法要求与正常方法有相同的入参和回参。</p><h2 id="启动熔断功能"><a href="#启动熔断功能" class="headerlink" title="启动熔断功能"></a>启动熔断功能</h2><p>在启动类上添加 @EnableCircuitBreaker 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCircuitBreaker</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServerApplication</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(OrderServerApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="熔断测试"><a href="#熔断测试" class="headerlink" title="熔断测试"></a>熔断测试</h2><p>我们首先演示没有开启熔断的功能，即先把上边的 @EnableCircuitBreaker 注解进行注释。 启动好所有项目，使用 Postman 请求 order-server 进行下单操作，运行结果如下：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/hystrix-03-02_1572403574165.gif?x-oss-process=style/small" alt="hystrix-03-02">当我们请求发送的 goodsId 的商品不存在，服务提供方抛会异常，调用方无法处理，因此只能展示图中的异常信息。</p><p>下面，我们再将 @EnableCircuitBreaker 注解的注释放开，运行结果如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210310202116369.jpeg" alt="hystrix-04-02"></p><p>从图中可知，虽然请求了一个 goodsId 不存在的商品，但是调用方（order-server）开启了熔断机制，执行默认方法，从而使接口能正常通信而不是抛出调用方不可处理的异常导致整个系统不能正常运行。</p><p>看到这里，或许会有读者产生一个疑问，如果类中定义 N 个方法，是不是意味着同时也要定义 N 个异常处理的方法呢，答案是否定的。</p><p>Hystrix 还提供了 @DefaultProperties 统一处理请求熔断，在该注解上设置 defaultFallback 属性值，即熔断开启后要执行的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@DefaultProperties(defaultFallback = &quot;defaultByHystrix&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span></span>&#123;<br><br><span class="hljs-comment">//@Autowired</span><br><span class="hljs-comment">//private RestTemplate restTemplate;</span><br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> GoodsServiceClient goodsServiceClient;<br> <br><span class="hljs-meta">@HystrixCommand</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">placeOrder</span><span class="hljs-params">(Order order)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br><span class="hljs-comment">//Result result = this.restTemplate.getForObject(&quot;http://GOODS/goods/goodsInfo/&quot; + order.getGoodsId(), Result.class);</span><br><br>Result result = <span class="hljs-keyword">this</span>.goodsServiceClient.goodsInfo(order.getGoodsId());<br><br><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span> &amp;&amp; result.getCode() == <span class="hljs-number">200</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;=====下订单====&quot;</span>);<br>System.out.println(result.getData());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(result.getMsg());<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultByHystrix</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;商品服务系统异常&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：defaultFallback 定义的方法必须是无参的。 <a href="https://github.com/cuixiaoyan/hystrix">源码下载</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java解决Emoji表情过滤问题</title>
    <link href="/blog/2021/03/07/Java%E8%A7%A3%E5%86%B3Emoji%E8%A1%A8%E6%83%85%E8%BF%87%E6%BB%A4%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2021/03/07/Java%E8%A7%A3%E5%86%B3Emoji%E8%A1%A8%E6%83%85%E8%BF%87%E6%BB%A4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong></p><p>Emoji表情从三方数据中获取没有过滤，导致存入DB的时候报错。</p><p><strong>原因：</strong></p><p>UTF-8编码有可能是两个、三个、四个字节。Emoji表情是4个字节，而Mysql的utf8编码最多3个字节，所以数据插不进去。</p><p><strong>解决方案：</strong></p><p>1.将已经建好的表也转换成utf8mb4，这个方法不可行，有的时候就不灵了。</p><p>2，写个工具类：过滤掉emoji表情符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmojiFilter</span> </span>&#123;<br>   <br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmojiCharacter</span><span class="hljs-params">(<span class="hljs-keyword">char</span> codePoint)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (codePoint == <span class="hljs-number">0x0</span>) || (codePoint == <span class="hljs-number">0x9</span>) || (codePoint == <span class="hljs-number">0xA</span>)<br>                || (codePoint == <span class="hljs-number">0xD</span>)<br>                || ((codePoint &gt;= <span class="hljs-number">0x20</span>) &amp;&amp; (codePoint &lt;= <span class="hljs-number">0xD7FF</span>))<br>                || ((codePoint &gt;= <span class="hljs-number">0xE000</span>) &amp;&amp; (codePoint &lt;= <span class="hljs-number">0xFFFD</span>))<br>                || ((codePoint &gt;= <span class="hljs-number">0x10000</span>) &amp;&amp; (codePoint &lt;= <span class="hljs-number">0x10FFFF</span>));<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤emoji 或者 其他非文字类型的字符</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> source</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">filterEmoji</span><span class="hljs-params">(String source)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(source)) &#123;<br>            <span class="hljs-keyword">return</span> source;<br>        &#125;<br>        StringBuilder buf = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> len = source.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">char</span> codePoint = source.charAt(i);<br>            <span class="hljs-keyword">if</span> (isEmojiCharacter(codePoint)) &#123;<br>                <span class="hljs-keyword">if</span> (buf == <span class="hljs-keyword">null</span>) &#123;<br>                    buf = <span class="hljs-keyword">new</span> StringBuilder(source.length());<br>                &#125;<br>                buf.append(codePoint);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (buf == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> source;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (buf.length() == len) &#123;<br>                buf = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">return</span> source;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> buf.toString();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用别人封装的一个类，专门解决emoji问题的。这个在git上有开源的代码。在pom工程中引入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>&lt;groupId&gt;com.vdurmont&lt;/groupId&gt;<br>&lt;artifactId&gt;emoji-java&lt;/artifactId&gt;<br>&lt;version&gt;4.0.0&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>直接就可以在代码中使用了。</p><p>EmojiParser.removeAllEmojis(str) 这个方法可以过滤掉字符串内的emoji表情。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud入门之Feign篇</title>
    <link href="/blog/2021/03/07/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BFeign%E7%AF%87/"/>
    <url>/blog/2021/03/07/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BFeign%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>上面介绍了 Ribbon 使用负载均衡调用微服务，但存在一个问题：消费端每个请求方法中都需要拼接请求服务的 URL 地址，存在硬编码问题且不符合面向对象编程思想。如果服务名称发生变化，消费端也需要跟着修改。</p><p>本篇文章将介绍 Feign 来解决上边的问题。</p><p>Feign 是一个声明式的 Web Service 客户端。使用 Feign 能让编写 Web Service 客户端更加简单，同时支持与Eureka、Ribbon 组合使用以支持负载均衡。</p><p>Spring Cloud 对 Feign 进行了封装，使其支持了 Spring MVC 标准注解和 HttpMessageConverters。</p><p>Feign 的使用方法是定义一个接口，然后在其上边添加 @FeignClient 注解。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在 common-api 和 user-web 项目中添加依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value=&quot;USER-API&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserFeignService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/provider/user/get/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 @FeignClient 注解指定调用的微服务名称，封装了调用 USER-API 的过程，作为消费方调用模板。</p><h2 id="修改服务消费方"><a href="#修改服务消费方" class="headerlink" title="修改服务消费方"></a>修改服务消费方</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserFeignService userFeignService;<br><br><span class="hljs-meta">@RequestMapping(&quot;get/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 使用 Feign 封装的模板</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userFeignService.get(id);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接使用 Feign 封装模板调用服务方，从而实现面向对象编程。</p><h2 id="启动-Feign-功能"><a href="#启动-Feign-功能" class="headerlink" title="启动 Feign 功能"></a>启动 Feign 功能</h2><p>在启动类上添加 @EnableEeignClients 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">@<span class="hljs-meta">@EnableFeignClients(basePackages=&#123;&quot;com.extlight.springcloud&quot;&#125;)</span><br><span class="hljs-meta">@ComponentScan(&quot;com.extlight.springcloud&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(ConsumerApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打开浏览器访问 user-web 项目，请求结果如下图：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/feign_1571967712084.jpg?x-oss-process=style/small" alt="feign"><a href="https://github.com/cuixiaoyan/feign">源码下载</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程容易产生的40个问题汇总</title>
    <link href="/blog/2021/03/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%B9%E6%98%93%E4%BA%A7%E7%94%9F%E7%9A%8440%E4%B8%AA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/blog/2021/03/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%B9%E6%98%93%E4%BA%A7%E7%94%9F%E7%9A%8440%E4%B8%AA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>这些多线程的问题，有些来源于各大网站、有些来源于自己的思考。可能有些问题网上有、可能有些问题对应的答案也有、也可能有些各位网友也都看过，但是本文写作的重心就是所有的问题都会按照自己的理解回答一遍，不会去看网上的答案，因此可能有些问题讲的不对，能指正的希望大家不吝指教。</strong></p><p>40个问题汇总</p><p>1、多线程有什么用？</p><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><p>2、创建线程的方式</p><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p><p>3、start()方法和run()方法的区别</p><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><p>4、Runnable接口和Callable接口的区别</p><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><p>5、CyclicBarrier和CountDownLatch的区别</p><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><p>6、Volatile关键字的作用</p><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C代码–&gt;C/C代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><p>7、什么是线程安全 又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><p>8、Java中如何获取到线程dump文件</p><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><p>9、一个线程如果出现了运行时异常会怎么样</p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><p>10、如何在两个线程之间共享数据</p><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p>11、sleep方法和wait方法有什么区别</p><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><p>12、生产者消费者模型的作用是什么</p><p>这个问题很理论，但是很重要：</p><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>13、ThreadLocal有什么用</p><p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><p>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</p><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><p>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</p><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p><p>16、为什么要使用线程池</p><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><p>17、怎么检测一个线程是否持有对象监视器</p><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。</p><p>18、synchronized和ReentrantLock的区别</p><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p>19、ConcurrentHashMap的并发度是什么</p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>20、ReadWriteLock是什么 首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>21、FutureTask是什么</p><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>22、Linux环境下如何查找哪个线程使用CPU最长 ‘</p><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p>23、Java编程写一个会导致死锁的程序</p><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程：死锁这篇文章里面有，就是上面步骤的代码实现。</p><p>24、怎么唤醒一个阻塞的线程</p><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p>25、不可变对象对多线程有什么帮助</p><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><p>26、什么是多线程的上下文切换</p><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p>27、如果你提交任务时，线程池队列已满，这时会发生什么</p><p>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p><p>28、Java中用到的线程调度算法是什么</p><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p>29、Thread.sleep(0)的作用是什么</p><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p>30、什么是自旋</p><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行地非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p>31、什么是Java内存模型</p><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><p>32、什么是CAS</p><p>CAS，全称为Compare and Set，即比较-设置。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><p>33、什么是乐观锁和悲观锁</p><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p>34、什么是AQS</p><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><p>35、单例模式的线程安全性</p><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><p>36、Semaphore有什么作用</p><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><p>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</p><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。</p><p>38、线程类的构造方法、静态块是被哪个线程调用的</p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><p>39、同步方法和同步块，哪个是更好的选择 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越少越好。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</p><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ribbon负载均衡</title>
    <link href="/blog/2021/03/02/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/blog/2021/03/02/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<p>策略规则 Ribbon 提供 IRule 接口，该接口定义了如何访问服务的策略，以下是该接口的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>) RoundRobinRule：轮询，默认使用的规则；<br><span class="hljs-number">2</span>) RandomRule：随机；<br><span class="hljs-number">3</span>) AvailabilityFilteringRule：先过滤由于多次访问故障而处于断路器跳闸状态以及并发连接数量超过阀值得服务，然后从剩余服务列表中按照轮询策略进行访问；<br><span class="hljs-number">4</span>) WeightedResponseTimeRule：根据平均响应时间计算所有的权重，响应时间越快服务权重越有可能被选中；<br><span class="hljs-number">5</span>) RetryRule：先按照 RoundRobinRule 策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用服务；<br><span class="hljs-number">6</span>) BestAvailableRule：先过滤由于多次访问故障而处于断路器跳闸状态的服务，然后选择并发量最小的服务；<br><span class="hljs-number">7</span>) ZoneAvoidanceRule：判断 server 所在区域的性能和 server 的可用性来选择服务器。<br></code></pre></td></tr></table></figure><p>策略使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfiguration</span> </span>&#123;<br> <br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">testRule</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RandomRule();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>手动创建负载均衡规则对象，本次测试使用的策略是随机。</p><p>启动 user-consumer 项目使用浏览器访问接口，运行结果如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210302204744717.jpeg" alt="ribbon-02"></p><p>由图可知，随机策略已生效，负载均衡的策略由轮询变成了随机。 <a href="https://github.com/cuixiaoyan/ribbon">源码下载</a></p>]]></content>
    
    
    <categories>
      
      <category>Ribbon</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Ribbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud入门之Ribbon篇</title>
    <link href="/blog/2021/03/02/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BRibbon%E7%AF%87/"/>
    <url>/blog/2021/03/02/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BRibbon%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>本篇文章将介绍如何使用 Ribbon 完成发现服务的调用以及其负载均衡的规则的使用。 Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的一套客户端负载均衡工具，其主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。</p><p>其运行原理如下图：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/ribbon_1571707503910.png?x-oss-process=style/small" alt="ribbon">Ribbon 运行时分成 2 个步骤： 1、先选择在同一个区域负载较少的 EurekaServer; 2、 再根据用户指定的策略，在从 EurekaServer 中获取注册列表中的服务信息进行调用。</p><p>添加依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>其实，添加 Eureka 包时，会自动添加 Ribbon 依赖包。 修改请求类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfiguration</span> </span>&#123;<br> <br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正如上文介绍的，Ribbon 是客户端负载均衡工具，所以在 getRestTemplate 方法上添加 @LoadBalanced 注解实现负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-comment">//@RequestMapping(&quot;get/&#123;id&#125;&quot;)</span><br><span class="hljs-comment">//public User get(@PathVariable(&quot;id&quot;) Integer id) throws Exception &#123;</span><br><span class="hljs-comment">//// 没有使用 Eureka 时，uri 为消息提供者的地址，需要指定 ip 和 端口</span><br><span class="hljs-comment">//return restTemplate.getForObject(new URI(&quot;http://localhost:8081/provider/user/get/&quot; + id), User.class);</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//@Autowired</span><br><span class="hljs-comment">//private DiscoveryClient client;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//@RequestMapping(&quot;get/&#123;id&#125;&quot;)</span><br><span class="hljs-comment">//public User get(@PathVariable(&quot;id&quot;) Integer id) throws Exception &#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//List&lt;ServiceInstance&gt; list = this.client.getInstances(&quot;USER-API&quot;);</span><br><span class="hljs-comment">//String uri = &quot;&quot;;</span><br><span class="hljs-comment">//    for (ServiceInstance instance : list) &#123;</span><br><span class="hljs-comment">//        if (instance.getUri() != null &amp;&amp; !&quot;&quot;.equals(instance.getUri().toString())) &#123;</span><br><span class="hljs-comment">//        uri = instance.getUri().toString();</span><br><span class="hljs-comment">//        break;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//return restTemplate.getForObject(uri + &quot;/provider/user/get/&quot; + id, User.class);</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-meta">@RequestMapping(&quot;get/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 使用 Eureka + Ribbon 后，uri 填写服务名称即可</span><br><span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://USER-API/provider/user/get/&quot;</span> + id, User.class);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改 DiscoveryClient 相关代码，使用 USER-API 服务名称作为请求 URL。</p><p>在启动类上将 @EnableDiscoveryClient 替换成 @EnableEurekaClient 注解。 完成上边 4 个操作后，启动 user-consumer 项目使用浏览器访问接口，运行结果如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210302204653022.jpeg" alt="ribbon-01">由图可知，Ribbon 默认使用负载均衡的策略是轮询，对服务进行调用。 <a href="https://github.com/cuixiaoyan/ribbon">源码下载</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Ribbon</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eureka集群</title>
    <link href="/blog/2021/03/02/Eureka%E9%9B%86%E7%BE%A4/"/>
    <url>/blog/2021/03/02/Eureka%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>Eureka 作为注册中心，保存了系统服务的相关信息，如果注册中心挂掉，那么系统就瘫痪了。因此，对 Eureka 做集群实现高可用是必不可少的。</p><p>本次测试使用一台机器部署 Eureka 集群，通过名字和端口区分不同的 eureka 服务。 Eureka 名称 端口号 eureka01 9001 eureka02 9002 由于使用一台机器，使用两个名称还需要修改 C:\Windows\System32\drivers\etc 下的 host 文件，添加如下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  eureka01<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  eureka02<br></code></pre></td></tr></table></figure><p>application.yml 文件需要进行如下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>    port: <span class="hljs-number">9001</span><br>    <br>eureka:<br>    instance:<br>        hostname: eureka01   # eureka 实例名称<br>    client:<br>        register-with-eureka: false # 不向注册中心注册自己<br>        fetch-registry: false       # 表示自己就是注册中心<br>        service-url:<br>            defaultZone: http:<span class="hljs-comment">//eureka01:9001/eureka/,http://eureka02:9002/eureka/</span><br></code></pre></td></tr></table></figure><p>两个 eureka 服务实例的配置文件修改方式类似，将名称和端口进行修改即可。 服务注册的项目中，将 eureka.client.service-url.defaultZone 改成集群的 url 即可。 启动效果如下图：<img src="https://cuixiaoyande.oss-cn-shanghai.aliyuncs.com/springcloud-eureka-05_1571621779024.jpg?x-oss-process=style/small" alt="springcloud-eureka-05"></p><p><strong>Eureka 与 Zookeeper 的区别</strong> 两者都可以充当注册中心的角色，且可以集群实现高可用，相当于小型的分布式存储系统。</p><h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><p>CAP 分别为 consistency(强一致性)、availability(可用性) 和 partition toleranc(分区容错性)。</p><p>理论核心：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个需求。因此，根据 CAP 原理将 NoSQL 数据库分成满足 CA 原则、满足 CP 原则和满足 AP 原则三大类： <strong>CA：单点集群，满足一致性，可用性的系统，通常在可扩展性上不高 CP: 满足一致性，分区容错性的系统，通常性能不是特别高 AP: 满足可用性，分区容错性的系统，通过对一致性要求较低</strong> 简单的说：CAP 理论描述在分布式存储系统中，最多只能满足两个需求。</p><h2 id="Zookeeper-保证-CP"><a href="#Zookeeper-保证-CP" class="headerlink" title="Zookeeper 保证 CP"></a>Zookeeper 保证 CP</h2><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟前的注册信息，但不能接受服务直接挂掉不可用了。因此，服务注册中心对可用性的要求高于一致性。</p><p>但是，zookeeper 会出现一种情况，当 master 节点因为网络故障与其他节点失去联系时，剩余节点会重新进行 leader 选举。问题在于，选举 leader 的时间较长，30 ~ 120 秒，且选举期间整个 zookeeper 集群是不可用的，这期间会导致注册服务瘫痪。在云部署的环境下，因网络问题导致 zookeeper 集群失去 master 节点的概率较大，虽然服务能最终恢复，但是漫长的选举时间导致注册服务长期不可用是不能容忍的。</p><h2 id="Eureka-保证-AP"><a href="#Eureka-保证-AP" class="headerlink" title="Eureka 保证 AP"></a>Eureka 保证 AP</h2><p>Eureka 在设计上优先保证了可用性。EurekaServer 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和发现服务。</p><p>而 Eureka 客户端在向某个 EurekaServer 注册或发现连接失败时，会自动切换到其他 EurekaServer 节点，只要有一台 EurekaServer 正常运行，就能保证注册服务可用，只不过查询到的信息可能不是最新的。</p><p>除此之外，EurekaServer 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点都没有正常的心跳，那么 EurekaServer 将认为客户端与注册中心出现网络故障，此时会出现一下几种情况：</p><p>EurekaServer 不再从注册列表中移除因为长时间没有收到心跳而应该过期的服务</p><p>EurekaServer 仍然能够接收新服务的注册和查询请求，但不会被同步到其他节点上</p><p>当网络稳定时，当前 EurekaServer 节点新的注册信息会同步到其他节点中 因此，Eureka 可以很好的应对因网络故障导致部分节点失去联系的情况，而不会向 Zookeeper 那样是整个注册服务瘫痪。 <a href="https://github.com/cuixiaoyan/eureka">源码下载</a></p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eureka</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud 入门之Eureka 篇</title>
    <link href="/blog/2021/02/27/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BEureka%E7%AF%87/"/>
    <url>/blog/2021/02/27/SpringCloud%E5%85%A5%E9%97%A8%E4%B9%8BEureka%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>本篇介绍 Spring Cloud 入门系列中的 Eureka，实现快速入门。</p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Eureka 是 Netflix 的子模块，它是一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</p><p>服务注册和发现对于微服务架构而言，是非常重要的。有了服务发现和注册，只需要使用服务的标识符就可以访问到服务，而不需要修改服务调用的配置文件。该功能类似于 Dubbo 的注册中心，比如 Zookeeper。</p><p>Eureka 采用了 CS 的设计架构。Eureka Server 作为服务注册功能的服务端，它是服务注册中心。而系统中其他微服务则使用 Eureka 的客户端连接到 Eureka Server 并维持心跳连接。</p><p>其运行原理如下图：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small.jpeg" alt="springcloud-eureka-01">由图可知，Eureka 的运行原理和 Dubbo 大同小异， Eureka 包含两个组件： Eureka Server 和 Eureka Client。</p><p>Eureka Server 提供服务的注册服务。各个服务节点启动后会在 Eureka Server 中注册服务，Eureka Server 中的服务注册表会存储所有可用的服务节点信息。</p><p>Eureka Client 是一个 Java 客户端，用于简化 Eureka Server 的交互，客户端同时也具备一个内置的、使用轮询负载算法的负载均衡器。在应用启动后，向 Eureka Server 发送心跳（默认周期 30 秒）。如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，Eureka Server 会从服务注册表中将该服务节点信息移除。</p><h1 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h1><p>创建 Spring Boot 项目，名为 eureka-server，进行如下操作：</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependencyManagement&gt;<br>  &lt;dependencies&gt;<br>  &lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;<br>&lt;version&gt;Dalston.SR1&lt;/version&gt;<br>&lt;type&gt;pom&lt;/type&gt;<br>&lt;scope&gt;import&lt;/scope&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;<br>&lt;type&gt;pom&lt;/type&gt;<br>&lt;scope&gt;import&lt;/scope&gt;<br>&lt;/dependency&gt;<br>  &lt;/dependencies&gt;<br>&lt;/dependencyManagement&gt;<br>  <br>&lt;dependencies&gt;  <br>    &lt;!-- eureka 服务端 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure><p>Spring Boot 与 SpringCloud 有版本兼容关系，如果引用版本不对应，项目启动会报错。</p><h2 id="application-yml-配置参数"><a href="#application-yml-配置参数" class="headerlink" title="application.yml 配置参数"></a>application.yml 配置参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>    port: <span class="hljs-number">9000</span><br>    <br>eureka:<br>    instance:<br>        hostname: localhost   # eureka 实例名称<br>    client:<br>        register-with-eureka: false # 不向注册中心注册自己<br>        fetch-registry: false       # 是否检索服务<br>        service-url:<br>            defaultZone: http:<span class="hljs-comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/  # 注册中心访问地址</span><br></code></pre></td></tr></table></figure><h2 id="开启注册中心功能"><a href="#开启注册中心功能" class="headerlink" title="开启注册中心功能"></a>开启注册中心功能</h2><p>在启动类上添加 @EnableEurekaServer 注解。</p><p>至此，准备工作完成，启动项目完成后，浏览器访问 <a href="http://localhost:9000/">http://localhost:9000</a> ，查看 Eureka 服务监控界面，如下图：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small.png" alt="springcloud-eureka-02">通过该网址可以查看注册中心注册服务的相关信息。当前还没有服务注册，因此没有服务信息。</p><p>补充：<a href="http://localhost:9000/">http://localhost:9000</a> 是 Eureka 监管界面访问地址，而 <a href="http://localhost:9000/eureka/">http://localhost:9000/eureka/</a> Eureka 注册服务的地址。</p><h1 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h1><p>了解 Eureka 的环境搭建后，我们需要进行实战直观的感受 Eureka 的真正作用，这样才能清楚掌握和学习 Eureka 。</p><p>我们再创建两个 Spring Boot 项目，一个名为 user-api ，用于提供接口服务，另一个名为 user-web，用于调用 user-api 接口获取数据与浏览器交互。 服务实例 端口 描述 eureka 9000 注册中心（Eureka 服务端） user-api 8081 服务提供者（Eureka 客户端） user-web 80 服务消费者，与浏览器端交互（Eureka 客户端）</p><h2 id="user-api-项目部分代码（服务提供）"><a href="#user-api-项目部分代码（服务提供）" class="headerlink" title="user-api 项目部分代码（服务提供）"></a>user-api 项目部分代码（服务提供）</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- eureka 客户端 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>    port: <span class="hljs-number">8081</span><br> <br>spring:<br>    application:<br>        name: user-api<br> <br>eureka:<br>    instance:<br>        instance-id: user-api-<span class="hljs-number">8081</span><br>        prefer-ip-address: true # 访问路径可以显示 IP<br>    client:<br>        service-url:<br>            defaultZone: http:<span class="hljs-comment">//localhost:9000/eureka/  # 注册中心访问地址</span><br></code></pre></td></tr></table></figure><h2 id="服务接口："><a href="#服务接口：" class="headerlink" title="服务接口："></a>服务接口：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br> <br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,User&gt; map;<br><br><span class="hljs-keyword">static</span> &#123;<br>map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">6</span>; i++) &#123;<br>map.put(i, <span class="hljs-keyword">new</span> User(i,<span class="hljs-string">&quot;test&quot;</span> +i , <span class="hljs-string">&quot;pwd&quot;</span> + i));<br>&#125;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br><span class="hljs-keyword">return</span> map.get(id);<br>&#125;<br> <br>&#125;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/provider/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br> <br><span class="hljs-meta">@RequestMapping(&quot;/get/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userService.getById(id);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：该 controller 是给 user-web 使用的（内部服务），不是给浏览器端调用的。</p><h2 id="开启服务注册功能："><a href="#开启服务注册功能：" class="headerlink" title="开启服务注册功能："></a>开启服务注册功能：</h2><p>在启动类上添加 @EnableEurekaClient 注解。</p><p>启动项目完成后，浏览器访问 <a href="http://localhost:9000/">http://localhost:9000</a> 查看 Eureka 服务监控界面 ，如下图：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210227094510603.jpeg" alt="springcloud-eureka-03">从图可知，user 相关服务信息已经注册到 Eureka 服务中了。</p><p>补充：在上图中，我们还看到一串红色的字体，那是因为 Eureka 启动了自我保护的机制。当 EurekaServer 在短时间内丢失过多客户端时（可能发生了网络故障），EurekaServer 将进入自我保护模式。进入该模式后，EurekaServer 会保护服务注册表中的信息不被删除。当网络故障恢复后，EurekaServer 会自动退出自我保护模式。</p><h2 id="user-web-项目部分代码（服务消费）"><a href="#user-web-项目部分代码（服务消费）" class="headerlink" title="user-web 项目部分代码（服务消费）"></a>user-web 项目部分代码（服务消费）</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- eureka 客户端 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="配置参数-1"><a href="#配置参数-1" class="headerlink" title="配置参数"></a>配置参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>  port: <span class="hljs-number">80</span><br> <br>spring:<br>  application:<br>    name: user-web<br>      <br>eureka:<br>  client:<br>    register-with-eureka: false # 不向注册中心注册自己<br>    fetch-registry: true        # 是否检索服务<br>    service-url:<br>      defaultZone: http:<span class="hljs-comment">//localhost:9000/eureka/  # 注册中心访问地址</span><br></code></pre></td></tr></table></figure><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfiguration</span> </span>&#123;<br> <br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br>&#125;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-comment">//@RequestMapping(&quot;get/&#123;id&#125;&quot;)</span><br><span class="hljs-comment">//public User get(@PathVariable(&quot;id&quot;) Integer id) throws Exception &#123;</span><br><span class="hljs-comment">//// 没有使用 Eureka 时，uri 为消息提供者的地址，需要指定 ip 和 端口</span><br><span class="hljs-comment">//return restTemplate.getForObject(new URI(&quot;http://localhost:8081/provider/user/get/&quot; + id), User.class);</span><br><span class="hljs-comment">//&#125;</span><br> <br>    <span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DiscoveryClient client;<br><br><span class="hljs-meta">@RequestMapping(&quot;get/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>List&lt;ServiceInstance&gt; list = <span class="hljs-keyword">this</span>.client.getInstances(<span class="hljs-string">&quot;USER-API&quot;</span>);<br>String uri = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (ServiceInstance instance : list) &#123;<br>        <span class="hljs-keyword">if</span> (instance.getUri() != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(instance.getUri())) &#123;<br>        uri = instance.getUri().toString();<br>        <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> restTemplate.getForObject(uri + <span class="hljs-string">&quot;/provider/user/get/&quot;</span> + id, User.class);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开启服务发现功能："><a href="#开启服务发现功能：" class="headerlink" title="开启服务发现功能："></a>开启服务发现功能：</h2><p>在启动类上添加 @EnableDiscoveryClient 注解。</p><p>启动项目后，使用浏览器访问 user-web 项目接口，运行结果如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/small-20210227094510701.jpeg" alt="springcloud-eureka-04-2"></p><p><a href="https://github.com/cuixiaoyan/eureka">源码下载</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>工具类</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python统计字符出现次数(Counter包)以及txt文件写入</title>
    <link href="/blog/2021/02/27/Python%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0(Counter%E5%8C%85)%E4%BB%A5%E5%8F%8Atxt%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/"/>
    <url>/blog/2021/02/27/Python%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0(Counter%E5%8C%85)%E4%BB%A5%E5%8F%8Atxt%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="统计字符-可以在jieba分词之后使用"><a href="#统计字符-可以在jieba分词之后使用" class="headerlink" title="统计字符(可以在jieba分词之后使用)"></a>统计字符(可以在jieba分词之后使用)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter<br> <br><span class="hljs-comment"># txt_list可以写成函数参数进行导入</span><br>txt_list = [<span class="hljs-string">&#x27;千古&#x27;</span>,<span class="hljs-string">&#x27;人间&#x27;</span>,<span class="hljs-string">&#x27;人间&#x27;</span>,<span class="hljs-string">&#x27;龙&#x27;</span>,<span class="hljs-string">&#x27;龙&#x27;</span>,<span class="hljs-string">&#x27;龙&#x27;</span>,<span class="hljs-string">&#x27;哈哈哈&#x27;</span>,<span class="hljs-string">&#x27;人才&#x27;</span>,<span class="hljs-string">&#x27;千古&#x27;</span>,<span class="hljs-string">&#x27;千古&#x27;</span>]<br>c = Counter()<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> txt_list:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;\r\n&#x27;</span> <span class="hljs-keyword">or</span> x == <span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-keyword">or</span> x == <span class="hljs-string">&#x27; &#x27;</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            c[x] += <span class="hljs-number">1</span><br>print(<span class="hljs-string">&#x27;常用词频统计结果: \n&#x27;</span>)<br><span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> c.most_common(<span class="hljs-number">4</span>): <span class="hljs-comment">#打印排名前四位</span><br>    print(<span class="hljs-string">&#x27;%s%s %s  %d&#x27;</span> % (<span class="hljs-string">&#x27;  &#x27;</span> * (<span class="hljs-number">3</span> ), k, <span class="hljs-string">&#x27;*&#x27;</span> * <span class="hljs-number">3</span>, v))<br> <br><span class="hljs-comment"># 按照词频数从大到小打印</span><br>d = <span class="hljs-built_in">sorted</span>(c.items(),key=itemgetter(<span class="hljs-number">1</span>),reverse = <span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> ss,tt <span class="hljs-keyword">in</span> d:<br>    out_words=ss + <span class="hljs-string">&#x27;\t&#x27;</span> + <span class="hljs-built_in">str</span>(tt)<br>    print(out_words)<br></code></pre></td></tr></table></figure><h1 id="多次覆盖，循环写入文件"><a href="#多次覆盖，循环写入文件" class="headerlink" title="多次覆盖，循环写入文件"></a>多次覆盖，循环写入文件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#写入文件，多次写入，后一次覆盖前一次，但是out_words本身是在叠加的</span><br><span class="hljs-comment">#即：第一次写入的是：千古\t3\n;第二次写入的是：千古\t3\n龙\t3\n，覆盖上一次的数据;</span><br><span class="hljs-comment">#第三次是：千古\t3\n龙\t3\n人间\t2\n，继续覆盖上一次的数据</span><br>out_words = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> ss,tt <span class="hljs-keyword">in</span> d:<br>    out_words=out_words + ss + <span class="hljs-string">&#x27;\t&#x27;</span> + <span class="hljs-built_in">str</span>(tt) + <span class="hljs-string">&#x27;\n&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;.\sss.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(out_words+<span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p>比如，循环两次的结果是：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1468269-20191016222751323-1357691422_1571276134547.png" alt="1468269-20191016222751323-1357691422"></p><p>一次性写入文件，中间不会覆盖和多次写入；但是如果重复运行代码，则会覆盖之前的全部内容，一次性重新写入所有新内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">out_words = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> ss,tt <span class="hljs-keyword">in</span> d:<br>    out_words=out_words + ss + <span class="hljs-string">&#x27;\t&#x27;</span> + <span class="hljs-built_in">str</span>(tt) + <span class="hljs-string">&#x27;\n&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;.\ttt.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(out_words+<span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1468269-20191016222730634-1775423973_1571276133624.png" alt="1468269-20191016222730634-1775423973"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Counter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何正确遍历删除List中的元素(普通for循环、增强for循环、迭代器iterator、removeIf+方法引用)</title>
    <link href="/blog/2021/02/27/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4List%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0(%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF%E3%80%81%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8iterator%E3%80%81removeIf+%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8)/"/>
    <url>/blog/2021/02/27/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4List%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0(%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF%E3%80%81%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8iterator%E3%80%81removeIf+%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8)/</url>
    
    <content type="html"><![CDATA[<p>遍历删除List中符合条件的元素主要有以下几种方法：</p><ol><li>普通for循环 2.增强for循环 foreach 3.迭代器iterator 4.removeIf 和 方法引用 (一行代码搞定) 其中使用普通for循环容易造成遗漏元素的问题，增强for循环foreach会报java.util.ConcurrentModificationException并发修改异常。</li></ol><p>所以推荐使用迭代器iterator，或者JDK1.8以上使用lambda表达式进行List的遍历删除元素操作。</p><p>以下是上述几种方法的具体分析：</p><h1 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 普通for循环遍历删除元素</span><br><span class="hljs-comment"> */</span>  <br>    List&lt;Student&gt; students = <span class="hljs-keyword">this</span>.getStudents();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;students.size(); i++) &#123;  <br>        <span class="hljs-keyword">if</span> (students.get(i).getId()%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;  <br>            Student student = students.get(i);  <br>            students.remove(student);  <br>        &#125;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>由于在循环中删除元素后，list的索引会自动变化，list.size()获取到的list长度也会实时更新，所以会造成漏掉被删除元素后一个索引的元素。</p><p>比如循环到第2个元素时你把它删了，接下来去访问第3个元素，实际上访问到的是原来list的第4个元素，因为原来的第3个元素变成了现在的第2个元素。这样就造成了元素的遗漏。</p><h1 id="增强for循环-foreach"><a href="#增强for循环-foreach" class="headerlink" title="增强for循环 foreach"></a>增强for循环 foreach</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增强for循环遍历删除元素</span><br><span class="hljs-comment"> */</span><br>    List&lt;Student&gt; students = <span class="hljs-keyword">this</span>.getStudents();  <br>    <span class="hljs-keyword">for</span> (Student stu : students) &#123;  <br>        <span class="hljs-keyword">if</span> (stu.getId() == <span class="hljs-number">2</span>)   <br>            students.remove(stu);  <br>    &#125;<br></code></pre></td></tr></table></figure><p>使用foreach遍历循环删除符合条件的元素，不会出现普通for循环的遗漏元素问题，但是会产生java.util.ConcurrentModificationException并发修改异常的错误。</p><p>报ConcurrentModificationException错误的原因：</p><p>　　先来看一下JDK源码中ArrayList的remove源码是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)<br>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                    fastRemove(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>一般情况下程序的执行路径会走到else路径下最终调用fastRemove方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        modCount++;<br>        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>在fastRemove方法中，可以看到第2行把modCount变量的值加一，但在ArrayList返回的迭代器会做迭代器内部的修改次数检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>     &#125;<br></code></pre></td></tr></table></figure><p>而foreach写法是对实际的Iterable、hasNext、next方法的简写，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。</p><p>要避免这种情况的出现则在使用迭代器迭代时（显式或for-each的隐式）不要使用List的remove，改为用Iterator的remove即可。</p><h1 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  迭代器iterator</span><br><span class="hljs-comment"> */</span><br>     List&lt;Student&gt; students = <span class="hljs-keyword">this</span>.getStudents();  <br>     System.out.println(students);  <br>     Iterator&lt;Student&gt; iterator = students.iterator();  <br>     <span class="hljs-keyword">while</span> (iterator .hasNext()) &#123;  <br>         Student student = iterator .next();  <br>         <span class="hljs-keyword">if</span> (iterator.getId() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  <br>             iterator.remove();<span class="hljs-comment">//这里要使用Iterator的remove方法移除当前对象，如果使用List的remove方法，则同样会出现ConcurrentModificationException  </span><br>     &#125;<br></code></pre></td></tr></table></figure><p>由上述foreach报错的原因，注意要使用迭代器的remove方法，而不是List的remove方法。</p><h1 id="removeIf-和-方法引用"><a href="#removeIf-和-方法引用" class="headerlink" title="removeIf 和 方法引用"></a>removeIf 和 方法引用</h1><p>在JDK1.8中，Collection以及其子类新加入了removeIf方法，作用是按照一定规则过滤集合中的元素。</p><p>方法引用是也是JDK1.8的新特性之一。方法引用通过方法的名字来指向一个方法，使用一对冒号 :: 来完成对方法的调用，可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>使用removeIf和方法引用删除List中符合条件的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; urls = <span class="hljs-keyword">this</span>.getUrls();  <br> <br><span class="hljs-comment">// 使用方法引用删除urls中值为&quot;null&quot;的元素</span><br>urls.removeIf(<span class="hljs-string">&quot;null&quot;</span>::equals);<br> <br></code></pre></td></tr></table></figure><p>作为removeIf的条件，为true时就删除元素。</p><p>使用removeIf 和 方法引用，可以将原本需要七八行的代码，缩减到一行即可完成，使代码的构造更紧凑简洁，减少冗余代码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot二十个注解</title>
    <link href="/blog/2021/02/27/SpringBoot%E4%BA%8C%E5%8D%81%E4%B8%AA%E6%B3%A8%E8%A7%A3/"/>
    <url>/blog/2021/02/27/SpringBoot%E4%BA%8C%E5%8D%81%E4%B8%AA%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h1><p>@SpringBootApplication 注解用于声明自动配置，即让Spring Boot 自动为程序进行必要的配置；@SpringBootApplication 注解配置等同于@Configuration、@EnableAutoConfiguration 和@ComponentScan 三个注解的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br> <br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-comment">/*@Configuration  三者只和等同于 @SpringBootApplication 注解进行自动配置</span><br><span class="hljs-comment">@EnableAutoConfiguration</span><br><span class="hljs-comment">@ComponentScan*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JzxyApplication</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(JzxyApplication.class, args);<br>        <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Contronller"><a href="#Contronller" class="headerlink" title="@Contronller"></a>@Contronller</h1><p>@Contronller 注解用于定义该类属于控制器类，因为在Sping Boot 项目中是由控制器负责将用户请求的URL 转发到对应的服务接口（Service 服务层），So使用其是必不可少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义控制器类 <span class="hljs-doctag">@Controller</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/demon/linux&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinuxUsersController</span> </span>&#123;<br> <br>    <span class="hljs-meta">@RequestMapping(&quot;/add/host&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getLinuxConn</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;LinuxConnEntity&gt; list)</span> </span>&#123;<br>        Map resultMap = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> list == <span class="hljs-keyword">null</span><br>                ? setResult(resultMap, Constant.ZERO, Constant.REQUEST_NULL_MSG)<br>                : linuxUsersServiceImpl.createLinuxConn(list);<br> <br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h1><p>@ResponseBody 注解表示该方法的返回结果直接写入HTTP 的Response Body 中，该注解一般在异步获取数据时使用，用于构建RESTful 的API；另外，在使用@RequestMapping 注解后返回值通常会解析为路径跳转，而在加上了@ResponseBody 注解后，返回结果则不会被解析为路径而是直接写入HTTP Response Body 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异步获取json 数据，加上<span class="hljs-doctag">@responsebody</span> 注解后，会直接返回json 数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/responsebody&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LinuxUserEntity <span class="hljs-title">testOne</span><span class="hljs-params">(LinuxUserEntity linuxUserEntity)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> linuxUsersServiceImpl.test();<br>        <span class="hljs-number">9</span>     &#125;<br></code></pre></td></tr></table></figure><h1 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h1><p>@RestController 注解用于标注控制层组件，其是@ResponseBody 和@Contronller 两个注解的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RestController</span> 等价于<span class="hljs-doctag">@Controller</span> 和 <span class="hljs-doctag">@ResponseBody</span> 两个注解的集合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/responsebody/linux&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinuxUsersController</span> </span>&#123;<br> <br>    <span class="hljs-meta">@RequestMapping(&quot;/responsebody&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LinuxUserEntity <span class="hljs-title">testOne</span><span class="hljs-params">(LinuxUserEntity linuxUserEntity)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> linuxUsersServiceImpl.test();<br>        <span class="hljs-number">12</span>     &#125;<br></code></pre></td></tr></table></figure><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><p>@RequestMapping 是提供路由信息的注解，其是负责URL 到Controller 中的具体函数的映射；此外，该注解后的括号内经常会使用如下六个属性：</p><ol><li>param：指定请求request 中必须包含某些参数，否则不处理该方法；</li><li>header：指定请求request 中必须包含某些指定的header 值，否则不处理该方法；</li><li>value：指定请求的实际地址；</li><li>method：指定请求的方法method 类型，通常设计为RESTful 风格的GET、POST、PUT 和DELETE；</li><li>consumes：指定处理请求提交内容的具体类型（即Content-Type），如applicatin/json 和text/html 等类型格式；</li></ol><p>6: produces：指定返回的内容类型，设置该属性后仅当request 请求头中的Accept 类型中包含该制定类型时才会返回，需谨慎。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@RequestMapping</span> 提供路由信息的注解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/responsebody&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LinuxUserEntity <span class="hljs-title">testOne</span><span class="hljs-params">(LinuxUserEntity linuxUserEntity)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> linuxUsersServiceImpl.test();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h1><p>@EnableAutoConfiguration 是Spring Boot 自动配置注解，其会根据项目中添加的依赖自动配置Spring 应用；比如Spring Boot 自动配置内嵌tomcat 的端口为8080；还有自动载入应用程序所需的所有Bean，这依赖于Spring Boot 在类路径中的查找结果，就比如你在classpath 下存在HSQLDB，并且没有手动配置任何数据库连接Bean，那么@EnableAutoConfiguration 注解就会自动配置一个内存模型（in-memory）数据库。</p><h1 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h1><p>@ComponentScan 注解表示该类会自动发现扫描组件，若扫描到包含@Component、@Controller 和@Service 等注解的类，则会将其注册为Bean，并且可以自动收集所有的Spring 组件，包括有@Configuration 注解标注的类；开发中经常使用@ComponentScan 注解搜索Beans，并结合@Autowired 注解将Beans 注入，若没有进行配置，则Spring Boot 只会扫描SpringBootApplication 启动类所在包下及其子包下的使用了@Service、@Repository 等注解的类。</p><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h1><p>@Configuration 注解作用类似于传统的xml 配置文件；例如，有第三方库需要用到xml 文件，则可以通过添加@Configuration 注解表示该类作为项目的配置主类，然后使用@ImportResource 注解加载xml 配置文件内容。</p><h1 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h1><p>@Import 注解作用是导入其它配置类。</p><h1 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h1><p>@ImportResource 注解作用是加载xml 配置文件。</p><h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p>@Autowired 注解的作用是自动导入依赖的Bean；即把配置好的Bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作；并且当加上标签（required=false）时，就算找不到bean 也不报错，允许注入为空。</p><h1 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h1><p>@Service 注解的作用是标志某类为Service 层，是Service 服务层组件注解。</p><h1 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h1><p>@Repository 注解作用是标志某类为数据层，其可用于确保DAO 层或者Repositories 能正常转译；当@Repository 注解修饰DAO 或者repositories 类时会被ComponentScan 发现并配置。</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h1><p>@Bean 注解相当于XML 配置文件中使用的标签，初始化的时候创建对象，并交由IOC 容器管理；需要注意的是@Bean 注解是放在方法的上面，而不是类，意思是产生一个bean，并交给spring 管理。</p><h1 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h1><p>@Value 注解作用是注入Spring Boot 配置文件application.properties，即获取application.properties 配置文件中属性的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(value = &quot;#&#123;VEHIVLE_TOPIC&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String VEHIVLE_TOPIC;<br></code></pre></td></tr></table></figure><h1 id="inject"><a href="#inject" class="headerlink" title="@inject"></a>@inject</h1><p>@inject 注解作用与@Autowired 相同，不同的是其没有require 属性，强制要求注入不能为空。</p><h1 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h1><p>@Component 注解泛指组件，即当组件不方便归类时，可以使用该注解进行标注归类。</p><h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><p>@Qualifier 注解用于当有多个同一类型的Bean 时，通过@Qualifier(“name”) 根据名字来指定注入的Bean；其需要配合@Autowired 使用，根据名字进行注入，进行更细粒度的控制如何选择要注入的Bean。</p><h1 id="Resouce"><a href="#Resouce" class="headerlink" title="@Resouce"></a>@Resouce</h1><p>@Resouce 注解的作用与@Autowired 相似，都是自动注入依赖的Bean；不同的是@Resource(name=”name”,type=”type”) 多了括号内的属性，当没有括号内内容的话，默认byName。</p><h1 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h1><p>@PathVariable 注解的作用是获取路径变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@RequestMapping</span> 获取路径变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/ioc/get/&#123;address&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testOne</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String address )</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取得到路径中address 的值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基本类型和包装类型</title>
    <link href="/blog/2021/02/27/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    <url>/blog/2021/02/27/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="包装类型可以为-null，而基本类型不可以"><a href="#包装类型可以为-null，而基本类型不可以" class="headerlink" title="包装类型可以为 null，而基本类型不可以"></a>包装类型可以为 null，而基本类型不可以</h1><p>别小看这一点区别，它使得包装类型可以应用于 POJO 中，而基本类型则不行。</p><p>POJO 是什么呢？这里稍微说明一下。</p><p>POJO 的英文全称是 Plain Ordinary Java Object，翻译一下就是，简单无规则的 Java 对象，只有属性字段以及 setter 和 getter 方法，示例如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Writer</span> </span>&#123;<br><span class="hljs-keyword">private</span> Integer age;<br><span class="hljs-keyword">private</span> String name;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>和 POJO 类似的，还有数据传输对象 DTO（Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象）、视图对象 VO（View Object，把某个页面的数据封装起来）、持久化对象 PO（Persistant Object，可以看成是与数据库中的表映射的 Java 对象）。</p><p>那为什么 POJO 的属性必须要用包装类型呢？ 数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。</p><h1 id="包装类型可用于泛型，而基本类型不可以"><a href="#包装类型可用于泛型，而基本类型不可以" class="headerlink" title="包装类型可用于泛型，而基本类型不可以"></a>包装类型可用于泛型，而基本类型不可以</h1><p>泛型不能使用基本类型，因为使用基本类型时会编译出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-keyword">int</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 提示 Syntax error, insert &quot;Dimensions&quot; to complete ReferenceType</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br> <br></code></pre></td></tr></table></figure><p>为什么呢？因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。</p><h1 id="基本类型比包装类型更高效"><a href="#基本类型比包装类型更高效" class="headerlink" title="基本类型比包装类型更高效"></a>基本类型比包装类型更高效</h1><p>基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTc5Mzg5LTM4MGYzMDk4YWQ3YzQwN2UucG5n_1571020521890.jpeg" alt="基本">很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过 new 一个包装类型就显得非常笨重。</p><h1 id="两个包装类型的值可以相同，但却不相等"><a href="#两个包装类型的值可以相同，但却不相等" class="headerlink" title="两个包装类型的值可以相同，但却不相等"></a>两个包装类型的值可以相同，但却不相等</h1><p>两个包装类型的值可以相同，但却不相等——这句话怎么理解呢？来看一段代码就明明白白了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer chenmo = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>Integer wanger = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br> <br>System.out.println(chenmo == wanger); <span class="hljs-comment">// false</span><br>System.out.println(chenmo.equals(wanger )); <span class="hljs-comment">// true</span><br> <br></code></pre></td></tr></table></figure><p>两个包装类型在使用“”进行判断的时候，判断的是其指向的地址是否相等。chenmo 和 wanger 两个变量使用了 new 关键字，导致它们在“”的时候输出了 false。</p><p>而 chenmo.equals(wanger) 的输出结果为 true，是因为 equals 方法内部比较的是两个 int 值是否相等。源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>        <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>虽然 chenmo 和 wanger 的值都是 10，但他们并不相等。换句话说就是：将“==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python爬图片</title>
    <link href="/blog/2021/02/21/python%E7%88%AC%E5%9B%BE%E7%89%87/"/>
    <url>/blog/2021/02/21/python%E7%88%AC%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p><strong>这个例子也不是我本意,不过好像大家都喜欢爬这类图片本人抱着学习技术的态度 深入研究,了解啦其过程(滑稽)</strong></p><p>建议: 编译器debug运行,加上浏览器开发者调试 会有更加容易了解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># 导入requests库</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 导入文件操作库</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> bs4<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> importlib<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br>importlib.reload(sys)<br> <br> <br><span class="hljs-comment"># 越多越好</span><br>meizi_headers = [<br>    <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36&quot;</span>,<br>    <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36&quot;</span>,<br>    <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0&quot;</span>,<br>    <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14&quot;</span>,<br>    <span class="hljs-string">&quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)&quot;</span>,<br>    <span class="hljs-string">&#x27;Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11&#x27;</span>,<br>    <span class="hljs-string">&#x27;Opera/9.25 (Windows NT 5.1; U; en)&#x27;</span>,<br>    <span class="hljs-string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&#x27;</span>,<br>    <span class="hljs-string">&#x27;Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)&#x27;</span>,<br>    <span class="hljs-string">&#x27;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12&#x27;</span>,<br>    <span class="hljs-string">&#x27;Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9&#x27;</span>,<br>    <span class="hljs-string">&quot;Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7&quot;</span>,<br>    <span class="hljs-string">&quot;Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0&quot;</span>,<br>    <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&#x27;</span><br>]<br><span class="hljs-comment"># 给请求指定一个请求头来模拟chrome浏览器</span><br><span class="hljs-keyword">global</span> headers<br>headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: random.choice(meizi_headers)&#125;<br><span class="hljs-comment"># 爬图地址</span><br>mziTu = <span class="hljs-string">&#x27;http://www.mzitu.com/&#x27;</span><br><span class="hljs-comment"># 定义存储位置</span><br><span class="hljs-keyword">global</span> save_path<br>save_path = <span class="hljs-string">&#x27;/Users/cuixiaoyan/Downloads/a&#x27;</span><br> <br> <br><span class="hljs-comment"># 创建文件夹</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">file_path</span>):</span><br>    <span class="hljs-keyword">if</span> os.path.exists(file_path) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>        os.makedirs(file_path)<br>    <span class="hljs-comment"># 切换路径至上面创建的文件夹</span><br>    os.chdir(file_path)<br> <br> <br><span class="hljs-comment"># 下载文件</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">page_no, file_path</span>):</span><br>    <span class="hljs-keyword">global</span> headers<br>    res_sub = requests.get(page_no, headers=headers)<br>    <span class="hljs-comment"># 解析html</span><br>    soup_sub = BeautifulSoup(res_sub.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    <span class="hljs-comment"># 获取页面的栏目地址</span><br>    all_a = soup_sub.find(<span class="hljs-string">&#x27;div&#x27;</span>,class_=<span class="hljs-string">&#x27;postlist&#x27;</span>).find_all(<span class="hljs-string">&#x27;a&#x27;</span>,target=<span class="hljs-string">&#x27;_blank&#x27;</span>)<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> all_a:<br>        count = count + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>:<br>            headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: random.choice(meizi_headers)&#125;<br>            print(<span class="hljs-string">&quot;内页第几页：&quot;</span> + <span class="hljs-built_in">str</span>(count))<br>            <span class="hljs-comment"># 提取href</span><br>            href = a.attrs[<span class="hljs-string">&#x27;href&#x27;</span>]<br>            print(<span class="hljs-string">&quot;套图地址：&quot;</span> + href)<br>            res_sub_1 = requests.get(href, headers=headers)<br>            soup_sub_1 = BeautifulSoup(res_sub_1.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>            <span class="hljs-comment"># ------ 这里最好使用异常处理 ------</span><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 获取套图的最大数量</span><br>                pic_max = soup_sub_1.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;pagenavi&#x27;</span>).find_all(<span class="hljs-string">&#x27;span&#x27;</span>)[<span class="hljs-number">6</span>].text<br>                print(<span class="hljs-string">&quot;套图数量：&quot;</span> + pic_max)<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(pic_max) + <span class="hljs-number">1</span>):<br>                    <span class="hljs-comment"># 单位为秒，1-3 随机数</span><br>                    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>                    headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: random.choice(meizi_headers)&#125;<br>                    <span class="hljs-comment"># print(&quot;子内页第几页：&quot; + str(j))</span><br>                    <span class="hljs-comment"># j int类型需要转字符串</span><br>                    href_sub = href + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(j)<br>                    print(<span class="hljs-string">&quot;图片地址：&quot;</span>+href_sub)<br>                    res_sub_2 = requests.get(href_sub, headers=headers)<br>                    soup_sub_2 = BeautifulSoup(res_sub_2.text, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>                    img = soup_sub_2.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;main-image&#x27;</span>).find(<span class="hljs-string">&#x27;img&#x27;</span>)<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(img, bs4.element.Tag):<br>                        <span class="hljs-comment"># 提取src</span><br>                        url = img.attrs[<span class="hljs-string">&#x27;src&#x27;</span>]<br>                        array = url.split(<span class="hljs-string">&#x27;/&#x27;</span>)<br>                        file_name = array[<span class="hljs-built_in">len</span>(array)-<span class="hljs-number">1</span>]<br>                        <span class="hljs-comment"># 防盗链加入Referer</span><br>                        headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: random.choice(meizi_headers), <span class="hljs-string">&#x27;Referer&#x27;</span>: url&#125;<br>                        img = requests.get(url, headers=headers)<br>                        print(<span class="hljs-string">&#x27;开始保存图片&#x27;</span>, img)<br>                        f = <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;ab&#x27;</span>)<br>                        f.write(img.content)<br>                        print(file_name, <span class="hljs-string">&#x27;图片保存成功！&#x27;</span>)<br>                        f.close()<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                print(e)<br> <br> <br><span class="hljs-comment"># 主方法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    res = requests.get(mziTu, headers=headers)<br>    <span class="hljs-comment"># 使用自带的html.parser解析</span><br>    soup = BeautifulSoup(res.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    <span class="hljs-comment"># 创建文件夹</span><br>    createFile(save_path)<br>    <span class="hljs-comment"># 获取首页总页数</span><br>    img_max = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;nav-links&#x27;</span>).find_all(<span class="hljs-string">&#x27;a&#x27;</span>)[<span class="hljs-number">3</span>].text<br>    <span class="hljs-comment"># print(&quot;总页数:&quot;+img_max)</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(img_max) + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 获取每页的URL地址</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>            page = mziTu<br>        <span class="hljs-keyword">else</span>:<br>            page = mziTu + <span class="hljs-string">&#x27;page/&#x27;</span> + <span class="hljs-built_in">str</span>(i)<br>        file = save_path + <span class="hljs-string">&#x27;\\&#x27;</span> + <span class="hljs-built_in">str</span>(i)<br>        createFile(file)<br>        <span class="hljs-comment"># 下载每页的图片</span><br>        print(<span class="hljs-string">&quot;套图页码：&quot;</span> + page)<br>        download(page, file)<br> <br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具类</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My97Date控件设置默认时间</title>
    <link href="/blog/2021/02/21/My97Date%E6%8E%A7%E4%BB%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%97%B6%E9%97%B4/"/>
    <url>/blog/2021/02/21/My97Date%E6%8E%A7%E4%BB%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p><strong>需求:设置开始时间和结束时间初始化时间隔为一周</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;startTime&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;startTime&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 45%&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Wdate&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&quot;WdatePicker(&#123;maxDate: $(&#x27;#endTime&#x27;).val(),dateFmt:&#x27;yyyy-MM-dd&#x27; &#125;)&quot;</span> <span class="hljs-attr">ignore</span>=<span class="hljs-string">&quot;ignore&quot;</span>/&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;endTime&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;endTime&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 45%&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Wdate&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&quot;WdatePicker(&#123;minDate: $(&#x27;#startTime&#x27;).val(),dateFmt:&#x27;yyyy-MM-dd&#x27; &#125;)&quot;</span><span class="hljs-attr">ignore</span>=<span class="hljs-string">&quot;ignore&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要设置一个月后的话 就加30</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js">       <span class="hljs-built_in">Date</span>.prototype.pattern = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fmt</span>) </span>&#123;<br>           <span class="hljs-keyword">var</span> o = &#123;<br>               <span class="hljs-string">&quot;M+&quot;</span>: <span class="hljs-built_in">this</span>.getMonth() + <span class="hljs-number">1</span>, <span class="hljs-comment">//月份</span><br>               <span class="hljs-string">&quot;d+&quot;</span>: <span class="hljs-built_in">this</span>.getDate(), <span class="hljs-comment">//日</span><br>               <span class="hljs-string">&quot;h+&quot;</span>: <span class="hljs-built_in">this</span>.getHours() % <span class="hljs-number">12</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">12</span> : <span class="hljs-built_in">this</span>.getHours() % <span class="hljs-number">12</span>, <span class="hljs-comment">//小时</span><br>               <span class="hljs-string">&quot;H+&quot;</span>: <span class="hljs-built_in">this</span>.getHours(), <span class="hljs-comment">//小时</span><br>               <span class="hljs-string">&quot;m+&quot;</span>: <span class="hljs-built_in">this</span>.getMinutes(), <span class="hljs-comment">//分</span><br>               <span class="hljs-string">&quot;s+&quot;</span>: <span class="hljs-built_in">this</span>.getSeconds(), <span class="hljs-comment">//秒</span><br>               <span class="hljs-string">&quot;q+&quot;</span>: <span class="hljs-built_in">Math</span>.floor((<span class="hljs-built_in">this</span>.getMonth() + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span>), <span class="hljs-comment">//季度</span><br>               <span class="hljs-string">&quot;S&quot;</span>: <span class="hljs-built_in">this</span>.getMilliseconds() <span class="hljs-comment">//毫秒</span><br>           &#125;;<br>           <span class="hljs-keyword">var</span> week = &#123;<br>               <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-string">&quot;\u65e5&quot;</span>,<br>               <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;\u4e00&quot;</span>,<br>               <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;\u4e8c&quot;</span>,<br>               <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-string">&quot;\u4e09&quot;</span>,<br>               <span class="hljs-string">&quot;4&quot;</span>: <span class="hljs-string">&quot;\u56db&quot;</span>,<br>               <span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-string">&quot;\u4e94&quot;</span>,<br>               <span class="hljs-string">&quot;6&quot;</span>: <span class="hljs-string">&quot;\u516d&quot;</span><br>           &#125;;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(y+)/</span>.test(fmt)) &#123;<br>               fmt = fmt.replace(<span class="hljs-built_in">RegExp</span>.$1, (<span class="hljs-built_in">this</span>.getFullYear() + <span class="hljs-string">&quot;&quot;</span>).substr(<span class="hljs-number">4</span> - <span class="hljs-built_in">RegExp</span>.$1.length));<br>           &#125;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(E+)/</span>.test(fmt)) &#123;<br>               fmt = fmt.replace(<span class="hljs-built_in">RegExp</span>.$1, ((<span class="hljs-built_in">RegExp</span>.$1.length &gt; <span class="hljs-number">1</span>) ? (<span class="hljs-built_in">RegExp</span>.$1.length &gt; <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;\u661f\u671f&quot;</span> : <span class="hljs-string">&quot;\u5468&quot;</span>) : <span class="hljs-string">&quot;&quot;</span>) + week[<span class="hljs-built_in">this</span>.getDay() + <span class="hljs-string">&quot;&quot;</span>]);<br>           &#125;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> o) &#123;<br>               <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;(&quot;</span> + k + <span class="hljs-string">&quot;)&quot;</span>).test(fmt)) &#123;<br>                   fmt = fmt.replace(<span class="hljs-built_in">RegExp</span>.$1, (<span class="hljs-built_in">RegExp</span>.$1.length == <span class="hljs-number">1</span>) ? (o[k]) : ((<span class="hljs-string">&quot;00&quot;</span> + o[k]).substr((<span class="hljs-string">&quot;&quot;</span> + o[k]).length)));<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> fmt;<br>       &#125;<br>       $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-keyword">var</span> dt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>           <span class="hljs-comment">//$(&quot;#startTime&quot;).val(dt.pattern(&quot;yyyy-MM-dd hh:mm:ss&quot;));</span><br>           $(<span class="hljs-string">&quot;#startTime&quot;</span>).val(dt.pattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br>           dt.setDate(dt.getDate() + <span class="hljs-number">7</span>);<span class="hljs-comment">//获取七天后的日期</span><br>           $(<span class="hljs-string">&quot;#endTime&quot;</span>).val(dt.pattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br><br>       &#125;);<br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;multitaskEchartsController.do?getAchievement&#x27;</span>;<br>       url += <span class="hljs-string">&#x27;&amp;startTime=&#x27;</span> + $(<span class="hljs-string">&quot;#startTime&quot;</span>).val()<br>       url += <span class="hljs-string">&#x27;&amp;endTime=&#x27;</span> + $(<span class="hljs-string">&quot;#endTime&quot;</span>).val()<br><br>       <span class="hljs-keyword">var</span> dt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>       <span class="hljs-comment">//$(&quot;#startTime&quot;).val(dt.pattern(&quot;yyyy-MM-dd hh:mm:ss&quot;));</span><br>       $(<span class="hljs-string">&quot;#startTime&quot;</span>).val(dt.pattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br>       dt.setDate(dt.getDate() + <span class="hljs-number">7</span>);<span class="hljs-comment">//获取七天后的日期</span><br>       $(<span class="hljs-string">&quot;#endTime&quot;</span>).val(dt.pattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br></code></pre></td></tr></table></figure><p>效果如下<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/QQ20191011-113936@2x_1570765228201.png" alt="QQ20191011-113936@2x"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>My97Date</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON数组形式字符串转换为Map数组</title>
    <link href="/blog/2021/02/21/JSON%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BAMap%E6%95%B0%E7%BB%84/"/>
    <url>/blog/2021/02/21/JSON%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BAMap%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><strong>阿里巴巴封装的FastJSON来转换JSON数组形式字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zkn.newlearn.json;<br> <br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONArray;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br> <br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这里我用到的是第一种方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonToMapTest02</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br> <br>        String strArr = <span class="hljs-string">&quot;[&#123;\&quot;0\&quot;:\&quot;zhangsan\&quot;,\&quot;1\&quot;:\&quot;lisi\&quot;,\&quot;2\&quot;:\&quot;wangwu\&quot;,\&quot;3\&quot;:\&quot;maliu\&quot;&#125;,&quot;</span> +<br>                <span class="hljs-string">&quot;&#123;\&quot;00\&quot;:\&quot;zhangsan\&quot;,\&quot;11\&quot;:\&quot;lisi\&quot;,\&quot;22\&quot;:\&quot;wangwu\&quot;,\&quot;33\&quot;:\&quot;maliu\&quot;&#125;]&quot;</span>;<br>        <span class="hljs-comment">//第一种方式</span><br>        List&lt;Map&lt;String,String&gt;&gt; listObjectFir = (List&lt;Map&lt;String,String&gt;&gt;) JSONArray.parse(strArr);<br>        System.out.println(<span class="hljs-string">&quot;利用JSONArray中的parse方法来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Map&lt;String,String&gt; mapList : listObjectFir)&#123;<br>            <span class="hljs-keyword">for</span> (Map.Entry entry : mapList.entrySet())&#123;<br>               System.out.println( entry.getKey()  + <span class="hljs-string">&quot;  &quot;</span> +entry.getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第二种方式</span><br>        List&lt;Map&lt;String,String&gt;&gt; listObjectSec = JSONArray.parseObject(strArr,List.class);<br>        System.out.println(<span class="hljs-string">&quot;利用JSONArray中的parseObject方法并指定返回类型来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Map&lt;String,String&gt; mapList : listObjectSec)&#123;<br>            <span class="hljs-keyword">for</span> (Map.Entry entry : mapList.entrySet())&#123;<br>                System.out.println( entry.getKey()  + <span class="hljs-string">&quot;  &quot;</span> +entry.getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第三种方式</span><br>        JSONArray listObjectThir = JSONArray.parseArray(strArr);<br>        System.out.println(<span class="hljs-string">&quot;利用JSONArray中的parseArray方法来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Object mapList : listObjectThir)&#123;<br>            <span class="hljs-keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;<br>                System.out.println(((Map.Entry)entry).getKey()  + <span class="hljs-string">&quot;  &quot;</span> +((Map.Entry)entry).getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第四种方式</span><br>        List listObjectFour = JSONArray.parseArray(strArr,Map.class);<br>        System.out.println(<span class="hljs-string">&quot;利用JSONArray中的parseArray方法并指定返回类型来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Object mapList : listObjectFour)&#123;<br>            <span class="hljs-keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;<br>                System.out.println(((Map.Entry)entry).getKey()  + <span class="hljs-string">&quot;  &quot;</span> +((Map.Entry)entry).getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第五种方式</span><br>        JSONArray listObjectFifth = JSONObject.parseArray(strArr);<br>        System.out.println(<span class="hljs-string">&quot;利用JSONObject中的parseArray方法来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Object mapList : listObjectFifth)&#123;<br>            <span class="hljs-keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;<br>                System.out.println(((Map.Entry)entry).getKey()  + <span class="hljs-string">&quot;  &quot;</span> +((Map.Entry)entry).getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第六种方式</span><br>        List listObjectSix = JSONObject.parseArray(strArr,Map.class);<br>        System.out.println(<span class="hljs-string">&quot;利用JSONObject中的parseArray方法并指定返回类型来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Object mapList : listObjectSix)&#123;<br>            <span class="hljs-keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;<br>                System.out.println(((Map.Entry)entry).getKey()  + <span class="hljs-string">&quot;  &quot;</span> +((Map.Entry)entry).getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第七种方式</span><br>        JSONArray listObjectSeven = JSON.parseArray(strArr);<br>        System.out.println(<span class="hljs-string">&quot;利用JSON中的parseArray方法来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Object mapList : listObjectSeven)&#123;<br>            <span class="hljs-keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;<br>                System.out.println(((Map.Entry)entry).getKey()  + <span class="hljs-string">&quot;  &quot;</span> +((Map.Entry)entry).getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第八种方式</span><br>        List listObjectEigh = JSONObject.parseArray(strArr,Map.class);<br>        System.out.println(<span class="hljs-string">&quot;利用JSON中的parseArray方法并指定返回类型来解析json数组字符串&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Object mapList : listObjectEigh)&#123;<br>            <span class="hljs-keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;<br>                System.out.println(((Map.Entry)entry).getKey()  + <span class="hljs-string">&quot;  &quot;</span> +((Map.Entry)entry).getValue());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>FastJSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS大更新导致git和svn无法使用</title>
    <link href="/blog/2021/02/17/macOS%E5%A4%A7%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4git%E5%92%8Csvn%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2021/02/17/macOS%E5%A4%A7%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4git%E5%92%8Csvn%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>大更新之后 更新一堆自带没用软件之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">$ git --version<br> <br>xcrun: error: <span class="hljs-function">invalid active developer <span class="hljs-title">path</span> <span class="hljs-params">(/Library/Developer/CommandLineTools)</span>, missing </span><br><span class="hljs-function">xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br><span class="hljs-function"> </span><br><span class="hljs-function"> </span><br></code></pre></td></tr></table></figure><p>原因是系统升级了，但是Xcode的命令行工具未升级导致的，更新一下就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">$ xcode-select --install<br> <br>xcode-select: note: install requested <span class="hljs-keyword">for</span> command line developer tools<br>弹窗安装完重启端口再输入命令就可以了<br> <br>$ git --version<br>git version <span class="hljs-number">2.17</span><span class="hljs-number">.2</span> (Apple Git-<span class="hljs-number">113</span>)<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java上传解压zip文件,并且解析文件里面的excel和图片</title>
    <link href="/blog/2021/02/17/Java%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6,%E5%B9%B6%E4%B8%94%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%E7%9A%84excel%E5%92%8C%E5%9B%BE%E7%89%87/"/>
    <url>/blog/2021/02/17/Java%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6,%E5%B9%B6%E4%B8%94%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%E7%9A%84excel%E5%92%8C%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p><strong>需求：上传一个zip文件，zip文件里面包含一个excel和很多图片，需要把excel里面的信息解析出来保存到表中，同时图片也转化成base64保存到数据库表中。</strong></p><h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这个deomo入参的类型是MultipartFile，很多网上的例子是File类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file (zip)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/addPersonsFileOfZip&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addPersonsFileOfZip</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String createdId = request.getParameter(KEY_CREATED_ID);<br>        <span class="hljs-comment">//正常上这里需要检查一下createdId是否为空</span><br>        <br>        <span class="hljs-comment">//原则上这个uploadZipFilesAndParse方法需要写到service和serviceImpl中</span><br>        String result =uploadZipFilesAndParse(file,createdId);<br>        <span class="hljs-keyword">return</span>  result;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回的是批次号</span><br><span class="hljs-comment">     *同时我另外开了线程处理zip文件里面的图片和excel，</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadZipFilesAndParse</span><span class="hljs-params">(MultipartFile file, String createdId)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String filename = file.getOriginalFilename();<br>        String fileType = filename.substring(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>).toLowerCase(Locale.US);<br>        String uuid = UUID.randomUUID().toString();<br>        <span class="hljs-comment">//判断文件是不是zip类型</span><br>        <span class="hljs-keyword">if</span>(fileType.equals(<span class="hljs-string">&quot;zip&quot;</span>))&#123;<br>            <br>            <span class="hljs-comment">//FileConfig.localtion是配置文件和config类生产的，我会在评论区附上这些代码，测试demo的时候大家可以直接把FileConfig.localtion替换成D:/test</span><br>            <span class="hljs-comment">//String desPath = FileConfig.localtion + File.separator + uuid.replaceAll(&quot;-&quot;, &quot;&quot;);</span><br>            String desPath = <span class="hljs-string">&quot;D:/test&quot;</span> + File.separator + uuid.replaceAll(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>            <br>            <br>            <span class="hljs-comment">//下面这三行的代码就是把上传文件copy到服务器，一定不要遗漏了。</span><br>            <span class="hljs-comment">//遗漏了这个代码，在本地测试环境不会出问题，在服务器上一定会报没有找到文件的错误</span><br>            String savePath = FileConfig.localtion + File.separator;<br>            File savefile = <span class="hljs-keyword">new</span> File(savePath+filename);<br>            file.transferTo(savefile);<br>            <br>            FileUtil fileUtil = <span class="hljs-keyword">new</span> FileUtil();<br>            <span class="hljs-comment">//解压zip文件，我是写在公共类里面，FileUtil类代码评论区见</span><br>            FileUtil.unZip(file, desPath,savePath);<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    List&lt;File&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    fileList = fileUtil.getSubFiles(desPath,fileList);<br>                        <span class="hljs-keyword">for</span> (File oneFile : fileList)&#123;<br>                            <span class="hljs-keyword">if</span> (oneFile.getName().toLowerCase().endsWith(<span class="hljs-string">&quot;.xls&quot;</span>) || oneFile.getName().toLowerCase().endsWith(<span class="hljs-string">&quot;.xlsx&quot;</span>) ) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-comment">//解析处理excel文件</span><br>                                    parseExcelFile(oneFile,createdId,uuid);<br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    LogUtils.error(e.getMessage());<br>                                &#125;<br>                            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oneFile.getName().toLowerCase().endsWith(<span class="hljs-string">&quot;.jpg&quot;</span>)) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-comment">//解析处理图片文件</span><br>                                    parseImageFile(oneFile,createdId,uuid);<br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    LogUtils.error(e.getMessage());<br>                                &#125;<br>                            &#125;<br>                        &#125;    <br>                        <br>                        <span class="hljs-comment">//最后要删除文件，删除文件的方法见评论区FileUtil类</span><br>                        FileUtil.clearFiles(desPath);<br>                        <br>                &#125;<br>            &#125;).start();            <br> <br>        &#125;<br>        <span class="hljs-keyword">return</span> uuid;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="解压zip文件的unzip方法"><a href="#解压zip文件的unzip方法" class="headerlink" title="解压zip文件的unzip方法"></a>解压zip文件的unzip方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unZip</span><span class="hljs-params">(MultipartFile  srcFile, String destDirPath,String savePath)</span> <span class="hljs-keyword">throws</span> RuntimeException, IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <br>        File file = <span class="hljs-keyword">null</span>;  <br>        InputStream ins = srcFile.getInputStream();  <br>        file=<span class="hljs-keyword">new</span> File(savePath+srcFile.getOriginalFilename()); <br>        LogUtils.info(<span class="hljs-string">&quot;MultipartFile transform to File,MultipartFile name:&quot;</span>+srcFile.getOriginalFilename());<br>        inputStreamToFile(ins, file);  <br>        <br>        <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(file.getPath() + <span class="hljs-string">&quot;,file is not found&quot;</span>);<br>        &#125;<br>        ZipFile zipFile = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zipFile = <span class="hljs-keyword">new</span> ZipFile(file);<br>            Enumeration&lt;?&gt; entries = zipFile.entries();<br>            <span class="hljs-keyword">while</span> (entries.hasMoreElements()) &#123;<br>                ZipEntry entry = (ZipEntry) entries.nextElement();<br>                LogUtils.info(<span class="hljs-string">&quot;zipFile context name:&quot;</span>+entry.getName());<br>                <span class="hljs-keyword">if</span> (entry.isDirectory()) &#123;<br>                    String dirPath = destDirPath + File.separator+ entry.getName();<br>                    File dir = <span class="hljs-keyword">new</span> File(dirPath);<br>                    dir.mkdirs();<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    File targetFile = <span class="hljs-keyword">new</span> File(destDirPath + File.separator + entry.getName());<br>                    targetFile.setExecutable(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">if</span>(!targetFile.getParentFile().exists())&#123;<br>                        targetFile.getParentFile().mkdirs();<br>                    &#125;<br>                    targetFile.createNewFile();<br>                    InputStream is = zipFile.getInputStream(entry);<br>                    FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(targetFile);<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-keyword">while</span> ((len = is.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                        fos.write(buf, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    fos.close();<br>                    is.close();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>            LogUtils.info(<span class="hljs-string">&quot;unZip time--&gt;&quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; ms&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;unzip error from FileUtil&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(zipFile != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    zipFile.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">//MultipartFile change to file may create a temp file in the project root folder(delete the temp file)</span><br>            File del = <span class="hljs-keyword">new</span> File(file.toURI());  <br>            del.delete(); <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="inputStreamToFile"><a href="#inputStreamToFile" class="headerlink" title="inputStreamToFile"></a>inputStreamToFile</h1><p>unzip方法中的inputStreamToFile方法，这个方法的目的是把MultipartFile转成File类型，但是会在项目根目录下生成一个临时文件，切记要删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inputStreamToFile</span><span class="hljs-params">(InputStream ins, File file)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            OutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>            <span class="hljs-keyword">int</span> bytesRead = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>            <span class="hljs-keyword">while</span> ((bytesRead = ins.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">8192</span>)) != -<span class="hljs-number">1</span>) &#123;<br>                os.write(buffer, <span class="hljs-number">0</span>, bytesRead);<br>            &#125;<br>            os.close();<br>            ins.close();<br>            LogUtils.info(<span class="hljs-string">&quot;MultipartFile transform to File completed!&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="parseExcelFile"><a href="#parseExcelFile" class="headerlink" title="parseExcelFile"></a>parseExcelFile</h1><p>parseExcelFile方法是解析excel的方法，里面包括我自己项目的逻辑处理，大家可以删除这些代码，只保留解析excel的代码就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseExcelFile</span><span class="hljs-params">(File file,String createdId,String uuid)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <br>        LogUtils.info(<span class="hljs-string">&quot;file name:&quot;</span>+file.getName());<br>        FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(file); <br>        Workbook workbook = WorkbookFactory.create(is);<br>        Sheet sheet = workbook.getSheetAt(<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">int</span> firstRowIndex = sheet.getFirstRowNum() + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lastRowIndex = sheet.getLastRowNum();<br>        <br>        List&lt;VapBatchPersonInfo&gt; batchPersonList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> rIndex = firstRowIndex; rIndex &lt;= lastRowIndex; rIndex++) &#123;<br>            <br>            VapBatchPersonInfo vapBatchPersonInfo  = <span class="hljs-keyword">new</span> VapBatchPersonInfo();<br>            Row row = sheet.getRow(rIndex);<br>            <span class="hljs-keyword">if</span> (row != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> firstCellIndex = row.getFirstCellNum();<br>                <span class="hljs-keyword">int</span> lastCellIndex = row.getLastCellNum();<br>                JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();<br>                jsonObject.put(KEY_CREATED_ID, createdId);<br> <br>                Cell resultCell = row.createCell(lastCellIndex);<br>                Cell msgCell = row.createCell(lastCellIndex + <span class="hljs-number">1</span>);<br>                Boolean flag = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cIndex = firstCellIndex; cIndex &lt; lastCellIndex; cIndex++) &#123;<br>                    Cell cell = row.getCell(cIndex);<br>                    String titleName = sheet.getRow(<span class="hljs-number">0</span>).getCell(cIndex).toString();<br>                    String checkTitleName = checkTitleName(cIndex, titleName);<br>                    <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;SUCCESS&quot;</span>.equals(checkTitleName)) &#123;<br>                        msgCell.setCellValue(checkTitleName);<br>                        resultCell.setCellValue(<span class="hljs-string">&quot;Failed&quot;</span>);<br>                        flag = <span class="hljs-keyword">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (cell != <span class="hljs-keyword">null</span>) &#123;<br>                        cell.setCellType(CellType.STRING);<br>                        jsonObject.put(titleName, cell.toString());<br>                    &#125;<br> <br>                &#125;<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    rIndex = <span class="hljs-number">0</span>;<br>                    lastRowIndex = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    vapBatchPersonInfo.setBatchNo(uuid);<br>                    vapBatchPersonInfo.setName(jsonObject.getString(<span class="hljs-string">&quot;fullName&quot;</span>));<br>                    vapBatchPersonInfo.setImageName(jsonObject.getString(<span class="hljs-string">&quot;imageName&quot;</span>));<br>                    vapBatchPersonInfo.setConfidenceThreshold(jsonObject.getString(<span class="hljs-string">&quot;confidenceThreshold&quot;</span>));<br>                    vapBatchPersonInfo.setCreatedId(jsonObject.getString(<span class="hljs-string">&quot;createdId&quot;</span>));<br>                    vapBatchPersonInfo.setIdentityNo(jsonObject.getString(<span class="hljs-string">&quot;identityNo&quot;</span>));<br>                    vapBatchPersonInfo.setCreatedDate(<span class="hljs-keyword">new</span> Date());<br>                    vapBatchPersonInfo.setLastUpdatedId(jsonObject.getString(<span class="hljs-string">&quot;createdId&quot;</span>));<br>                    vapBatchPersonInfo.setLastUpdatedDate(<span class="hljs-keyword">new</span> Date());<br>                    vapBatchPersonInfo.setStatus(TaskStatus.RUNNING);<br>                    batchPersonList.add(vapBatchPersonInfo);<br>                &#125;<br>            &#125;<br>        &#125;<br>        batchPersonInfoRepository.saveAll(batchPersonList);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="解析图片的方法"><a href="#解析图片的方法" class="headerlink" title="解析图片的方法"></a>解析图片的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseImageFile</span><span class="hljs-params">(File file, String createdId, String uuid)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <br>        String imgStr =<span class="hljs-string">&quot;&quot;</span>;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file);<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()]; <br>        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">int</span> numRead = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">while</span> (offset &lt; buffer.length &amp;&amp; (numRead = fis.read(buffer, offset, buffer.length - offset)) &gt;= <span class="hljs-number">0</span>) &#123;<br>            offset += numRead;<br>        &#125; <br>        <span class="hljs-keyword">if</span> (offset != buffer.length) &#123; <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Could not completely read file &quot;</span> + file.getName()); <br>        &#125; <br>        fis.close(); <br>        Base64 encoder = <span class="hljs-keyword">new</span> Base64();<br>        imgStr = Base64.encodeBase64String(buffer);<br>        imgStr.length();<br>        LogUtils.info(<span class="hljs-string">&quot;file name:&quot;</span>+file.getName());<br><span class="hljs-comment">//        LogUtils.info(&quot;file imgStr:&quot;+imgStr);</span><br><span class="hljs-comment">//        LogUtils.info(&quot;file imgStr.length:&quot;+imgStr.length());</span><br> <br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="FileConfig文件"><a href="#FileConfig文件" class="headerlink" title="FileConfig文件"></a>FileConfig文件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *Jun 12, 2019</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * FileConfig.java</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;upload&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Order</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileConfig</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String localtion;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String maxFileSize;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String maxRequestSize;    <br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> localtion the localtion to set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocaltion</span><span class="hljs-params">(String localtion)</span> </span>&#123;<br>        FileConfig.localtion = localtion;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxFileSize the maxFileSize to set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMaxFileSize</span><span class="hljs-params">(String maxFileSize)</span> </span>&#123;<br>        FileConfig.maxFileSize = maxFileSize;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maxRequestSize the maxRequestSize to set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMaxRequestSize</span><span class="hljs-params">(String maxRequestSize)</span> </span>&#123;<br>        FileConfig.maxRequestSize = maxRequestSize;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>配置文件类型是yml,大家也可以自己改成properties文件格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">upload: <br>  #localtion: $&#123;UPLOAD_DIR:/home/data/test&#125;<br>  localtion: $&#123;UPLOAD_DIR:D:/test&#125;<br>  maxFileSize: 10240KB <br>  maxRequestSize: 102400KB  <br></code></pre></td></tr></table></figure><h1 id="FileUtil类"><a href="#FileUtil类" class="headerlink" title="FileUtil类"></a>FileUtil类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Path;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.nio.file.attribute.PosixFilePermission;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.zip.ZipEntry;<br><span class="hljs-keyword">import</span> java.util.zip.ZipFile;<br> <br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br> <br><span class="hljs-keyword">import</span> sg.com.mha.ummi.common.util.LogUtils;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUtil</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearFiles</span><span class="hljs-params">(String workspaceRootPath)</span> </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(workspaceRootPath);<br>        deleteFile(file);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFile</span><span class="hljs-params">(File file)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>            <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>                File[] files = file.listFiles();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) &#123;<br>                    deleteFile(files[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        file.delete();<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileWrite</span><span class="hljs-params">(String str, String fileNamePath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileWriter writer = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            File file = <span class="hljs-keyword">new</span> File(fileNamePath);<br>            <span class="hljs-keyword">if</span> (!file.getParentFile().exists()) &#123;<br>                file.getParentFile().mkdirs();<br>                file.createNewFile();<br>            &#125;<br>            writer = <span class="hljs-keyword">new</span> FileWriter(file, <span class="hljs-keyword">true</span>);<br>            writer.write(str + System.getProperty(<span class="hljs-string">&quot;line.separator&quot;</span>));<br> <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            LogUtils.error(e.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (writer != <span class="hljs-keyword">null</span>) &#123;<br>                writer.close();<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changePermission</span><span class="hljs-params">(File dirFile, <span class="hljs-keyword">int</span> mode)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">char</span>[] modes = Integer.toOctalString(mode).toCharArray();<br>        <span class="hljs-keyword">if</span> (modes.length != <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Set&lt;PosixFilePermission&gt; perms = <span class="hljs-keyword">new</span> HashSet&lt;PosixFilePermission&gt;();<br>        <span class="hljs-keyword">switch</span> (modes[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>                perms.add(PosixFilePermission.OWNER_EXECUTE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>                perms.add(PosixFilePermission.OWNER_WRITE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>                perms.add(PosixFilePermission.OWNER_READ);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:<br>                perms.add(PosixFilePermission.OWNER_READ);<br>                perms.add(PosixFilePermission.OWNER_EXECUTE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:<br>                perms.add(PosixFilePermission.OWNER_READ);<br>                perms.add(PosixFilePermission.OWNER_WRITE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:<br>                perms.add(PosixFilePermission.OWNER_READ);<br>                perms.add(PosixFilePermission.OWNER_WRITE);<br>                perms.add(PosixFilePermission.OWNER_EXECUTE);<br>                <span class="hljs-keyword">break</span>;<br> <br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (modes[<span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>                perms.add(PosixFilePermission.GROUP_EXECUTE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>                perms.add(PosixFilePermission.GROUP_WRITE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>                perms.add(PosixFilePermission.GROUP_READ);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:<br>                perms.add(PosixFilePermission.GROUP_READ);<br>                perms.add(PosixFilePermission.GROUP_EXECUTE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:<br>                perms.add(PosixFilePermission.GROUP_READ);<br>                perms.add(PosixFilePermission.GROUP_WRITE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:<br>                perms.add(PosixFilePermission.GROUP_READ);<br>                perms.add(PosixFilePermission.GROUP_WRITE);<br>                perms.add(PosixFilePermission.GROUP_EXECUTE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (modes[<span class="hljs-number">2</span>]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>                perms.add(PosixFilePermission.OTHERS_EXECUTE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>                perms.add(PosixFilePermission.OTHERS_WRITE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>                perms.add(PosixFilePermission.OTHERS_READ);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:<br>                perms.add(PosixFilePermission.OTHERS_EXECUTE);<br>                perms.add(PosixFilePermission.OTHERS_READ);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:<br>                perms.add(PosixFilePermission.OTHERS_READ);<br>                perms.add(PosixFilePermission.OTHERS_WRITE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:<br>                perms.add(PosixFilePermission.OTHERS_EXECUTE);<br>                perms.add(PosixFilePermission.OTHERS_READ);<br>                perms.add(PosixFilePermission.OTHERS_WRITE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">try</span> &#123;<br>            Path path = Paths.get(dirFile.getAbsolutePath());<br>            Files.setPosixFilePermissions(path, perms);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> File <span class="hljs-title">mkFile</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        File f = <span class="hljs-keyword">new</span> File(fileName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (f.exists()) &#123;<br>                f.delete();<br>            &#125;<br>            f.createNewFile();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br> <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyDirAndFile</span><span class="hljs-params">(String oldPath, String newPath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">new</span> File(newPath)).exists()) &#123;<br>            (<span class="hljs-keyword">new</span> File(newPath)).mkdir();<br>        &#125;<br>        File file = <span class="hljs-keyword">new</span> File(oldPath);<br>        <span class="hljs-comment">//file name list</span><br>        String[] filePaths = file.list();<br>        <span class="hljs-keyword">for</span> (String filePath : filePaths) &#123;<br>            String oldFullPath = oldPath + file.separator + filePath;<br>            String newFullPath = newPath + file.separator + filePath;<br>            File oldFile = <span class="hljs-keyword">new</span> File(oldFullPath);<br>            File newFile = <span class="hljs-keyword">new</span> File(newFullPath);<br>            <span class="hljs-keyword">if</span> (oldFile.isDirectory()) &#123;<br>                copyDirAndFile(oldFullPath, newFullPath);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldFile.isFile()) &#123;<br>                copyFile(oldFile, newFile);<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFile</span><span class="hljs-params">(File source, File dest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileChannel inputChannel = <span class="hljs-keyword">null</span>;<br>        FileChannel outputChannel = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputChannel = <span class="hljs-keyword">new</span> FileInputStream(source).getChannel();<br>            outputChannel = <span class="hljs-keyword">new</span> FileOutputStream(dest).getChannel();<br>            outputChannel.transferFrom(inputChannel, <span class="hljs-number">0</span>, inputChannel.size());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            inputChannel.close();<br>            outputChannel.close();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> panchaoyuan</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> srcFile    Unzipped file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> destDirPath   Unzipped destination folder</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RuntimeException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unZip</span><span class="hljs-params">(MultipartFile  srcFile, String destDirPath,String savePath)</span> <span class="hljs-keyword">throws</span> RuntimeException, IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <br>        File file = <span class="hljs-keyword">null</span>;  <br>        InputStream ins = srcFile.getInputStream();  <br>        file=<span class="hljs-keyword">new</span> File(savePath+srcFile.getOriginalFilename()); <br>        LogUtils.info(<span class="hljs-string">&quot;MultipartFile transform to File,MultipartFile name:&quot;</span>+srcFile.getOriginalFilename());<br>        inputStreamToFile(ins, file);  <br>        <br>        <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(file.getPath() + <span class="hljs-string">&quot;,file is not found&quot;</span>);<br>        &#125;<br>        ZipFile zipFile = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zipFile = <span class="hljs-keyword">new</span> ZipFile(file);<br>            Enumeration&lt;?&gt; entries = zipFile.entries();<br>            <span class="hljs-keyword">while</span> (entries.hasMoreElements()) &#123;<br>                ZipEntry entry = (ZipEntry) entries.nextElement();<br>                LogUtils.info(<span class="hljs-string">&quot;zipFile context name:&quot;</span>+entry.getName());<br>                <span class="hljs-keyword">if</span> (entry.isDirectory()) &#123;<br>                    String dirPath = destDirPath + File.separator+ entry.getName();<br>                    File dir = <span class="hljs-keyword">new</span> File(dirPath);<br>                    dir.mkdirs();<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    File targetFile = <span class="hljs-keyword">new</span> File(destDirPath + File.separator + entry.getName());<br>                    targetFile.setExecutable(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">if</span>(!targetFile.getParentFile().exists())&#123;<br>                        targetFile.getParentFile().mkdirs();<br>                    &#125;<br>                    targetFile.createNewFile();<br>                    InputStream is = zipFile.getInputStream(entry);<br>                    FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(targetFile);<br>                    <span class="hljs-keyword">int</span> len;<br>                    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-keyword">while</span> ((len = is.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>                        fos.write(buf, <span class="hljs-number">0</span>, len);<br>                    &#125;<br>                    fos.close();<br>                    is.close();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>            LogUtils.info(<span class="hljs-string">&quot;unZip time--&gt;&quot;</span> + (endTime - startTime) + <span class="hljs-string">&quot; ms&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;unzip error from FileUtil&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(zipFile != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    zipFile.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">//MultipartFile change to file may create a temp file in the project root folder(delete the temp file)</span><br>            File del = <span class="hljs-keyword">new</span> File(file.toURI());  <br>            del.delete(); <br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * MultipartFile changed to File</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> panchaoyuan</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inputStreamToFile</span><span class="hljs-params">(InputStream ins, File file)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            OutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>            <span class="hljs-keyword">int</span> bytesRead = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8192</span>];<br>            <span class="hljs-keyword">while</span> ((bytesRead = ins.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">8192</span>)) != -<span class="hljs-number">1</span>) &#123;<br>                os.write(buffer, <span class="hljs-number">0</span>, bytesRead);<br>            &#125;<br>            os.close();<br>            ins.close();<br>            LogUtils.info(<span class="hljs-string">&quot;MultipartFile transform to File completed!&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br> <br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span> panchaoyuan</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;File&gt; <span class="hljs-title">getSubFiles</span><span class="hljs-params">(String  desFile,List&lt;File&gt; fileList)</span> </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(desFile);<br>        File[] files = file.listFiles();<br>        <span class="hljs-keyword">for</span> (File fileIndex : files) &#123;<br>            <span class="hljs-keyword">if</span> (!fileIndex.exists()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;Cannot find &quot;</span> + fileIndex);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileIndex.isFile()) &#123;<br>                fileList.add(fileIndex);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (fileIndex.isDirectory()) &#123;<br>                    getSubFiles(fileIndex.getAbsolutePath(),fileList);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fileList;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#%E4%B8%80">一</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#%E4%BA%8C">二</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6%E7%9A%84unzip%E6%96%B9%E6%B3%95">解压zip文件的unzip方法</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#inputstreamtofile">inputStreamToFile</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#parseexcelfile">parseExcelFile</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#%E8%A7%A3%E6%9E%90%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95">解析图片的方法</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#fileconfig%E6%96%87%E4%BB%B6">FileConfig文件</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a><a href="https://bk.cuixiaoyan.xyz/archives/jiexi#fileutil%E7%B1%BB">FileUtil类</a></p>]]></content>
    
    
    <categories>
      
      <category>excel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python实现微信头像加国旗</title>
    <link href="/blog/2021/02/17/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F%E5%8A%A0%E5%9B%BD%E6%97%97/"/>
    <url>/blog/2021/02/17/python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F%E5%8A%A0%E5%9B%BD%E6%97%97/</url>
    
    <content type="html"><![CDATA[<p>喜迎国庆,最近到处都是充满这对祖国对祝福,这里身为码农我也很开心。 并不是为了想放假(手动狗头)<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190930-152916@2x_1569828571186.png" alt="WX20190930-152916@2x">代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf8 -*-</span><br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-comment"># 读取头像和国旗图案</span><br>img_head = cv2.imread(<span class="hljs-string">&#x27;/Users/cuixiaoyan/biancheng/python/guoqi/img/touxiang.jpeg&#x27;</span>)<br>img_flag = cv2.imread(<span class="hljs-string">&#x27;/Users/cuixiaoyan/biancheng/python/guoqi/img/guoqi.png&#x27;</span>)<br><span class="hljs-comment"># 获取头像和国旗图案宽度</span><br>w_head, h_head = img_head.shape[:<span class="hljs-number">2</span>]<br>w_flag, h_flag = img_flag.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-comment"># 计算图案缩放比例</span><br>scale = w_head / w_flag / <span class="hljs-number">4</span><br><span class="hljs-comment"># 缩放图案</span><br>img_flag = cv2.resize(img_flag, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), fx=scale, fy=scale)<br><span class="hljs-comment"># 获取缩放后新宽度</span><br>w_flag, h_flag = img_flag.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-comment"># 按3个通道合并图片</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>):<br>    img_head[w_head - w_flag:, h_head - h_flag:, c] = img_flag[:, :, c]<br><span class="hljs-comment"># 保存最终结果 路径可以写为绝对 或者相对</span><br>cv2.imwrite(<span class="hljs-string">&#x27;/Users/cuixiaoyan/biancheng/python/guoqi/img/duang.png&#x27;</span>, img_head)<br></code></pre></td></tr></table></figure><p>祝福祖国永远繁荣昌盛。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>微信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分库分表之后,id主键如何处理</title>
    <link href="/blog/2021/02/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E,id%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <url>/blog/2021/02/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E,id%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>其实这是分库分表之后你必然要面对的一个问题，就是 id 咋生成？因为要是分成多个表之后，每个表都是从 1 开始累加，那肯定不对啊，需要一个全局唯一的 id 来支持。所以这都是你实际生产环境中必须考虑的问题。</strong></p><h1 id="数据库自增-id"><a href="#数据库自增-id" class="headerlink" title="数据库自增 id"></a>数据库自增 id</h1><p>这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。</p><p>这个方案的好处就是方便简单，谁都会用；缺点就是单库生成自增 id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是无论如何都是基于单个数据库。</p><p>适合的场景：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你并发不高，但是数据量太大导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。</p><h1 id="设置数据库-sequence-或者表自增字段步长"><a href="#设置数据库-sequence-或者表自增字段步长" class="headerlink" title="设置数据库 sequence 或者表自增字段步长"></a>设置数据库 sequence 或者表自增字段步长</h1><p>可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。</p><p>比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1756639-20190929231341180-1764461227_1569810079034.jpg" alt="1756639-20190929231341180-1764461227">适合的场景：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p><h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><p>好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p><p>适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">UUID.randomUUID().toString().replace(“-”, “”) -&gt; sfsdf23423rr234sfdaf<br> <br></code></pre></td></tr></table></figure><h1 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h1><p>这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。基本就不用考虑了。</p><p>适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p><h1 id="snowflake-算法"><a href="#snowflake-算法" class="headerlink" title="snowflake 算法"></a>snowflake 算法</h1><p>snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p><ol><li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li><li>41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示69年的时间。</li><li>10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 2^5个机房（32个机房），每个机房里可以代表 2^5 个机器（32台机器）。</li><li>12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 2^12 - 1 = 4096，也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdWorker</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> datacenterId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdWorker</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId, <span class="hljs-keyword">long</span> datacenterId, <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>        <span class="hljs-comment">// sanity check for workerId</span><br>        <span class="hljs-comment">// 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0</span><br>        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    String.format(<span class="hljs-string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    String.format(<span class="hljs-string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));<br>        &#125;<br>        System.out.printf(<br>                <span class="hljs-string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,<br>                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);<br> <br>        <span class="hljs-keyword">this</span>.workerId = workerId;<br>        <span class="hljs-keyword">this</span>.datacenterId = datacenterId;<br>        <span class="hljs-keyword">this</span>.sequence = sequence;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> twepoch = <span class="hljs-number">1288834974657L</span>;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerIdBits = <span class="hljs-number">5L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> datacenterIdBits = <span class="hljs-number">5L</span>;<br> <br>    <span class="hljs-comment">// 这个是二进制运算，就是 5 bit最多只能有31个数字，也就是说机器id最多只能是32以内</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> maxWorkerId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);<br> <br>    <span class="hljs-comment">// 这个是一个意思，就是 5 bit最多只能有31个数字，机房id最多只能是32以内</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> maxDatacenterId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; datacenterIdBits);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequenceBits = <span class="hljs-number">12L</span>;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerIdShift = sequenceBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequenceMask = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTimestamp = -<span class="hljs-number">1L</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getWorkerId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> workerId;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDatacenterId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> datacenterId;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTimestamp</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 这儿就是获取当前时间戳，单位是毫秒</span><br>        <span class="hljs-keyword">long</span> timestamp = timeGen();<br> <br>        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(String.format(<br>                    <span class="hljs-string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;<br>            <span class="hljs-comment">// 这个意思是说一个毫秒内最多只能有4096个数字</span><br>            <span class="hljs-comment">// 无论你传递多少进来，这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span><br>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>                timestamp = tilNextMillis(lastTimestamp);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sequence = <span class="hljs-number">0</span>;<br>        &#125;<br> <br>        <span class="hljs-comment">// 这儿记录一下最近一次生成id的时间戳，单位是毫秒</span><br>        lastTimestamp = timestamp;<br> <br>        <span class="hljs-comment">// 这儿就是将时间戳左移，放到 41 bit那儿；</span><br>        <span class="hljs-comment">// 将机房 id左移放到 5 bit那儿；</span><br>        <span class="hljs-comment">// 将机器id左移放到5 bit那儿；将序号放最后12 bit；</span><br>        <span class="hljs-comment">// 最后拼接起来成一个 64 bit的二进制数字，转换成 10 进制就是个 long 型</span><br>        <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift)<br>                | (workerId &lt;&lt; workerIdShift) | sequence;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">tilNextMillis</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lastTimestamp)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> timestamp = timeGen();<br>        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;<br>            timestamp = timeGen();<br>        &#125;<br>        <span class="hljs-keyword">return</span> timestamp;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">timeGen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br> <br>    <span class="hljs-comment">// ---------------测试---------------</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IdWorker worker = <span class="hljs-keyword">new</span> IdWorker(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(worker.nextId());<br>        &#125;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个机房 id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的机器 id（但是最大只能是 32 以内），剩下的那个 12 bit序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。</p><p>所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。</p><p>利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。</p><p>这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具类</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎么快速插100条数据用时最短</title>
    <link href="/blog/2021/02/12/%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E6%8F%92100%E6%9D%A1%E6%95%B0%E6%8D%AE%E7%94%A8%E6%97%B6%E6%9C%80%E7%9F%AD/"/>
    <url>/blog/2021/02/12/%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E6%8F%92100%E6%9D%A1%E6%95%B0%E6%8D%AE%E7%94%A8%E6%97%B6%E6%9C%80%E7%9F%AD/</url>
    
    <content type="html"><![CDATA[<p>问：为何对同一个表的插入多线程会比单线程快？同一时间对一个表的写操作不应该是独占的吗？ 答：在数据里做插入操作的时候，整体时间的分配是这样的：</p><ol><li>链接耗时 （30%）</li><li>发送query到服务器 （20%）</li><li>解析query （20%）</li><li>插入操作 （10% * 词条数目）</li><li>插入index （10% * Index的数目）</li><li>关闭链接 （10%） 从这里可以看出来，真正耗时的不是操作，而是链接，解析的过程。 MySQL插入数据在写阶段是独占的，但是插入一条数据仍然需要解析、计算、最后才进行写处理，比如要给每一条记录分配自增id，校验主键唯一键属性，或者其他一些逻辑处理，都是需要计算的，所以说多线程能够提高效率。 多线程插入(多表) 分区分表后使用多线程插入。 预处理SQL</li><li>普通SQL，即使用Statement接口执行SQL</li><li>预处理SQL，即使用PreparedStatement接口执行SQL 使用PreparedStatement接口允许数据库预编译SQL语句，以后只需传入参数，避免了数据库每次都编译SQL语句，因此性能更好。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">String sql = <span class="hljs-string">&quot;insert into testdb.tuser (name, remark, createtime, updatetime) values (?, ?, ?, ?)&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-comment">//从池中获取连接</span><br>    Connection conn = myBroker.getConnection();<br>    PreparedStatement pstmt = conn.prepareStatement(sql);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>            pstmt.setString(<span class="hljs-number">1</span>, RandomToolkit.generateString(<span class="hljs-number">12</span>));<br>            pstmt.setString(<span class="hljs-number">2</span>, RandomToolkit.generateString(<span class="hljs-number">24</span>));<br>            pstmt.setDate(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> Date(System.currentTimeMillis()));<br>            pstmt.setDate(<span class="hljs-number">4</span>, <span class="hljs-keyword">new</span> Date(System.currentTimeMillis()));<br>            <span class="hljs-comment">//加入批处理</span><br>            pstmt.addBatch();<br>    &#125;<br>    pstmt.executeBatch();    <span class="hljs-comment">//执行批处理</span><br>    pstmt.close();<br>    myBroker.freeConnection(conn); <span class="hljs-comment">//连接归池</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多值插入SQL</strong></p><ol><li>普通插入SQL：INSERT INTO TBL_TEST (id) VALUES(1)</li><li>多值插入SQL：INSERT INTO TBL_TEST (id) VALUES (1), (2), (3) 使用多值插入SQL，SQL语句的总长度减少，即减少了网络IO，同时也降低了连接次数，数据库一次SQL解析，能够插入多条数据。 <strong>事务(N条提交一次)</strong> 在一个事务中提交大量INSERT语句可以提高性能。</li><li>将表的存储引擎修改为myisam</li><li>将 sql 拼接成字符串，每 1000 条左右提交事务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/// &lt;summary&gt;</span><br>        <span class="hljs-comment">/// 执行多条SQL语句，实现数据库事务。</span><br>        <span class="hljs-comment">/// &lt;/summary&gt;mysql数据库</span><br>        <span class="hljs-comment">/// &lt;param name=&quot;SQLStringList&quot;&gt;多条SQL语句&lt;/param&gt;</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExecuteSqlTran</span><span class="hljs-params">(List&lt;string&gt; SQLStringList)</span></span><br><span class="hljs-function">        </span>&#123;<br>            using (MySqlConnection conn = <span class="hljs-keyword">new</span> MySqlConnection(connectionString))<br>            &#123;<br>                <span class="hljs-keyword">if</span> (DBVariable.flag)<br>                &#123;<br>                    conn.Open();<br>                    MySqlCommand cmd = <span class="hljs-keyword">new</span> MySqlCommand();<br>                    cmd.Connection = conn;<br>                    MySqlTransaction tx = conn.BeginTransaction();<br>                    cmd.Transaction = tx;<br>                    <span class="hljs-keyword">try</span><br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; SQLStringList.Count; n++)<br>                        &#123;<br>                            string strsql = SQLStringList[n].ToString();<br>                            <span class="hljs-keyword">if</span> (strsql.Trim().Length &gt; <span class="hljs-number">1</span>)<br>                            &#123;<br>                                cmd.CommandText = strsql;<br>                                cmd.ExecuteNonQuery();<br>                            &#125;<br>                            <span class="hljs-comment">//后来加上的</span><br>                            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span> &amp;&amp; (n % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span> || n == SQLStringList.Count - <span class="hljs-number">1</span>))<br>                            &#123;<br>                                tx.Commit();<br>                                tx = conn.BeginTransaction();<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">//tx.Commit();//原来一次性提交</span><br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (System.Data.SqlClient.SqlException E)<br>                    &#123;<br>                        tx.Rollback();<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(E.Message);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>10w条数据大概用时10s！</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将map按照值排序</title>
    <link href="/blog/2021/02/12/%E5%B0%86map%E6%8C%89%E7%85%A7%E5%80%BC%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2021/02/12/%E5%B0%86map%E6%8C%89%E7%85%A7%E5%80%BC%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>值里面存放的是一个对象需要根据id排序 将相同的人放在一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Map.Entry&lt;String, CorrectRate&gt;&gt; list =<br>               <span class="hljs-keyword">new</span> LinkedList&lt;Map.Entry&lt;String, CorrectRate&gt;&gt;(correctRateOm.entrySet());<br>       Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;String, CorrectRate&gt;&gt;() &#123;<br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;String, CorrectRate&gt; o1, Map.Entry&lt;String, CorrectRate&gt; o2)</span> </span>&#123;<br>               <span class="hljs-keyword">return</span> (o1.getValue().getStudentId()).compareTo(o2.getValue().getStudentId());<br>           &#125;<br>       &#125;);<br></code></pre></td></tr></table></figure><h1 id="list集合分页"><a href="#list集合分页" class="headerlink" title="list集合分页"></a>list集合分页</h1><p>java对list进行分页 <strong>业务场景因为数据是通过从数据库中多次sql查出来之后存放到list 无法使用sql进行分页</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.unote.echarts.entity;<br> <br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: unote</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: list分页工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: cuixy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2019-09-27 09:37</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageModel</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> page = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前页</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> totalPages = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总页数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pageRecorders;<span class="hljs-comment">// 每页5条数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalRows = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总数据数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pageStartRow = <span class="hljs-number">0</span>;<span class="hljs-comment">// 每页的起始数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pageEndRow = <span class="hljs-number">0</span>; <span class="hljs-comment">// 每页显示数据的终止数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> hasNextPage = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 是否有下一页</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> hasPreviousPage = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 是否有前一页</span><br>    <span class="hljs-keyword">private</span> List list;<br> <br>    <span class="hljs-comment">// private Iterator it;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageModel</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> pageRecorders)</span> </span>&#123;<br>        init(list, pageRecorders);<span class="hljs-comment">// 通过对象集，记录总数划分</span><br>    &#125;<br> <br>    <span class="hljs-comment">/** */</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化list，并告之该list每页的记录数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageRecorders</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> pageRecorders)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pageRecorders = pageRecorders;<br>        <span class="hljs-keyword">this</span>.list = list;<br>        totalRows = list.size();<br>        <span class="hljs-comment">// it = list.iterator();</span><br>        hasPreviousPage = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> ((totalRows % pageRecorders) == <span class="hljs-number">0</span>) &#123;<br>            totalPages = totalRows / pageRecorders;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            totalPages = totalRows / pageRecorders + <span class="hljs-number">1</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (page &gt;= totalPages) &#123;<br>            hasNextPage = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hasNextPage = <span class="hljs-keyword">true</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (totalRows &lt; pageRecorders) &#123;<br>            <span class="hljs-keyword">this</span>.pageStartRow = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.pageEndRow = totalRows;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.pageStartRow = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>.pageEndRow = pageRecorders;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// 判断要不要分页</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.size() &gt; <span class="hljs-number">5</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHasPreviousPage</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasPreviousPage)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hasPreviousPage = hasPreviousPage;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> temp)</span> </span>&#123;<br>        String str = Integer.toString(temp);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">description</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        String description = <span class="hljs-string">&quot;共有数据数:&quot;</span> + <span class="hljs-keyword">this</span>.getTotalRows()<br>                + <span class="hljs-string">&quot;共有页数: &quot;</span> + <span class="hljs-keyword">this</span>.getTotalPages()<br>                + <span class="hljs-string">&quot;当前页数为:&quot;</span> + <span class="hljs-keyword">this</span>.getPage()<br>                + <span class="hljs-string">&quot; 是否有前一页: &quot;</span> + <span class="hljs-keyword">this</span>.isHasPreviousPage()<br>                + <span class="hljs-string">&quot; 是否有下一页:&quot;</span> + <span class="hljs-keyword">this</span>.isHasNextPage()<br>                + <span class="hljs-string">&quot; 开始行数:&quot;</span> + <span class="hljs-keyword">this</span>.getPageStartRow()<br>                + <span class="hljs-string">&quot; 终止行数:&quot;</span> + <span class="hljs-keyword">this</span>.getPageEndRow();<br> <br>        System.out.println(description);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getNextPage</span><span class="hljs-params">()</span> </span>&#123;<br>        page = page + <span class="hljs-number">1</span>;<br> <br>        disposePage();<br> <br>        System.out.println(<span class="hljs-string">&quot;用户凋用的是第&quot;</span> + page + <span class="hljs-string">&quot;页&quot;</span>);<br>        <span class="hljs-keyword">this</span>.description();<br>        <span class="hljs-keyword">return</span> getObjects(page);<br>    &#125;<br> <br>    <span class="hljs-comment">/** */</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理分页</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disposePage</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        <span class="hljs-keyword">if</span> (page == <span class="hljs-number">0</span>) &#123;<br>            page = <span class="hljs-number">1</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> ((page - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            hasPreviousPage = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hasPreviousPage = <span class="hljs-keyword">false</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (page &gt;= totalPages) &#123;<br>            hasNextPage = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hasNextPage = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getPreviousPage</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        page = page - <span class="hljs-number">1</span>;<br> <br>        <span class="hljs-keyword">if</span> ((page - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            hasPreviousPage = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hasPreviousPage = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (page &gt;= totalPages) &#123;<br>            hasNextPage = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hasNextPage = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.description();<br>        <span class="hljs-keyword">return</span> getObjects(page);<br>    &#125;<br> <br>    <span class="hljs-comment">/** */</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第几页的内容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getObjects</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (page == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.setPage(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.setPage(page);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.disposePage();<br>        <span class="hljs-keyword">if</span> (page * pageRecorders &lt; totalRows) &#123;<span class="hljs-comment">// 判断是否为最后一页</span><br>            pageEndRow = page * pageRecorders;<br>            pageStartRow = pageEndRow - pageRecorders;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pageEndRow = totalRows;<br>            pageStartRow = pageRecorders * (totalPages - <span class="hljs-number">1</span>);<br>        &#125;<br> <br>        List objects = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (!list.isEmpty()) &#123;<br>            objects = list.subList(pageStartRow, pageEndRow);<br>        &#125;<br>        <span class="hljs-comment">//this.description();</span><br>        <span class="hljs-keyword">return</span> objects;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getFistPage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isNext()) &#123;<br>            <span class="hljs-keyword">return</span> list.subList(<span class="hljs-number">0</span>, pageRecorders);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHasNextPage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hasNextPage;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHasNextPage</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasNextPage)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hasNextPage = hasNextPage;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setList</span><span class="hljs-params">(List list)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list = list;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.page = page;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPageEndRow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pageEndRow;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPageEndRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageEndRow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pageEndRow = pageEndRow;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPageRecorders</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pageRecorders;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPageRecorders</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageRecorders)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pageRecorders = pageRecorders;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPageStartRow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pageStartRow;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPageStartRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageStartRow)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pageStartRow = pageStartRow;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTotalPages</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> totalPages;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalPages</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalPages)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalPages = totalPages;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTotalRows</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> totalRows;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalRows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalRows)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalRows = totalRows;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHasPreviousPage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hasPreviousPage;<br>    &#125;<br> <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">PageModel pm = <span class="hljs-keyword">new</span> PageModel(list, Integer.parseInt(page_size));<span class="hljs-comment">//每页显示条数</span><br> <br>List sublist = pm.getObjects(Integer.parseInt(page_no));<span class="hljs-comment">//显示第几页</span><br> <br> <br>data.put(<span class="hljs-string">&quot;list&quot;</span>, sublist);<br>data.put(<span class="hljs-string">&quot;total_count&quot;</span>, list.size());<br>data.put(<span class="hljs-string">&quot;page_no&quot;</span>, Integer.parseInt(page_no));<br>data.put(<span class="hljs-string">&quot;page_size&quot;</span>, Integer.parseInt(page_size));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取map对象中的最大最小值</title>
    <link href="/blog/2021/02/07/%E8%8E%B7%E5%8F%96map%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/blog/2021/02/07/%E8%8E%B7%E5%8F%96map%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>遇到的问题是获取map中的最高成绩和最低成绩 xxx.entrySet() 这里放的你的map</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WechatIMG96_1569388966080.png" alt="WechatIMG96">两种方式</p><h1 id="1-8后"><a href="#1-8后" class="headerlink" title="1.8后"></a>1.8后</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Map.Entry&lt;String, CorrectRate&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList(correctRateOm.entrySet());<br>Collections.sort(list, (o1, o2) -&gt; (o1.getValue().getScore().intValue() - o2.getValue().getScore().intValue()));<br>        <br>Double minScore = list.get(<span class="hljs-number">0</span>).getValue().getScore();<br> <br>List&lt;Map.Entry&lt;String, CorrectRate&gt;&gt; list1 = <span class="hljs-keyword">new</span> ArrayList(correctRateOm.entrySet());<br>Collections.sort(list1, (o1, o2) -&gt; (o2.getValue().getScore().intValue()) - o1.getValue().getScore().intValue());<br> <br>Double maxScore = list1.get(<span class="hljs-number">0</span>).getValue().getScore();<br></code></pre></td></tr></table></figure><h1 id="1-8前"><a href="#1-8前" class="headerlink" title="1.8前"></a>1.8前</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最大值</span><br>               List&lt;Map.Entry&lt;String, CorrectRate&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList(correctRateOm.entrySet());<br>               Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;String, CorrectRate&gt;&gt;() &#123;<br>                           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;String, CorrectRate&gt; o1, Map.Entry&lt;String, CorrectRate&gt; o2)</span> </span>&#123;<br>                               <span class="hljs-keyword">return</span> (o2.getValue().getScore().intValue() - o1.getValue().getScore().intValue());<br>                           &#125;<br>                       &#125;<br>               );<br>Double maxScore = list.get(<span class="hljs-number">0</span>).getValue().getScore();<br><br>               <span class="hljs-comment">//最小值</span><br>               List&lt;Map.Entry&lt;String, CorrectRate&gt;&gt; list1 = <span class="hljs-keyword">new</span> ArrayList(correctRateOm1.entrySet());<br>               Collections.sort(list1, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;String, CorrectRate&gt;&gt;() &#123;<br>                           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;String, CorrectRate&gt; o1, Map.Entry&lt;String, CorrectRate&gt; o2)</span> </span>&#123;<br>                               <span class="hljs-keyword">return</span> (o1.getValue().getScore().intValue() - o2.getValue().getScore().intValue());<br>                           &#125;<br>                       &#125;<br>               );<br>Double minScore = list1.get(<span class="hljs-number">0</span>).getValue().getScore();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合RabbitMQ</title>
    <link href="/blog/2021/02/06/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/"/>
    <url>/blog/2021/02/06/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h1 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.rabbitmq.host=<span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.71</span><br>spring.rabbitmq.port=<span class="hljs-number">5672</span><br>spring.rabbitmq.username=light<br>spring.rabbitmq.password=light<br>spring.rabbitmq.virtual-host=/test<br></code></pre></td></tr></table></figure><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmqpConfirguration</span> </span>&#123;<br> <br>  <span class="hljs-comment">//=============简单、工作队列模式===============</span><br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SIMPLE_QUEUE = <span class="hljs-string">&quot;simple_queue&quot;</span>;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SIMPLE_QUEUE, <span class="hljs-keyword">true</span>);<br>  &#125;<br> <br>  <span class="hljs-comment">//===============发布/订阅模式============</span><br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PS_QUEUE_1 = <span class="hljs-string">&quot;ps_queue_1&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PS_QUEUE_2 = <span class="hljs-string">&quot;ps_queue_2&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_EXCHANGE = <span class="hljs-string">&quot;fanout_exchange&quot;</span>;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">psQueue1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(PS_QUEUE_1, <span class="hljs-keyword">true</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">psQueue2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(PS_QUEUE_2, <span class="hljs-keyword">true</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">fanoutBinding1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(psQueue1()).to(fanoutExchange());<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">fanoutBinding2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(psQueue2()).to(fanoutExchange());<br>  &#125;<br> <br>  <span class="hljs-comment">//===============路由模式============</span><br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTING_QUEUE_1 = <span class="hljs-string">&quot;routing_queue_1&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTING_QUEUE_2 = <span class="hljs-string">&quot;routing_queue_2&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_EXCHANGE = <span class="hljs-string">&quot;direct_exchange&quot;</span>;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">routingQueue1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(ROUTING_QUEUE_1, <span class="hljs-keyword">true</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">routingQueue2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(ROUTING_QUEUE_2, <span class="hljs-keyword">true</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DIRECT_EXCHANGE);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">directBinding1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(routingQueue1()).to(directExchange()).with(<span class="hljs-string">&quot;user&quot;</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">directBinding2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(routingQueue2()).to(directExchange()).with(<span class="hljs-string">&quot;order&quot;</span>);<br>  &#125;<br> <br>  <span class="hljs-comment">//===============主题模式============</span><br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE_1 = <span class="hljs-string">&quot;topic_queue_1&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE_2 = <span class="hljs-string">&quot;topic_queue_2&quot;</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_EXCHANGE = <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">topicQueue1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(TOPIC_QUEUE_1, <span class="hljs-keyword">true</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">topicQueue2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(TOPIC_QUEUE_2, <span class="hljs-keyword">true</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TopicExchange(TOPIC_EXCHANGE);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">topicBinding1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(<span class="hljs-string">&quot;user.add&quot;</span>);<br>  &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">topicBinding2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(<span class="hljs-string">&quot;user.#&quot;</span>);<br>  &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息生产者："><a href="#消息生产者：" class="headerlink" title="消息生产者："></a>消息生产者：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmqpSender</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 简单模式发送</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleSend</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(AmqpConfirguration.SIMPLE_QUEUE, message);<br>  &#125;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 发布/订阅模式发送</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">psSend</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(AmqpConfirguration.FANOUT_EXCHANGE, <span class="hljs-string">&quot;&quot;</span>, message);<br>  &#125;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 路由模式发送</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">routingSend</span><span class="hljs-params">(String routingKey, String message)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(AmqpConfirguration.DIRECT_EXCHANGE, routingKey, message);<br>  &#125;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 主题模式发送</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> routingKey</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topicSend</span><span class="hljs-params">(String routingKey, String message)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(AmqpConfirguration.TOPIC_EXCHANGE, routingKey, message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息消费者："><a href="#消息消费者：" class="headerlink" title="消息消费者："></a>消息消费者：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmqpReceiver</span> </span>&#123;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 简单模式接收</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@RabbitListener(queues = AmqpConfirguration.SIMPLE_QUEUE)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleReceive</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接收消息:&quot;</span> + message);<br>  &#125;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 发布/订阅模式接收</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@RabbitListener(queues = AmqpConfirguration.PS_QUEUE_1)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">psReceive1</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(AmqpConfirguration.PS_QUEUE_1 + <span class="hljs-string">&quot;接收消息:&quot;</span> + message);<br>  &#125;<br> <br>  <span class="hljs-meta">@RabbitListener(queues = AmqpConfirguration.PS_QUEUE_2)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">psReceive2</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(AmqpConfirguration.PS_QUEUE_2 + <span class="hljs-string">&quot;接收消息:&quot;</span> + message);<br>  &#125;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 路由模式接收</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@RabbitListener(queues = AmqpConfirguration.ROUTING_QUEUE_1)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">routingReceive1</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(AmqpConfirguration.ROUTING_QUEUE_1 + <span class="hljs-string">&quot;接收消息:&quot;</span> + message);<br>  &#125;<br> <br>  <span class="hljs-meta">@RabbitListener(queues = AmqpConfirguration.ROUTING_QUEUE_2)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">routingReceive2</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(AmqpConfirguration.ROUTING_QUEUE_2 + <span class="hljs-string">&quot;接收消息:&quot;</span> + message);<br>  &#125;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 主题模式接收</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@RabbitListener(queues = AmqpConfirguration.TOPIC_QUEUE_1)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topicReceive1</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(AmqpConfirguration.TOPIC_QUEUE_1 + <span class="hljs-string">&quot;接收消息:&quot;</span> + message);<br>  &#125;<br> <br>  <span class="hljs-meta">@RabbitListener(queues = AmqpConfirguration.TOPIC_QUEUE_2)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topicReceive2</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(AmqpConfirguration.TOPIC_QUEUE_2 + <span class="hljs-string">&quot;接收消息:&quot;</span> + message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消息消费者使用 @RabbitListener 注解监听消息。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmqpTest</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> AmqpSender sender;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSimpleSend</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>      <span class="hljs-keyword">this</span>.sender.simpleSend(<span class="hljs-string">&quot;test simpleSend &quot;</span> + i);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPsSend</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>      <span class="hljs-keyword">this</span>.sender.psSend(<span class="hljs-string">&quot;test psSend &quot;</span> + i);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRoutingSend</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>      <span class="hljs-keyword">this</span>.sender.routingSend(<span class="hljs-string">&quot;order&quot;</span>, <span class="hljs-string">&quot;test routingSend &quot;</span> + i);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTopicSend</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>      <span class="hljs-keyword">this</span>.sender.topicSend(<span class="hljs-string">&quot;user.add&quot;</span>, <span class="hljs-string">&quot;test topicSend &quot;</span> + i);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合ActiveMQ</title>
    <link href="/blog/2021/02/06/SpringBoot%E6%95%B4%E5%90%88ActiveMQ/"/>
    <url>/blog/2021/02/06/SpringBoot%E6%95%B4%E5%90%88ActiveMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- 如果需要配置连接池，添加如下依赖 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;<br>    &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h1 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"># activemq 配置<br>spring.activemq.broker-url=tcp:<span class="hljs-comment">//192.168.2.61:61616</span><br>spring.activemq.user=admin<br>spring.activemq.password=admin<br>spring.activemq.pool.enabled=<span class="hljs-keyword">false</span><br>spring.activemq.pool.max-connections=<span class="hljs-number">50</span><br># 使用发布/订阅模式时，下边配置需要设置成 true<br>spring.jms.pub-sub-domain=<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p>此处 spring.activemq.pool.enabled=false，表示关闭连接池。</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JmsConfirguration</span> </span>&#123;<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;activemq_queue&quot;</span>;<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_NAME = <span class="hljs-string">&quot;activemq_topic&quot;</span>;<br> <br>  <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveMQQueue(QUEUE_NAME);<br>    &#125;<br> <br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Topic <span class="hljs-title">topic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveMQTopic(TOPIC_NAME);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JmsSender</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> Queue queue;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> Topic topic;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> JmsMessagingTemplate jmsTemplate;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendByQueue</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.jmsTemplate.convertAndSend(queue, message);<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendByTopic</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.jmsTemplate.convertAndSend(topic, message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JmsReceiver</span> </span>&#123;<br> <br>  <span class="hljs-meta">@JmsListener(destination = JmsConfirguration.QUEUE_NAME)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveByQueue</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接收队列消息:&quot;</span> + message);<br>  &#125;<br> <br>  <span class="hljs-meta">@JmsListener(destination = JmsConfirguration.TOPIC_NAME)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveByTopic</span><span class="hljs-params">(String message)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接收主题消息:&quot;</span> + message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消息消费者使用 @JmsListener 注解监听消息。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JmsTest</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> JmsSender sender;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendByQueue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>      <span class="hljs-keyword">this</span>.sender.sendByQueue(<span class="hljs-string">&quot;hello activemq queue &quot;</span> + i);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendByTopic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>      <span class="hljs-keyword">this</span>.sender.sendByTopic(<span class="hljs-string">&quot;hello activemq topic &quot;</span> + i);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="打印结果："><a href="#打印结果：" class="headerlink" title="打印结果："></a>打印结果：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">接收队列消息:hello activemq queue <span class="hljs-number">1</span><br>接收队列消息:hello activemq queue <span class="hljs-number">2</span><br>接收队列消息:hello activemq queue <span class="hljs-number">3</span><br>接收队列消息:hello activemq queue <span class="hljs-number">4</span><br>接收队列消息:hello activemq queue <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h1 id="测试发布-订阅模式时"><a href="#测试发布-订阅模式时" class="headerlink" title="测试发布/订阅模式时"></a>测试发布/订阅模式时</h1><p>设置 spring.jms.pub-sub-domain=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">接收主题消息:hello activemq topic <span class="hljs-number">1</span><br>接收主题消息:hello activemq topic <span class="hljs-number">2</span><br>接收主题消息:hello activemq topic <span class="hljs-number">3</span><br>接收主题消息:hello activemq topic <span class="hljs-number">4</span><br>接收主题消息:hello activemq topic <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>ActiveMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea将项目提交到github上</title>
    <link href="/blog/2021/02/06/idea%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E5%88%B0github%E4%B8%8A/"/>
    <url>/blog/2021/02/06/idea%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E5%88%B0github%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>首先区分git 和 github 是不一样的, github 和 码云是一样的。 我的文字表达确实差 所以一图胜万语千言</p><h1 id="配置本地"><a href="#配置本地" class="headerlink" title="配置本地"></a>配置本地</h1><p>先把他放到本地git 本地想必大家都已经安装好了 没有安装的话百度一下 然后选择整个项目的文件夹 然后项目会变成红色<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190924-133614@2x_1569303820807.png" alt="WX20190924-133614@2x"></p><h1 id="上传本地"><a href="#上传本地" class="headerlink" title="上传本地"></a>上传本地</h1><p>右键项目 add之后 文件都会变成绿色 然后在提交项目就没颜色了<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190924-133704@2x_1569303820892.png" alt="WX20190924-133704@2x"></p><h1 id="上传到GitHub"><a href="#上传到GitHub" class="headerlink" title="上传到GitHub"></a>上传到GitHub</h1><p>这里输入备注 就会提交到GitHub 可以自定义名字我这里使用的就是项目的名字<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190924-133818@2x_1569303820981.png" alt="WX20190924-133818@2x"></p><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190924-134320@2x_1569303820947.png" alt="WX20190924-134320@2x">#两者区分 一般上先上传到本地 然后再右键push<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190924-133901@2x_1569303821043.png" alt="WX20190924-133901@2x"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="/blog/2021/02/05/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
    <url>/blog/2021/02/05/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
    
    <content type="html"><![CDATA[<p>Spring Data Redis 为我们提供 RedisTemplate 和 StringRedisTemplate 两个模板进行数据操作，它们主要 的访问方法如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190919-173422@2x_1568885674306.png" alt="WX20190919-173422@2x"></p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h1 id="配置连接"><a href="#配置连接" class="headerlink" title="配置连接"></a>配置连接</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.redis.host=<span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.11</span><br>spring.redis.port=<span class="hljs-number">6379</span><br>spring.redis.password=redis123<br></code></pre></td></tr></table></figure><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDao</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.stringRedisTemplate.opsForValue().set(key, value);<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stringRedisTemplate.opsForValue().get(key);<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.stringRedisTemplate.delete(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDaoTest</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedisDao redisDao;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">()</span> </span>&#123;<br>    String key = <span class="hljs-string">&quot;name&quot;</span>;<br>    String value = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br> <br>    <span class="hljs-keyword">this</span>.redisDao.set(key, value);<br>  &#125;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> </span>&#123;<br>    String key = <span class="hljs-string">&quot;name&quot;</span>;<br>    String value = <span class="hljs-keyword">this</span>.redisDao.get(key);<br>    System.out.println(value);<br>  &#125;<br> <br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>    String key = <span class="hljs-string">&quot;name&quot;</span>;<br>    <span class="hljs-keyword">this</span>.redisDao.delete(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot配置EhCache缓存</title>
    <link href="/blog/2021/02/05/SpringBoot%E9%85%8D%E7%BD%AEEhCache%E7%BC%93%E5%AD%98/"/>
    <url>/blog/2021/02/05/SpringBoot%E9%85%8D%E7%BD%AEEhCache%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;dependency&gt;<br>  &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;<br>  &lt;artifactId&gt;ehcache&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h1 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h1><p>在 src/main/resources 目录下创建 ehcache.xml 文件，内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;ehcache xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>         xsi:noNamespaceSchemaLocation=<span class="hljs-string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;<br> <br>    &lt;!-- 磁盘缓存位置 --&gt;<br>    &lt;diskStore path=<span class="hljs-string">&quot;java.io.tmpdir/ehcache&quot;</span>/&gt;<br> <br>    &lt;!-- 默认缓存 --&gt;<br>    &lt;defaultCache<br>            maxEntriesLocalHeap=<span class="hljs-string">&quot;10000&quot;</span><br>            eternal=<span class="hljs-string">&quot;false&quot;</span><br>            timeToIdleSeconds=<span class="hljs-string">&quot;120&quot;</span><br>            timeToLiveSeconds=<span class="hljs-string">&quot;120&quot;</span><br>            maxEntriesLocalDisk=<span class="hljs-string">&quot;10000000&quot;</span><br>            diskExpiryThreadIntervalSeconds=<span class="hljs-string">&quot;120&quot;</span><br>            memoryStoreEvictionPolicy=<span class="hljs-string">&quot;LRU&quot;</span>&gt;<br>        &lt;persistence strategy=<span class="hljs-string">&quot;localTempSwap&quot;</span>/&gt;<br>    &lt;/defaultCache&gt;<br> <br>    &lt;!-- 自定义缓存 --&gt;<br>    &lt;cache name=<span class="hljs-string">&quot;department&quot;</span><br>           maxElementsInMemory=<span class="hljs-string">&quot;1000&quot;</span><br>           eternal=<span class="hljs-string">&quot;false&quot;</span><br>           timeToIdleSeconds=<span class="hljs-string">&quot;50&quot;</span><br>           timeToLiveSeconds=<span class="hljs-string">&quot;50&quot;</span><br>           overflowToDisk=<span class="hljs-string">&quot;false&quot;</span><br>           memoryStoreEvictionPolicy=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;<br>&lt;/ehcache&gt;<br></code></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">name：Cache 的唯一标识<br>maxElementsInMemory：内存中允许存储的最大的元素个数<br>maxElementsOnDisk：硬盘最大缓存个数，<span class="hljs-number">0</span>代表无限个<br>clearOnFlush：内存数量最大时是否清除<br>eternal：缓存对象是否永久有效，如果是，超时设置将被忽略<br>overflowToDisk：内存不足（超过 maxElementsInMemory）时，是否启用磁盘缓存<br>timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=<span class="hljs-keyword">false</span>对象不是永久有效时使用，可选属性，默认值是<span class="hljs-number">0</span>，也就是可闲置时间无穷大<br>timeToLiveSeconds：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是<span class="hljs-number">0</span>就意味着元素可以停顿无穷长的时间<br>diskPersistent：是否将缓存数据持久化到磁盘上，如果为 <span class="hljs-keyword">true</span>，JVM 重启数据依然存在。默认值是<span class="hljs-keyword">false</span><br>diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区<br>diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是<span class="hljs-number">120</span>秒<br>memoryStoreEvictionPolicy：当达到 maxElementsInMemory 限制时，Ehcache 将根据指定策略清除内存。默认为 LRU（最近最少使用），其他策略有 FIFO（先进先出），LFU（较少使用）<br></code></pre></td></tr></table></figure><h1 id="application-properties-："><a href="#application-properties-：" class="headerlink" title="application.properties ："></a>application.properties ：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"># 缓存类型（ehcache、redis）<br>spring.cache.type=ehcache<br> <br># ehcache 配置文件<br>spring.cache.ehcache.config=classpath:ehcache.xml<br> <br># 打印日志，查看 sql<br>logging.level.com.light.springboot=DEBUG<br></code></pre></td></tr></table></figure><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>在持久层篇的基础上，结合 Mybatis 测试：</p><p>Service 层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheConfig(cacheNames = &quot;department&quot;)</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentService</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> DepartmentMapper departmentMapper;<br> <br>  <span class="hljs-meta">@CachePut(key = &quot;#department.id&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">save</span><span class="hljs-params">(Department department)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;保存 id=&quot;</span> + department.getId() + <span class="hljs-string">&quot; 的数据&quot;</span>);<br>    <span class="hljs-keyword">this</span>.departmentMapper.insert(department);<br>    <span class="hljs-keyword">return</span> department;<br>  &#125;<br> <br>  <span class="hljs-meta">@CachePut(key = &quot;#department.id&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">update</span><span class="hljs-params">(Department department)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;修改 id=&quot;</span> + department.getId() + <span class="hljs-string">&quot; 的数据&quot;</span>);<br>    <span class="hljs-keyword">this</span>.departmentMapper.update(department);<br>    <span class="hljs-keyword">return</span> department;<br>  &#125;<br> <br>  <span class="hljs-meta">@Cacheable(key = &quot;#id&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">getDepartmentById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;获取 id=&quot;</span> + id + <span class="hljs-string">&quot; 的数据&quot;</span>);<br>    Department department = <span class="hljs-keyword">this</span>.departmentMapper.getById(id);<br>    <span class="hljs-keyword">return</span> department;<br>  &#125;<br> <br>  <span class="hljs-meta">@CacheEvict(key = &quot;#id&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;删除 id=&quot;</span> + id + <span class="hljs-string">&quot; 的数据&quot;</span>);<br>    <span class="hljs-keyword">this</span>.departmentMapper.deleteById(id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="控制层："><a href="#控制层：" class="headerlink" title="控制层："></a>控制层：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;department&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentController</span> </span>&#123;<br> <br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> DepartmentService departmentService;<br> <br>  <span class="hljs-meta">@RequestMapping(&quot;save&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">save</span><span class="hljs-params">(Department department)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.departmentService.save(department);<br> <br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br>    map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;保存成功&quot;</span>);<br>    <span class="hljs-keyword">return</span> map;<br>  &#125;<br> <br>  <span class="hljs-meta">@RequestMapping(&quot;get/&#123;id&#125;&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>    Department department = <span class="hljs-keyword">this</span>.departmentService.getDepartmentById(id);<br> <br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br>    map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;获取成功&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;data&quot;</span>, department);<br>    <span class="hljs-keyword">return</span> map;<br>  &#125;<br> <br>  <span class="hljs-meta">@RequestMapping(&quot;update&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">update</span><span class="hljs-params">(Department department)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.departmentService.update(department);<br> <br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br>    map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;修改成功&quot;</span>);<br>    <span class="hljs-keyword">return</span> map;<br>  &#125;<br> <br>  <span class="hljs-meta">@RequestMapping(&quot;delete/&#123;id&#125;&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.departmentService.delete(id);<br> <br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br>    map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;删除成功&quot;</span>);<br>    <span class="hljs-keyword">return</span> map;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动类：</p><p>添加 @EnableCaching 注解，开启缓存功能。</p><h1 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h1><p>由于 ehcache 缓存是存储在应用的内存中，如果使用 junit 测试，方法执行完毕缓存就释放了，无法正常测试缓存效果，因此测试使用发起 http 请求的形式。</p><p>发起保存请求：</p><h2 id="发起保存请求："><a href="#发起保存请求：" class="headerlink" title="发起保存请求："></a>发起保存请求：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">保存 id=<span class="hljs-number">2</span> 的数据<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">50</span>:<span class="hljs-number">48.800</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">7</span>] c.l.s.dao.DepartmentMapper.insert        : ==&gt;  Preparing: <span class="hljs-function">insert into <span class="hljs-title">department</span><span class="hljs-params">(id,name,descr)</span> <span class="hljs-title">values</span><span class="hljs-params">(?,?,?)</span></span><br><span class="hljs-function">2017-12-06 14:50:48.801 DEBUG 680 --- [nio-8081-exec-7] c.l.s.dao.DepartmentMapper.insert        : </span>==&gt; Parameters: <span class="hljs-number">2</span>(Integer), Ehcache 部门(String), Ehcache(String)<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">50</span>:<span class="hljs-number">48.868</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">7</span>] c.l.s.dao.DepartmentMapper.insert        : &lt;==    Updates: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>保存成功后，立刻发起查询请求，没有日志打印，但返回对象数据，说明数据是从缓存中获取。</p><h2 id="发起修改请求："><a href="#发起修改请求：" class="headerlink" title="发起修改请求："></a>发起修改请求：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修改 id=<span class="hljs-number">2</span> 的数据<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">16.588</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">8</span>] c.l.s.dao.DepartmentMapper.update        : ==&gt;  Preparing: update department set name = ? , descr = ? where id = ?<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">16.589</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">8</span>] c.l.s.dao.DepartmentMapper.update        : ==&gt; Parameters: Ehcache 部门<span class="hljs-number">2</span>(String), Ehcache2(String), <span class="hljs-number">2</span>(Integer)<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">16.657</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">8</span>] c.l.s.dao.DepartmentMapper.update        : &lt;==    Updates: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>修改成功后，立刻发起查询请求，没有日志打印，但返回修改后的对象数据，说明缓存中的数据已经同步。</p><h2 id="发起删除请求："><a href="#发起删除请求：" class="headerlink" title="发起删除请求："></a>发起删除请求：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">删除 id=<span class="hljs-number">2</span> 的数据<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">07.572</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">1</span>] c.l.s.dao.DepartmentMapper.deleteById    : ==&gt;  Preparing: delete from department where id = ?<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">07.572</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">1</span>] c.l.s.dao.DepartmentMapper.deleteById    : ==&gt; Parameters: <span class="hljs-number">2</span>(Integer)<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">07.613</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">1</span>] c.l.s.dao.DepartmentMapper.deleteById    : &lt;==    Updates: <span class="hljs-number">1</span><br> <br></code></pre></td></tr></table></figure><p>删除成功后，立刻发起查询请求，控制台打印 sql 语句，说明缓存数据被删除，需要查询数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">获取 id=<span class="hljs-number">2</span> 的数据<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">40.324</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">3</span>] c.l.s.dao.DepartmentMapper.getById       : ==&gt;  Preparing: select id,name,descr from department where id = ?<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">40.325</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">3</span>] c.l.s.dao.DepartmentMapper.getById       : ==&gt; Parameters: <span class="hljs-number">2</span>(Integer)<br><span class="hljs-number">2017</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">40.328</span> DEBUG <span class="hljs-number">680</span> --- [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">3</span>] c.l.s.dao.DepartmentMapper.getById       : &lt;==      Total: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>EhCache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot配置 Druid 数据源</title>
    <link href="/blog/2021/02/03/Springboot%E9%85%8D%E7%BD%AEDruid%20%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <url>/blog/2021/02/03/Springboot%E9%85%8D%E7%BD%AEDruid%20%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>    &lt;artifactId&gt;druid&lt;/artifactId&gt;<br>    &lt;version&gt;1.1.8&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h1 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.datasource.druid.driverClassName=com.mysql.jdbc.Driver<br>spring.datasource.druid.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><br>spring.datasource.druid.username=root<br>spring.datasource.druid.password=tiger<br> <br>spring.datasource.druid.initialSize=<span class="hljs-number">5</span><br>spring.datasource.druid.minIdle=<span class="hljs-number">5</span><br>spring.datasource.druid.maxActive=<span class="hljs-number">20</span><br>spring.datasource.druid.maxWait=<span class="hljs-number">60000</span><br>spring.datasource.druid.timeBetweenEvictionRunsMillis=<span class="hljs-number">60000</span><br>spring.datasource.druid.min-evictableIdleTimeMillis=<span class="hljs-number">300000</span><br>spring.datasource.druid.validationQuery=SELECT <span class="hljs-number">1</span> FROM DUAL<br>spring.datasource.druid.testWhileIdle=<span class="hljs-keyword">true</span><br>spring.datasource.druid.testOnBorrow=<span class="hljs-keyword">false</span><br>spring.datasource.druid.testOnReturn=<span class="hljs-keyword">false</span><br>spring.datasource.druid.poolPreparedStatements=<span class="hljs-keyword">true</span><br>spring.datasource.druid.maxPoolPreparedStatementPerConnectionSize=<span class="hljs-number">20</span><br>spring.datasource.druid.filters=stat,wall<br> <br></code></pre></td></tr></table></figure><p>注意：配置中都是以 spring.datasource.druid 开头，使用驼峰命名</p><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfiguration</span> </span>&#123;<br> <br>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)</span><br>    <span class="hljs-meta">@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;close&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource ds = <span class="hljs-keyword">new</span> DruidDataSource();<br>        ds.setProxyFilters(Arrays.asList(statFilter()));<br>        <span class="hljs-keyword">return</span> ds;<br>    &#125;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Filter <span class="hljs-title">statFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        StatFilter filter = <span class="hljs-keyword">new</span> StatFilter();<br>        filter.setSlowSqlMillis(<span class="hljs-number">5000</span>);<br>        filter.setLogSlowSql(<span class="hljs-keyword">true</span>);<br>        filter.setMergeSql(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了保证访问的安全性，我们可以如下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">## druid 监控<br>spring.datasource.druid.web-stat-filter.enabled=<span class="hljs-keyword">true</span><br>spring.datasource.druid.web-stat-filter.url-pattern=<span class="hljs-comment">/*</span><br><span class="hljs-comment">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">## druid 监控页面</span><br><span class="hljs-comment">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="hljs-comment">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br><span class="hljs-comment">spring.datasource.druid.stat-view-servlet.login-username=druid</span><br><span class="hljs-comment">spring.datasource.druid.stat-view-servlet.login-password=druid123</span><br><span class="hljs-comment"> </span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190917-133136@2x_1568698317734.png" alt="WX20190917-133136@2x"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Druid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Mybatis</title>
    <link href="/blog/2021/02/03/SpringBoot%E6%95%B4%E5%90%88Mybatis/"/>
    <url>/blog/2021/02/03/SpringBoot%E6%95%B4%E5%90%88Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="整合-Mybatis"><a href="#整合-Mybatis" class="headerlink" title="整合 Mybatis"></a>整合 Mybatis</h1><h2 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- jdbc --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- mybatis --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;<br>    &lt;version&gt;3.4.4&lt;/version&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- spring,mybatis整合包 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;<br>    &lt;version&gt;1.3.1&lt;/version&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- mysql 驱动包 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="配置数据库连接："><a href="#配置数据库连接：" class="headerlink" title="配置数据库连接："></a>配置数据库连接：</h2><p>在 application.properties 中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"># 数据源配置<br>spring.datasource.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span></span>=com.mysql.jdbc.Driver<br>spring.datasource.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><br>spring.datasource.username=root<br>spring.datasource.password=tiger<br></code></pre></td></tr></table></figure><h2 id="创建配置类："><a href="#创建配置类：" class="headerlink" title="创建配置类："></a>创建配置类：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfiguration</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">// 当容器里没有指定的 Bean 的情况下创建该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();<br>        <span class="hljs-comment">// 设置数据源</span><br>        sqlSessionFactoryBean.setDataSource(dataSource);<br> <br>        <span class="hljs-comment">// 设置mybatis的主配置文件</span><br>        sqlSessionFactoryBean.setConfigLocation(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;mybatis/mybatis-config.xml&quot;</span>));<br> <br>        <span class="hljs-comment">// 设置mapper映射文件</span><br>        PathMatchingResourcePatternResolver resolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();<br>        Resource[] mapperXml;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mapperXml = resolver.getResources(<span class="hljs-string">&quot;classpath:mybatis/mapper/*.xml&quot;</span>);<br>            sqlSessionFactoryBean.setMapperLocations(mapperXml);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br> <br>        <span class="hljs-comment">// 设置别名包</span><br>        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="hljs-string">&quot;com.light.springboot.domain&quot;</span>);<br> <br>        <span class="hljs-keyword">return</span> sqlSessionFactoryBean;<br>    &#125;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnBean(SqlSessionFactoryBean.class)</span> <span class="hljs-comment">// 当 SqlSessionFactoryBean 实例存在时创建对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MapperScannerConfigurer <span class="hljs-title">mapperScannerConfigurer</span><span class="hljs-params">()</span> </span>&#123;<br>        MapperScannerConfigurer mapperScannerConfigurer = <span class="hljs-keyword">new</span> MapperScannerConfigurer();<br>        mapperScannerConfigurer.setBasePackage(<span class="hljs-string">&quot;com.light.springboot.mapper&quot;</span>);<br>        <span class="hljs-keyword">return</span> mapperScannerConfigurer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 src/main/resources 下创建 mybatis 文件夹，并在 mybatis 文件夹中创建 “mybatis-config.xml” 配置文件，内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!DOCTYPE configuration<br>        PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br>        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;<br>&lt;configuration&gt;<br>    &lt;settings&gt;<br>        &lt;!-- 获取数据库自增主键值 --&gt;<br>        &lt;setting name=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>        &lt;!-- 使用列别名替换列名，默认为 <span class="hljs-keyword">true</span> --&gt;<br>        &lt;setting name=<span class="hljs-string">&quot;useColumnLabel&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>        &lt;!-- 开启驼峰命名转换：Table(create_time) =&gt; Entity(createTime) --&gt;<br>        &lt;setting name=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>    &lt;/settings&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure><p>mybatis 文件夹下再创建一个 “mapper” 文件夹，里边存放 Mpper 接口对应的 mapper 映射文件。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>在 MySQL 中创建名为 springboot 的数据库，在该库中创建 role 表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">CREATE TABLE `department` (<br>    `id` INT(<span class="hljs-number">11</span>) NOT NULL,<br>    `name` VARCHAR(<span class="hljs-number">10</span>) NOT NULL,<br>    `descr` VARCHAR(<span class="hljs-number">50</span>) NULL DEFAULT NULL,<br>    <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`id`)</span></span><br><span class="hljs-function">)</span><br><span class="hljs-function">ENGINE</span>=InnoDB<br>;<br></code></pre></td></tr></table></figure><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>setet 和 getter 方法省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6067283535977178571L</span>;<br> <br>    <span class="hljs-keyword">private</span> Integer id;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">private</span> String descr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mapper-接口"><a href="#Mapper-接口" class="headerlink" title="Mapper 接口"></a>Mapper 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DepartmentMapper</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Department department)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">getById</span><span class="hljs-params">(Integer id)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Department department)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>补充：Mapper 接口需要添加 @Mapper 注解，如果不想使用该注解，可以在启动类上使用 @MapperScan 配置 Mapper 接口路径</p><p>mybatis/mapper/departmentMapper.xml ：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!DOCTYPE mapper PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;<br>&lt;mapper namespace=<span class="hljs-string">&quot;com.light.springboot.dao.DepartmentMapper&quot;</span>&gt;<br> <br>    &lt;insert id=<span class="hljs-string">&quot;insert&quot;</span> parameterType=<span class="hljs-string">&quot;com.light.springboot.domain.Department&quot;</span>&gt;<br>        <span class="hljs-function">insert into <span class="hljs-title">department</span><span class="hljs-params">(id,name,descr)</span> <span class="hljs-title">values</span><span class="hljs-params">(#&#123;id&#125;,#&#123;name&#125;,#&#123;descr&#125;)</span></span><br><span class="hljs-function">    &lt;/insert&gt;</span><br><span class="hljs-function">    </span><br><span class="hljs-function">    &lt;select id</span>=<span class="hljs-string">&quot;getById&quot;</span> parameterType=<span class="hljs-string">&quot;java.lang.Integer&quot;</span> resultType=<span class="hljs-string">&quot;com.light.springboot.domain.Department&quot;</span>&gt;<br>        select id,name,descr from department where id = #&#123;id&#125;<br>    &lt;/select&gt;<br>    <br>    &lt;update id=<span class="hljs-string">&quot;update&quot;</span> parameterType=<span class="hljs-string">&quot;com.light.springboot.domain.Department&quot;</span>&gt;<br>        update department set descr = #&#123;descr&#125; where id = #&#123;id&#125;<br>    &lt;/update&gt;<br>    <br>    &lt;delete id=<span class="hljs-string">&quot;deleteById&quot;</span> parameterType=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;<br>        delete from department where id = #&#123;id&#125;<br>    &lt;/delete&gt;<br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentTest</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DepartmentMapper departmentMapper;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>        Department department = <span class="hljs-keyword">new</span> Department();<br>        department.setId(<span class="hljs-number">1</span>);<br>        department.setName(<span class="hljs-string">&quot;研发部&quot;</span>);<br>        department.setDescr(<span class="hljs-string">&quot;开发产品&quot;</span>);<br>        <span class="hljs-keyword">this</span>.departmentMapper.insert(department);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetById</span><span class="hljs-params">()</span> </span>&#123;<br>        Department department = <span class="hljs-keyword">this</span>.departmentMapper.getById(<span class="hljs-number">1</span>);<br>        System.out.println(department);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>        Department department = <span class="hljs-keyword">new</span> Department();<br>        department.setId(<span class="hljs-number">1</span>);<br>        department.setDescr(<span class="hljs-string">&quot;开发高级产品&quot;</span>);<br>        <span class="hljs-keyword">this</span>.departmentMapper.update(department);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteById</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.departmentMapper.deleteById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Spring-data-jpa</title>
    <link href="/blog/2021/02/03/SpringBoot%E6%95%B4%E5%90%88Spring-data-jpa/"/>
    <url>/blog/2021/02/03/SpringBoot%E6%95%B4%E5%90%88Spring-data-jpa/</url>
    
    <content type="html"><![CDATA[<p>增删改查很爽就对了 适合业务性比较单一的项目</p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- jdbc --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- springboot,jpa 整合包--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;!-- mysql 驱动包 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h1 id="配置数据库连接"><a href="#配置数据库连接" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h1><p>在 application.properties 中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"># 数据库连接配置<br>spring.datasource.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span></span>=com.mysql.jdbc.Driver<br>spring.datasource.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><br>spring.datasource.username=root<br>spring.datasource.password=tiger<br> <br># JPA 配置<br>spring.jpa.hibernate.ddl-auto=update<br>spring.jpa.show-sql=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>在 MySQL 中创建名为 springboot 的数据库，在该库中创建 role 表： 注意，主键 ID 为 AUTO_INCREMENT 自增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">CREATE TABLE `role` (<br>    `id` INT(<span class="hljs-number">11</span>) NOT NULL AUTO_INCREMENT,<br>    `name` VARCHAR(<span class="hljs-number">10</span>) NOT NULL,<br>    `descr` VARCHAR(<span class="hljs-number">100</span>) NULL DEFAULT NULL,<br>    <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`id`)</span></span><br><span class="hljs-function">)</span><br><span class="hljs-function">COLLATE</span>=<span class="hljs-string">&#x27;utf8_general_ci&#x27;</span><br>ENGINE=InnoDB<br>;<br></code></pre></td></tr></table></figure><h2 id="建实体类"><a href="#建实体类" class="headerlink" title="建实体类"></a>建实体类</h2><p>添加相应的注解 getset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3926276668667517847L</span>;<br> <br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> String descr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Repository-接口"><a href="#Repository-接口" class="headerlink" title="Repository 接口"></a>Repository 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RoleRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Role</span>, <span class="hljs-title">Integer</span>&gt;</span>&#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleRepositoryTest</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleRepository roleRepository;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>        Role role = <span class="hljs-keyword">new</span> Role();<br>        role.setName(<span class="hljs-string">&quot;管理员&quot;</span>);<br>        role.setDescr(<span class="hljs-string">&quot;测试&quot;</span>);<br>        Role result = <span class="hljs-keyword">this</span>.roleRepository.save(role);<br>        System.out.println(result);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindOne</span><span class="hljs-params">()</span> </span>&#123;<br>        Role role = <span class="hljs-keyword">this</span>.roleRepository.findOne(<span class="hljs-number">1</span>);<br>        System.out.println(role);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>        Role role = <span class="hljs-keyword">new</span> Role();<br>        role.setId(<span class="hljs-number">1</span>);<br>        role.setName(<span class="hljs-string">&quot;管理员&quot;</span>);<br>        role.setDescr(<span class="hljs-string">&quot;控制权限&quot;</span>);<br>        Role result = <span class="hljs-keyword">this</span>.roleRepository.save(role);<br>        System.out.println(result);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roleRepository.delete(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>jpa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装Tomcat</title>
    <link href="/blog/2021/02/02/Docker%E5%AE%89%E8%A3%85Tomcat/"/>
    <url>/blog/2021/02/02/Docker%E5%AE%89%E8%A3%85Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="查看-Tomcat-镜像"><a href="#查看-Tomcat-镜像" class="headerlink" title="查看 Tomcat 镜像"></a>查看 Tomcat 镜像</h1><p>我一般上都是直接获取最新的 除非指定要哪个版本的时候 <strong>docker search tomcat</strong></p><h1 id="获取-Tomcat-镜像"><a href="#获取-Tomcat-镜像" class="headerlink" title="获取 Tomcat 镜像"></a>获取 Tomcat 镜像</h1><p>比如： 这种是指定版本 docker pull mongo:3.2.4 dockre pull redis:3.2</p><p><strong>docker pull tomcat</strong>（这种方法是获取最新的Tomcat镜像）</p><h1 id="启动Tomcat容器实例"><a href="#启动Tomcat容器实例" class="headerlink" title="启动Tomcat容器实例"></a>启动Tomcat容器实例</h1><p>第一个端口是外部访问的 我这里换成 8888 <strong>docker run –name tomcat -d -it –rm -p 8888:8080 tomcat</strong> –rm:表示当关闭或者销毁当前容器实例进程时，同时销毁容器实例。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190911-173602@2x_1568194575420.png" alt="WX20190911-173602@2x"></p><h1 id="实例化Tomcat容器实例"><a href="#实例化Tomcat容器实例" class="headerlink" title="实例化Tomcat容器实例"></a>实例化Tomcat容器实例</h1><p>docker restart tomcat（tomcat是当前实例的名称，也可以通过当前实例的容器ID来重启）</p><h1 id="关闭Tomcat容器实例"><a href="#关闭Tomcat容器实例" class="headerlink" title="关闭Tomcat容器实例"></a>关闭Tomcat容器实例</h1><p>docker stop tomcat（tomcat是当前实例的名称，也可以通过当前实例的容器ID来重启）</p><h1 id="启动Tomcat容器实例-1"><a href="#启动Tomcat容器实例-1" class="headerlink" title="启动Tomcat容器实例"></a>启动Tomcat容器实例</h1><p>docker start tomcat</p><h1 id="查看Tomcat容器实例进程信息"><a href="#查看Tomcat容器实例进程信息" class="headerlink" title="查看Tomcat容器实例进程信息"></a>查看Tomcat容器实例进程信息</h1><p>通过docker top tomcat查看</p><p>通过ps -ef | grep tomcat查看</p><h1 id="杀死Tomcat容器实例进程"><a href="#杀死Tomcat容器实例进程" class="headerlink" title="杀死Tomcat容器实例进程"></a>杀死Tomcat容器实例进程</h1><p>docker kill -s KILL tomcat 再查看 docker ps</p><h1 id="移除Tomcat容器实例"><a href="#移除Tomcat容器实例" class="headerlink" title="移除Tomcat容器实例"></a>移除Tomcat容器实例</h1><p>docker rm -f -v tomcat</p><h1 id="进入Tomcat容器实例"><a href="#进入Tomcat容器实例" class="headerlink" title="进入Tomcat容器实例"></a>进入Tomcat容器实例</h1><p>docker exec -it tomcat /bin/sh</p><h1 id="Tomcat-环境说明"><a href="#Tomcat-环境说明" class="headerlink" title="Tomcat 环境说明"></a>Tomcat 环境说明</h1><p>Tomcat 7、Tomcat 8 在容器的中的默认环境： CATALINA_BASE: /usr/local/tomcat CATALINA_HOME: /usr/local/tomcat CATALINA_TMPDIR: /usr/local/tomcat/temp JRE_HOME: /usr CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</p><h1 id="上传WEB应用到Tomcat的容器实例中"><a href="#上传WEB应用到Tomcat的容器实例中" class="headerlink" title="上传WEB应用到Tomcat的容器实例中"></a>上传WEB应用到Tomcat的容器实例中</h1><p>进入war包 文件所在目录 docker cp tyrone-demo.war tomcat:/usr/local/tomcat/webapps</p><p>注意：将WEB应用复制到Tomcat容器实例中后，会自动解压部署的，不需要重启容器。</p><h1 id="查看Tomcat容器实例中的WEB应用"><a href="#查看Tomcat容器实例中的WEB应用" class="headerlink" title="查看Tomcat容器实例中的WEB应用"></a>查看Tomcat容器实例中的WEB应用</h1><p>语法：docker exec -it tomcat /bin/sh（相当于开启tomcat终端）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap按照value排序</title>
    <link href="/blog/2021/02/02/HashMap%E6%8C%89%E7%85%A7value%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2021/02/02/HashMap%E6%8C%89%E7%85%A7value%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>给定一个HashMap&lt;String, BuziObj&gt; buziObjMap;，其中 BuziObj 实现了 Comparable 接口。现在需要将 buziObjMap 按照 BuziObj 有序输出。注意，BuziObj 实例有可能相等，要求多次返回的结果一致。可以使用JDK提供的各种API。</p><p>当时自己的想法是，将 buziObjMap 的 values 放在一个 List 中。然后使用 Collections.sort(valuesList) 对存放 values 的 valuesList 排序。再遍历排序之后的 valuesList 和 buziObjMap，比对 valuesList 与 buziObjMap 中的值，相等之后，将当前 buziObjMap 中的 Entry 放在 LinkedHashMap 中，返回 LinkedHashMap 即可。</p><p>但是如上解法主要存在两个问题： 1，不满足多次执行返回结果一致这个要求，因为在遍历 valuesList 与 buziObjMap 时，buziObjMap的输出顺序无法保证每次都是一致的。 2，算法的复杂度过大。</p><h1 id="实际遇到的问题"><a href="#实际遇到的问题" class="headerlink" title="实际遇到的问题"></a>实际遇到的问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br> <br>List&lt;Map.Entry&lt;K, V&gt;&gt; list =  <br>            <span class="hljs-keyword">new</span> LinkedList&lt;Map.Entry&lt;K, V&gt;&gt;( map.entrySet() );  <br>        Collections.sort( list, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;K, V&gt;&gt;()  <br>        &#123;  <br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">( Map.Entry&lt;K, V&gt; o1, Map.Entry&lt;K, V&gt; o2 )</span>  </span><br><span class="hljs-function">            </span>&#123;  <br>                <span class="hljs-keyword">return</span> (o1.getValue()).compareTo( o2.getValue() );  <br>            &#125;  <br>        &#125; );  <br>  <br>        Map&lt;K, V&gt; result = <span class="hljs-keyword">new</span> LinkedHashMap&lt;K, V&gt;();  <br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;K, V&gt; entry : list)  <br>        &#123;  <br>            result.put( entry.getKey(), entry.getValue() );  <br>        &#125;<br> <br><span class="hljs-comment">//map 里面的属性值需要替换成自己的 我这里用的key是String型 value 是实体类</span><br>  List&lt;Map.Entry&lt;String, CorrectRate&gt;&gt; list =<br>                <span class="hljs-keyword">new</span> LinkedList&lt;Map.Entry&lt;String, CorrectRate&gt;&gt;(correctRateOm.entrySet());<br>        Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;String, CorrectRate&gt;&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;String, CorrectRate&gt; o1, Map.Entry&lt;String, CorrectRate&gt; o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> (o1.getValue().getStudentId()).compareTo(o2.getValue().getStudentId());<br>            &#125;<br>        &#125;);<br> <br></code></pre></td></tr></table></figure><p>list 返回的就是排好顺序的啦</p><p><a href="https://bk.cuixiaoyan.xyz/archives/valuepaixu#%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a><a href="https://bk.cuixiaoyan.xyz/archives/valuepaixu#%E5%AE%9E%E9%99%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">实际遇到的问题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java的三种随机数生成方式</title>
    <link href="/blog/2021/02/02/java%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/"/>
    <url>/blog/2021/02/02/java%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>随机数的产生在一些代码中很常用，也是我们必须要掌握的。而java中产生随机数的方法主要有三种：</p><p>第一种：new Random()</p><p>第二种：Math.random()</p><p>第三种：currentTimeMillis()</p><p>第一种需要借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。</p><p>种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关。以代码为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function"></span>&#123;<br>　　Random r = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">1</span>);<br>　　<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">5</span> ; i++)<br>　　&#123;<br>　　　　<span class="hljs-keyword">int</span> ran1 = r.nextInt(<span class="hljs-number">100</span>);<br>　　　　System.out.println(ran1);<br>　　&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>在我的编译器下产生的五个数均为85,88,47,13,54，如果采用Random r = new Random()，产生的随机数就不同，这就是确定种子导致的结果。</p><p>而第二种方法返回的数值是[0.0,1.0）的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function"> </span>&#123;    <br>    <span class="hljs-keyword">int</span> max=<span class="hljs-number">100</span>,min=<span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">int</span> ran2 = (<span class="hljs-keyword">int</span>) (Math.random()*(max-min)+min); <br>     System.out.println(ran2);<br> &#125;<br> <br></code></pre></td></tr></table></figure><p>至于第三种方法虽然不常用，但是也是一种思路。方法返回从1970年1月1日0时0分0秒（这与UNIX系统有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> max=<span class="hljs-number">100</span>,min=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">long</span> randomNum = System.currentTimeMillis();<br><span class="hljs-keyword">int</span> ran3 = (<span class="hljs-keyword">int</span>) (randomNum%(max-min)+min);<br>System.out.println(ran3);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法移除K个数字</title>
    <link href="/blog/2021/02/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <url>/blog/2021/02/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%A7%BB%E9%99%A4K%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>题目描述：有一 十进制正整数，移除其中的 K 个数，使剩下的数字是所有可能中最大的。 假设： 字符串的长度一定大于等于 K 字符串不会以 0 开头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：<span class="hljs-number">1432219</span><br>           <span class="hljs-number">3</span><br> <br>输出：<span class="hljs-number">4329</span><br></code></pre></td></tr></table></figure><p>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.Stack;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeleteK</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Scanner scanner=<span class="hljs-keyword">new</span> Scanner(System.in);<br>String num=scanner.nextLine();<br><span class="hljs-keyword">int</span> k=scanner.nextInt();<br>String resulteString=DeleteK.removeK(num, k);<br>System.out.println(resulteString);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span>   <span class="hljs-keyword">static</span> String <span class="hljs-title">removeK</span><span class="hljs-params">(String num,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>String result=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">//根据数值比较进行入栈移除</span><br>Stack&lt;Integer&gt; stack=<span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num.length(); i++) &#123;<br><span class="hljs-keyword">int</span> temp=num.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-comment">//进行比较操作</span><br><span class="hljs-keyword">while</span> (stack.size()!=<span class="hljs-number">0</span>&amp;&amp;stack.peek()&lt;temp&amp;&amp;k&gt;<span class="hljs-number">0</span>) &#123;<br>stack.pop();<br>k--;<br>&#125;<br><span class="hljs-comment">//比较完成后，执行入栈操作</span><br><span class="hljs-keyword">if</span> (stack.size()!=<span class="hljs-number">0</span>||temp!=<span class="hljs-number">0</span>) &#123;<br>stack.push(temp);<br>&#125;<br>&#125;<br><span class="hljs-comment">//如果存在数据全部存入栈中，但是k的值不为0的</span><br><span class="hljs-keyword">while</span> (k&gt;<span class="hljs-number">0</span>&amp;&amp;stack.size()!=<span class="hljs-number">0</span>) &#123;<br>stack.pop();<br>k--;<br>&#125;<br><br><span class="hljs-comment">//将数据从栈中全部取出</span><br><span class="hljs-keyword">while</span> (stack.size()!=<span class="hljs-number">0</span>) &#123;<br>result=stack.pop()+result;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot工具集成</title>
    <link href="/blog/2021/02/01/SpringBoot%E5%B7%A5%E5%85%B7%E9%9B%86%E6%88%90/"/>
    <url>/blog/2021/02/01/SpringBoot%E5%B7%A5%E5%85%B7%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="整合-JavaMail"><a href="#整合-JavaMail" class="headerlink" title="整合 JavaMail"></a>整合 JavaMail</h1><p>本次测试演示带模板的邮件，使用 Freemark 实现邮件的模板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"> 添加依赖<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>添加配置<br>在 application.properties 中添加<br>这里的密码需要设置的是<span class="hljs-number">163</span>的第三方工具访问密码<br># javamail 配置<br>spring.mail.host=smtp<span class="hljs-number">.163</span>.com<br>spring.mail.username=<span class="hljs-number">13738137546</span>@<span class="hljs-number">163.</span>com<br>spring.mail.password=<br>spring.mail.properties.mail.smtp.auth=<span class="hljs-keyword">true</span><br>spring.mail.properties.mail.smtp.starttls.enable=<span class="hljs-keyword">true</span><br>spring.mail.properties.mail.smtp.starttls.required=<span class="hljs-keyword">true</span><br> <br> <br> 编码<br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@EnableConfigurationProperties(MailProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaMailComponent</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String template = <span class="hljs-string">&quot;mail.ftl&quot;</span>;<br> <br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> FreeMarkerConfigurer freeMarkerConfigurer;<br><br><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JavaMailSender javaMailSender;<br> <br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MailProperties mailProperties;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMail</span><span class="hljs-params">(String email)</span> </span>&#123;<br>Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>map.put(<span class="hljs-string">&quot;email&quot;</span>, email);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 获取内容</span><br>String text = <span class="hljs-keyword">this</span>.getTextByTemplate(template, map);<br><span class="hljs-comment">// 发送</span><br><span class="hljs-keyword">this</span>.send(email, text);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getTextByTemplate</span><span class="hljs-params">(String template, Map&lt;String, Object&gt; model)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">return</span> FreeMarkerTemplateUtils<br>.processTemplateIntoString(<span class="hljs-keyword">this</span>.freeMarkerConfigurer.getConfiguration().getTemplate(template), model);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">send</span><span class="hljs-params">(String email, String text)</span> <span class="hljs-keyword">throws</span> MessagingException, UnsupportedEncodingException </span>&#123;<br>MimeMessage message = <span class="hljs-keyword">this</span>.javaMailSender.createMimeMessage();<br>MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(message, <span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>InternetAddress from = <span class="hljs-keyword">new</span> InternetAddress();<br>from.setAddress(<span class="hljs-keyword">this</span>.mailProperties.getUsername());<br>from.setPersonal(<span class="hljs-string">&quot;崔笑颜&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>helper.setFrom(from);<br>helper.setTo(email);<br>helper.setSubject(<span class="hljs-string">&quot;SpringBoot 发送的第一封邮件&quot;</span>);<br>helper.setText(text, <span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">this</span>.javaMailSender.send(message);<br><span class="hljs-keyword">return</span> text;<br>&#125;<br>&#125;<br> <br>在 src/main/resources 下的 template 目录下创建名为 mail.ftl 的文件，其内容如下：<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;zh&quot;</span>&gt;<br>&lt;head&gt;<br>&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Type&quot;</span> content=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div style=<span class="hljs-string">&quot;width: 600px; text-align: left; margin: 0 auto;&quot;</span>&gt;<br>&lt;h1 style=&quot;color: #005da7;&quot;&gt;崔笑颜&lt;/h1&gt;<br>&lt;div style=&quot;border-bottom: 5px solid #005da7; height: 2px; width: 100%;&quot;&gt;&lt;/div&gt;<br>&lt;div style=<span class="hljs-string">&quot;border: 1px solid #005da7; font-size: 16px; line-height: 50px; padding: 20px;&quot;</span>&gt;<br>&lt;div&gt;$&#123;email&#125;，您好！&lt;/div&gt;<br>&lt;div&gt;<br>这是个测试<br>&lt;/div&gt;<br>&lt;div&gt;<br>想了解更多信息，请访问 &lt;a href=<span class="hljs-string">&quot;https://bk.cuixiaoyan.xyz/&quot;</span>&gt;https:<span class="hljs-comment">//bk.cuixiaoyan.xyz/&lt;/a&gt;</span><br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br> <br>测试<br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailTest</span> </span>&#123;<br> <br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JavaMailComponent javaMailComponent;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">this</span>.javaMailComponent.sendMail(<span class="hljs-string">&quot;56696508@qq.com&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="整合定时任务"><a href="#整合定时任务" class="headerlink" title="整合定时任务"></a>整合定时任务</h1><h2 id="Scheduled-方式"><a href="#Scheduled-方式" class="headerlink" title="Scheduled 方式"></a>Scheduled 方式</h2><h3 id="任务类"><a href="#任务类" class="headerlink" title="任务类"></a>任务类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schedule</span> </span>&#123;<br> <br><span class="hljs-meta">@Scheduled(fixedRate = 2000)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;启动定时任务:&quot;</span> + <span class="hljs-keyword">new</span> Date());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 @Scheduled 定义任务执行时间，代码中表示每隔 2 秒执行一次任务。</p><h3 id="开启定时计划"><a href="#开启定时计划" class="headerlink" title="开启定时计划"></a>开启定时计划</h3><p>只需在 Spring Boot 的启动类上添加 @EnableScheduling 后，启动项目即可。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboot-web-schedule_1567762142429.jpg" alt="springboot-web-schedule"></p><h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>默认情况下，Spring Task 使用一条线程串行的执行所有的定时任务。为了提高执行效率，我们需要手动编写一个线程池实现定时任务的并行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTaskConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SchedulingConfigurer</span>, <span class="hljs-title">AsyncConfigurer</span> </span>&#123;<br> <br>    <span class="hljs-comment">//线程池线程数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> corePoolSize = <span class="hljs-number">5</span>;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskScheduler <span class="hljs-title">taskScheduler</span><span class="hljs-params">()</span> </span>&#123;<br>        ThreadPoolTaskScheduler scheduler = <span class="hljs-keyword">new</span> ThreadPoolTaskScheduler();<br>        scheduler.initialize();<span class="hljs-comment">//初始化线程池</span><br>        scheduler.setPoolSize(corePoolSize);<span class="hljs-comment">//线程池容量</span><br>        <span class="hljs-keyword">return</span> scheduler;<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getAsyncExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        Executor executor = <span class="hljs-keyword">this</span>.taskScheduler();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar scheduledTaskRegistrar)</span> </span>&#123;<br>        scheduledTaskRegistrar.setTaskScheduler(taskScheduler());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="整合-Swagger2"><a href="#整合-Swagger2" class="headerlink" title="整合 Swagger2"></a>整合 Swagger2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java">添加依赖<br>&lt;dependency&gt;<br>&lt;groupId&gt;io.springfox&lt;/groupId&gt;<br>&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;<br>&lt;version&gt;2.7.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;io.springfox&lt;/groupId&gt;<br>&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;<br>&lt;version&gt;2.7.0&lt;/version&gt;<br>&lt;/dependency&gt;<br> <br>重新创建一个配置类，如下：<br> <br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Configuration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">accessToken</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>                .groupName(<span class="hljs-string">&quot;api&quot;</span>)<span class="hljs-comment">// 定义组</span><br>                .select() <span class="hljs-comment">// 选择那些路径和 api 会生成 document</span><br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.cxy.template.controller&quot;</span>)) <span class="hljs-comment">// 拦截的包路径</span><br>                .paths(PathSelectors.regex(<span class="hljs-string">&quot;/*/.*&quot;</span>))<span class="hljs-comment">// 拦截的接口路径</span><br>                .build() <span class="hljs-comment">// 创建</span><br>                .apiInfo(apiInfo()); <span class="hljs-comment">// 配置说明</span><br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()<span class="hljs-comment">//</span><br>                .title(<span class="hljs-string">&quot;Spring Boot 之 Web 篇&quot;</span>)<span class="hljs-comment">// 标题</span><br>                .description(<span class="hljs-string">&quot;spring boot Web 相关内容&quot;</span>)<span class="hljs-comment">// 描述</span><br>                .termsOfServiceUrl(<span class="hljs-string">&quot;https://bk.cuixiaoyan.xyz/&quot;</span>)<span class="hljs-comment">//</span><br>                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;moonlightL&quot;</span>, <span class="hljs-string">&quot;https://bk.cuixiaoyan.xyz/&quot;</span>, <span class="hljs-string">&quot;cuixiaoyande@163.com&quot;</span>))<span class="hljs-comment">// 联系</span><br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<span class="hljs-comment">// 版本</span><br>                .build();<br>    &#125;<br> <br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 解决静态资源无法访问</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .addResourceLocations(<span class="hljs-string">&quot;classpath:/static/&quot;</span>);<br>        <span class="hljs-comment">// 解决swagger无法访问</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/swagger-ui.html&quot;</span>)<br>                .addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>);<br>        <span class="hljs-comment">// 解决swagger的js文件无法访问</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/webjars/**&quot;</span>)<br>                .addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>    &#125;<br> <br> <br>&#125;<br> <br></code></pre></td></tr></table></figure><p>为了能更好的说明接口信息，我们还可以在 Controller 类上使用 Swagger2 相关注解说明信息。 我们以 FastJsonController 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(value = &quot;FastJson测试&quot;, tags = &#123; &quot;测试接口&quot; &#125;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;fastjson&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastJsonController</span> </span>&#123;<br> <br><span class="hljs-meta">@ApiOperation(&quot;获取用户信息&quot;)</span><br><span class="hljs-meta">@ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, dataType = &quot;string&quot;, paramType = &quot;query&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/test/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;<br>User user = <span class="hljs-keyword">new</span> User();<br> <br>user.setId(<span class="hljs-number">1</span>);<br>user.setUsername(name);<br>user.setPassword(<span class="hljs-string">&quot;jack123&quot;</span>);<br>user.setBirthday(<span class="hljs-keyword">new</span> Date());<br> <br><span class="hljs-keyword">return</span> user;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，上边的方法是用 @GetMapping 注解，如果只是使用 @RequestMapping 注解，不配置 method 属性，那么 API 文档会生成 7 种请求方式。</p><p>启动项目，打开浏览器访问 <a href="http://localhost:8080/swagger-ui.html![WX20190906-173719@2x](https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190906-173719@2x_1567762664793.png)">http://localhost:8080/swagger-ui.html![WX20190906-173719@2x](https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190906-173719@2x_1567762664793.png)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合</title>
    <link href="/blog/2021/02/01/SpringBoot%E6%95%B4%E5%90%88/"/>
    <url>/blog/2021/02/01/SpringBoot%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="配置-AOP-切面"><a href="#配置-AOP-切面" class="headerlink" title="配置 AOP 切面"></a>配置 AOP 切面</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">添加依赖<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>编写切面类<br>使用 <span class="hljs-meta">@Component</span>，<span class="hljs-meta">@Aspect</span> 标记到切面类上：<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeAspect</span> </span>&#123;<br> <br><span class="hljs-meta">@Around(&quot;execution(* com.light.springboot.controller.FastJsonController..*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">method</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br> <br>System.out.println(<span class="hljs-string">&quot;=====Aspect处理=======&quot;</span>);<br>Object[] args = pjp.getArgs();<br><span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>System.out.println(<span class="hljs-string">&quot;参数为:&quot;</span> + arg);<br>&#125;<br> <br><span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br> <br>Object object = pjp.proceed();<br> <br>System.out.println(<span class="hljs-string">&quot;Aspect 耗时:&quot;</span> + (System.currentTimeMillis() - start));<br> <br><span class="hljs-keyword">return</span> object;<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>请求 FastJsonController 控制器的方法，结果如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboot-web-08_1567733306478.jpg" alt="springboot-web-08"></p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java">友好页面<br>先演示非友好页面，修改 FastJsonController 类中的 test 方法：<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;fastjson&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastJsonController</span> </span>&#123;<br> <br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>User user = <span class="hljs-keyword">new</span> User();<br><br>user.setId(<span class="hljs-number">1</span>);<br>user.setUsername(<span class="hljs-string">&quot;jack&quot;</span>);<br>user.setPassword(<span class="hljs-string">&quot;jack123&quot;</span>);<br>user.setBirthday(<span class="hljs-keyword">new</span> Date());<br><br><span class="hljs-comment">// 模拟异常</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> user;<br>&#125;<br>&#125;<br> <br>当系统报错时，返回到页面的内容通常是一些杂乱的代码段，这种显示对用户来说不友好，因此我们需要自定义一个友好的提示系统异常的页面。<br> <br>在 src/main/resources 下创建 /<span class="hljs-keyword">public</span>/error，在该目录下再创建一个名为 5xx.html 文件，该页面的内容就是当系统报错时返回给用户浏览的内容：<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;zh&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;系统错误&lt;/title&gt;<br>    &lt;link href=<span class="hljs-string">&quot;/css/index.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>/&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>    &lt;h2&gt;系统内部错误&lt;/h2&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>路径时固定的，Spring Boot 会在系统报错时将返回视图指向该目录下的文件。<br>上边处理的 5xx 状态码的问题，接下来解决 <span class="hljs-number">404</span> 状态码的问题。<br> <br>当出现 <span class="hljs-number">404</span> 的情况时，用户浏览的页面也不够友好，因此我们也需要自定义一个友好的页面给用户展示。<br> <br>在 /<span class="hljs-keyword">public</span>/error 目录下再创建一个名为 <span class="hljs-number">404.</span>html 的文件：<br> <br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;zh&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;访问异常&lt;/title&gt;<br>    &lt;link href=<span class="hljs-string">&quot;/css/index.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>/&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>    &lt;h2&gt;找不到页面&lt;/h2&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br> <br>全局异常捕获<br>如果项目前后端是通过 JSON 进行数据通信，则当出现异常时可以常用如下方式处理异常信息。<br> <br>编写一个类充当全局异常的处理类，需要使用 <span class="hljs-meta">@ControllerAdvice</span> 和 <span class="hljs-meta">@ExceptionHandler</span> 注解：<br><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalDefaultExceptionHandler</span> </span>&#123;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理 Exception 类型的异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">defaultExceptionHandler</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br><br>Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br>map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">500</span>);<br>map.put(<span class="hljs-string">&quot;msg&quot;</span>, e.getMessage());<br><span class="hljs-keyword">return</span> map;<br>&#125;<br>&#125;<br>其中，方法名为任意名，入参一般使用 Exception 异常类，方法返回值可自定义。<br> <br></code></pre></td></tr></table></figure><h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java">添加依赖<br>&lt;dependency&gt;<br>&lt;groupId&gt;commons-io&lt;/groupId&gt;<br>&lt;artifactId&gt;commons-io&lt;/artifactId&gt;<br>&lt;version&gt;2.4&lt;/version&gt;<br>&lt;/dependency&gt;<br> <br>编写一个实体类，用于封装返回信息：<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileInfo</span> </span>&#123;<br> <br><span class="hljs-keyword">private</span> String path;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileInfo</span><span class="hljs-params">(String path)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.path = path;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPath</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> path;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.path = path;<br>&#125;<br><br>&#125;<br>编写 Controller，用于处理文件上传下载：<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/file&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileController</span> </span>&#123;<br> <br><span class="hljs-keyword">private</span> String path = <span class="hljs-string">&quot;d:\\&quot;</span>;<br> <br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> FileInfo <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br> <br>System.out.println(file.getName());<br>System.out.println(file.getOriginalFilename());<br>System.out.println(file.getSize());<br> <br>File localFile = <span class="hljs-keyword">new</span> File(path, file.getOriginalFilename());<br> <br>file.transferTo(localFile);<br> <br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FileInfo(localFile.getAbsolutePath());<br>&#125;<br> <br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br><span class="hljs-keyword">try</span> (InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(path, id + <span class="hljs-string">&quot;.jpg&quot;</span>));<br>OutputStream outputStream = response.getOutputStream();) &#123;<br> <br>response.setContentType(<span class="hljs-string">&quot;application/x-download&quot;</span>);<br>response.addHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + id + <span class="hljs-string">&quot;.jpg&quot;</span>);<br> <br>IOUtils.copy(inputStream, outputStream);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h1 id="CORS-支持"><a href="#CORS-支持" class="headerlink" title="CORS 支持"></a>CORS 支持</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java">前端页面<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br> <br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;跨域测试&lt;/title&gt;<br>&lt;/head&gt;<br> <br>&lt;body&gt;<br>    &lt;button id=&quot;test&quot;&gt;测试&lt;/button&gt;<br>    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt;<br>    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    $(function() &#123;<br>        $(<span class="hljs-string">&quot;#test&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, function() &#123;<br>            $.ajax(&#123;<br>                <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/fastjson/test&quot;</span>,<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>                <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;json&quot;</span>,<br>                <span class="hljs-string">&quot;success&quot;</span>: function(data) &#123;<br>                    console.log(data);<br>                &#125;<br>            &#125;)<br>        &#125;);<br>    &#125;);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br> <br>&lt;/html&gt;<br> <br>前端服务器启动端口为 <span class="hljs-number">8088</span> 与后端服务器 <span class="hljs-number">8080</span> 不同源，因此出现跨域的问题。<br> <br>现在开始解决跨域问题，可以两种维度控制客户端请求。<br>粗粒度控制：<br> <br>方式一<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title">corsConfigurer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcConfigurerAdapter() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>              registry.addMapping(<span class="hljs-string">&quot;/fastjson/**&quot;</span>)<br>                      .allowedOrigins(<span class="hljs-string">&quot;http://localhost:8088&quot;</span>);<span class="hljs-comment">// 允许 8088 端口访问</span><br>          &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br> <br>方式二<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span></span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/fastjson/**&quot;</span>)<br>              .allowedOrigins(<span class="hljs-string">&quot;http://localhost:8088&quot;</span>);<span class="hljs-comment">// 允许 8088 端口访问</span><br>    &#125;<br>&#125;<br>细粒度控制：<br>在 FastJsonController 类中的方法上添加 <span class="hljs-meta">@CrossOrigin(origins=&quot;xx&quot;)</span> 注解：<br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@CrossOrigin(origins=&quot;http://localhost:8088&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>User user = <span class="hljs-keyword">new</span> User();<br><br>user.setId(<span class="hljs-number">1</span>);<br>user.setUsername(<span class="hljs-string">&quot;jack&quot;</span>);<br>user.setPassword(<span class="hljs-string">&quot;jack123&quot;</span>);<br>user.setBirthday(<span class="hljs-keyword">new</span> Date());<br><br><span class="hljs-keyword">return</span> user;<br>&#125;<br>在使用该注解时，需要注意 <span class="hljs-meta">@RequestMapping</span> 使用的请求方式类型，即 GET 或 POST。<br> <br> <br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自定义</title>
    <link href="/blog/2021/01/31/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    <url>/blog/2021/01/31/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义-Servlet"><a href="#自定义-Servlet" class="headerlink" title="自定义 Servlet"></a>自定义 Servlet</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"> 编写 Servlet<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>doPost(req, resp);<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>resp.getWriter().write(<span class="hljs-string">&quot;自定义 Servlet&quot;</span>);<br>&#125;<br><br>&#125;<br> <br>注册 Servlet<br>将 Servelt 注册成 Bean。在上文创建的 WebConfig 类中添加如下代码：<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">servletRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> ServletTest(),<span class="hljs-string">&quot;/servletTest&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下:<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboot-web-04_1567661032166.jpg" alt="springboot-web-04"></p><h1 id="自定义过滤器-第三方过滤器"><a href="#自定义过滤器-第三方过滤器" class="headerlink" title="自定义过滤器/第三方过滤器"></a>自定义过滤器/第三方过滤器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">编写过滤器<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;=======初始化过滤器=========&quot;</span>);<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br> <br><span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br> <br>filterChain.doFilter(request, response);<br> <br>System.out.println(<span class="hljs-string">&quot;filter 耗时：&quot;</span> + (System.currentTimeMillis() - start));<br> <br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;=======销毁过滤器=========&quot;</span>);<br>&#125;<br> <br>&#125;<br> <br> 注册过滤器<br>要是该过滤器生效，有两种方式：<br><span class="hljs-number">1.</span>使用 <span class="hljs-meta">@Component</span> 注解<br><span class="hljs-number">2.</span>添加到过滤器链中，此方式适用于使用第三方的过滤器。将过滤器写到 WebConfig 类中，如下：<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">timeFilter</span><span class="hljs-params">()</span> </span>&#123;<br>FilterRegistrationBean registrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br><br>TimeFilter timeFilter = <span class="hljs-keyword">new</span> TimeFilter();<br>registrationBean.setFilter(timeFilter);<br><br>List&lt;String&gt; urls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>urls.add(<span class="hljs-string">&quot;/*&quot;</span>);<br>registrationBean.setUrlPatterns(urls);<br><br><span class="hljs-keyword">return</span> registrationBean;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>结果如下:<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboot-web-05_1567661159541.jpg" alt="springboot-web-05"></p><h1 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">编写监听器<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListenerTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;监听器初始化...&quot;</span>);<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent sce)</span> </span>&#123;<br> <br>&#125;<br> <br>&#125;<br> <br>注册监听器<br>注册监听器为 Bean，在 WebConfig 配置类中添加如下代码：<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ServletListenerRegistrationBean&lt;ListenerTest&gt; <span class="hljs-title">servletListenerRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletListenerRegistrationBean&lt;ListenerTest&gt;(<span class="hljs-keyword">new</span> ListenerTest());<br>&#125;<br> <br>针对自定义 Servlet、Filter 和 Listener 的配置，还有另一种方式：<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootWebApplication</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextInitializer</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    <span class="hljs-comment">// 配置 Servlet</span><br>        servletContext.addServlet(<span class="hljs-string">&quot;servletTest&quot;</span>,<span class="hljs-keyword">new</span> ServletTest())<br>          .addMapping(<span class="hljs-string">&quot;/servletTest&quot;</span>);<br>        <span class="hljs-comment">// 配置过滤器</span><br>        servletContext.addFilter(<span class="hljs-string">&quot;timeFilter&quot;</span>,<span class="hljs-keyword">new</span> TimeFilter())<br>          .addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST),<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-comment">// 配置监听器</span><br>        servletContext.addListener(<span class="hljs-keyword">new</span> ListenerTest());<br>    &#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(SpringbootWebApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下:<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboot-web-06_1567661262946.jpg" alt="springboot-web-06"></p><h1 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">编写拦截器<br>使用 <span class="hljs-meta">@Component</span> 让 Spring 管理其生命周期：<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>System.out.println(<span class="hljs-string">&quot;========preHandle=========&quot;</span>);<br>System.out.println(((HandlerMethod)handler).getBean().getClass().getName());<br>System.out.println(((HandlerMethod)handler).getMethod().getName());<br><br>request.setAttribute(<span class="hljs-string">&quot;startTime&quot;</span>, System.currentTimeMillis());<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;<br> <br>System.out.println(<span class="hljs-string">&quot;========postHandle=========&quot;</span>);<br>Long start = (Long) request.getAttribute(<span class="hljs-string">&quot;startTime&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;耗时:&quot;</span>+(System.currentTimeMillis() - start));<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;<br> <br>System.out.println(<span class="hljs-string">&quot;========afterCompletion=========&quot;</span>);<br>Long start = (Long) request.getAttribute(<span class="hljs-string">&quot;startTime&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;耗时:&quot;</span>+(System.currentTimeMillis() - start));<br><br>System.out.println(exception);<br>&#125;<br> <br>&#125;<br> <br>注册拦截器<br>编写拦截器后，我们还需要将其注册到拦截器链中，如下配置：<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span></span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> TimeInterceptor timeInterceptor;<br><br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>registry.addInterceptor(timeInterceptor);<br>&#125;<br> <br>&#125;<br> <br></code></pre></td></tr></table></figure><p>请求一个 controller ，结果如下：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboot-web-07_1567661364759.jpg" alt="springboot-web-07"></p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Web-Fastjson</title>
    <link href="/blog/2021/01/31/SpringBoot-Web-Fastjson/"/>
    <url>/blog/2021/01/31/SpringBoot-Web-Fastjson/</url>
    
    <content type="html"><![CDATA[<h1 id="整合模板引擎"><a href="#整合模板引擎" class="headerlink" title="整合模板引擎"></a>整合模板引擎</h1><p>由于 jsp 不被 SpringBoot 推荐使用，所以模板引擎主要介绍 Freemarker 和 Thymeleaf。</p><h2 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">添加 Freemarker 依赖<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>添加 Freemarker 模板配置<br>在 application.properties 中添加如下内容：<br>spring.freemarker.allow-request-override=<span class="hljs-keyword">false</span><br>spring.freemarker.cache=<span class="hljs-keyword">true</span><br>spring.freemarker.check-template-location=<span class="hljs-keyword">true</span><br>spring.freemarker.charset=UTF-<span class="hljs-number">8</span><br>spring.freemarker.content-type=text/html<br>spring.freemarker.expose-request-attributes=<span class="hljs-keyword">false</span><br>spring.freemarker.expose-session-attributes=<span class="hljs-keyword">false</span><br>spring.freemarker.expose-spring-macro-helpers=<span class="hljs-keyword">false</span><br>spring.freemarker.prefix=<br>spring.freemarker.suffix=.ftl<br> <br>Freemarker 案例演示<br>在 controller 包中创建 FreemarkerController：<br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;freemarker&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkerController</span> </span>&#123;<br> <br><span class="hljs-meta">@RequestMapping(&quot;hello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span> </span>&#123;<br><br>map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;Hello Freemarker&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br>&#125;<br>在 templates 目录中创建名为 hello.ftl 文件，内容如下：<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;zh&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;link href=<span class="hljs-string">&quot;/css/index.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>/&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>    &lt;h2&gt;$&#123;msg&#125;&lt;/h2&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br> <br></code></pre></td></tr></table></figure><h3 id="结果如下："><a href="#结果如下：" class="headerlink" title="结果如下："></a>结果如下：</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboog-5-1_1567562182671.jpg" alt="springboog-5-1"></p><h2 id="整合-Thymeleaf"><a href="#整合-Thymeleaf" class="headerlink" title="整合 Thymeleaf"></a>整合 Thymeleaf</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">添加 Thymeleaf 依赖<br>在 pom.xml 文件中添加：<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br> <br>添加 Thymeleaf 模板配置<br>在 application.properties 中添加如下内容：<br>spring.thymeleaf.cache=<span class="hljs-keyword">true</span><br>spring.thymeleaf.prefix=classpath:/templates/<br>spring.thymeleaf.suffix=.html<br>spring.thymeleaf.mode=HTML5<br>spring.thymeleaf.encoding=UTF-<span class="hljs-number">8</span><br>spring.thymeleaf.content-type=text/html<br>上述配置都是默认值。<br> <br>Thymeleaf 案例演示<br>在 controller 包中创建 ThymeleafController:<br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;thymeleaf&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafController</span> </span>&#123;<br> <br><span class="hljs-meta">@RequestMapping(&quot;hello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span> </span>&#123;<br>map.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;Hello Thymeleaf&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br>&#125;<br> <br>在 template 目录下创建名为 hello.html 的文件，内容如下：<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;zh&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;link href=<span class="hljs-string">&quot;/css/index.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>/&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>    &lt;h2 th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/h2&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br> <br></code></pre></td></tr></table></figure><h3 id="结果如下：-1"><a href="#结果如下：-1" class="headerlink" title="结果如下："></a>结果如下：</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboog-5-2_1567562330507.jpg" alt="springboog-5-2"></p><h2 id="整合-Fastjson"><a href="#整合-Fastjson" class="headerlink" title="整合 Fastjson"></a>整合 Fastjson</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java">添加依赖<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>    &lt;version&gt;1.2.35&lt;/version&gt;<br>&lt;/dependency&gt;<br> <br>整合 Fastjson<br>创建一个配置管理类 WebConfig ，如下：<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> </span>&#123;<br> <br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> HttpMessageConverters <span class="hljs-title">fastJsonHttpMessageConverters</span><span class="hljs-params">()</span> </span>&#123;<br>FastJsonHttpMessageConverter fastJsonHttpMessageConverter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();<br> <br>FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();<br>fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);<br><br>fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);<br><br>HttpMessageConverter&lt;?&gt; converter = fastJsonHttpMessageConverter;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpMessageConverters(converter);<br> <br>&#125;<br>&#125;<br> <br>演示案例：<br>创建一个实体类 User： 记得get set<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br> <br><span class="hljs-keyword">private</span> Integer id;<br><br><span class="hljs-keyword">private</span> String username;<br><br><span class="hljs-keyword">private</span> String password;<br><br><span class="hljs-meta">@JSONField(format=&quot;yyyy-MM-dd&quot;)</span><br><span class="hljs-keyword">private</span> Date birthday;<br> <br>&#125;<br> <br>创建控制器类 FastjsonController :<br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;fastjson&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastJsonController</span> </span>&#123;<br> <br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>User user = <span class="hljs-keyword">new</span> User();<br><br>user.setId(<span class="hljs-number">1</span>);<br>user.setUsername(<span class="hljs-string">&quot;jack&quot;</span>);<br>user.setPassword(<span class="hljs-string">&quot;jack123&quot;</span>);<br>user.setBirthday(<span class="hljs-keyword">new</span> Date());<br><br><span class="hljs-keyword">return</span> user;<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h3 id="结果如下图："><a href="#结果如下图：" class="headerlink" title="结果如下图："></a>结果如下图：</h3><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/springboot-06-1_1567562545811.jpg" alt="springboot-06-1">日期格式与我们修改的内容格式一致，说明 Fastjson 整合成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Fastjson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot配置logback</title>
    <link href="/blog/2021/01/31/SpringBoot%E9%85%8D%E7%BD%AElogback/"/>
    <url>/blog/2021/01/31/SpringBoot%E9%85%8D%E7%BD%AElogback/</url>
    
    <content type="html"><![CDATA[<h1 id="配置日志文件"><a href="#配置日志文件" class="headerlink" title="配置日志文件"></a>配置日志文件</h1><p>spring boot 默认会加载 classpath:logback-spring.xml 或者 classpath:logback-spring.groovy。</p><p>如需要自定义文件名称，在 application.properties 中配置 logging.config 选项即可。</p><p>在 src/main/resources 下创建 logback-spring.xml 文件，内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;configuration&gt;<br>    &lt;!-- 文件输出格式 --&gt;<br>    &lt;property name=<span class="hljs-string">&quot;PATTERN&quot;</span> value=<span class="hljs-string">&quot;%-12(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;) |-%-5level [%thread] %c [%L] -| %msg%n&quot;</span> /&gt;<br>    &lt;!-- test文件路径 --&gt;<br>    &lt;property name=<span class="hljs-string">&quot;TEST_FILE_PATH&quot;</span> value=<span class="hljs-string">&quot;d:/test.log&quot;</span> /&gt;<br>    &lt;!-- pro文件路径 --&gt;<br>    &lt;property name=<span class="hljs-string">&quot;PRO_FILE_PATH&quot;</span> value=<span class="hljs-string">&quot;/opt/test/log&quot;</span> /&gt;<br> <br>    &lt;!-- 开发环境 --&gt;<br>    &lt;springProfile name=<span class="hljs-string">&quot;dev&quot;</span>&gt;<br>        &lt;appender name=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;<br>            &lt;encoder&gt;<br>                &lt;pattern&gt;$&#123;PATTERN&#125;&lt;/pattern&gt;<br>            &lt;/encoder&gt;<br>        &lt;/appender&gt;<br>        &lt;logger name=<span class="hljs-string">&quot;com.light.springboot&quot;</span> level=<span class="hljs-string">&quot;debug&quot;</span> /&gt;<br>        &lt;root level=<span class="hljs-string">&quot;info&quot;</span>&gt;<br>            &lt;appender-ref ref=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;<br>        &lt;/root&gt;<br>    &lt;/springProfile&gt;<br> <br>    &lt;!-- 测试环境 --&gt;<br>    &lt;springProfile name=<span class="hljs-string">&quot;test&quot;</span>&gt;<br>        &lt;!-- 每天产生一个文件 --&gt;<br>        &lt;appender name=<span class="hljs-string">&quot;TEST-FILE&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;<br>            &lt;!-- 文件路径 --&gt;<br>            &lt;file&gt;$&#123;TEST_FILE_PATH&#125;&lt;/file&gt;<br>            &lt;rollingPolicy <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;<br>                &lt;!-- 文件名称 --&gt;<br>                &lt;fileNamePattern&gt;$&#123;TEST_FILE_PATH&#125;/info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;<br>                &lt;!-- 文件最大保存历史数量 --&gt;<br>                &lt;MaxHistory&gt;100&lt;/MaxHistory&gt;<br>            &lt;/rollingPolicy&gt;<br>            &lt;layout <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;<br>                &lt;pattern&gt;$&#123;PATTERN&#125;&lt;/pattern&gt;<br>            &lt;/layout&gt;<br>        &lt;/appender&gt;<br>        &lt;logger name=<span class="hljs-string">&quot;com.light.springboot&quot;</span> level=<span class="hljs-string">&quot;debug&quot;</span> /&gt;<br>        &lt;root level=<span class="hljs-string">&quot;info&quot;</span>&gt;<br>            &lt;appender-ref ref=<span class="hljs-string">&quot;TEST-FILE&quot;</span> /&gt;<br>        &lt;/root&gt;<br>    &lt;/springProfile&gt;<br> <br>    &lt;!-- 生产环境 --&gt;<br>    &lt;springProfile name=<span class="hljs-string">&quot;prod&quot;</span>&gt;<br>        &lt;appender name=<span class="hljs-string">&quot;PROD_FILE&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;<br>            &lt;file&gt;$&#123;PRO_FILE_PATH&#125;&lt;/file&gt;<br>            &lt;rollingPolicy <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;<br>                &lt;fileNamePattern&gt;$&#123;PRO_FILE_PATH&#125;/warn.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;<br>                &lt;MaxHistory&gt;100&lt;/MaxHistory&gt;<br>            &lt;/rollingPolicy&gt;<br>            &lt;layout <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;<br>                &lt;pattern&gt;$&#123;PATTERN&#125;&lt;/pattern&gt;<br>            &lt;/layout&gt;<br>        &lt;/appender&gt;<br>        &lt;root level=<span class="hljs-string">&quot;warn&quot;</span>&gt;<br>            &lt;appender-ref ref=<span class="hljs-string">&quot;PROD_FILE&quot;</span> /&gt;<br>        &lt;/root&gt;<br>    &lt;/springProfile&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure><p>其中，springProfile 标签的 name 属性对应 application.properties 中的 spring.profiles.active 的配置。</p><p>即 spring.profiles.active 的值可以看作是日志配置文件中对应的 springProfile 是否生效的开关。</p><h1 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h1><p>下面列出 Spring Boot 开发中常用的注解：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">@Configuration                 # 作用于类上，相当于一个 xml 配置文件<br>@Bean                          # 作用于方法上，相当于 xml 配置中的 &lt;bean&gt;<br>@SpringBootApplication         # Spring Boot的核心注解，是一个组合注解，用于启动类上<br>@EnableAutoConfiguration       # 启用自动配置，允许加载第三方 Jar 包的配置<br>@ComponentScan                 # 默认扫描 @SpringBootApplication 所在类的同级目录以及它的子目录<br>@PropertySource                # 加载 properties 文件<br>@Value                         # 将配置文件的属性注入到 Bean 中特定的成员变量<br>@EnableConfigurationProperties # 开启一个特性，让配置文件的属性可以注入到 Bean 中，与 @ConfigurationProperties 结合使用<br>@ConfigurationProperties       # 关联配置文件中的属性到 Bean 中<br>@Import                        # 加载指定 Class 文件，其生命周期被 Spring 管理<br>@ImportResource                # 加载 xml 文件<br></code></pre></td></tr></table></figure><h1 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h1><h2 id="属性装配"><a href="#属性装配" class="headerlink" title="属性装配"></a>属性装配</h2><p>有两种方式：使用 @Value 注解和 Environment 对象。 在 application.properties 中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">ds.userName=root<br>ds.password=tiger<br>ds.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/test</span><br>ds.driverClassName=com.mysql.jdbc.Driver<br> <br>以上是自定义的配置。<br>创建一个配置类，如下：<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Value(&quot;$&#123;ds.userName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br> <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Environment environment;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ds.userName:&quot;</span> + <span class="hljs-keyword">this</span>.userName);<br>        System.out.println(<span class="hljs-string">&quot;ds.password:&quot;</span> + <span class="hljs-keyword">this</span>.environment.getProperty(<span class="hljs-string">&quot;ds.password&quot;</span>));<br>    &#125;<br>&#125;<br> <br>通过 <span class="hljs-meta">@Value</span> 获取 config.userName 配置；通过 environment 获取 config.password 配置。<br> <br>测试：<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConfigurableApplicationContext context = SpringApplication.run(SpringbootApplication.class, args);<br>        context.getBean(WebConfig.class).show();<br>    &#125;<br>&#125;<br> <br>打印结果：<br>userName:root<br>password:tiger<br></code></pre></td></tr></table></figure><h2 id="对象装配"><a href="#对象装配" class="headerlink" title="对象装配"></a>对象装配</h2><p>创建一个封装类： 省略 get set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;ds&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProperties</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> String url;<br> <br>    <span class="hljs-keyword">private</span> String driverClassName;<br> <br>    <span class="hljs-keyword">private</span> String userName;<br> <br>    <span class="hljs-keyword">private</span> String password;<br> <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ds.url=&quot;</span> + <span class="hljs-keyword">this</span>.url);<br>        System.out.println(<span class="hljs-string">&quot;ds.driverClassName=&quot;</span> + <span class="hljs-keyword">this</span>.driverClassName);<br>        System.out.println(<span class="hljs-string">&quot;ds.userName=&quot;</span> + <span class="hljs-keyword">this</span>.userName);<br>        System.out.println(<span class="hljs-string">&quot;ds.password=&quot;</span> +<span class="hljs-keyword">this</span>.password);<br>    &#125;<br> <br>&#125;<br>测试：<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConfigurableApplicationContext context = SpringApplication.run(SpringbootApplication.class, args);<br>        context.getBean(DataSourceProperties.class).show();<br>    &#125;<br>&#125;<br> <br>打印结果<br>ds.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/test</span><br>ds.driverClassName=com.mysql.jdbc.Driver<br>ds.userName=root<br>ds.password=tiger<br></code></pre></td></tr></table></figure><h1 id="打包运行"><a href="#打包运行" class="headerlink" title="打包运行"></a>打包运行</h1><p>打包的形式有两种：jar 和 war。</p><h2 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h2><p>默认情况下，通过 maven 执行 package 命令后，会生成 jar 包，且该 jar 包会内置了 tomcat 容器，因此我们可以通过 java -jar 就可以运行项目</p><h2 id="war"><a href="#war" class="headerlink" title="war"></a>war</h2><p>让 SpringbootApplication 类继承 SpringBootServletInitializer 并重写 configure 方法，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder application)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> application.sources(SpringbootApplication.class);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringbootApplication.class, args);<br>    &#125;<br>&#125;<br>修改 pom.xml 文件，将 jar 改成 war，如下：<br>&lt;packaging&gt;war&lt;/packaging&gt;<br>移除内置 tomcat：<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;exclusions&gt;<br>&lt;exclusion&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;<br>&lt;/exclusion&gt;<br>&lt;/exclusions&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Servlet API --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br>&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br>&lt;version&gt;3.1.0&lt;/version&gt;<br>&lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>打包成功后，将 war 包部署到 tomcat 容器中运行即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>logback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基本命令加RabbitMq安装</title>
    <link href="/blog/2021/01/25/Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%8A%A0RabbitMq%E5%AE%89%E8%A3%85/"/>
    <url>/blog/2021/01/25/Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%8A%A0RabbitMq%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<ol><li>查看安装的Docker信息 docker info</li><li>查看Docker版本 docker version</li></ol><h1 id="镜像类命令"><a href="#镜像类命令" class="headerlink" title="镜像类命令"></a>镜像类命令</h1><ol><li>查看镜像 docker images</li><li>删除镜像 根据imageId或者imageName:tag删除本地镜像 docker rmi &lt;imageId|imageName:tag&gt;</li><li>拉取镜像 docker pull <a href="imagename:tag">imageName:tag</a></li><li>上传镜像到仓库 docker push <a href="imagename:tag">imageName:tag</a></li><li>保存镜像为tar包 docker save registry:latest &gt; /data/registry.tar</li><li>搜索镜像 docker search</li><li>导入镜像（用本地的tar包导入镜像） docker load –i</li><li>给镜像重新打tag docker tag <a href="imagename:tag">imageName:tag</a></li><li>构建镜像 docker build -t<img src="" alt="img">&lt;&gt;</li></ol><h1 id="容器类命令"><a href="#容器类命令" class="headerlink" title="容器类命令"></a>容器类命令</h1><ol><li>查询正在运行的容器 查询所有容器 docker ps docker ps -a</li><li>删除容器 删除的容器只能是停止的，非正在运行的容器 docker rm &lt;containerId|containerName&gt;</li><li>开启停止的容器 docker start &lt;containerId|containerName&gt;</li><li>停止容器 docker stop &lt;containerId|containerName&gt;</li><li>杀死容器 docker kill &lt;containerId|containerName&gt;</li><li>从容器中取日志 docker logs &lt;containerId|containerName&gt;</li><li>显示一个运行的容器里面的进程信息 docker top &lt;containerId|containerName&gt;</li><li>重启容器 docker restart &lt;containerId|containerName&gt;</li><li>从容器里面拷贝文件/目录到本地一个路径 docker cp &lt;containerId|containerName&gt;:/container_path to_path</li><li>启动容器 在容器中运行”echo”命令，输出”helloword” docker run image_name echo “hello word”</li><li>交互式进入容器中 docker run -i -t image_name /bin/bash</li><li>后台运行容器使用–d参数(后台运行) docker run -d image_name</li></ol><h1 id="Docker下安装rabbitmq"><a href="#Docker下安装rabbitmq" class="headerlink" title="Docker下安装rabbitmq"></a>Docker下安装rabbitmq</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">拉取镜像 <br>docker pull rabbitmq:3-management<br> <br>启动镜像<br>docker <span class="hljs-builtin-name">run</span> -d --hostname my-rabbit --name rabbit -v /data/rabbitmq:/var/lib/rabbitmq -e <span class="hljs-attribute">RABBITMQ_DEFAULT_USER</span>=admin -e <span class="hljs-attribute">RABBITMQ_DEFAULT_PASS</span>=admin -p 15672:15672 -p 5672:5672 rabbitmq:3-management<br></code></pre></td></tr></table></figure><p>完成后访问：<a href="http://ip:15672/">http://ip:15672</a> 用户名admin 密码 admin 也可以自己设置密码</p><p>是不是很简单 我自己在物理机上装了好几次 还是没有成功 docker 两句命令</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>mq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot入门设置</title>
    <link href="/blog/2021/01/25/SpringBoot%E5%85%A5%E9%97%A8%E8%AE%BE%E7%BD%AE/"/>
    <url>/blog/2021/01/25/SpringBoot%E5%85%A5%E9%97%A8%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。好就对了</p><h1 id="环境搭建maven项目"><a href="#环境搭建maven项目" class="headerlink" title="环境搭建maven项目"></a>环境搭建maven项目</h1><h2 id="pom-xml-中"><a href="#pom-xml-中" class="headerlink" title="pom.xml 中"></a>pom.xml 中</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 定义公共资源版本 --&gt;<br>&lt;parent&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>    &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;<br>    &lt;relativePath /&gt;<br>&lt;/parent&gt;<br> <br>&lt;properties&gt;<br>    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br>    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;<br>    &lt;java.version&gt;1.8&lt;/java.version&gt;<br>&lt;/properties&gt;<br> <br>&lt;dependencies&gt;<br>    &lt;!-- 上边引入 parent，因此 下边无需指定版本 --&gt;<br>    &lt;!-- 包含 mvc,aop 等jar资源 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br> <br>&lt;build&gt;<br>    &lt;plugins&gt;<br>        &lt;plugin&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>        &lt;/plugin&gt;<br>    &lt;/plugins&gt;<br>&lt;/build&gt;<br></code></pre></td></tr></table></figure><h2 id="创建目录和配置文件"><a href="#创建目录和配置文件" class="headerlink" title="创建目录和配置文件"></a>创建目录和配置文件</h2><p>创建 src/main/resources 源文件目录，并在该目录下创建 application.properties 文件、static 和 templates 的文件夹。</p><p>application.properties：用于配置项目运行所需的配置数据。</p><p>static：用于存放静态资源，如：css、js、图片等。</p><p>templates：用于存放模板文件。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190902-094158@2x_1567388546384.png" alt="WX20190902-094158@2x"></p><h2 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h2><p>放在包下 com.cxy.template 不用单独建文件夹放 保持同级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 该注解指定项目为springboot，由此类当作程序入口</span><br><span class="hljs-comment"> 自动装配 web 依赖的环境</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">**/</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringbootApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>在com.cxy.template 下创建一个Controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br> <br>    <span class="hljs-meta">@GetMapping(&quot;/helloworld&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloworld</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;helloworld&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打开浏览器访问 <a href="http://localhost:8080/helloworld">http://localhost:8080/helloworld</a> 这里建议增加热部署插件 <a href="https://bk.cuixiaoyan.xyz/archives/jrebel">idea 激活 jrebel</a></p><h2 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h2><p>pplication.properties 是 springboot 在运行中所需要的配置信息。</p><p>当我们在开发阶段，使用自己的机器开发，测试的时候需要用的测试服务器测试，上线时使用正式环境的服务器。</p><p>这三种环境需要的配置信息都不一样，当我们切换环境运行项目时，需要手动的修改多出配置信息，非常容易出错。</p><p>为了解决上述问题，springboot 提供多环境配置的机制，让开发者非常容易的根据需求而切换不同的配置环境。</p><p>在 src/main/resources 目录下创建三个配置文件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">application-dev.properties：用于开发环境<br>application-test.properties：用于测试环境<br>application-prod.properties：用于生产环境<br> <br>我们可以在这个三个配置文件中设置不同的信息，application.properties 配置公共的信息。<br> <br>在 application.properties 中配置：<br>spring.profiles.active=dev<br> <br></code></pre></td></tr></table></figure><p>切换项目启动的环境不仅对读取配置文件信息有效，也可以对 Bean 有效。</p><p>当我们需要对不同环境使用不同的 Bean 时，可以通过 @Profile 注解进行区分，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanConfiguration</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Profile(&quot;dev&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Runnable <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开发环境使用的 Bean&quot;</span>);<br>        <span class="hljs-keyword">return</span> () -&gt; &#123;&#125;;<br>    &#125;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Profile(&quot;test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Runnable <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;测试环境使用的 Bean&quot;</span>);<br>        <span class="hljs-keyword">return</span> () -&gt; &#123;&#125;;<br>    &#125;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Profile(&quot;pro&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Runnable <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;生成环境使用的 Bean&quot;</span>);<br>        <span class="hljs-keyword">return</span> () -&gt; &#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当启动项目后，Spring 会根据 spring.profiles.active 的值实例化对应的 Bean。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7安装Docker</title>
    <link href="/blog/2021/01/25/centos7%E5%AE%89%E8%A3%85Docker/"/>
    <url>/blog/2021/01/25/centos7%E5%AE%89%E8%A3%85Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><p>全凭自己理解 我又不是专业的运维 搞这个干嘛 这种想法可不行哦</p><ol><li>安装软件方便快捷 例如rabbitmq 之前在本地怎么安装都访问不到web管理页面 但是docker就两句话 最后的效果是一样的</li><li>能节省服务器一部分资源 我的服务器确实太小了</li><li>而且像我这种小白白 安装错了 直接停止 删除镜像就可以了</li><li>安装在服务器上 恐怕要去谷歌 如何完全卸载xxx啦</li></ol><h1 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h1><p>目前，CentOS 仅发行版本中的内核支持 Docker。 Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。 Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p><p><strong>两种方式 二选一</strong></p><h2 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#查看你当前的内核版本</span><br>uname -r<br><br><span class="hljs-meta">#安装 Docker</span><br>yum -y install docker<br><br><span class="hljs-meta">#启动 Docker 后台服务</span><br>service docker start<br><br><span class="hljs-meta">#测试运行 hello-world,由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。</span><br>docker run hello-world<br></code></pre></td></tr></table></figure><h1 id="使用脚本安装-Docker"><a href="#使用脚本安装-Docker" class="headerlink" title="使用脚本安装 Docker"></a>使用脚本安装 Docker</h1><p>1、使用 sudo 或 root 权限登录 Centos。 2、确保 yum 包更新到最新。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#确保 yum 包更新到最新</span><br>sudo yum update<br><br><span class="hljs-meta">#执行 Docker 安装脚本,执行这个脚本会添加 docker.repo 源并安装 Docker。</span><br>curl -fsSL https:<span class="hljs-comment">//get.docker.com/ | sh</span><br><br><span class="hljs-meta">#启动 Docker 进程</span><br>sudo service docker start<br><br><span class="hljs-meta">#验证 docker 是否安装成功并在容器中执行一个测试的镜像</span><br>sudo docker run hello-world<br></code></pre></td></tr></table></figure><h2 id="查看Docker版本"><a href="#查看Docker版本" class="headerlink" title="查看Docker版本"></a>查看Docker版本</h2><p>docker version<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190828-091709@2x_1566955051972.png" alt="WX20190828-091709@2x"></p><p>到此安装成功 最后推荐一款 管理界面 个人使用是免费的 足够啦<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190828-092421@2x_1566955505633.png" alt="WX20190828-092421@2x"></p><p><a href="https://bk.cuixiaoyan.xyz/archives/docker#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8docker">为什么要用Docker</a><a href="https://bk.cuixiaoyan.xyz/archives/docker#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">前提条件</a><a href="https://bk.cuixiaoyan.xyz/archives/docker#%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85-docker">使用脚本安装 Docker</a><a href="https://bk.cuixiaoyan.xyz/archives/docker#%E6%9F%A5%E7%9C%8Bdocker%E7%89%88%E6%9C%AC">查看Docker版本</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中的数学工具类Math</title>
    <link href="/blog/2021/01/24/java%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E7%B1%BBMath/"/>
    <url>/blog/2021/01/24/java%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E7%B1%BBMath/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</p><h2 id="基本的方法"><a href="#基本的方法" class="headerlink" title="基本的方法"></a>基本的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-keyword">double</span> num)</span></span>;获取绝对值。有多种重载，absolutely绝对地<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">ceil</span><span class="hljs-params">(<span class="hljs-keyword">double</span> num)</span></span>;向上取整，ceil是天花板的意思<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">floor</span><span class="hljs-params">(<span class="hljs-keyword">double</span> num)</span></span>;向下取整，floor是地板的意思<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">round</span><span class="hljs-params">(<span class="hljs-keyword">double</span> num)</span></span>;四舍六入五成双（看下面代码的注释），round有大约，完整的意思<br> <br></code></pre></td></tr></table></figure><h2 id="四种方法一起通过代码演示一遍"><a href="#四种方法一起通过代码演示一遍" class="headerlink" title="四种方法一起通过代码演示一遍"></a>四种方法一起通过代码演示一遍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//abs方法，取绝对值</span><br>        System.out.println(Math.abs(<span class="hljs-number">3.14</span>)); <span class="hljs-comment">//3.14</span><br>        System.out.println(Math.abs(<span class="hljs-number">0</span>));    <span class="hljs-comment">//0</span><br>        System.out.println(Math.abs(-<span class="hljs-number">2.2</span>)); <span class="hljs-comment">//2.2</span><br> <br>        System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br> <br>        <span class="hljs-comment">//ceil方法，向上取整，往大的靠</span><br>        System.out.println(Math.ceil(<span class="hljs-number">3.2</span>));  <span class="hljs-comment">//4.0</span><br>        System.out.println(Math.ceil(<span class="hljs-number">3.8</span>));  <span class="hljs-comment">//4.0</span><br>        System.out.println(Math.ceil(-<span class="hljs-number">3.2</span>)); <span class="hljs-comment">//-3.0</span><br>        System.out.println(Math.ceil(-<span class="hljs-number">3.8</span>)); <span class="hljs-comment">//-3.0</span><br> <br>        System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br>        <br>        <span class="hljs-comment">//floor方法，向下取整，往小的靠</span><br>        System.out.println(Math.floor(<span class="hljs-number">3.2</span>));  <span class="hljs-comment">//3.0</span><br>        System.out.println(Math.floor(<span class="hljs-number">3.8</span>));  <span class="hljs-comment">//3.0</span><br>        System.out.println(Math.floor(-<span class="hljs-number">3.2</span>)); <span class="hljs-comment">//-4.0</span><br>        System.out.println(Math.floor(-<span class="hljs-number">3.8</span>)); <span class="hljs-comment">//-4.0</span><br> <br>        System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br> <br>        <span class="hljs-comment">//【注意，面试高频】round方法，四舍 六入 五成双</span><br>        <span class="hljs-comment">//先看看四舍六入，如果出现负数，先转成正数，再四舍六入，最后加上负号</span><br>        System.out.println(Math.round(<span class="hljs-number">3.4</span>));  <span class="hljs-comment">//3</span><br>        System.out.println(Math.round(<span class="hljs-number">3.6</span>));  <span class="hljs-comment">//4</span><br>        System.out.println(Math.round(-<span class="hljs-number">3.4</span>)); <span class="hljs-comment">//-3</span><br>        System.out.println(Math.round(-<span class="hljs-number">3.6</span>)); <span class="hljs-comment">//-4</span><br>        <span class="hljs-comment">//五成双是什么意思呢？当出现0.5结尾的时候，就给它再加上+0.5，5不就成双了</span><br>        <span class="hljs-comment">//接着再对相加的结果进行floor运算</span><br>        System.out.println(Math.round(-<span class="hljs-number">2.5</span>));  <span class="hljs-comment">//-2</span><br>        System.out.println(Math.floor(-<span class="hljs-number">2.5</span> + <span class="hljs-number">0.5</span>));  <span class="hljs-comment">//与Math.round(-2.5)结果一致</span><br> <br>System.out.println(Math.round(<span class="hljs-number">2.5</span>));  <span class="hljs-comment">//3</span><br>        System.out.println(Math.floor(<span class="hljs-number">2.5</span> + <span class="hljs-number">0.5</span>));  <span class="hljs-comment">//与Math.round(2.5)结果一致</span><br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="圆周率Math-PI"><a href="#圆周率Math-PI" class="headerlink" title="圆周率Math.PI"></a>圆周率Math.PI</h2><p>在Math类的源码中，我们可以看到，它自定义的圆周率 PI = 3.14159265358979323846</p><p>以后的计算如果需要用到PI，尽量用已经定义好的圆周率，非常精确</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql入门</title>
    <link href="/blog/2021/01/24/mysql%E5%85%A5%E9%97%A8/"/>
    <url>/blog/2021/01/24/mysql%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="索引的概念"><a href="#索引的概念" class="headerlink" title="索引的概念"></a>索引的概念</h1><p>是数据库对象，实现数据库的快速查询</p><p>使用索引的原因：实现数据库的快速查询，提高查询速度</p><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <br><span class="hljs-number">1</span>，普通索引<br>最基本的索引，对字段数据的类型和值没有任何限制，数据类型可以任意，字段的值可以为空也可以重复。<br> <br><span class="hljs-number">2</span>，主键索引<br>给主键字段添加的索引、<br>主键特点：唯一且非空<br> <br><span class="hljs-number">3</span>，唯一索引<br>给唯一字段添加的索引<br>唯一索引和主键索引的区别：<br>唯一索引：只有唯一，可以有空值<br>主键索引：唯一且非空<br><br><span class="hljs-number">4</span>，全文索引<br>适用于给一大串文本添加的索引，只可以给字符串数据类型添加<br>字符串数据类型（<span class="hljs-type">char</span> <span class="hljs-type">varchar</span> text）<br><br><span class="hljs-number">5</span>，空间索引<br>字段的数据类型只能是空间数据类型，且改字段的值必须为 非空 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>空间数据类型 geometry point linestring polygon<br><br><span class="hljs-number">6</span>，复合索引<br>给多个字段添加的索引<br>注意：如果使用了复合索引，查询条件中只有使用了第一个字段，该索引才会被触发<br>例如（id name）只有查询条件中使用了id字段，索引才会被使用<br>如果查询条件只有name字段，则索引不会被触发<br> <br></code></pre></td></tr></table></figure><h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>，自动创建索引<br>在创建表的时候，给表添加了主键和唯一约束时，数据库给自动的给主键约束和唯一约束创建对应的主键索引和唯一索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">unique</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br>查询表中的索引语法为：<span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br><br><span class="hljs-number">2</span>，手动创建索引<br> <br>a，创建表时创建索引<br><br><br><span class="hljs-number">1</span>，创建普通索引、<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 字段类型<span class="hljs-number">1</span>,<br>....,<br>index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>])<br>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>index (sno)<br>);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br><br><span class="hljs-number">2</span>，唯一索引的创建<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 字段类型<span class="hljs-number">1</span>,<br>....,<br><span class="hljs-keyword">unique</span> index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>])<br>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br><span class="hljs-keyword">unique</span> index (sno)<br>);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br><span class="hljs-number">3</span>，创建主键索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>表名(<br>字段名<span class="hljs-number">1</span> 字段类型<span class="hljs-number">1</span>,<br>....,<br><span class="hljs-keyword">primary</span> index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>])<br>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br><span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> (sno)<br>);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br> <br><span class="hljs-number">4</span>，创建全文索引、只有：只能给字符串数据类型添加<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 字段类型<span class="hljs-number">1</span>,<br>....,<br>fulltext index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>])<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>sinfo <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),<br>fulltext key (sinfo)<br>);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br> <br><span class="hljs-number">5</span>，创建复合索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 字段类型<span class="hljs-number">1</span>,<br>....,<br>index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名<span class="hljs-number">1</span>[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>], 字段名<span class="hljs-number">2</span>[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>], 字段名<span class="hljs-number">3</span>[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>])<br>);<br><br><span class="hljs-comment">---创建表index_student,给sno 和 sname 添加复合索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>sinfo <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),<br>index (sno,sname)<br>);<br> <br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br><span class="hljs-number">6</span>，创建空间索引<br>注意：只能给空间数据类型添加，且该字段的值不能为空 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>字段名<span class="hljs-number">1</span> 字段类型<span class="hljs-number">1</span>,<br>....,<br>spatial index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>])<br>);<br><br><span class="hljs-comment">---创建表index_student,给sloc字段（是point字段类型）添加空间索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>sinfo <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),<br>sloc point <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>spatial index (sloc)<br>);<br><br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br><br>b，创建表后使用“<span class="hljs-keyword">create</span> index ”创建索引<br><span class="hljs-keyword">create</span> [ <span class="hljs-keyword">unique</span><span class="hljs-operator">|</span>fulltext<span class="hljs-operator">|</span>spatial ] index 索引名称 [索引的类型] <span class="hljs-keyword">on</span> 表名 (字段名<span class="hljs-number">1</span>[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>], 字段名<span class="hljs-number">2</span>[(长度)] [<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>])<br> <br>需要注意的是：使用<span class="hljs-keyword">create</span> index这种创建索引的方式不能创建主键索引<br> <br>(<span class="hljs-number">1</span>)，创建普通索引<br><span class="hljs-comment">---创建表index_student,给表sno添加普通索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br><span class="hljs-keyword">create</span> index index_student_sno <span class="hljs-keyword">on</span> index_student (sno);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>(<span class="hljs-number">2</span>)，创建唯一索引<br><span class="hljs-comment">---创建表index_student,给表sname添加唯一索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index index_student_sname <span class="hljs-keyword">on</span> index_student (sname);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>(<span class="hljs-number">3</span>)，创建全文索引 fulltext<br><span class="hljs-comment">---创建表index_student,给表sinfo添加全文索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>sinfo <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>)<br>);<br><span class="hljs-keyword">create</span> fulltext index index_student_sinfo <span class="hljs-keyword">on</span> index_student (sinfo);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br><br> <br>(<span class="hljs-number">4</span>)，创建空间索引<br><span class="hljs-comment">---创建表index_student,给表sloc添加空间索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>sloc point <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><span class="hljs-keyword">create</span> spatial index index_student_sloc <span class="hljs-keyword">on</span> index_student (sloc);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>(<span class="hljs-number">5</span>)，创建复合索引<br><span class="hljs-comment">---创建表index_student,给表sno和sname添加复合索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br><span class="hljs-keyword">create</span> index index_student_sno_sname <span class="hljs-keyword">on</span> index_student (sno, sname);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>c，给已有表添加索引“<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>”<br><br>(<span class="hljs-number">1</span>)添加普通索引<br>语法为：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名 [长度] [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>])<br><span class="hljs-comment">---创建表index_student,给表sno添加普通索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> index_student <span class="hljs-keyword">add</span> index (sno)<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>(<span class="hljs-number">2</span>)添加唯一索引<br>语法为：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> [index<span class="hljs-operator">|</span>key] [索引名] [索引类型] (字段名 [长度] [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>])<br><span class="hljs-comment">---创建表index_student,给表sname添加唯一索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> index_student <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> index (sname);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>(<span class="hljs-number">3</span>)添加主键索引<br>语法为：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> [index<span class="hljs-operator">|</span>key] [索引名] [索引类型] (字段名 [长度] [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>])<br><span class="hljs-comment">---创建表index_student,给表sno添加主键索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> index_student <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> (sno);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br><br><br>(<span class="hljs-number">4</span>)添加全文索引<br>语法为：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> fulltext [index<span class="hljs-operator">|</span>key] [索引名] [索引类型] (字段名 [长度] [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>])<br><span class="hljs-comment">---创建表index_student,给表sinfo添加全文索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>sinfo <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>)<br>);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> index_student <span class="hljs-keyword">add</span> fulltext index(sinfo);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>(<span class="hljs-number">5</span>)添加空间索引<br>语法为：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> spatial [index<span class="hljs-operator">|</span>key] [索引名] [索引类型] (字段名 [长度] [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>])<br><span class="hljs-comment">---创建表index_student,给表sloc添加空间索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>),<br>sloc point <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> index_student <span class="hljs-keyword">add</span> spatial index (sloc);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br>(<span class="hljs-number">6</span>)添加复合索引<br>语法为：<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> index<span class="hljs-operator">|</span>key [索引名] [索引类型] (字段名<span class="hljs-number">1</span> [长度] [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>], 字段名<span class="hljs-number">2</span> [长度] [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>])<br><span class="hljs-comment">---创建表index_student,给表sno和sname添加复合索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> index_student(<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">5</span>),<br>age <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> index_student <span class="hljs-keyword">add</span> index (sno,sname);<br><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> index_student;<br> <br> <br></code></pre></td></tr></table></figure><h1 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>，使用<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 删除<br>语法为<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> index<span class="hljs-operator">|</span>key 索引名称<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> index_student <span class="hljs-keyword">drop</span> index sno;<br><br><span class="hljs-number">2</span>，使用<span class="hljs-keyword">drop</span> index 删除<br>语法为<span class="hljs-keyword">drop</span> index 索引名称 <span class="hljs-keyword">on</span> 表名<br><br>注意：使用<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 方式不能删除主键索引<br>  删除主键索引的方式为：<br>  a,<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span><br>  b,使用<span class="hljs-keyword">drop</span> index进行删除<br> <br></code></pre></td></tr></table></figure><h1 id="数据的插入"><a href="#数据的插入" class="headerlink" title="数据的插入"></a>数据的插入</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-number">1</span>)为所有字段插入数据<br>语法为：<span class="hljs-keyword">insert</span> [<span class="hljs-keyword">into</span>] 表名 [(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....)] <span class="hljs-keyword">values</span><span class="hljs-operator">|</span><span class="hljs-keyword">value</span> (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3.</span>...)<br><br><span class="hljs-comment">---创建一张表student（sno主键 自动增长 sname 非空 age sex默认男 email唯一）</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> &quot;男&quot;,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span><br>);<br><span class="hljs-comment">---为表中所有字段插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student (sno,sname,age,sex,email) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,&quot;张三&quot;, <span class="hljs-number">20</span>, &quot;男&quot;, &quot;zhangsan@163.com&quot;);<br><br><span class="hljs-comment">---另一种写法表后面不写字段名，则插入值的顺序要与表结构相同</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,&quot;李四&quot;, <span class="hljs-number">21</span>, &quot;女&quot;, &quot;lisi@163.com&quot;);<br><span class="hljs-comment">---查询表student中的数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br> <br> <br> <br>(<span class="hljs-number">2</span>)为指定字段插入数据<br>语法为：<span class="hljs-keyword">insert</span> [<span class="hljs-keyword">into</span>] 表名 (字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....) <span class="hljs-keyword">values</span><span class="hljs-operator">|</span><span class="hljs-keyword">value</span> (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3.</span>...)<br><br><span class="hljs-comment">---创建一张表student（sno主键 自动增长 sname 非空 age sex默认男 email唯一）</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> &quot;男&quot;,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span><br>);<br><span class="hljs-comment">---给表中sname和age插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student (sname,age) <span class="hljs-keyword">values</span> (&quot;王五&quot;, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">---查询表student中的数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br> <br> <br>(<span class="hljs-number">3</span>)使用<span class="hljs-keyword">SET</span>方式插入数据<br>语法为：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 <span class="hljs-keyword">set</span> 字段名<span class="hljs-number">1</span><span class="hljs-operator">=</span>字段值<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span><span class="hljs-operator">=</span>字段值<span class="hljs-number">2</span>,....;<br><br><span class="hljs-comment">---创建一张表student（sno主键 自动增长 sname 非空 age sex默认男 email唯一）</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> &quot;男&quot;,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span><br>);<br><span class="hljs-comment">---使用set方式给表中所有字段插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">set</span> sno<span class="hljs-operator">=</span><span class="hljs-number">4</span>,sname<span class="hljs-operator">=</span>&quot;皮皮&quot;,age<span class="hljs-operator">=</span><span class="hljs-number">17</span>,sex<span class="hljs-operator">=</span>&quot;男&quot;,email<span class="hljs-operator">=</span>&quot;pipi@16.com&quot;;<br><br><span class="hljs-comment">---使用set方式给指定的字段插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">set</span> sname<span class="hljs-operator">=</span>&quot;彬彬&quot;,age<span class="hljs-operator">=</span><span class="hljs-number">2</span>,email<span class="hljs-operator">=</span>&quot;binbin@163.com&quot;;<br><br><span class="hljs-comment">---查询表student中的数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br><br> <br>(<span class="hljs-number">4</span>)同时插入多条数据<br>语法为：<span class="hljs-keyword">insert</span> [<span class="hljs-keyword">into</span>] 表名 [(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....)] <span class="hljs-keyword">values</span><span class="hljs-operator">|</span><span class="hljs-keyword">value</span> (值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3.</span>...),(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3.</span>...),....;<br><br><span class="hljs-comment">---创建一张表student（sno主键 自动增长 sname 非空 age sex默认男 email唯一）</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> &quot;男&quot;,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span><br>);<br><br><span class="hljs-comment">---给所有字段插入多条数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student (sno,sname,age,sex,email) <br><span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>,&quot;小红&quot;,<span class="hljs-number">15</span>,&quot;女&quot;,&quot;xiaohong@163.com&quot;),(<span class="hljs-number">7</span>,&quot;小二&quot;,<span class="hljs-number">17</span>,&quot;男&quot;,&quot;xiaoer@163.com&quot;);<br><br><span class="hljs-comment">---给指定字段插入多条数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student (sname,age,email) <br><span class="hljs-keyword">values</span> (&quot;小花&quot;,<span class="hljs-number">14</span>,&quot;xiaohua@163.com&quot;),(&quot;小强&quot;,<span class="hljs-number">11</span>,&quot;xiaoqiang@163.com&quot;);<br><br><span class="hljs-comment">---查询表student中的数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br> <br> <br> <br>(<span class="hljs-number">5</span>)插入查询结果<br>语法为：<span class="hljs-keyword">insert</span> [<span class="hljs-keyword">into</span>] 表名 (字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....) <span class="hljs-keyword">select</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3.</span>....<span class="hljs-keyword">from</span> 表 <span class="hljs-keyword">where</span> 条件;<br>注意：插入表的字段和查询的字段个数和类型要保持一致<br><br><span class="hljs-comment">---创建一张表student（sno主键 自动增长 sname 非空 age sex默认男 email唯一）</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> &quot;男&quot;,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span><br>);<br><br><span class="hljs-comment">---创建t_student表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> &quot;女&quot;,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span><br>);<br><br><span class="hljs-comment">---将student表中的数据查询结果插入到t_student表中</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_student <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_student;<br> <br> <br></code></pre></td></tr></table></figure><h1 id="数据的更新"><a href="#数据的更新" class="headerlink" title="数据的更新"></a>数据的更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>，更新指定数据<br>语法为：<span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 字段名<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>[,字段名<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>,....] <span class="hljs-keyword">where</span> 条件<br><br><span class="hljs-comment">---创建一张表student（sno主键 自动增长 sname 非空 age sex默认男 email唯一）</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>sno <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>sname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age <span class="hljs-type">int</span>(<span class="hljs-number">8</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> &quot;男&quot;,<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">unique</span><br>);<br><br><span class="hljs-comment">---更新指定数据</span><br><span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> sname<span class="hljs-operator">=</span>&quot;张老大&quot; <span class="hljs-keyword">where</span> sname<span class="hljs-operator">=</span>&quot;张三&quot;;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br><br> <br><span class="hljs-number">2</span>，更新全部数据<br>语法为：<span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 字段名<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>[,字段名<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>,....] <br> <br><span class="hljs-comment">---更新全部数据 将表中年龄都修改为18</span><br><span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> age<span class="hljs-operator">=</span><span class="hljs-number">18</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br> <br></code></pre></td></tr></table></figure><h1 id="数据的删除"><a href="#数据的删除" class="headerlink" title="数据的删除"></a>数据的删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>，删除指定数据<br>语法为：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件<br><br><span class="hljs-comment">---删除student表中sno大于2的学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> sno<span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>;<br> <br> <br><span class="hljs-number">2</span>，删除全部数据<br>语法为：<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件<br><br><span class="hljs-comment">---删除student表的全部数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student;<br> <br> <br><span class="hljs-number">3</span>，<span class="hljs-keyword">truncate</span>关键字删除数据<br>语法为：<span class="hljs-keyword">truncate</span> 表名<br> <br><span class="hljs-number">4</span>，<span class="hljs-keyword">truncate</span>与<span class="hljs-keyword">delete</span>删除全部记录的区别：<br> <br>a，<span class="hljs-keyword">delete</span>是数据操纵语言DML 而<span class="hljs-keyword">truncate</span>是数据定义语言DDL<br><br>b，<span class="hljs-keyword">delete</span>删除数据是一条一条删除<br><span class="hljs-keyword">truncate</span>删除数据是保留表结构，直接删除数据，删除后表的状态相当于新表<br><span class="hljs-keyword">truncate</span>的效率比<span class="hljs-keyword">delete</span>高<br><br>c，<span class="hljs-keyword">delete</span>删除数据，会显示删除行数<br><span class="hljs-keyword">truncate</span>不会显示<br><br>d，删除记录后，再次向表添加数据，自增的值会在原来最大值<span class="hljs-operator">+</span><span class="hljs-number">1</span><br><span class="hljs-keyword">truncate</span>删除记录后，会从<span class="hljs-number">1</span>开始自增<br><br>e，<span class="hljs-keyword">delete</span>操作可以回滚即删除的数据可以恢复<br><span class="hljs-keyword">truncate</span>操作隐士提交，删除的数据不能恢复<br> <br> <br></code></pre></td></tr></table></figure><h1 id="创建emp表"><a href="#创建emp表" class="headerlink" title="创建emp表"></a>创建emp表</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <br> <br>用户用不同的方式从数据库中获取自己所需要的数据<br>是数据库操作中非常重要且频繁的操作<br> <br><span class="hljs-comment">---创建新库test</span><br><span class="hljs-comment">---在test库中创建emp(雇员表)</span><br>emp(雇员编号empno<br>雇员名称ename<br>雇员职位job<br>雇员领导mgr<br>雇员入职日期hiredate<br>雇员月薪sal<br>雇员津贴comm<br>雇员部门编号deptno<br><br><span class="hljs-keyword">create</span> database test;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>empno <span class="hljs-type">int</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>ename <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>job <span class="hljs-type">varchar</span>(<span class="hljs-number">9</span>),<br>mgr <span class="hljs-type">int</span>(<span class="hljs-number">4</span>),<br>hiredate <span class="hljs-type">date</span>,<br>sal <span class="hljs-type">decimal</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>),<br>comm <span class="hljs-type">decimal</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>),<br>deptno <span class="hljs-type">int</span>(<span class="hljs-number">2</span>)<br>);<br> <br><span class="hljs-comment">---同时插入多条数据</span><br> <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> emp <span class="hljs-keyword">values</span><br>(<span class="hljs-number">7369</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>, <span class="hljs-string">&#x27;clerk&#x27;</span>, <span class="hljs-number">7902</span>, <span class="hljs-string">&#x27;1980-12-17&#x27;</span>, <span class="hljs-number">800</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">20</span>), (<span class="hljs-number">7499</span>, <span class="hljs-string">&#x27;Allen&#x27;</span>, <span class="hljs-string">&#x27;salesman&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-02-20&#x27;</span>, <span class="hljs-number">1600</span>, <span class="hljs-number">300</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">7521</span>, <span class="hljs-string">&#x27;Ward&#x27;</span>, <span class="hljs-string">&#x27;salesman&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-02-22&#x27;</span>, <span class="hljs-number">1250</span>, <span class="hljs-number">500</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">7566</span>, <span class="hljs-string">&#x27;Jones&#x27;</span>, <span class="hljs-string">&#x27;manager&#x27;</span>, <span class="hljs-number">7839</span>, <span class="hljs-string">&#x27;1981-04-02&#x27;</span>, <span class="hljs-number">2975</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">20</span>), (<span class="hljs-number">7654</span>, <span class="hljs-string">&#x27;Maritn&#x27;</span>, <span class="hljs-string">&#x27;salesman&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-09-28&#x27;</span>, <span class="hljs-number">1250</span>, <span class="hljs-number">1400</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;Blake&#x27;</span>, <span class="hljs-string">&#x27;manager&#x27;</span>, <span class="hljs-number">7839</span>, <span class="hljs-string">&#x27;1981-05-01&#x27;</span>, <span class="hljs-number">2850</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">7782</span>, <span class="hljs-string">&#x27;Clark&#x27;</span>, <span class="hljs-string">&#x27;manager&#x27;</span>, <span class="hljs-number">7839</span>, <span class="hljs-string">&#x27;1981-06-09&#x27;</span>, <span class="hljs-number">2450</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">7788</span>, <span class="hljs-string">&#x27;Scott&#x27;</span>, <span class="hljs-string">&#x27;analyst&#x27;</span>, <span class="hljs-number">7566</span>, <span class="hljs-string">&#x27;1987-04-19&#x27;</span>, <span class="hljs-number">3000</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">20</span>), (<span class="hljs-number">7839</span>, <span class="hljs-string">&#x27;King&#x27;</span>, <span class="hljs-string">&#x27;president&#x27;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;1981-11-17&#x27;</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">7844</span>, <span class="hljs-string">&#x27;Turner&#x27;</span>, <span class="hljs-string">&#x27;salesman&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-09-08&#x27;</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">7876</span>, <span class="hljs-string">&#x27;Adams&#x27;</span>, <span class="hljs-string">&#x27;clerk&#x27;</span>, <span class="hljs-number">7788</span>, <span class="hljs-string">&#x27;1987-05-23&#x27;</span>, <span class="hljs-number">1100</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">20</span>), (<span class="hljs-number">7900</span>, <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-string">&#x27;clerk&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-12-03&#x27;</span>, <span class="hljs-number">950</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">7902</span>, <span class="hljs-string">&#x27;Ford&#x27;</span>, <span class="hljs-string">&#x27;analyst&#x27;</span>, <span class="hljs-number">7566</span>, <span class="hljs-string">&#x27;1981-12-03&#x27;</span>, <span class="hljs-number">3000</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">20</span>), (<span class="hljs-number">7934</span>, <span class="hljs-string">&#x27;Miller&#x27;</span>, <span class="hljs-string">&#x27;clerk&#x27;</span>, <span class="hljs-number">7782</span>, <span class="hljs-string">&#x27;1982-01-23&#x27;</span>, <span class="hljs-number">1300</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">10</span>);<br> <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br> <br> <br> <br><span class="hljs-number">2</span>，以上表创建完成之后进行单表查询<br> <br>a，查询所有字段<br>语法<span class="hljs-number">1</span>为：<span class="hljs-keyword">select</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....<span class="hljs-keyword">from</span> 表名<br>语法<span class="hljs-number">2</span>为：<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名<br> <br>b，查询指定字段<br>语法为：<span class="hljs-keyword">select</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....<span class="hljs-keyword">from</span> 表名<br><span class="hljs-comment">---查询雇员表中雇员姓名，职位，部门号，薪资</span><br><span class="hljs-keyword">select</span> ename,job,deptno,sal <span class="hljs-keyword">from</span> emp;<br> <br>c，去重<span class="hljs-keyword">distinct</span>的使用<br>语法为：<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> 字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....<span class="hljs-keyword">from</span> 表名<br><span class="hljs-comment">---查询雇员在哪个部门号中</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> deptno <span class="hljs-keyword">from</span> emp;<br><span class="hljs-comment">---查询雇员部门号及职位</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> deptno,job <span class="hljs-keyword">from</span> emp;<br>注意：<span class="hljs-keyword">distinct</span>使用到多个字段上时，只有多个字段的值都相同时才去重<br> <br><br>d，查询时算术运算符的使用<br> <span class="hljs-operator">+</span>   <span class="hljs-operator">-</span>   <span class="hljs-operator">*</span>  <span class="hljs-operator">/</span>(div)   v<span class="hljs-operator">%</span>(mod)<br><span class="hljs-comment">---查询每个雇员的年薪</span><br><span class="hljs-keyword">select</span> ename,sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">from</span> emp;<br> <br>e，给字段起别名<br>语法为：<span class="hljs-keyword">select</span> 字段名<span class="hljs-number">1</span> [<span class="hljs-keyword">as</span>] 别名,字段名<span class="hljs-number">2</span>,字段名<span class="hljs-number">3</span>,....<span class="hljs-keyword">from</span> 表名;<br><span class="hljs-comment">---查询每个雇员的年薪，别名为yearsal</span><br><span class="hljs-keyword">select</span> ename,sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">as</span> yearsal <span class="hljs-keyword">from</span> emp;<br>注意：如果别名中有空格特殊符号，需要使用单引号括起来<br><span class="hljs-comment">---查询每个雇员的年薪，别名为yearsal&amp;年薪 或者别名为 yearsal 年薪</span><br><span class="hljs-keyword">select</span> ename,sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;yearsal&amp;年薪&#x27;</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> ename,sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;yearsal 年薪&#x27;</span> <span class="hljs-keyword">from</span> emp;<br> <br></code></pre></td></tr></table></figure><h2 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">默认升序 <span class="hljs-keyword">asc</span><br>降序 <span class="hljs-keyword">desc</span><br> <br><span class="hljs-number">1</span>，在单个字段中排序<br>语法为：<span class="hljs-keyword">select</span> 查询内容 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段  <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span><br><span class="hljs-comment">---查询雇员信息按雇员薪资升序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">asc</span>;<br><span class="hljs-comment">---由于默认的排序方式是升序，所以asc可以省略</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal;<br><br><span class="hljs-number">2</span>，在多个字段中使用排序<br>语法为：<span class="hljs-keyword">select</span> 查询内容 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段名<span class="hljs-number">1</span>  <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>,字段名<span class="hljs-number">2</span>  <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span>desc....<br><span class="hljs-comment">---查询雇员信息，先按雇员薪资升序排，如薪资相同则按入职日期降序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal,hiredate <span class="hljs-keyword">desc</span>;<br>注意：排序可以起别名<br><span class="hljs-comment">---查询雇员的年薪给年薪起个别名yearsal,按年薪降序排序</span><br><span class="hljs-keyword">select</span> ename,sal<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">as</span> yearsal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> yearsal <span class="hljs-keyword">desc</span>;<br> <br></code></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs sql">是用户按照一定条件查询，查询满足条件的部分记录<br>语法格式：<span class="hljs-keyword">select</span> 查询内容 <span class="hljs-keyword">from</span> 表 <span class="hljs-keyword">where</span> 条件<br> <br>(<span class="hljs-number">1</span>)比较运算符的使用   <span class="hljs-operator">=</span>    <span class="hljs-operator">&gt;</span>    <span class="hljs-operator">&lt;</span>      <span class="hljs-operator">&gt;=</span>      <span class="hljs-operator">&lt;=</span>      <span class="hljs-operator">!=</span>       <span class="hljs-operator">&lt;&gt;</span><br><span class="hljs-comment">---查询部门号为20的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span>;<br><span class="hljs-comment">---查询薪资大于等于3000的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;=</span><span class="hljs-number">3000</span>;<br><span class="hljs-comment">---查询薪资小于3000的雇员名称，薪资，职位</span><br><span class="hljs-keyword">select</span> ename,sal,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&lt;</span><span class="hljs-number">3000</span>;<br><span class="hljs-comment">---查询名为Smith的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename<span class="hljs-operator">=</span>&quot;Smith&quot;;<br>注意：MySQL默认不区分大小写，如果要区分大小写则可以使用<span class="hljs-type">binary</span>关键字<br><span class="hljs-comment">---binary的使用</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">binary</span> ename<span class="hljs-operator">=</span>&quot;Smith&quot;;<br><br>(<span class="hljs-number">2</span>) [<span class="hljs-keyword">not</span>] <span class="hljs-keyword">between</span> <span class="hljs-keyword">and</span>的使用 <br>可以查询某区间范围的记录<br><span class="hljs-comment">---查询薪资在1200-3000之间的雇员信息</span><br><span class="hljs-comment">---between后面是开始值，and后面是结束值，不能颠倒。包括边界</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-keyword">between</span> <span class="hljs-number">1200</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3000</span>;<br><span class="hljs-comment">---查询薪资不在1200-3000范围之内的雇员姓名，薪资</span><br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-keyword">not</span> <span class="hljs-keyword">between</span> <span class="hljs-number">1200</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3000</span>;<br> <br>(<span class="hljs-number">3</span>)[<span class="hljs-keyword">not</span>] <span class="hljs-keyword">in</span>的使用<br>语法格式为：<span class="hljs-keyword">select</span> 查询内容 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 字段名 <span class="hljs-keyword">in</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>,...)<br><span class="hljs-comment">---查询雇员姓名是smith,scott,king的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">in</span>(&quot;smith&quot;,&quot;scott&quot;,&quot;king&quot;);<br><span class="hljs-comment">---查询雇员姓名不是smith,scott,king的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(&quot;smith&quot;,&quot;scott&quot;,&quot;king&quot;);<br> <br>(<span class="hljs-number">4</span>)<span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> 或者 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>  判断某个字段是否为空<br><span class="hljs-comment">---查询雇员中，有津贴的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> comm <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">---查询雇员中，没有津贴的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> comm <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br> <br>(<span class="hljs-number">5</span>)模糊查询<br>可查询以XX开头，以XX结尾，包含XX，第几个是X<br><span class="hljs-operator">%</span>：指任意长度的字符<br>_：匹配一个字符<br>语法为：<span class="hljs-keyword">select</span> 查询内容<span class="hljs-keyword">from</span>表名<span class="hljs-keyword">where</span>字段名<span class="hljs-keyword">like</span><br><span class="hljs-comment">---查询雇员姓名以S开头的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span>&quot;S%&quot;;<br><span class="hljs-comment">---查询雇员姓名以S结尾的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span>&quot;%S&quot;;<br><span class="hljs-comment">---查询雇员姓名包含S的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span>&quot;%S%&quot;;<br><span class="hljs-comment">---查询雇员姓名第二个字符是L的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span>&quot;_L%&quot;;<br><span class="hljs-comment">---查询雇员姓名长度是5的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span>&quot;_____&quot;;<br> <br>(<span class="hljs-number">6</span>)条件中的逻辑运算符<br><span class="hljs-keyword">and</span>：查询时，只有满足所有条件的记录才会被查询出来<br><span class="hljs-keyword">select</span> 查询内容<span class="hljs-keyword">from</span>表名<span class="hljs-keyword">where</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> 条件<span class="hljs-number">2</span> and....<br><span class="hljs-comment">---查询雇员表中部门号为20 职位是clerk的雇员姓名 部门编号 职位</span><br><span class="hljs-keyword">select</span> ename,deptno,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span> <span class="hljs-keyword">and</span> job<span class="hljs-operator">=</span>&quot;clerk&quot;;<br><span class="hljs-comment">---查询部门号为30，薪资在1500-3000之间的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">30</span> <span class="hljs-keyword">and</span> sal <span class="hljs-keyword">between</span> <span class="hljs-number">1500</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3000</span>;<br><br><span class="hljs-keyword">or</span>：查询时，只要满足任一条件记录就能被查询出来<br><span class="hljs-keyword">select</span> 查询内容<span class="hljs-keyword">from</span>表名<span class="hljs-keyword">where</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> 条件<span class="hljs-number">2</span> or....<br><span class="hljs-comment">---查询雇员表中部门号为20 或者职位是clerk的雇员姓名 部门编号 职位</span><br><span class="hljs-keyword">select</span> ename,deptno,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno<span class="hljs-operator">=</span><span class="hljs-number">20</span> <span class="hljs-keyword">or</span> job<span class="hljs-operator">=</span>&quot;clerk&quot;;<br> <br> <br></code></pre></td></tr></table></figure><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 查询内容 <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段名 <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span> limit a,b <br>注意：<br>(a代表从哪条记录开始，b代表每页显示的条数) 且默认第一条数据的值为<span class="hljs-number">0</span><br>如果limit与<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 连用的时候，先排序再分页<br><span class="hljs-comment">---显示第一页雇员信息 例如每页显示4条</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">0</span>,<span class="hljs-number">4</span>;<br><span class="hljs-comment">---显示第二页雇员信息 每页显示4条</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">4</span>,<span class="hljs-number">4</span>;<br><span class="hljs-comment">---显示第三页雇员信息 每页显示4条</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">8</span>,<span class="hljs-number">4</span>;<br><span class="hljs-comment">---显示第n页雇员信息 每页显示4条</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit (n<span class="hljs-number">-1</span>)<span class="hljs-operator">*</span><span class="hljs-number">4</span>,<span class="hljs-number">4</span>;<br> <br> <br></code></pre></td></tr></table></figure><h1 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h1><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs sql">a，字符函数 <br>(<span class="hljs-number">1</span>)concat() 拼接字符串<br><span class="hljs-comment">---查询雇员信息，以指定格式输出</span><br>雇员姓名：XX,薪资：XX,职位：XX,入职日期：XX,年薪：XX,<br><span class="hljs-keyword">select</span> concat(&quot;雇员姓名：&quot;,ename,&quot;，薪资：&quot;,sal,&quot;，职位：&quot;,job,&quot;，入职日期：&quot;,hiredate,&quot;，年薪：&quot;,sal<span class="hljs-operator">*</span><span class="hljs-number">12</span>) <span class="hljs-keyword">from</span> emp;<br><br>(<span class="hljs-number">2</span>)length()计算字符串的长度<br><span class="hljs-comment">---查询雇员姓名长度是5的雇员信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> length(ename)<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br><br>(<span class="hljs-number">3</span>)<span class="hljs-built_in">lower</span>()  <span class="hljs-built_in">upper</span>()转换大小写<br><span class="hljs-comment">---查询雇员姓名 大写的雇员姓名 小写的雇员姓名</span><br><span class="hljs-keyword">select</span> ename,<span class="hljs-built_in">lower</span>(ename),<span class="hljs-built_in">upper</span>(ename) <span class="hljs-keyword">from</span> emp;<br><br>(<span class="hljs-number">4</span>)replace()在指定的字符串中，将某子串替换为新的字符串<br>replace(目标字符串,查找的子串,新字符串)<br><span class="hljs-comment">---将helloWord字符串中的hello替换为hi</span><br><span class="hljs-keyword">select</span> replace(&quot;helloworld&quot;,&quot;hello&quot;,&quot;hi&quot;) <span class="hljs-keyword">from</span> dual;<br><span class="hljs-comment">---另一种写法为</span><br><span class="hljs-keyword">select</span> replace(&quot;helloworld&quot;,&quot;hello&quot;,&quot;hi&quot;);<br><br>(<span class="hljs-number">5</span>)<span class="hljs-built_in">substring</span>()截取子串<br><span class="hljs-built_in">substring</span>(目标字符串,开始位置,长度)  注意开始索引是从<span class="hljs-number">1</span>开始的。<br><span class="hljs-comment">---截取雇员姓名的前4个字符</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">substring</span>(ename,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) <span class="hljs-keyword">from</span> emp;<br> <br> <br>b，数值函数<br><span class="hljs-number">1</span>，<span class="hljs-built_in">abs</span>()  作用是：取绝对值<br><span class="hljs-keyword">select</span>(<span class="hljs-number">1</span>),(<span class="hljs-number">-1</span>);<br> <br><span class="hljs-number">2</span>，pi()  作用是：获取圆周率<br><span class="hljs-keyword">select</span> pi();<br> <br><span class="hljs-number">3</span>，<span class="hljs-built_in">mod</span>() 作用是：取余<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-number">5</span>，pow() 作用是：求一个数的n次方<br><span class="hljs-keyword">select</span> pow(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br> <br><span class="hljs-number">6</span>，<span class="hljs-built_in">ceil</span>() 向上取整  <span class="hljs-built_in">floor</span>()向下取整<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">5.43</span>),<span class="hljs-built_in">floor</span>(<span class="hljs-number">5.7</span>);<br> <br><span class="hljs-number">7</span>，round(num) 代表返回四舍五入的整数<br>round(num,n)返回四舍五入n位小数<br><span class="hljs-keyword">select</span> round(<span class="hljs-number">5.4</span>),round(<span class="hljs-number">6.8</span>),round(<span class="hljs-number">5.34</span>,<span class="hljs-number">1</span>),round(<span class="hljs-number">6.789</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-number">8</span>，<span class="hljs-keyword">truncate</span>(num,n) n的值可以为<span class="hljs-number">0</span>,<span class="hljs-number">1</span>，<span class="hljs-number">2</span>,<span class="hljs-number">3</span>，<span class="hljs-number">4.</span>..其中n为<span class="hljs-number">0</span>时代表截取整数<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">5.3</span>,<span class="hljs-number">0</span>),<span class="hljs-keyword">truncate</span>(<span class="hljs-number">5.67</span>,<span class="hljs-number">1</span>),<span class="hljs-keyword">truncate</span>(<span class="hljs-number">5.789</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-number">9</span>，rand() 获取浮点类型的随机数，范围是<span class="hljs-number">0</span><span class="hljs-number">-1.0</span>。包括<span class="hljs-number">0</span>但不包含<span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> rand(),rand(),rand();<br> <br> <br>c，时间日期函数<br><span class="hljs-number">1</span>，now() 获取<span class="hljs-keyword">SQL</span>执行时当前日期和时间 包括年月日 时分秒<br><span class="hljs-keyword">select</span> now();<br> <br><span class="hljs-number">2</span>，curdate()获取当前日期 只包括年月日<br><span class="hljs-keyword">select</span> curdate()<br><br><span class="hljs-number">3</span>，curtime()获取当前时间 只包括时分秒<br><span class="hljs-keyword">select</span> curtime();<br><br><span class="hljs-number">4</span>，sysdate()获取函数执行时的日期和时间<br><span class="hljs-keyword">select</span> sysdate(),now(),sleep(<span class="hljs-number">3</span>),sysdate(),now();<br><br><span class="hljs-number">5</span>，dayofyear()获取某个日期是所在年份的第几天<br> week()获取某个日期是所在年份的第几周<br> <span class="hljs-keyword">select</span> dayofyear(now()),week(now());<br><br><span class="hljs-number">6</span>，datediff()计算两个日期之间的时间间隔<br><span class="hljs-comment">---计算2019.1.1日距离现在时间间隔</span><br><span class="hljs-keyword">select</span> datediff(&quot;2019-12-30&quot;,now());<br> <br><span class="hljs-number">7</span>，date_add(),date_sub() 实现日期的加减运算<br>date_add(日期, 时间间隔类型关键字<span class="hljs-type">interval</span>, 时间间隔类型对应的表达式, 时间间隔类型)<br> day_hour  <span class="hljs-number">1</span>_12 代表<span class="hljs-number">1</span>天<span class="hljs-number">12</span>个小时<br> year_month <span class="hljs-number">2</span>_1 代表<span class="hljs-number">2</span>年<span class="hljs-number">1</span>个月<br> <br> <span class="hljs-keyword">select</span> date_add(now(), <span class="hljs-type">interval</span> &quot;2_1&quot; year_month)<br> <span class="hljs-keyword">select</span> date_sub(now(), <span class="hljs-type">interval</span> <span class="hljs-number">10</span> <span class="hljs-keyword">day</span>);<br> <br>e，流程控制函数<br><span class="hljs-number">1</span>，if(条件,t,f) 如果条件成立返回t，否则返回f<br><span class="hljs-keyword">select</span> if(<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>,&quot;1大于2&quot;,&quot;1小于2&quot;);<br><span class="hljs-comment">---查询雇员的薪资，如果薪资&gt;=3000，输入“高薪”，否则“低薪”</span><br><span class="hljs-keyword">select</span> sal,if(sal<span class="hljs-operator">&gt;=</span><span class="hljs-number">3000</span>,&quot;高薪&quot;,&quot;低薪&quot;) &quot;薪资水平&quot; <span class="hljs-keyword">from</span> emp;<br><br><span class="hljs-number">2</span>，ifnull(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>) 如果值<span class="hljs-number">1</span>不为空则返回值<span class="hljs-number">1</span>，否则返回值<span class="hljs-number">2</span><br><span class="hljs-comment">---查询雇员的年薪</span><br><span class="hljs-keyword">select</span> sal,comm,(sal<span class="hljs-operator">+</span>comm)<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">from</span> emp; 此语句达不到想要的效果<br><span class="hljs-keyword">select</span> (sal<span class="hljs-operator">+</span>ifnull(comm,<span class="hljs-number">0</span>))<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> sal,comm,(sal<span class="hljs-operator">+</span>ifnull(comm,<span class="hljs-number">0</span>))<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-number">3</span>，<span class="hljs-built_in">nullif</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>) 如果值<span class="hljs-number">1</span>等于值<span class="hljs-number">2</span>返回<span class="hljs-keyword">null</span>，否则返回值<span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">nullif</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-built_in">nullif</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><br><span class="hljs-number">4</span>，   <span class="hljs-keyword">case</span> 值<br><span class="hljs-keyword">when</span> 值<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 结果<span class="hljs-number">1</span><br><span class="hljs-keyword">when</span> 值<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 结果<span class="hljs-number">2</span><br>...<br><span class="hljs-keyword">else</span> 其他结果<br><span class="hljs-keyword">end</span><br> <span class="hljs-keyword">select</span> <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> <span class="hljs-keyword">when</span> <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> &quot;这是结果1&quot; <span class="hljs-keyword">when</span> <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> &quot;这是结果2&quot; <span class="hljs-keyword">else</span> &quot;这是其他结果&quot; <span class="hljs-keyword">end</span>;<br> <br><span class="hljs-number">5</span>，   <span class="hljs-keyword">case</span> <br><span class="hljs-keyword">when</span> 条件 <span class="hljs-keyword">then</span> 结果<span class="hljs-number">1</span><br><span class="hljs-keyword">when</span> 条件 <span class="hljs-keyword">then</span> 结果<span class="hljs-number">2</span><br>...<br><span class="hljs-keyword">else</span> 其他结果<br><span class="hljs-keyword">end</span><br>示例为：<span class="hljs-comment">---查询雇员薪资，如果薪资&gt;=3000返回“高薪”，否则“低薪”</span><br><span class="hljs-keyword">select</span> sal,<span class="hljs-keyword">case</span><br><span class="hljs-keyword">when</span> sal<span class="hljs-operator">&gt;=</span><span class="hljs-number">3000</span> <span class="hljs-keyword">then</span> &quot;高薪&quot;<br><span class="hljs-keyword">else</span> &quot;低薪&quot;<br><span class="hljs-keyword">end</span> &quot;薪资水平&quot;<br><span class="hljs-keyword">from</span> emp;<br> <br></code></pre></td></tr></table></figure><h2 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h2><p>定义：操作一组数据(多行记录)返回一个结果，也叫分组函数 大多用于统计 例如：统计各部门中雇员的人数。统计各部门中最高和最低薪资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>，<span class="hljs-built_in">count</span>()统计表中记录的数目<br><span class="hljs-comment">---查询emp表中有多少条记录</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp;<br> <br>另一条语法是<span class="hljs-built_in">count</span>(exp)统计exp值非空的记录数目<br><span class="hljs-comment">---查询雇员表中，有多少位雇员有津贴</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(comm) <span class="hljs-keyword">from</span> emp;<br> <br>另一条语法是<span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span>(exp)) 返回表达式exp的值不重复且非空的总记录数目<br><span class="hljs-comment">---统计雇员表中有多少位雇员是领导</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span>(mgr)) <span class="hljs-keyword">from</span> emp;<span class="hljs-comment">--统计的是除董事长外的领导人数</span><br><span class="hljs-comment">---统计雇员表中包含董事长的领导数 需要用到ifnull函数</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span>(ifnull(mgr,<span class="hljs-number">1</span>))) <span class="hljs-keyword">from</span> emp;<br> <br><span class="hljs-number">2</span>，<span class="hljs-built_in">sum</span>(exp) 返回表达式值的总和<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(sal) <span class="hljs-keyword">from</span> emp;<br><br>另一条语法是<span class="hljs-built_in">sum</span>(<span class="hljs-keyword">distinct</span>(exp))返回不重复的表达式exp的总和<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(sal),<span class="hljs-built_in">sum</span>(<span class="hljs-keyword">distinct</span>(sal)) <span class="hljs-keyword">from</span> emp;<br> <br><span class="hljs-number">3</span>，<span class="hljs-built_in">avg</span>(exp)返回表达式值的平均值<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp;<br> <br>另一条语法是<span class="hljs-built_in">avg</span>(<span class="hljs-keyword">distinct</span>(exp))返回不重复的表达式exp的平均值<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(<span class="hljs-keyword">distinct</span>(sal)) <span class="hljs-keyword">from</span> emp;<br> <br><span class="hljs-number">4</span>，<span class="hljs-built_in">max</span>()  <span class="hljs-built_in">min</span>() <br><span class="hljs-built_in">max</span>(emp)返回表达式值的最大值<br><span class="hljs-built_in">min</span>(emp)返回表达式值的最小值<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(sal),<span class="hljs-built_in">max</span>(sal) <span class="hljs-keyword">from</span> emp;<br> <br></code></pre></td></tr></table></figure><h2 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql">语法为：<br><span class="hljs-keyword">select</span> 查询内容<br><span class="hljs-keyword">from</span> 表名<br>[<span class="hljs-keyword">where</span> 条件]<br>[<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段名<span class="hljs-number">1</span>,分组字段名<span class="hljs-number">2</span>,...]<br>[<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 字段名 <span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>]<br>[limit]<br> <br>示例如下：<br> <span class="hljs-comment">---求每个部门的人数</span><br> <span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br> <span class="hljs-comment">---求每个部门的平均工资</span><br> <span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br> <span class="hljs-comment">---求每个部门中最高工资和人数</span><br> <span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">max</span>(sal),<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno;<br> <span class="hljs-comment">---求每个岗位的人数</span><br> <span class="hljs-keyword">select</span> job,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job;<br> <span class="hljs-comment">---显示每个部门不同岗位的人数</span><br> <span class="hljs-keyword">select</span> deptno,job,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno,job;<br> <br>注意事项<span class="hljs-number">1</span>：如果查询字段，没有在多行函数中，则必须是分组字段<br><span class="hljs-keyword">select</span> ename,job,<span class="hljs-built_in">sum</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job; 此语句运行后会报错<br> <br>注意事项<span class="hljs-number">2</span>：如果没有<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 则查询字段不能与多行函数一起查询<br><span class="hljs-keyword">select</span> sal,empto <span class="hljs-keyword">from</span> emp; 合法<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(sal),empto <span class="hljs-keyword">from</span> emp;不合法<br> <br>注意事项<span class="hljs-number">3</span>：不允许在<span class="hljs-keyword">where</span>条件中使用多行函数<br> <br></code></pre></td></tr></table></figure><h2 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql">语法为：<br><span class="hljs-keyword">select</span> 查询内容<br><span class="hljs-keyword">from</span> 表名<br>[<span class="hljs-keyword">where</span> 条件]<br>[<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段]<br>[<span class="hljs-keyword">having</span> 条件]<br>[<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>]<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">from</span> <span class="hljs-comment">---where过滤---group by---having过滤</span><br>示例如下：<br><span class="hljs-comment">---每个部门不同岗位的人数，且人数大于2</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),deptno,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno,job <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>;<br><span class="hljs-comment">---在emp表中列出工资最小值小于2000的职位</span><br><span class="hljs-keyword">select</span> job,<span class="hljs-built_in">min</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job <span class="hljs-keyword">having</span> <span class="hljs-built_in">min</span>(sal)<span class="hljs-operator">&lt;</span><span class="hljs-number">2000</span>;<br><span class="hljs-comment">---查询每个职位的最低薪资</span><br><span class="hljs-keyword">select</span> job,<span class="hljs-built_in">min</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job;<br><span class="hljs-comment">---列出平均工资大于1200的部门和职位搭配组合</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(avg) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno,job <span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span>(sal)<span class="hljs-operator">&gt;</span><span class="hljs-number">1200</span>;<br><span class="hljs-comment">---求每个部门不同职位的平均工资</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno,job;<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql子查询</title>
    <link href="/blog/2021/01/24/mysql%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/blog/2021/01/24/mysql%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1g8kqx5e1oouz">https://cloud.tencent.com/developer/support-plan?invite_code=1g8kqx5e1oouz</a></p><h1 id="子查询定义"><a href="#子查询定义" class="headerlink" title="子查询定义"></a>子查询定义</h1><p>在一个表表达中可以调用另一个表表达式，这个被调用的表表达式叫做子查询（subquery），我么也称作子选择（subselect）或内嵌选择（inner select）。子查询的结果传递给调用它的表表达式继续处理。</p><h1 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h1><h2 id="按返回结果集分类"><a href="#按返回结果集分类" class="headerlink" title="按返回结果集分类"></a>按返回结果集分类</h2><p>子查询按返回结果集的不同分为4种：表子查询，行子查询，列子查询和标量子查询。 表子查询：返回的结果集是一个行的集合，N行N列（N&gt;=1）。表子查询经常用于父查询的FROM子句中。 行子查询：返回的结果集是一个列的集合，一行N列（N&gt;=1）。行子查询可以用于福查询的FROM子句和WHERE子句中。 列子查询：返回的结果集是一个行的集合，N行一列（N&gt;=1）。 标量子查询：返回的结果集是一个标量集合，一行一列，也就是一个标量值。可以指定一个标量表达式的任何地方，都可以用一个标量子查询。</p><p>从定义上讲，每个标量子查询也是一个行子查询和一个列子查询，反之则不是；每个行子查询和列子查询也是一个表子查询，反之也不是。</p><h2 id="按照对返回结果的调用方法"><a href="#按照对返回结果的调用方法" class="headerlink" title="按照对返回结果的调用方法"></a>按照对返回结果的调用方法</h2><p>子查询按对返回结果集的调用方法，可分为where型子查询，from型子查询及exists型子查询。</p><p>where型子查询：（把内层查询结果当作外层查询的比较条件）定义：where型的子查询就是把内层查询的结果当作外层查询的条件。 from型子查询：（把内层的查询结果供外层再次查询）定义：from子查询就是把子查询的结果(内存里的一张表)当作一张临时表，然后再对它进行处理。 exists型子查询：（把外层查询结果拿到内层，看内层的查询是否成立）定义：exists子查询就是对外层表进行循环，再对内表进行内层查询。和in ()差不多，但是它们还是有区别的。主要是看两个张表大小差的程度。若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）；</p><h1 id="使用子查询原则"><a href="#使用子查询原则" class="headerlink" title="使用子查询原则"></a>使用子查询原则</h1><p>1.一个子查询必须放在圆括号中。 2.将子查询放在比较条件的右边以增加可读性。子查询不包含 ORDER BY 子句。对一个 SELECT 语句只能用一个 ORDER BY 子句，并且如果指定了它就必须放在主 SELECT 语句的最后。 3.在子查询中可以使用两种比较条件：单行运算符(&gt;, =, &gt;=, &lt;, &lt;&gt;, &lt;=) 和多行运算符(IN, ANY, ALL)。</p><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="创建测试表"><a href="#创建测试表" class="headerlink" title="创建测试表"></a>创建测试表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> PLAYERS<br>    (PLAYERNO      <span class="hljs-type">INTEGER</span>      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    NAME           <span class="hljs-type">CHAR</span>(<span class="hljs-number">15</span>)     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    INITIALS       <span class="hljs-type">CHAR</span>(<span class="hljs-number">3</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    BIRTH_DATE     <span class="hljs-type">DATE</span>                 ,<br>    SEX            <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    JOINED         <span class="hljs-type">SMALLINT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    STREET         <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    HOUSENO        <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>)              ,<br>    POSTCODE       <span class="hljs-type">CHAR</span>(<span class="hljs-number">6</span>)              ,<br>    TOWN           <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    PHONENO        <span class="hljs-type">CHAR</span>(<span class="hljs-number">13</span>)             ,<br>    LEAGUENO       <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>)              ,<br>    <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span>    (PLAYERNO));<br> <br><span class="hljs-keyword">CREATE</span>   <span class="hljs-keyword">TABLE</span> PENALTIES<br>        (PAYMENTNO      <span class="hljs-type">INTEGER</span>      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>         PLAYERNO       <span class="hljs-type">INTEGER</span>      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>         PAYMENT_DATE   <span class="hljs-type">DATE</span>         <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>         AMOUNT         <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>         <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span>    (PAYMENTNO));<br></code></pre></td></tr></table></figure><p>注：表players为球员信息基本表，表penalties为有过罚款记录的球员信息列表。</p><h2 id="插入测试数据"><a href="#插入测试数据" class="headerlink" title="插入测试数据"></a>插入测试数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Everett&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;1948-09-01&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1975</span>, <span class="hljs-string">&#x27;Stoney Road&#x27;</span>,<span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;3575NH&#x27;</span>, <span class="hljs-string">&#x27;Stratford&#x27;</span>, <span class="hljs-string">&#x27;070-237893&#x27;</span>, <span class="hljs-string">&#x27;2411&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Parmenter&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;1964-06-25&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1977</span>, <span class="hljs-string">&#x27;Haseltine Lane&#x27;</span>,<span class="hljs-string">&#x27;80&#x27;</span>, <span class="hljs-string">&#x27;1234KK&#x27;</span>, <span class="hljs-string">&#x27;Stratford&#x27;</span>, <span class="hljs-string">&#x27;070-476537&#x27;</span>, <span class="hljs-string">&#x27;8467&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Wise&#x27;</span>, <span class="hljs-string">&#x27;GWS&#x27;</span>, <span class="hljs-string">&#x27;1963-05-11&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1981</span>, <span class="hljs-string">&#x27;Edgecombe Way&#x27;</span>,<span class="hljs-string">&#x27;39&#x27;</span>, <span class="hljs-string">&#x27;9758VB&#x27;</span>, <span class="hljs-string">&#x27;Stratford&#x27;</span>, <span class="hljs-string">&#x27;070-347689&#x27;</span>, <span class="hljs-keyword">NULL</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;Newcastle&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;1962-07-08&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-number">1980</span>, <span class="hljs-string">&#x27;Station Road&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;6584WO&#x27;</span>, <span class="hljs-string">&#x27;Inglewood&#x27;</span>, <span class="hljs-string">&#x27;070-458458&#x27;</span>, <span class="hljs-string">&#x27;2983&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">27</span>, <span class="hljs-string">&#x27;Collins&#x27;</span>, <span class="hljs-string">&#x27;DD&#x27;</span>, <span class="hljs-string">&#x27;1964-12-28&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-number">1983</span>, <span class="hljs-string">&#x27;Long Drive&#x27;</span>,<span class="hljs-string">&#x27;804&#x27;</span>, <span class="hljs-string">&#x27;8457DK&#x27;</span>, <span class="hljs-string">&#x27;Eltham&#x27;</span>, <span class="hljs-string">&#x27;079-234857&#x27;</span>, <span class="hljs-string">&#x27;2513&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">28</span>, <span class="hljs-string">&#x27;Collins&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;1963-06-22&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-number">1983</span>, <span class="hljs-string">&#x27;Old Main Road&#x27;</span>,<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;1294QK&#x27;</span>, <span class="hljs-string">&#x27;Midhurst&#x27;</span>, <span class="hljs-string">&#x27;010-659599&#x27;</span>, <span class="hljs-keyword">NULL</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">39</span>, <span class="hljs-string">&#x27;Bishop&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;1956-10-29&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1980</span>, <span class="hljs-string">&#x27;Eaton Square&#x27;</span>,<span class="hljs-string">&#x27;78&#x27;</span>, <span class="hljs-string">&#x27;9629CD&#x27;</span>, <span class="hljs-string">&#x27;Stratford&#x27;</span>, <span class="hljs-string">&#x27;070-393435&#x27;</span>, <span class="hljs-keyword">NULL</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">44</span>, <span class="hljs-string">&#x27;Baker&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;1963-01-09&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1980</span>, <span class="hljs-string">&#x27;Lewis Street&#x27;</span>,<span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;4444LJ&#x27;</span>, <span class="hljs-string">&#x27;Inglewood&#x27;</span>, <span class="hljs-string">&#x27;070-368753&#x27;</span>, <span class="hljs-string">&#x27;1124&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">57</span>, <span class="hljs-string">&#x27;Brown&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;1971-08-17&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1985</span>, <span class="hljs-string">&#x27;Edgecombe Way&#x27;</span>,<span class="hljs-string">&#x27;16&#x27;</span>, <span class="hljs-string">&#x27;4377CB&#x27;</span>, <span class="hljs-string">&#x27;Stratford&#x27;</span>, <span class="hljs-string">&#x27;070-473458&#x27;</span>, <span class="hljs-string">&#x27;6409&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">83</span>, <span class="hljs-string">&#x27;Hope&#x27;</span>, <span class="hljs-string">&#x27;PK&#x27;</span>, <span class="hljs-string">&#x27;1956-11-11&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1982</span>, <span class="hljs-string">&#x27;Magdalene Road&#x27;</span>,<span class="hljs-string">&#x27;16A&#x27;</span>, <span class="hljs-string">&#x27;1812UP&#x27;</span>, <span class="hljs-string">&#x27;Stratford&#x27;</span>, <span class="hljs-string">&#x27;070-353548&#x27;</span>, <span class="hljs-string">&#x27;1608&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">95</span>, <span class="hljs-string">&#x27;Miller&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;1963-05-14&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1972</span>, <span class="hljs-string">&#x27;High Street&#x27;</span>,<span class="hljs-string">&#x27;33A&#x27;</span>, <span class="hljs-string">&#x27;5746OP&#x27;</span>, <span class="hljs-string">&#x27;Douglas&#x27;</span>, <span class="hljs-string">&#x27;070-867564&#x27;</span>, <span class="hljs-keyword">NULL</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;Parmenter&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;1963-02-28&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1979</span>, <span class="hljs-string">&#x27;Haseltine Lane&#x27;</span>,<span class="hljs-string">&#x27;80&#x27;</span>, <span class="hljs-string">&#x27;6494SG&#x27;</span>, <span class="hljs-string">&#x27;Stratford&#x27;</span>, <span class="hljs-string">&#x27;070-494593&#x27;</span>, <span class="hljs-string">&#x27;6524&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">104</span>, <span class="hljs-string">&#x27;Moorman&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;1970-05-10&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-number">1984</span>, <span class="hljs-string">&#x27;Stout Street&#x27;</span>,<span class="hljs-string">&#x27;65&#x27;</span>, <span class="hljs-string">&#x27;9437AO&#x27;</span>, <span class="hljs-string">&#x27;Eltham&#x27;</span>, <span class="hljs-string">&#x27;079-987571&#x27;</span>, <span class="hljs-string">&#x27;7060&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PLAYERS <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">112</span>, <span class="hljs-string">&#x27;Bailey&#x27;</span>, <span class="hljs-string">&#x27;IP&#x27;</span>, <span class="hljs-string">&#x27;1963-10-01&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-number">1984</span>, <span class="hljs-string">&#x27;Vixen Road&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;6392LK&#x27;</span>, <span class="hljs-string">&#x27;Plymouth&#x27;</span>, <span class="hljs-string">&#x27;010-548745&#x27;</span>, <span class="hljs-string">&#x27;1319&#x27;</span>);<br> <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,  <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;1980-12-08&#x27;</span>,<span class="hljs-number">100</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-number">44</span>, <span class="hljs-string">&#x27;1981-05-05&#x27;</span>, <span class="hljs-number">75</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&#x27;1983-09-10&#x27;</span>,<span class="hljs-number">100</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>,<span class="hljs-number">104</span>, <span class="hljs-string">&#x27;1984-12-08&#x27;</span>, <span class="hljs-number">50</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-number">44</span>, <span class="hljs-string">&#x27;1980-12-08&#x27;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>,  <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;1980-12-08&#x27;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7</span>, <span class="hljs-number">44</span>, <span class="hljs-string">&#x27;1982-12-30&#x27;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> PENALTIES <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">8</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&#x27;1984-11-12&#x27;</span>, <span class="hljs-number">75</span>);<br></code></pre></td></tr></table></figure><h2 id="表子查询实例"><a href="#表子查询实例" class="headerlink" title="表子查询实例"></a>表子查询实例</h2><p>如：获取编号小于10的男性球员的号码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> playerno <span class="hljs-keyword">from</span> (<br>    <span class="hljs-keyword">select</span> playerno, sex <br>    <span class="hljs-keyword">from</span> players <br>    <span class="hljs-keyword">where</span> playerno <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>) <br><span class="hljs-keyword">as</span> players10 <span class="hljs-keyword">where</span> sex<span class="hljs-operator">=</span><span class="hljs-string">&#x27;M&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="行子查询实例"><a href="#行子查询实例" class="headerlink" title="行子查询实例"></a>行子查询实例</h2><p>如：获取和100号球员性别相同并且居住在同一城市的球员号码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> playerno <br><span class="hljs-keyword">from</span> players <br><span class="hljs-keyword">where</span> (sex, town) <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">select</span> sex, town <br>    <span class="hljs-keyword">from</span> players <br>    <span class="hljs-keyword">where</span> playerno <span class="hljs-operator">=</span> <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>说明：子查询的结果是带有两个值的一行：（’M’,’stratford’）。这个值和一个行表达式（sex,town）进行比较。</p><h2 id="标量子查询实例"><a href="#标量子查询实例" class="headerlink" title="标量子查询实例"></a>标量子查询实例</h2><p>可以指定一个标量表达式的任何地方，几乎都可以使用一个标量子查询。 如：获取和27号球员出生在同一年的球员的号码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> playerno <br><span class="hljs-keyword">from</span> players <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span>(birth_date) <span class="hljs-operator">=</span> <br>    (<span class="hljs-keyword">select</span> <span class="hljs-keyword">year</span>(birth_date) <br>    <span class="hljs-keyword">from</span> players <br>    <span class="hljs-keyword">where</span> playerno <span class="hljs-operator">=</span> <span class="hljs-number">27</span>) <br><span class="hljs-keyword">and</span> playerno <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">27</span>;<br></code></pre></td></tr></table></figure><p>上面语句等同于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> playerno <span class="hljs-keyword">from</span> players <span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span>(birth_date) <span class="hljs-operator">=</span> <span class="hljs-number">1964</span> <span class="hljs-keyword">and</span> playerno <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">27</span>;<br></code></pre></td></tr></table></figure><h2 id="列子查询实例"><a href="#列子查询实例" class="headerlink" title="列子查询实例"></a>列子查询实例</h2><p> 由于列子查询返回的结果集是 N 行一列，因此不能直接使用 =  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt; 这些比较标量结果的操作符。在列子查询中可以使用 IN、ANY（SOME）和ALL操作符：   IN：在指定项内，同 IN(项1,项2,…)。   ANY：与比较操作符联合使用，ANY关键字必须接在一个比较操作符的后面，表示与子查询返回的任何值比较为 TRUE ，则返回 TRUE 。   SOME：ANY 的别名，较少使用。   ALL：与比较操作符联合使用，ALL关键字必须接在一个比较操作符的后面，表示与子查询返回的所有值比较都为 TRUE ，则返回 TRUE 。</p><p>  实例1（in）：获取球员性别为女的所有球员的球员号，名字及所在城市。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> playerno, name, town <br><span class="hljs-keyword">from</span> players <br><span class="hljs-keyword">where</span> playerno <span class="hljs-keyword">in</span> <br>    (<span class="hljs-keyword">select</span> playerno <br>    <span class="hljs-keyword">from</span> players <br>    <span class="hljs-keyword">where</span> sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;F&#x27;</span>);<br></code></pre></td></tr></table></figure><p>实例2（any）：获取至少比同城的另一球员年轻的所有球员的号码，日期和居住城市。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> playerno, birth_date, town <br><span class="hljs-keyword">from</span> players <span class="hljs-keyword">as</span> p1 <br><span class="hljs-keyword">where</span> birth_date <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span> <br>    (<span class="hljs-keyword">select</span> birth_date <br>    <span class="hljs-keyword">from</span> players <span class="hljs-keyword">as</span> p2 <br>    <span class="hljs-keyword">where</span> p1.town <span class="hljs-operator">=</span> p2.town);<br></code></pre></td></tr></table></figure><p>实例3（all）：获取最老球员的号码，名字及生日。（即出生日期数值小于或等于所有其它球员的球员）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> playerno, name, birth_date <br><span class="hljs-keyword">from</span> players <br><span class="hljs-keyword">where</span> birth_date <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">all</span> <br>    (<span class="hljs-keyword">select</span> birth_date <br>    <span class="hljs-keyword">from</span> players);<br></code></pre></td></tr></table></figure><p>XISTS关键字表示存在。使用EXISTS关键字时，内层查询语句不返回查询的记录，而是返回一个真假值，如果内层查询语句查询到满足条件的记录，只要子查询中至少返回一个值，则EXISTS语句的值就为True。就返回true，否则返回false。当返回的值为true时，外层查询语句将进行查询，否则不进行查询。NOT EXISTS刚好与之相反。exists的用法和in ()差不多，但是它们还是有区别的。主要是看两个张表大小差的程度。若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）;</p><p>  实例1（exists）：获取那些至少支付了一次罚款的球员的名字和首字母。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> name, initials <br><span class="hljs-keyword">from</span> players <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> <br>    (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> penalties <br>    <span class="hljs-keyword">where</span> playerno <span class="hljs-operator">=</span> players.playerno);<br></code></pre></td></tr></table></figure><p>实例2（not exists）：获取那些从来没有罚款的球员的名字和首字母。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> name, initials <br><span class="hljs-keyword">from</span> players <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> <br>    (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> penalties <br>    <span class="hljs-keyword">where</span> playerno <span class="hljs-operator">=</span> players.playerno);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java语言描述数据结构与算法</title>
    <link href="/blog/2021/01/20/java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/blog/2021/01/20/java%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>冒泡排序 插入排序 选择排序 希尔排序 快速排序 归并排序 二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">package</span> com.demo.test;<br> <br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//随机输入n个数,存放在数组a中</span><br>    Scanner scanner=<span class="hljs-keyword">new</span> Scanner(System.in);<br>    <span class="hljs-keyword">int</span> n=scanner.nextInt();<br>    <span class="hljs-keyword">int</span> a[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-comment">//这是第一种输入方法</span><br>    <span class="hljs-comment">/*for (int i=0;i&lt;n;i++) &#123;</span><br><span class="hljs-comment">    a[i]=scanner.nextInt();</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//这是第二种输入方法</span><br>    <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(k&lt;n) &#123;<br>    a[k]=scanner.nextInt();<br>    k++;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span>[] b=choicSort(a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;b.length;j++) &#123;<br>    System.out.print(b[j]+<span class="hljs-string">&quot;  &quot;</span>);<br>    &#125;<br>    &#125;<br>    <br><br><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] array) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;array.length;i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;array.length-i;j++) &#123;<br><span class="hljs-keyword">if</span> (array[j]&gt;array[j+<span class="hljs-number">1</span>]) &#123;<br><span class="hljs-keyword">int</span> temp=array[j];<br>array[j]=array[j+<span class="hljs-number">1</span>];<br>array[j+<span class="hljs-number">1</span>]=temp;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-comment">//插入排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] insertSort(<span class="hljs-keyword">int</span>[] array) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;array.length;i++) &#123;<br><span class="hljs-keyword">int</span> j=i;<br><span class="hljs-keyword">int</span> temp=array[i];<br><span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;array[j-<span class="hljs-number">1</span>]&gt;temp) &#123;<br>array[j]=array[j-<span class="hljs-number">1</span>];<br>j--;<br>&#125;<br>array[j]=temp;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-comment">//选择排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] choicSort(<span class="hljs-keyword">int</span>[] array) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;array.length-<span class="hljs-number">1</span>;i++) &#123;<br><span class="hljs-keyword">int</span> min=i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;array.length;j++) &#123;<br><span class="hljs-keyword">if</span> (array[j]&lt;array[min]) &#123;<br>min=j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (min!=i) &#123;<br><span class="hljs-keyword">int</span> temp=array[i];<br>array[i]=array[min];<br>array[min]=temp;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-comment">//希尔排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] shellSort(<span class="hljs-keyword">int</span>[] array) &#123;<br><span class="hljs-keyword">int</span> step=(array.length-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (step&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=step;i&lt;array.length;i++) &#123;<br><span class="hljs-keyword">int</span> j=i;<br><span class="hljs-keyword">int</span> temp=array[i];<br><span class="hljs-keyword">while</span>(j&gt;(step-<span class="hljs-number">1</span>)&amp;&amp;array[j-step]&gt;=temp) &#123;<br>array[j]=array[j-step];<br>j=j-step;<br>&#125;<br>array[j]=temp;<br>&#125;<br>step=step/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-comment">//快速排序</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>reQuickSort(array,<span class="hljs-number">0</span>,array.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reQuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (left&gt;=right) &#123;<br><span class="hljs-keyword">return</span> ;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">int</span> partition=partitionIt(array,left,right);<br>reQuickSort(array,left,partition-<span class="hljs-number">1</span>);<br>reQuickSort(array,partition+<span class="hljs-number">1</span>,right);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partitionIt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=left;<br><span class="hljs-keyword">int</span> j=right+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> povit=array[left];<br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">while</span> (i&lt;right&amp;&amp;array[++i]&lt;povit) &#123;&#125;<br><span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;array[--j]&gt;povit) &#123;&#125;<br><span class="hljs-keyword">if</span> (i&lt;j) &#123;<br>swap(array,i,j);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>swap(array,left,j);<br><span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123;<br><span class="hljs-keyword">int</span> temp=array[i];<br>array[i]=array[j];<br>array[j]=temp;<br>&#125;<br> <br> <br><span class="hljs-comment">//归并排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] a,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)&#123;<br>        <span class="hljs-keyword">int</span> mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>            sort(a,low,mid);<br>            sort(a,mid+<span class="hljs-number">1</span>,high);<br>            <span class="hljs-comment">//左右归并</span><br>            merge(a,low,mid,high);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[high-low+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> i= low;<br>        <span class="hljs-keyword">int</span> j = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 把较小的数先移到新数组中</span><br>        <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=high)&#123;<br>            <span class="hljs-keyword">if</span>(a[i]&lt;a[j])&#123;<br>                temp[k++] = a[i++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp[k++] = a[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 把左边剩余的数移入数组 </span><br>        <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>            temp[k++] = a[i++];<br>        &#125;<br>        <span class="hljs-comment">// 把右边边剩余的数移入数组</span><br>        <span class="hljs-keyword">while</span>(j&lt;=high)&#123;<br>            temp[k++] = a[j++];<br>        &#125;<br>        <span class="hljs-comment">// 把新数组中的数覆盖nums数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;temp.length;x++)&#123;<br>            a[x+low] = temp[x];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySerach</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i=left;<br><span class="hljs-keyword">int</span> j=right;<br><span class="hljs-keyword">int</span> mid=(i+j)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (i&gt;j) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (array[mid]&gt;value) &#123;<br><span class="hljs-keyword">return</span> binarySerach(array,<span class="hljs-number">0</span>,mid-<span class="hljs-number">1</span>,value);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[mid]&lt;value)&#123;<br><span class="hljs-keyword">return</span> binarySerach(array,mid+<span class="hljs-number">1</span>,right,value);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><br>&#125;<br><br>&#125;<br> <br> <br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql行列转换</title>
    <link href="/blog/2021/01/20/mysql%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2/"/>
    <url>/blog/2021/01/20/mysql%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>需求是将以下两种表样式互相转换：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190821-153724@2x_1566373118554.png" alt="WX20190821-153724@2x"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190821-153732@2x_1566373118567.png" alt="WX20190821-153732@2x">score_1转score_2，如下： 这里也可以用来统计数据</p><p>如果等于1 就加一 不然就不加 SUM(IF(C.question_type = ‘1’, 1, 0)) AS ‘论述’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ID<br>    ,<span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> course<span class="hljs-operator">=</span><span class="hljs-string">&#x27;数学&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数学&#x27;</span><br>    ,<span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> course<span class="hljs-operator">=</span><span class="hljs-string">&#x27;英语&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;英语&#x27;</span><br>    ,<span class="hljs-built_in">max</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> course<span class="hljs-operator">=</span><span class="hljs-string">&#x27;法律&#x27;</span> <span class="hljs-keyword">then</span> score <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;法律&#x27;</span><br><span class="hljs-keyword">from</span> score_1<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> id;<br></code></pre></td></tr></table></figure><p>score_2转score_1：两种引号不同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <br>    ,<span class="hljs-string">&#x27;数学&#x27;</span> <span class="hljs-keyword">as</span> course<br>    ,`数学` <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> score_2<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <br><span class="hljs-keyword">select</span> id <br>    ,<span class="hljs-string">&#x27;英语&#x27;</span> <span class="hljs-keyword">as</span> course<br>    ,`英语` <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> score_2<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <br><span class="hljs-keyword">select</span> id <br>    ,<span class="hljs-string">&#x27;法律&#x27;</span> <span class="hljs-keyword">as</span> course<br>    ,`法律` <span class="hljs-keyword">as</span> score<br><span class="hljs-keyword">from</span> score_2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左连接-右连接-内连接-全外连接的4者区别</title>
    <link href="/blog/2021/01/20/%E5%B7%A6%E8%BF%9E%E6%8E%A5-%E5%8F%B3%E8%BF%9E%E6%8E%A5-%E5%86%85%E8%BF%9E%E6%8E%A5-%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%844%E8%80%85%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/01/20/%E5%B7%A6%E8%BF%9E%E6%8E%A5-%E5%8F%B3%E8%BF%9E%E6%8E%A5-%E5%86%85%E8%BF%9E%E6%8E%A5-%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%844%E8%80%85%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="基本定义："><a href="#基本定义：" class="headerlink" title="基本定义："></a>基本定义：</h1><p>　　left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。</p><p>　　right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。</p><p>　　inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。</p><p>　　full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。</p><p>举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">　A表　　　　　　　　　　<br> <br>　　id　  name　　<br> <br>　　<span class="hljs-number">1</span>　　小王<br> <br>　　<span class="hljs-number">2</span>　　小李<br> <br>　　<span class="hljs-number">3</span>　　小刘<br> <br>　　B表<br> <br>　　id　　A_id　　job<br> <br>　　<span class="hljs-number">1</span>　　<span class="hljs-number">2</span>　　　　老师<br> <br>　　<span class="hljs-number">2</span>　　<span class="hljs-number">4</span>　　　　程序员<br></code></pre></td></tr></table></figure><h2 id="内连接：（只有2张表匹配的行才能显示）"><a href="#内连接：（只有2张表匹配的行才能显示）" class="headerlink" title="内连接：（只有2张表匹配的行才能显示）"></a>内连接：（只有2张表匹配的行才能显示）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name,b.job <span class="hljs-keyword">from</span> A a  <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B b <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>b.A_id<br> <br>　　只能得到一条记录<br> <br>　　小李　　老师<br></code></pre></td></tr></table></figure><h2 id="左连接：（左边的表不加限制）"><a href="#左连接：（左边的表不加限制）" class="headerlink" title="左连接：（左边的表不加限制）"></a>左连接：（左边的表不加限制）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name,b.job <span class="hljs-keyword">from</span> A a  <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B b <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>b.A_id<br> <br>　　三条记录<br> <br>　　小王　　<span class="hljs-keyword">null</span><br> <br>　　小李　　老师<br> <br>　　小刘　　<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h2 id="右连接：（右边的表不加限制）"><a href="#右连接：（右边的表不加限制）" class="headerlink" title="右连接：（右边的表不加限制）"></a>右连接：（右边的表不加限制）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name,b.job <span class="hljs-keyword">from</span> A a  <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B b <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>b.A_id<br> <br>　　两条记录<br> <br>　　小李　　老师<br> <br>　　<span class="hljs-keyword">null</span>　　程序员<br></code></pre></td></tr></table></figure><h2 id="全外连接：-左右2张表都不加限制）"><a href="#全外连接：-左右2张表都不加限制）" class="headerlink" title="全外连接：(左右2张表都不加限制）"></a>全外连接：(左右2张表都不加限制）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name,b.job <span class="hljs-keyword">from</span> A a  <span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> B b <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>b.A_id<br> <br>　　四条数据<br> <br>　　小王　　<span class="hljs-keyword">null</span><br> <br>　　小李　　老师<br> <br>　　小刘　　<span class="hljs-keyword">null</span><br> <br>　　<span class="hljs-keyword">null</span>　　程序员<br></code></pre></td></tr></table></figure><p>注：在sql中l外连接包括左连接（left join ）和右连接（right join），全外连接（full join），等值连接（inner join）又叫内连接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql基本操作命令汇总</title>
    <link href="/blog/2021/01/19/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <url>/blog/2021/01/19/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="关于数据库"><a href="#关于数据库" class="headerlink" title="关于数据库"></a>关于数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建数据库<br><span class="hljs-keyword">create</span> database h_test;        <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看数据库<br><span class="hljs-keyword">show</span> databases;  <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看数据库信息    <br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> database h_test;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改数据库的编码，可使用上一条语句查看是否修改成功<br><span class="hljs-keyword">alter</span> database h_test <span class="hljs-keyword">default</span> <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> gbk <span class="hljs-keyword">collate</span> gbk_bin;      <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除数据库<br><span class="hljs-keyword">drop</span> database h_test;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>综上，可以直接创建数据库且设置编码方式<br><span class="hljs-keyword">CREATE</span> DATABASE h_test <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>首先选定操作的数据库<br>use h_test;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建表student<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id  <span class="hljs-type">int</span>(<span class="hljs-number">11</span>),<br>  name  <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>  age <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看数据表<br><span class="hljs-keyword">show</span> tables;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看数据表信息，后面加上参数<span class="hljs-operator">/</span>G可使结果更加美观<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看表的的字段信息<br><span class="hljs-keyword">desc</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改表名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student rename [<span class="hljs-keyword">to</span>] h_student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改字段名<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> h_student change name stu_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改字段的数据类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> h_student modify id <span class="hljs-type">int</span>(<span class="hljs-number">20</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>添加字段<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> h_student <span class="hljs-keyword">add</span> grade <span class="hljs-type">float</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除字段<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> h_student <span class="hljs-keyword">drop</span> grade;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改字段的位置<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> h_student modify stu_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">first</span>;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> h_student modify id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) after age;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除数据表<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> h_student;<br></code></pre></td></tr></table></figure><h2 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190820-155510@2x_1566287798018.png" alt="WX20190820-155510@2x"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>作用：提高表中数据的查询速度 1.普通索引 2.唯一性索引 3.全文索引 4.单列索引 5.多列索引 6.空间索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建索引<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一.创建表的时候创建索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>        字段名 数据类型[完整性约束条件],<br>        ...<br>        字段名 数据类型,<br>        [<span class="hljs-keyword">UNIQUE</span><span class="hljs-operator">|</span>FULLTEXT<span class="hljs-operator">|</span>SPATIAL] INDEX<span class="hljs-operator">|</span>KEY<br>  );<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-number">-1.</span>创建普通索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test1(<br>  id  <span class="hljs-type">INT</span>,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  age <span class="hljs-type">INT</span>,<br>  INDEX (id)<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>可以插入一条数据,查看索引是否被使用<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test1 <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> \G;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-number">-2.</span>创建唯一性索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test2(<br>  id  <span class="hljs-type">INT</span>,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  age <span class="hljs-type">INT</span>,<br>  <span class="hljs-keyword">UNIQUE</span> INDEX unique_id(id <span class="hljs-keyword">asc</span>)<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-number">-3.</span>创建全文索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test3(<br>  id  <span class="hljs-type">INT</span>,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  age <span class="hljs-type">INT</span>,<br>  FULLTEXT INDEX fulltext_name(name)<br>)ENGINE<span class="hljs-operator">=</span>MyISAM;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-number">-4.</span>创建单列索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test4(<br>  id  <span class="hljs-type">INT</span>,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  age <span class="hljs-type">INT</span>,<br>  INDEX single_name(name(<span class="hljs-number">20</span>))<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-number">-5.</span>创建多列索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test5(<br>  id  <span class="hljs-type">INT</span>,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  age <span class="hljs-type">INT</span>,<br>  INDEX multi(id,name(<span class="hljs-number">20</span>))<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-number">-6.</span>创建空间索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test6(<br>  id  <span class="hljs-type">INT</span>,<br>  space GEOMETRY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  SPATIAL INDEX sp(space)<br>)ENGINE<span class="hljs-operator">=</span>MyISAM;<br><span class="hljs-comment">---------------------------------------------------</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>二.使用<span class="hljs-keyword">create</span> index语句在已经存在的表上创建索引<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>首先新建一个表,这个表没有索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id <span class="hljs-type">int</span>,<br>  age <span class="hljs-type">int</span>,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>  intro <span class="hljs-type">varchar</span>(<span class="hljs-number">40</span>),<br>  g GEOMETRY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)ENGINE<span class="hljs-operator">=</span>MyISAM;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-number">-1.</span>创建普通索引<br><span class="hljs-keyword">create</span> index index_id <span class="hljs-keyword">on</span> student(id);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-number">-2.</span>创建唯一性索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index uniqueidx <span class="hljs-keyword">on</span> student(id);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-number">-3.</span>创建单列索引<br><span class="hljs-keyword">create</span> index singleidx <span class="hljs-keyword">on</span> student(age);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-number">-4.</span>创建多列索引<br><span class="hljs-keyword">create</span> index mulitidx <span class="hljs-keyword">on</span> student(name(<span class="hljs-number">20</span>),intro(<span class="hljs-number">40</span>));<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-number">-5.</span>创建全文索引<br><span class="hljs-keyword">create</span> fulltext index fulltextidx <span class="hljs-keyword">on</span> student(name);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-number">-6.</span>创建空间索引<br><span class="hljs-keyword">create</span> spatial index spatidx <span class="hljs-keyword">on</span> student(g); <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>三.使用<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>语句在已经存在的表上创建索引<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除student表，重新创建<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id <span class="hljs-type">int</span>,<br>  age <span class="hljs-type">int</span>,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>  intro <span class="hljs-type">varchar</span>(<span class="hljs-number">40</span>),<br>  space GEOMETRY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)ENGINE<span class="hljs-operator">=</span>MyISAM;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3</span><span class="hljs-number">-1.</span>创建普通索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> index index_id(id);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3</span><span class="hljs-number">-2.</span>创建唯一性索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> uniqueidx(id);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3</span><span class="hljs-number">-3.</span>创建单列索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> index singleidx (age);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3</span><span class="hljs-number">-4.</span>创建多列索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> index multidx(name(<span class="hljs-number">20</span>),intro(<span class="hljs-number">40</span>));<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3</span><span class="hljs-number">-5.</span>创建全文索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> fulltext index fulltextidx(name);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3</span><span class="hljs-number">-6.</span>创建空间索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> spatial index spatidx(space);<br> <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除索引，有下面两种方式<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>使用<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>删除索引fulltextidx<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">drop</span> index fulltextidx;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>使用<span class="hljs-keyword">drop</span> index删除索引spatidx<br><span class="hljs-keyword">drop</span> index spatidx <span class="hljs-keyword">on</span> student;<br> <br></code></pre></td></tr></table></figure><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>重新建立表student<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id <span class="hljs-type">int</span>,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  grade <span class="hljs-type">float</span><br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>插入一条数据，也可以少某个字段的同时也少对应的数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,name,grade) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;howie&#x27;</span>,<span class="hljs-number">70</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>也可以不指定字段名，但要注意顺序<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;howie&#x27;</span>,<span class="hljs-number">80</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>也可以这样添加数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">set</span> id<span class="hljs-operator">=</span><span class="hljs-number">3</span>,name<span class="hljs-operator">=</span>&quot;howie&quot;,grade<span class="hljs-operator">=</span><span class="hljs-number">90</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>同时添加多条数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span><br>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;howie&#x27;</span>,<span class="hljs-number">80</span>),<br>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;howie&#x27;</span>,<span class="hljs-number">80</span>),<br>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;howie&#x27;</span>,<span class="hljs-number">80</span>);<br></code></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>更新id<span class="hljs-operator">=</span><span class="hljs-number">1</span>的数据<br><span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span>&quot;howie1&quot;,grade<span class="hljs-operator">=</span><span class="hljs-number">60</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>批量更新,如果没有<span class="hljs-keyword">where</span>子句，会更新表中所有对应数据<br><span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> grade<span class="hljs-operator">=</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">4</span>;<br> <br></code></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除id<span class="hljs-operator">=</span><span class="hljs-number">6</span>的数据<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">6</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>批量删除数据<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除所有数据,DDL(数据定义语言)语句 <span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> student也可以删除表内所有数据<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student;<br></code></pre></td></tr></table></figure><h2 id="单表查询和多表操作"><a href="#单表查询和多表操作" class="headerlink" title="单表查询和多表操作"></a>单表查询和多表操作</h2><p>单表查询：如何从数据库中获取你需要的数据 多表查询：实际开发中，需要进行2张表以上进行操作</p><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>建立表student<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  grade <span class="hljs-type">float</span>,<br>  <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>(id)<br>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>插入数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student (name,grade) <span class="hljs-keyword">values</span><br>(&quot;howie1&quot;,<span class="hljs-number">40</span>),<br>(&quot;howie1&quot;,<span class="hljs-number">50</span>),<br>(&quot;howie2&quot;,<span class="hljs-number">50</span>),<br>(&quot;howie3&quot;,<span class="hljs-number">60</span>),<br>(&quot;howie4&quot;,<span class="hljs-number">70</span>),<br>(&quot;howie5&quot;,<span class="hljs-number">80</span>),<br>(&quot;howie6&quot;,<span class="hljs-keyword">null</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询全部<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询某个字段<br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>条件查询,查询id<span class="hljs-operator">=</span><span class="hljs-number">2</span>学生的信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">in</span>关键字查询,也可以使用<span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-keyword">IN</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">between</span> <span class="hljs-keyword">and</span>关键字查询<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>空值(<span class="hljs-keyword">NULL</span>)查询，使用<span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>来判断<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> grade <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">distinct</span>关键字查询<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> name <span class="hljs-keyword">from</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">like</span>关键字查询,查询以h开头，e结尾的数据<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> &quot;h%e&quot;;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">and</span>关键字多条件查询,<span class="hljs-keyword">or</span>关键字的使用也是类似<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">5</span> <span class="hljs-keyword">and</span> grade<span class="hljs-operator">&gt;</span><span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>聚合函数<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-built_in">count</span>()函数,<span class="hljs-built_in">sum</span>()函数,<span class="hljs-built_in">avg</span>()函数,<span class="hljs-built_in">max</span>()函数,<span class="hljs-built_in">min</span>()函数<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> student;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(grade) <span class="hljs-keyword">from</span> student;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(grade) <span class="hljs-keyword">from</span> student;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(grade) <span class="hljs-keyword">from</span> student;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(grade) <span class="hljs-keyword">from</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对查询结果进行排序<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> grade;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>分组查询<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>单独使用<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>分组<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> grade;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>和聚合函数一起使用<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),grade <span class="hljs-keyword">from</span> student <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> grade;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3.</span>和<span class="hljs-keyword">having</span>关键字一起使用<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(grade),name <span class="hljs-keyword">from</span> student <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> grade <span class="hljs-keyword">having</span> <span class="hljs-built_in">sum</span>(grade) <span class="hljs-operator">&gt;</span><span class="hljs-number">100</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>使用limit限制查询结果的数量<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student limit <span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student limit <span class="hljs-number">2</span>,<span class="hljs-number">2</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> grade <span class="hljs-keyword">desc</span> limit <span class="hljs-number">2</span>,<span class="hljs-number">2</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>函数,mysql提供了许多函数<br><span class="hljs-keyword">select</span> concat(id,<span class="hljs-string">&#x27;:&#x27;</span>,name,<span class="hljs-string">&#x27;:&#x27;</span>,grade) <span class="hljs-keyword">from</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>为表取别名<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">as</span> stu <span class="hljs-keyword">where</span> stu.name<span class="hljs-operator">=</span>&quot;howie&quot;;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>为字段取别名,<span class="hljs-keyword">as</span>关键字也可以不写<br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">as</span> stu_name,grade stu_grade <span class="hljs-keyword">from</span> student;<br></code></pre></td></tr></table></figure><h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><p>1.了解外键 2.了解关联关系 3.了解各种连接查询多表的数据 4.了解子查询，会使用各种关键字以及比较运算符查询多表中的数据</p><p>外键 外键是指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一性约束，用于建立和加强两个数据表之间的连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建表class,student<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> class(<br>   id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>   classname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>)ENGINE<span class="hljs-operator">=</span>InnoDB;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>   stu_id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>   stu_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>   cid <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>      <span class="hljs-comment">-- 表示班级id，它就是class表的外键</span><br>)ENGINE<span class="hljs-operator">=</span>InnoDB;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>添加外键约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_ID <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(cid) <span class="hljs-keyword">references</span> class(id);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除外键约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span> FK_ID;<br></code></pre></td></tr></table></figure><h2 id="操作关联表"><a href="#操作关联表" class="headerlink" title="操作关联表"></a>操作关联表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>数据表有三种关联关系，多对一、多对多、一对一<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>学生(student)和班级(class)是多对一关系，添加数据<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>首选添加外键约束<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK_ID <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(cid) <span class="hljs-keyword">references</span> class(id);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>添加数据,这两个表便有了关联若插入中文在终端显示空白，可设置<span class="hljs-keyword">set</span> names <span class="hljs-string">&#x27;gbk&#x27;</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> class <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,&quot;软件一班&quot;),(<span class="hljs-number">2</span>,&quot;软件二班&quot;);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,&quot;howie&quot;,<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>,&quot;howie1&quot;,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,&quot;howie2&quot;,<span class="hljs-number">1</span>),(<span class="hljs-number">4</span>,&quot;howie3&quot;,<span class="hljs-number">2</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>交叉连接<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> class;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>内连接，该功能也可以使用<span class="hljs-keyword">where</span>语句实现<br><span class="hljs-keyword">select</span> student.stu_name,class.classname <span class="hljs-keyword">from</span> student <span class="hljs-keyword">join</span> class <span class="hljs-keyword">on</span> class.id<span class="hljs-operator">=</span>student.cid;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>外连接<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>首先在student,class表中插入数据<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> class <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,&quot;软件三班&quot;);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>左连接，右连接<br><span class="hljs-keyword">select</span> s.stu_id,s.stu_name,c.classname <span class="hljs-keyword">from</span> student s <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> class c <span class="hljs-keyword">on</span> c.id<span class="hljs-operator">=</span>s.cid;<br><span class="hljs-keyword">select</span> s.stu_id,s.stu_name,c.classname <span class="hljs-keyword">from</span> student s <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> class c <span class="hljs-keyword">on</span> c.id<span class="hljs-operator">=</span>s.cid;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>复合条件连接查询就是添加过滤条件<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>子查询<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">in</span>关键字子查询跟上面的<span class="hljs-keyword">in</span>关键字查询类似<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> cid <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> class <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">exists</span>关键字查询,相当于测试，不产生数据，只返回<span class="hljs-literal">true</span>或者<span class="hljs-literal">false</span>，只有返回<span class="hljs-literal">true</span>，外层才会执行，具体看下图<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> class <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">12</span>);   <span class="hljs-comment">-- 外层不会执行</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> class <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>);    <span class="hljs-comment">-- 外层会执行</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">any</span>关键字查询<br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> cid<span class="hljs-operator">&gt;</span><span class="hljs-keyword">any</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> class);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">all</span>关键字查询<br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> cid<span class="hljs-operator">=</span><span class="hljs-keyword">any</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> class);<br></code></pre></td></tr></table></figure><h1 id="事务与存储过程"><a href="#事务与存储过程" class="headerlink" title="事务与存储过程"></a>事务与存储过程</h1><p>事务的概念，会开启、提交和回滚事务 事务的四种隔离级别 创建存储过程 调用、查看、修改和删除存储过程</p><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;  <span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">commit</span>;             <span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">rollback</span>;           <span class="hljs-comment">-- 取消事务(回滚)</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建表account，插入数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> account(<br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">40</span>),<br>  money <span class="hljs-type">float</span><br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account(name,money) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1000</span>),(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2000</span>),(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3000</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>利用事务实现转账功能，首先开启事务，然后执行语句，提交事务<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money<span class="hljs-operator">=</span>money<span class="hljs-number">-100</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money<span class="hljs-operator">=</span>money<span class="hljs-operator">+</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-keyword">commit</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>事务的提交，通过这个命令查看mysql提交方式<br><span class="hljs-keyword">select</span> @<span class="hljs-variable">@autocommit</span>; <span class="hljs-comment">-- 若为1，表示自动提交，为0，就要手动提交</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>若事务的提交方式为手动提交<br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">-- 设置为手动提交</span><br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money<span class="hljs-operator">=</span>money<span class="hljs-operator">+</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money<span class="hljs-operator">=</span>money<span class="hljs-number">-100</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>现在执行<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account 可以看到转账成功，若此时退出数据库重新登录，会看到各账户余额没有改变，所以一定要用<span class="hljs-keyword">commit</span>语句提交事务，否则会失败<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>事务的回滚，别忘记设置为手动提交的模式<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money<span class="hljs-operator">=</span>money<span class="hljs-number">-100</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> money<span class="hljs-operator">=</span>money<span class="hljs-operator">+</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>若此时a不想转账给b，可以使用事务的回滚<br><span class="hljs-keyword">rollback</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>事务的隔离级别<br>read uncommitted;<br>read committed;<br>repeatable read;<br>serializable;<br></code></pre></td></tr></table></figure><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建查看student表的存储过程<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建student表<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student( <br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment, <br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>), <br>  grade <span class="hljs-type">float</span> <br>)ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br>delimiter <span class="hljs-operator">/</span><span class="hljs-operator">/</span>  <span class="hljs-comment">-- 将mysql的结束符设置为//</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> Proc()<br>  <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br>  <span class="hljs-keyword">end</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br>delimiter ;   <span class="hljs-comment">-- 将mysql的结束符设置为;</span><br><span class="hljs-keyword">call</span> Proc();  <span class="hljs-comment">-- 这样就可以调用该存储过程</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>变量的使用,mysql中变量不用事前申明，在用的时候直接用“@变量名”使用就可以<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@number</span><span class="hljs-operator">=</span><span class="hljs-number">100</span>; <span class="hljs-comment">-- 或set @num:=1;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>定义条件和处理程序<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>光标的使用<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>声明光标<br><span class="hljs-keyword">DECLARE</span> <span class="hljs-operator">*</span> cursor_name<span class="hljs-operator">*</span> <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> select_statement<br><span class="hljs-number">2.</span> 光标<span class="hljs-keyword">OPEN</span>语句<br><span class="hljs-keyword">OPEN</span> cursor_name<br><span class="hljs-number">3.</span> 光标<span class="hljs-keyword">FETCH</span>语句<br><span class="hljs-keyword">FETCH</span> cursor_name <span class="hljs-keyword">INTO</span> var_name [, var_name] ...<br><span class="hljs-number">4.</span> 光标<span class="hljs-keyword">CLOSE</span>语句<br><span class="hljs-keyword">CLOSE</span> cursor_name<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>流程控制的使用  不做介绍<br> <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>定义存储过程<br>delimiter <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> proc1(<span class="hljs-keyword">in</span> name <span class="hljs-type">varchar</span>(<span class="hljs-number">4</span>),<span class="hljs-keyword">out</span> num <span class="hljs-type">int</span>)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> num <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>name;<br><span class="hljs-keyword">end</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br>delimiter ;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>调用存储过程<br><span class="hljs-keyword">call</span> proc1(&quot;tom&quot;,<span class="hljs-variable">@num</span>) <span class="hljs-comment">-- 查找名为tom学生人数</span><br> <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看存储过程<br> <span class="hljs-keyword">show</span> <span class="hljs-keyword">procedure</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;p%&#x27;</span> \G <span class="hljs-comment">-- 获得以p开头的存储过程信息</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改存储过程<br>alter &#123;procedure|function&#125; sp_name[characteristic...]<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除存储过程<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">procedure</span> proc1;<br></code></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>如何创建视图 查看、修改、更新、删除视图</p><h2 id="视图的基本操作"><a href="#视图的基本操作" class="headerlink" title="视图的基本操作"></a>视图的基本操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>在单表上创建视图,重新创建student表，插入数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  math <span class="hljs-type">float</span>,<br>  chinese <span class="hljs-type">float</span><br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(name,math,chinese) <span class="hljs-keyword">values</span><br>(<span class="hljs-string">&#x27;howie1&#x27;</span>,<span class="hljs-number">66</span>,<span class="hljs-number">77</span>),<br>(<span class="hljs-string">&#x27;howie2&#x27;</span>,<span class="hljs-number">66</span>,<span class="hljs-number">77</span>),<br>(<span class="hljs-string">&#x27;howie3&#x27;</span>,<span class="hljs-number">66</span>,<span class="hljs-number">77</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>开始创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> stu_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> math,chinese,math<span class="hljs-operator">+</span>chinese <span class="hljs-keyword">from</span> student;  <span class="hljs-comment">-- 下图可看出创建成功</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>也可以创建自定义字段名称的视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> stu_view2(math,chin,sum) <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> math,chinese,math<span class="hljs-operator">+</span>chinese <span class="hljs-keyword">from</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>在多表上创建视图，创建表stu_info，插入数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu_info(<br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>  class <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  addr <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> stu_info(class,addr) <span class="hljs-keyword">values</span><br>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;anhui&#x27;</span>),<br>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;fujian&#x27;</span>),<br>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;guangdong&#x27;</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建视图stu_class<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> stu_class(id,name,class) <span class="hljs-keyword">as</span> <br><span class="hljs-keyword">select</span> student.id,student.name,stu_info.class <span class="hljs-keyword">from</span> <br>student,stu_info <span class="hljs-keyword">where</span> student.id<span class="hljs-operator">=</span>stu_info.id;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看视图<br><span class="hljs-keyword">desc</span> stu_class;<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">table</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;stu_class&#x27;</span>\G<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> stu_class\G<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> stu_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">view</span> stu_view <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> chinese <span class="hljs-keyword">from</span> student;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>更新视图<br><span class="hljs-keyword">update</span> stu_view <span class="hljs-keyword">set</span> chinese<span class="hljs-operator">=</span><span class="hljs-number">100</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;haha&#x27;</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> stu_view2 <span class="hljs-keyword">where</span> math<span class="hljs-operator">=</span><span class="hljs-number">100</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除视图<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> if <span class="hljs-keyword">exists</span> stu_view2;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringAOP原理分析</title>
    <link href="/blog/2021/01/19/SpringAOP%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/blog/2021/01/19/SpringAOP%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring核心知识"><a href="#Spring核心知识" class="headerlink" title="Spring核心知识"></a>Spring核心知识</h1><p>Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为J2EE应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转(IoC)和面向切面(AOP)。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式)轻量级开源框架。</p><p>为什么说Spring是一个一站式的轻量级开源框架呢？EE开发可分成三层架构，针对JavaEE的三层结构，每一层Spring都提供了不同的解决技术。</p><p>• WEB层：SpringMVC</p><p>• 业务层：Spring的IoC</p><p>• 持久层：Spring的JDBCTemplate(Spring的JDBC模板，ORM模板用于整合其他的持久层框架)</p><p>从上面的简要介绍中，我们要知道Spring的核心有两部分：</p><p>• IoC：控制反转。</p><p>举例来说，在之前的操作中，比方说有一个类，我们想要调用类里面的方法(不是静态方法)，就要创建类的对象，使用对象调用方法实现。对于Spring来说，Spring创建对象的过程，不是在代码里面实现的，而是交给Spring来进行配置实现的。</p><p>AOP：面向切面编程。</p><h1 id="SpringAOP原理"><a href="#SpringAOP原理" class="headerlink" title="SpringAOP原理"></a>SpringAOP原理</h1><p>AOP编程技术 什么是AOP编程 AOP: Aspect Oriented Programming 面向切面编程。 　　面向切面编程(也叫面向方面)：Aspect Oriented Programming(AOP),是目前软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 　　AOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向切面（方面）编程。 　　主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。 　　主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改 变这些行为的时候不影响业务逻辑的代码。</p><p>　　可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP实际是GoF设计模式的延续，设计模式孜孜不倦追求的是调用者和被调用者之间的解耦，AOP可以说也是这种目标的一种实现。</p><p>假设把应用程序想成一个立体结构的话，OOP的利刃是纵向切入系统，把系统划分为很多个模块（如：用户模块，文章模块等等），而AOP的利刃是横向切入系统，提取各个模块可能都要重复操作的部分（如：权限检查，日志记录等等）。由此可见，AOP是OOP的一个有效补充。</p><p>注意：AOP不是一种技术，实际上是编程思想。凡是符合AOP思想的技术，都可以看成是AOP的实现。</p><p>Aop， aspect object programming 面向切面编程</p><p>功能： 让关注点代码与业务代码分离！</p><p>关注点</p><p>关注点,重复代码就叫做关注点；</p><p>切面</p><p>关注点形成的类，就叫切面(类)！</p><p>面向切面编程，就是指 对很多功能都有的重复的代码抽取，再在运行的时候网业务方法上动态植入“切面类代码”。</p><p>切入点</p><p>执行目标对象方法，动态植入切面代码。</p><p>可以通过切入点表达式，指定拦截哪些类的哪些方法； 给指定的类在运行的时候植入切面类代码。</p><h1 id="AOP底层实现原理"><a href="#AOP底层实现原理" class="headerlink" title="AOP底层实现原理"></a>AOP底层实现原理</h1><p>代理设计模式</p><p>什么是代理模式</p><p>通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。既(AOP微实现) ,AOP核心技术面向切面编程。</p><p>代理模式应用场景</p><p>SpringAOP、事物原理、日志打印、权限控制、远程调用、安全代理 可以隐蔽真实角色</p><p>代理的分类</p><p>静态代理(静态定义代理类)</p><p>动态代理(动态生成代理类)</p><p>Jdk自带动态代理</p><p>Cglib 、javaassist（字节码操作库）</p><p>静态代理</p><p>什么是静态代理</p><p>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p><p>静态代理代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;已经保存数据...&quot;</span>);<br>    &#125;<br>&#125;<br>代理类<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> IUserDao target;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserDaoProxy</span><span class="hljs-params">(IUserDao iuserDao)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = iuserDao;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开启事物...&quot;</span>);<br>        target.save();<br>        System.out.println(<span class="hljs-string">&quot;关闭事物...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理</p><p>什么是动态代理</p><p>1.代理对象,不需要实现接口</p><p>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</p><p>3.动态代理也叫做:JDK代理,接口代理</p><p>JDK动态代理</p><p>1)原理：是根据类加载器和接口创建代理类（此代理类是接口的实现类，所以必须使用接口 面向接口生成代理，位于java.lang.reflect包下）</p><p>2)实现方式：</p><p>通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);</p><p>通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类Class clazz = Proxy.getProxyClass(classLoader,new Class[]{…});</p><p>通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型Constructor constructor = clazz.getConstructor(new Class[]);</p><p>通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));</p><p>缺点：jdk动态代理，必须是面向接口，目标业务类必须实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvocationHandlerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object target;<span class="hljs-comment">// 这其实业务实现类对象，用来调用具体的业务方法</span><br>    <span class="hljs-comment">// 通过构造函数传入目标对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InvocationHandlerImpl</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = <span class="hljs-keyword">null</span>;<br>        System.out.println(<span class="hljs-string">&quot;调用开始处理&quot;</span>);<br>        result = method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;调用结束处理&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException, InstantiationException,</span><br><span class="hljs-function">            IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;<br>        <span class="hljs-comment">// 被代理对象</span><br>        IUserDao userDao = <span class="hljs-keyword">new</span> UserDao();<br>        InvocationHandlerImpl invocationHandlerImpl = <span class="hljs-keyword">new</span> InvocationHandlerImpl(userDao);<br>        ClassLoader loader = userDao.getClass().getClassLoader();<br>        Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces();<br>        <span class="hljs-comment">// 主要装载器、一组接口及调用处理动态代理实例</span><br>        IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);<br>        newProxyInstance.save();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>CGLIB动态代理与JDK动态区别</p><p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p><p>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p><p>Spring中。</p><p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</p><p>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP</p><p>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p><p>JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。 CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。 因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。</p><h1 id="AOP编程使用"><a href="#AOP编程使用" class="headerlink" title="AOP编程使用"></a>AOP编程使用</h1><p>注解版本实现AOP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;  开启事物注解权限<br><span class="hljs-meta">@Aspect</span>                         指定一个类为切面类       <br><span class="hljs-meta">@Pointcut(&quot;execution(* com.service.UserService.add(..))&quot;)</span>  指定切入点表达式<br><span class="hljs-meta">@Before(&quot;pointCut_()&quot;)</span>              前置通知: 目标方法之前执行<br><span class="hljs-meta">@After(&quot;pointCut_()&quot;)</span>               后置通知：目标方法之后执行（始终执行）<br><span class="hljs-meta">@AfterReturning(&quot;pointCut_()&quot;)</span>       返回后通知： 执行方法结束前执行(异常不执行)<br><span class="hljs-meta">@AfterThrowing(&quot;pointCut_()&quot;)</span>           异常通知:  出现异常时候执行<br><span class="hljs-meta">@Around(&quot;pointCut_()&quot;)</span>              环绕通知： 环绕目标方法执行<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopLog</span> </span>&#123;<br><br>    <span class="hljs-comment">// 前置通知</span><br>    <span class="hljs-meta">@Before(&quot;execution(* com.service.UserService.add(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置通知&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">// 后置通知</span><br>    <span class="hljs-meta">@After(&quot;execution(* com.service.UserService.add(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 运行通知</span><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* com.service.UserService.add(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returning</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;运行通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 异常通知</span><br>    <span class="hljs-meta">@AfterThrowing(&quot;execution(* com.service.UserService.add(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;异常通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知</span><br>    <span class="hljs-meta">@Around(&quot;execution(* com.service.UserService.add(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;环绕通知开始&quot;</span>);<br>        proceedingJoinPoint.proceed();<br>        System.out.println(<span class="hljs-string">&quot;环绕通知结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML方式实现AOP</p><p>Xml实现aop编程： 1） 引入jar文件 【aop 相关jar， 4个】 2） 引入aop名称空间 3）aop 配置 * 配置切面类 （重复执行代码形成的类） * aop配置 拦截哪些方法 / 拦截到方法后应用通知代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>    xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:p=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span><br>    xmlns:context=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span><br>    xmlns:aop=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span><br>    xsi:schemaLocation=<span class="hljs-string">&quot;</span><br><span class="hljs-string">        http://www.springframework.org/schema/beans</span><br><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="hljs-string">        http://www.springframework.org/schema/context</span><br><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="hljs-string">        http://www.springframework.org/schema/aop</span><br><span class="hljs-string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;<br><br>    &lt;!-- dao 实例 --&gt;<br><br>    &lt;bean id=&quot;userService&quot; class=&quot;com.service.UserService&quot;&gt;&lt;/bean&gt;<br>    &lt;!-- 切面类 --&gt;<br>    &lt;bean id=&quot;aop&quot; class=&quot;com.aop2.AopLog2&quot;&gt;&lt;/bean&gt;<br>    &lt;!-- Aop配置 --&gt;<br>    &lt;aop:config&gt;<br>        &lt;!-- 定义一个切入点表达式： 拦截哪些方法 --&gt;<br>        &lt;aop:pointcut expression=<span class="hljs-string">&quot;execution(* com.service.UserService.*(..))&quot;</span><br>            id=<span class="hljs-string">&quot;pt&quot;</span> /&gt;<br>        &lt;!-- 切面 --&gt;<br>        &lt;aop:aspect ref=<span class="hljs-string">&quot;aop&quot;</span>&gt;<br>            &lt;!-- 环绕通知 --&gt;<br>            &lt;aop:around method=<span class="hljs-string">&quot;around&quot;</span> pointcut-ref=<span class="hljs-string">&quot;pt&quot;</span> /&gt;<br>            &lt;!-- 前置通知： 在目标方法调用前执行 --&gt;<br>            &lt;aop:before method=<span class="hljs-string">&quot;begin&quot;</span> pointcut-ref=<span class="hljs-string">&quot;pt&quot;</span> /&gt;<br>            &lt;!-- 后置通知： --&gt;<br>            &lt;aop:after method=<span class="hljs-string">&quot;after&quot;</span> pointcut-ref=<span class="hljs-string">&quot;pt&quot;</span> /&gt;<br>            &lt;!-- 返回后通知 --&gt;<br>            &lt;aop:after-returning method=<span class="hljs-string">&quot;afterReturning&quot;</span><br>                pointcut-ref=<span class="hljs-string">&quot;pt&quot;</span> /&gt;<br>            &lt;!-- 异常通知 --&gt;<br>            &lt;aop:after-throwing method=<span class="hljs-string">&quot;afterThrowing&quot;</span><br>                pointcut-ref=<span class="hljs-string">&quot;pt&quot;</span> /&gt;<br>        &lt;/aop:aspect&gt;<br>    &lt;/aop:config&gt;<br><br>&lt;/beans&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopLog2</span> </span>&#123;<br><br>    <span class="hljs-comment">// 前置通知</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 后置通知</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 运行通知</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returning</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;运行通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 异常通知</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;异常通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;环绕通知开始&quot;</span>);<br>        proceedingJoinPoint.proceed();<br>        System.out.println(<span class="hljs-string">&quot;环绕通知结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://bk.cuixiaoyan.xyz/archives/aop#spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86">Spring核心知识</a><a href="https://bk.cuixiaoyan.xyz/archives/aop#springaop%E5%8E%9F%E7%90%86">SpringAOP原理</a><a href="https://bk.cuixiaoyan.xyz/archives/aop#aop%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">AOP底层实现原理</a><a href="https://bk.cuixiaoyan.xyz/archives/aop#aop%E7%BC%96%E7%A8%8B%E4%BD%BF%E7%94%A8">AOP编程使用</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现多线程的三种方法</title>
    <link href="/blog/2021/01/19/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/01/19/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Java虚拟机（JVM，是运行所有Java程序的抽象计算机，是Java语言的运行环境）允许应用程序并发地运行多个线程。在Java语言中，多线程的实现一般有以下三种方法：</p><p>1、实现Runnable接口，并实现该接口的run()方法。</p><p>　　①自定义类并实现Runnable接口，实现run()方法。</p><p>　　②创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。</p><p>　　③调用Thread的start()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;　　<span class="hljs-comment">//创建线程类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread body&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread thread = <span class="hljs-keyword">new</span> MyThread();<br>        Thread t = <span class="hljs-keyword">new</span> Thread(thread);<br>        t.run();　　<span class="hljs-comment">//开启线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、继承Thread类，重写run()方法。</p><p>　　Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()方法。start()方法是一个native（本地）方法，它将启动一个新线程，并执行run()方法（Thread中提供的run()方法是一个空方法）。这种方式通过自定义类直接extends Thread，并重写run()方法，就可以启动新线程并执行自己定义的run()方法。需要注意的是，当start()方法调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行多线程代码是由操作系统决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-comment">//创建线程类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread body&quot;</span>);    <span class="hljs-comment">//线程的方法体</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThread thread = <span class="hljs-keyword">new</span> MyThread();<br>        thread.run();    <span class="hljs-comment">//开启线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、实现Callable接口，重写call()方法。</p><p>　　Callable对象实际是属于Executor框架中的功能类，Callable接口与Runnable接口类似，但是提供了比Runnable更强大 的功能，主要表现为以下三点：</p><p>　　①Callable可以在任务结束后提供一个返回值，Runnable无法提供这个功能。</p><p>　　②Callable中的call方法可以抛出异常，而Runnable的run()方法不能抛出异常。</p><p>　　③运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果。它提供了检查计算是否完成的方法。由于线程属于异步计算模型，所以无法从其他线程中得到方法的返回值，在这种情况下，就可以使用Future来监视目标线程调用call()方法的情况，当调用Future的get()方法以获取结果时，当前线程就会阻塞，直到call()方法结束返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableAndFuture</span></span>&#123;　　<span class="hljs-comment">//创建线程类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService threadPool = Executors.newSingleThreadExecutor();<br>        <span class="hljs-comment">//启动线程</span><br>        Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> CallableTest());<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;waiting thread to finish&quot;</span>);<br>            System.out.println(future.get());　　<span class="hljs-comment">//等待线程结束，并获取返回结果</span><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　在以上三种方式中，前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。当需要实现多线程时，一般推荐实现Runnable接口的方式，原因如下：首先，Thread类定义了多种方法可以被派生类使用或重写，但是只有run方法是必须被重写的，在run方法中实现这个线程的主要功能。这当然是实现Runnable接口所需的同样的方法。而且，很多Java开发人员认为，一个人仅在它们需要被加强或修改时才会被继承。因此，如果没有必要重写Thread类中的其他方法，那么通过继承Thread的实现方式和实现Runnable接口的效果相同，在这种情况下最好通过Runnable接口的方式来创建线程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java集合面试20问</title>
    <link href="/blog/2021/01/18/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%9520%E9%97%AE/"/>
    <url>/blog/2021/01/18/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%9520%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<ol><li>HashMap的内部实现原理是什么？</li></ol><p>HashMap内部实现原理是数组+链表，通过散列算法将key值散列到数组中，如果到相同的位置，则通过拉链法解决散列冲突。在JDK8中新增了红黑树结构，当HashMap中的散列冲突链表结构超过8个数据时，会从链表结构转换为红黑树结构。</p><ol><li>HashMap的key值能否是null，如果能，key=null如何存储以及如何读取的？如果不能，为什么？</li></ol><p>HashMap的key值可以是null。如果key=null，则会将它放置在数组下标为0的位置。</p><ol><li>HashMap如何实现扩容？</li></ol><p>HashMap扩容和初始容器大小与负载因子有关。HashMap的初始容器大小为16，默认的负载因子为0.75，当实际容量超过16*0.75=12个元素时会进行扩容。扩容后的容器大小是扩容前的2倍，第一次扩容后的容器大小为32。</p><ol><li>设置HashMap的容量有没有注意的地方，为什么？</li></ol><p>指定HashMap的容量时，建议是2的幂次方。</p><p>HashMap在寻址是会key的hash值与容器长度做与运算，(n - 1) &amp; hash。当n的长度为2的幂次方时，n-1的二进制形式就会是111111，这样与操作效率会非常的快。</p><ol><li>HashMap是否是线程安全的？如果不是，多线程下并发操作它可能会带来什么问题？如果是，它是怎么实现的？</li></ol><p>HashMap不是线程安全的。如果在多线程下并发操作不仅会导致脏数据，甚至可能会造成死循环。（关于死循环产生的原因参考<a href="https://www.cnblogs.com/yulinfeng/p/8558983.html%EF%BC%89">https://www.cnblogs.com/yulinfeng/p/8558983.html）</a></p><ol><li>LinkedHashMap的内部实现原理是什么？它是否支持key=null？</li></ol><p>LinkedHashMap是插入有序的Map集合。它直接继承了HashMap，所以很多都直接复用了HashMap方法，所以也支持key=null。它在内部除了沿用HashMap的底层结构，还单独维护了一个双向链表，在对Map进行put操作时，同时还会将数据写到了链表的尾部，保证了插入有序。</p><ol><li>TreeMap的内部实现原理是什么？它是否支持key=null？</li></ol><p>TreeMap结构也是有序的，不同的是它是字典有序，由于它底层是红黑树结构，插入时会进行比较key值的顺序，所以不允许key=null的情况。</p><ol><li>介绍下Hashtable</li></ol><p>Hashtable是线程安全的Map类型，但它的线程安全代价是为整个散列表加锁，效率很低，几乎已经废弃。如果要使用线程安全的Map，应该使用ConcurrentHashMap，它的实现是分段锁，能最大的提高效率。</p><ol><li>以上三种Map类型分别可以应用到哪些场景？你在哪些场景下使用过？</li></ol><p>HashMap的使用场景很多，这个使用场景就太多了，比如用作本地缓存。</p><p>LinkedHashMap因为它的链表结构可以实现LRU（最近最少使用），即缓存空间有限，当元素多余缓存空间，可淘汰掉最近最少使用的元素。在LinkedHashMap维护了一个accessOrder字段，默认为false，当设置为true时，如果访问一个key值，就会将这个元素放置链表头部，这样在链表尾部的元素就是不常用的元素，空间不足直接remove末尾的元素即可。所以当要实现LRU缓存时，就可以将accessOrder设置为true实现。</p><p>TreeMap没有实际应用过，如果有需要排序的场景则使用TreeMap</p><p>Set 10. HashSet的内部实现原理是什么，它有什么特点？</p><p>HashSet集合的特点是不允许有重复的元素，且无序的，允许null值。它在内部维护一个HashMap，存储在HashSet中的元素实际上存储在HashMap的key中。</p><ol><li>LinkedHashSet的内部实现原理是什么，它有什么特点？</li></ol><p>LinkedHashSet继承自HashMap，在内部维护一个双向链表保证插入有序，允许null值。</p><ol><li>TreeSet的内部实现原理是什么，它有什么特点？</li></ol><p>TreeSet是一个有序的集合，它的作用是提供有序的Set集合，TreeSet是基于TreeMap实现的。不允许有null值。</p><ol><li>以上三种Set类型分别可以应用到哪些场景？你在哪些场景下使用过？</li></ol><p>HashSet可应用于批量查询时去重。</p><p>如果需要返回的数据和入参的数据顺序一致则可以使用LinkedHashSet。</p><p>List 14. ArrayList的内部实现原理什么？</p><p>底层通过数组实现，创建一个ArrayList对象实例时不会初始化数组，当插入第一条数据时会创建一个大小为10的数组。</p><ol><li>既然ArrayList的底层实现是数组，那定义ArrayList时，需要定义它的大小吗？</li></ol><p>可以不用定义容器的大小，默认大小为10，当容量大小不足时此时将会进行扩容。</p><ol><li>ArrayList的扩容机制是什么？</li></ol><p>每次新增的容量是旧容量的一半，扩容后调用System.arraycopy方法拷贝到新的数组。</p><ol><li>如果初始化ArrayList时，定义一个容量大小为11，此时扩容了几次，容量大小为16呢？</li></ol><p>不进行扩容。</p><ol><li>LinkedList的内部实现原理是什么？</li></ol><p>底层通过链表实现，所以不存在扩容。</p><ol><li>Vector和ArrayList、LinkedList的区别？</li></ol><p>Vector是线程安全的额，ArrayList、LinkedList不是线程安全的。Vector的线程安全是为每个方法加上synchronized关键字，效率不高，不常用。</p><ol><li>ArrayList与LinkedList分别可以应用到哪些场景？</li></ol><p>大多数情况下使用ArrayList，因为ArrayList是数组实现，它随机读取的速度更快，但插入指定位置慢；LinkedList由于是链表实现，所以随机读取的速度慢，但插入指定位置快。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7安装ElasticSearch6</title>
    <link href="/blog/2021/01/18/centos7%E5%AE%89%E8%A3%85ElasticSearch6/"/>
    <url>/blog/2021/01/18/centos7%E5%AE%89%E8%A3%85ElasticSearch6/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-ElasticSearch"><a href="#什么是-ElasticSearch" class="headerlink" title="什么是 ElasticSearch"></a>什么是 ElasticSearch</h1><p>ElasticSearch是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>索引：含有相同属性的文档集合</p><p>类型：索引可以定义一个或多个类型，文档必须属于一个类型</p><p>文档：可以被索引的基础数据单位</p><p>分片：每个索引都有多个分片，每个分片都是 Lucene 索引</p><p>备份：拷贝一份分片就完成分片的备份</p><h2 id="形象比喻："><a href="#形象比喻：" class="headerlink" title="形象比喻："></a>形象比喻：</h2><p>百货大楼里有各式各样的商品，例如书籍、笔、水果等。书籍可以根据内容划分成不同种类，如科技类、教育类、悬疑推理等。悬疑推理类的小说中比较有名气的有《福尔摩斯探案集》、《白夜行》等。</p><p>百货大楼 –&gt; ElasticSearch 数据库</p><p>书籍 –&gt; 索引</p><p>悬疑推理 –&gt; 类型</p><p>白夜行 –&gt; 文档</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>需要JDK1.8 和 NodeJS 最新版的7 慎重考虑需要需要JDK 11 登陆<a href="https://www.elastic.co/cn/downloads/past-releases">老版本下载</a> 官网下载文件。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190816-094122@2x_1565919762389.png" alt="WX20190816-094122@2x">解压到 /use 目录下<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190816-094419@2x_1565919900521.png" alt="WX20190816-094419@2x"></p><p>因为 Elasticsearch 可以执行脚本文件，为了安全性，默认不允许通过 root 用户启动服务。我们需要新创建用户名和用户组启动服务</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">#增加 es 组<br>groupadd es<br><br>#增加 es 用户并附加到 es 组<br>useradd es -g es -<span class="hljs-keyword">p</span> es<br><br>#给目录权限 进入到你解压的位置 输入<span class="hljs-keyword">pwd</span> 将路径拷贝到 es 后面<br>chown -R <span class="hljs-keyword">e</span><span class="hljs-variable">s:es</span> /usr/elasticsearch-<span class="hljs-number">5.6</span>.<span class="hljs-number">1</span><br><br>#使用es用户<br>su es<br></code></pre></td></tr></table></figure><p>默认情况下，Elasticsearch 只允许本机访问，如果需要远程访问，需要修改其配置文件 特别注意 要和上下文对齐 不要多空格 和少空格</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> config/elasticsearch.yml<br><br># 去掉 network.host 前边的注释，将它的值改成<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br>network.hos<span class="hljs-variable">t:</span> <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><br><br><br># 在文件末尾添加 <span class="hljs-number">2</span> 段配置 这里是为了解决跨域问题 web管理界面<br><br>http.cors.enabled: true<br>http.cors.allow-origin: <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">bin/elasticsearch 或 bin/elasticsearch -d # -d 表示后台启动<br></code></pre></td></tr></table></figure><h1 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h1><p>先不后台启动 错误会直接打印 调试没有问题之后 后台启动 可能会出现的问题 6也会遇到</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs vim">elasticsearch5.<span class="hljs-number">0</span>启动失败，出现如下提示：<br><br>1、Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=&#x27;Cannot allocate memory&#x27; (errno=12)<br><br>由于elasticsearch5.<span class="hljs-number">0</span>默认分配jvm空间大小为<span class="hljs-number">2</span>g，修改jvm空间分配<br><br># <span class="hljs-keyword">vim</span> config/jvm.<span class="hljs-keyword">options</span><br>-Xms2g<br>-Xmx2g<br>修改为  还是同样的错误的话 继续往下调 <br>-Xms512m<br>-Xmx512m<br><br><br><span class="hljs-number">2</span>、<span class="hljs-built_in">max</span> <span class="hljs-keyword">number</span> of threads [<span class="hljs-number">1024</span>] <span class="hljs-keyword">for</span> user [elasticsearch] <span class="hljs-keyword">is</span> too low, increase <span class="hljs-keyword">to</span> at least [<span class="hljs-number">2048</span>]<br>修改 /etc/security/limits.d/<span class="hljs-number">90</span>-nproc.<span class="hljs-keyword">conf</span> <br><br>*          soft    nproc     <span class="hljs-number">1024</span><br><br>*          soft    nproc     <span class="hljs-number">2048</span><br><br><br><br><span class="hljs-number">3</span>、<span class="hljs-built_in">max</span> virtual memory areas <span class="hljs-keyword">vm</span>.max_map_count [<span class="hljs-number">65530</span>] <span class="hljs-keyword">is</span> too low, increase <span class="hljs-keyword">to</span> at least [<span class="hljs-number">262144</span>]<br><br>修改/etc/sysctl.<span class="hljs-keyword">conf</span>配置文件，<br><br><span class="hljs-keyword">cat</span> /etc/sysctl.<span class="hljs-keyword">conf</span> | <span class="hljs-keyword">grep</span> <span class="hljs-keyword">vm</span>.max_map_count<br><span class="hljs-keyword">vm</span>.max_map_count=<span class="hljs-number">262144</span><br><br>如果不存在则添加<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;vm.max_map_count=262144&quot;</span> &gt;&gt;/etc/sysctl.<span class="hljs-keyword">conf</span><br><br><br><br><span class="hljs-number">4</span>、<span class="hljs-built_in">max</span> <span class="hljs-keyword">file</span> descriptors [<span class="hljs-number">65535</span>] <span class="hljs-keyword">for</span> elasticsearch process likely too low, increase <span class="hljs-keyword">to</span> at least [<span class="hljs-number">65536</span>]<br><br><br><br>ulimit -n <span class="hljs-number">65536</span><br><br><br><br><br><br>以下是在<span class="hljs-number">5.5</span>.<span class="hljs-number">1</span>是踩过的坑<br><br><br><br><span class="hljs-number">5</span>、启动异常：ERROR: bootstrap checks failed<br><br>system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk<br><br><br><br>问题原因：因为Centos6不支持SecComp，而ES默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。详见 ：http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/elastic/elasticsearch/issues/<span class="hljs-number">22899</span><br><br><br><br>解决方法：在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:<br>bootstrap.memory_lock: false<br>bootstrap.system_call_filter: false<br><br><br><br><span class="hljs-number">6</span>、logstash使用rpm包安装的时候没有配置init的启动脚本<br><br>默认情况使用rpm包安装完logstash之后没有启动脚本。官网给了一个脚本，需要根据不同的系统版本生成对应的启动脚本，而且官网没有给明使用方法，对于新用户来说算是个坑，不过在终端可以查看到脚本的使用帮助# /usr/share/logstash/bin/<span class="hljs-built_in">system</span>-install --<span class="hljs-keyword">help</span><br><br>生成启动脚本，centos6使用sysv参数，centos7使用systemd<br><br># /usr/share/logstash/bin/<span class="hljs-built_in">system</span>-install /etc/logstash/startup.<span class="hljs-keyword">options</span> sysv<br><br>Successfully created <span class="hljs-built_in">system</span> startup script <span class="hljs-keyword">for</span> Logstash<br></code></pre></td></tr></table></figure><p>启动成功 你的ip 9200 默认端口<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190816-100353@2x_1565921056554.png" alt="WX20190816-100353@2x"></p><h1 id="head插件"><a href="#head插件" class="headerlink" title="head插件"></a>head插件</h1><p>查看内容显示效果不友好，因此，我们需要安装一个名为 elasticsearch-head 的插件，让内容显示效果比较舒适。需要安装nodejs githup下载 端口9100</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> elasticsearch-head-master<br><br>npm install<br><br>npm run start<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190816-100733@2x_1565921326422.png" alt="WX20190816-100733@2x"></p><p>后面是我整合啦spring boot</p>]]></content>
    
    
    
    <tags>
      
      <tag>centos7</tag>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB 与 MySQL 的区别</title>
    <link href="/blog/2021/01/18/MongoDB%E4%B8%8E%20MySQL%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/01/18/MongoDB%E4%B8%8E%20MySQL%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>概念区别<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190815-134731@2x_1565848087636.png" alt="WX20190815-134731@2x">关键字和函数区别<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190815-134744@2x_1565848087719.png" alt="WX20190815-134744@2x">语句区别 创建表/集合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.insertOne( &#123;<br>    user_id: &quot;abc123&quot;,<br>    age: <span class="hljs-number">55</span>,<br>    status: &quot;A&quot;<br> &#125; )<br> <br>相当于 <br> <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> people (<br>    id MEDIUMINT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    user_id <span class="hljs-type">Varchar</span>(<span class="hljs-number">30</span>),<br>    age Number,<br>    status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (id)<br>)<br></code></pre></td></tr></table></figure><p>新增字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.updateMany(<br>    &#123; &#125;,<br>    &#123; $set: &#123; join_date: new Date() &#125; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> people <span class="hljs-keyword">ADD</span> join_date DATETIME<br></code></pre></td></tr></table></figure><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.updateMany(<br>    &#123; &#125;,<br>    &#123; $unset: &#123; &quot;join_date&quot;: &quot;&quot; &#125; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> people <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> join_date<br></code></pre></td></tr></table></figure><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.createIndex( &#123; user_id: 1 &#125; )<br> <br>相当于 <span class="hljs-keyword">CREATE</span> INDEX idx_user_id_asc <span class="hljs-keyword">ON</span> people(user_id)<br></code></pre></td></tr></table></figure><p>删除表/集合</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.drop()<br> <br>相当于 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> people<br></code></pre></td></tr></table></figure><p>新增记录/文档</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.insertOne(<br>   &#123; user_id: &quot;bcd001&quot;, age: 45, status: &quot;A&quot; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> people(user_id,age,status) <span class="hljs-keyword">VALUES</span> (&quot;bcd001&quot;,<span class="hljs-number">45</span>,&quot;A&quot;)<br></code></pre></td></tr></table></figure><p>简单查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find()<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people<br> <br>db.people.find(<br>    &#123; &#125;,<br>    &#123; user_id: 1, status: 1 &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> id,user_id,status <span class="hljs-keyword">FROM</span> people<br> <br>db.people.find(<br>    &#123; &#125;,<br>    &#123; user_id: 1, status: 1, _id: 0 &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> user_id, status <span class="hljs-keyword">FROM</span> people<br></code></pre></td></tr></table></figure><p>条件查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>    &#123; status: &quot;A&quot; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot;<br> <br>db.people.find(<br>    &#123; status: &quot;A&quot; &#125;,<br>    &#123; user_id: 1, status: 1, _id: 0 &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> user_id, status <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot;<br></code></pre></td></tr></table></figure><p>非查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>    &#123; status: &#123; $ne: &quot;A&quot; &#125; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">!=</span> &quot;A&quot;<br></code></pre></td></tr></table></figure><p>且查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>    &#123; status: &quot;A&quot;,<br>      age: 50 &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot; <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>或查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>    &#123; $or: [ &#123; status: &quot;A&quot; &#125; ,<br>             &#123; age: 50 &#125; ] &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot; <span class="hljs-keyword">OR</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>大于查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>    &#123; age: &#123; $gt: 25 &#125; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>小于查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>   &#123; age: &#123; $lt: 25 &#125; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>范围查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find(<br>   &#123; age: &#123; $gt: 25, $lte: 50 &#125; &#125;<br>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">25</span> <span class="hljs-keyword">AND</span>   age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>模糊查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find( &#123; user_id: /bc/ &#125; ) 或 db.people.find( &#123; user_id: &#123; $regex: /bc/ &#125; &#125; )<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">like</span> &quot;%bc%&quot;<br> <br>db.people.find( &#123; user_id: /^bc/ &#125; ) 或 db.people.find( &#123; user_id: &#123; $regex: /^bc/ &#125; &#125; )<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">like</span> &quot;bc%&quot;<br></code></pre></td></tr></table></figure><p>排序查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find( &#123; status: &quot;A&quot; &#125; ).sort( &#123; user_id: 1 &#125; )<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot; <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ASC</span><br> <br>db.people.find( &#123; status: &quot;A&quot; &#125; ).sort( &#123; user_id: -1 &#125; )<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot; <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p>统计查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.<span class="hljs-built_in">count</span>() 或 db.people.find().<span class="hljs-built_in">count</span>()<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> people<br> <br>db.people.count( &#123; user_id: &#123; $exists: true &#125; &#125; ) 或 db.people.find( &#123; user_id: &#123; $exists: true &#125; &#125; ).count()<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(user_id) <span class="hljs-keyword">FROM</span> people<br> <br>db.people.count( &#123; age: &#123; $gt: 30 &#125; &#125; ) 或 db.people.find( &#123; age: &#123; $gt: 30 &#125; &#125; ).count()<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>去重查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.distinct( &quot;status&quot; )<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span>(status) <span class="hljs-keyword">FROM</span> people<br></code></pre></td></tr></table></figure><p>分页查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.findOne() 或 db.people.find().limit(<span class="hljs-number">1</span>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people LIMIT <span class="hljs-number">1</span><br> <br>db.people.find().limit(<span class="hljs-number">5</span>).<span class="hljs-keyword">skip</span>(<span class="hljs-number">10</span>)<br> <br>相当于 <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people LIMIT <span class="hljs-number">5</span> <span class="hljs-keyword">SKIP</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>查询计划</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.find( &#123; status: &quot;A&quot; &#125; ).explain()<br> <br>相当于 EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot;<br></code></pre></td></tr></table></figure><p>修改记录/文档</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.updateMany(<br>   &#123; age: &#123; $gt: 25 &#125; &#125;,<br>   &#123; $set: &#123; status: &quot;C&quot; &#125; &#125;<br>);<br> <br>相当于 <span class="hljs-keyword">UPDATE</span> people <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> &quot;C&quot; <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">25</span>;<br> <br>db.people.updateMany(<br>   &#123; status: &quot;A&quot; &#125; ,<br>   &#123; $inc: &#123; age: 3 &#125; &#125;<br>);<br> <br>相当于 <span class="hljs-keyword">UPDATE</span> people <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> age <span class="hljs-operator">+</span> <span class="hljs-number">3</span> <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;A&quot;;<br></code></pre></td></tr></table></figure><p>删除记录/文档</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.people.deleteMany( &#123; status: &quot;D&quot; &#125; );<br> <br>相当于 <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> people <span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> &quot;D&quot;;<br> <br>db.people.deleteMany(&#123;&#125;);<br> <br>相当于 <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> people;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gradle使用本地jar包</title>
    <link href="/blog/2021/01/16/gradle%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0jar%E5%8C%85/"/>
    <url>/blog/2021/01/16/gradle%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0jar%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>有很多时候 我们需要用到自己的jar包 特殊原因 你明白的</p><p>1.在项目根目录(与src同级目录)创建lib文件夹，并将jar包拷贝进去。</p><p>2.在build.gradle文件中的dependencies中添加如下脚本： compile fileTree(dir: ‘lib’, include: [ ‘*.jar’])</p><p>3.运行gradle build即可将jar文件打到工程Jar包中。<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190815-103617@2x_1565836606994.png" alt="WX20190815-103617@2x"></p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pdf 转 图片</title>
    <link href="/blog/2021/01/16/pdf%E8%BD%AC%E5%9B%BE%E7%89%87/"/>
    <url>/blog/2021/01/16/pdf%E8%BD%AC%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>这里使用到的jar包 是 // <a href="https://mvnrepository.com/artifact/org.apache.pdfbox/fontbox">https://mvnrepository.com/artifact/org.apache.pdfbox/fontbox</a> compile group: ‘org.apache.pdfbox’, name: ‘fontbox’, version: ‘1.8.16’ // <a href="https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox">https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox</a> compile group: ‘org.apache.pdfbox’, name: ‘pdfbox’, version: ‘1.8.16’</p><p>pdf转单页图片 合并一张的工具库 前往<a href="https://bk.cuixiaoyan.xyz/archives/zhuantupian">aspose-words word转图片</a> 下载使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将pdf转成一张图片</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pdffile</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getPDFBinary</span><span class="hljs-params">(String pdffile)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//文件流</span><br>InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(pdffile);<br><span class="hljs-comment">//文件 获取文件名字</span><br>File file = <span class="hljs-keyword">new</span> File(pdffile);<br>String name = file.getName();<br><span class="hljs-comment">//截取不带后缀名的字段</span><br>String fileName = name.substring(<span class="hljs-number">0</span>, name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br> <br><span class="hljs-comment">//文件上传路径</span><br>String parent = file.getParent();<br> <br>PDDocument doc = PDDocument.load(inputStream);<br><span class="hljs-comment">//获取pdf文件 页数</span><br>List&lt;PDPage&gt; pages = doc.getDocumentCatalog().getAllPages();<br> <br>List&lt;BufferedImage&gt; imageList = <span class="hljs-keyword">new</span> ArrayList&lt;BufferedImage&gt;();<br>BufferedImage image = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pages.size(); i++) &#123;<br>PDPage page = (PDPage)pages.get(i); <span class="hljs-comment">// 获取第i页</span><br>image = page.convertToImage();<br>imageList.add(image);<br><span class="hljs-comment">//合并一张</span><br>image = MergeImage.mergeImage(<span class="hljs-keyword">false</span>, imageList);<br>&#125;<br> <br><span class="hljs-keyword">boolean</span> png = ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-keyword">new</span> File(parent +<span class="hljs-string">&quot;/&quot;</span>+ fileName + <span class="hljs-string">&quot;.png&quot;</span>));<br><span class="hljs-keyword">if</span>(png == <span class="hljs-keyword">false</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转换失败&quot;</span>;<br>&#125;<br> <br><span class="hljs-comment">//关闭流</span><br>inputStream.close();<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转换成功&quot;</span>;<br> <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>pdf 每页转图片 放到文件夹内 转换成压缩包 也可以不放压缩包 随意 压缩包工具类 <a href="https://bk.cuixiaoyan.xyz/archives/yasuo">java实现文件压缩，文件夹压缩，以及文件和文件夹的混合压缩</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将pdf 转化为 图片分页 压缩包</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getPDFBinarys</span><span class="hljs-params">(String pdffile)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//文件流</span><br>InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(pdffile);<br>PDDocument doc = PDDocument.load(inputStream);<br> <br><span class="hljs-comment">//文件 获取文件名字</span><br>File file = <span class="hljs-keyword">new</span> File(pdffile);<br>String name = file.getName();<br><span class="hljs-comment">//截取不带后缀名的字段</span><br>String fileName = name.substring(<span class="hljs-number">0</span>, name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><span class="hljs-comment">//文件上传路径</span><br>String parent = file.getParent();<br> <br><span class="hljs-comment">//获取pdf文件 页数</span><br>List&lt;PDPage&gt; pages = doc.getDocumentCatalog().getAllPages();<br> <br>BufferedImage image = <span class="hljs-keyword">null</span>;<br> <br><span class="hljs-comment">//创建同名文件夹</span><br><span class="hljs-keyword">new</span> File(parent+<span class="hljs-string">&quot;/&quot;</span>+ fileName).mkdir();<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pages.size(); i++) &#123;<br>PDPage page = (PDPage) pages.get(i); <span class="hljs-comment">// 获取第i页</span><br>image = page.convertToImage();<br>ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-keyword">new</span> File(parent +<span class="hljs-string">&quot;/&quot;</span>+ fileName +<span class="hljs-string">&quot;/&quot;</span>+ <span class="hljs-string">&quot;第&quot;</span>+ i +<span class="hljs-string">&quot;页&quot;</span> + fileName + <span class="hljs-string">&quot;.png&quot;</span>));<br> <br>&#125;<br> <br><span class="hljs-comment">//压缩同名文件夹</span><br>    File f = <span class="hljs-keyword">new</span> File(parent  +<span class="hljs-string">&quot;/&quot;</span> + fileName );<br>            <span class="hljs-keyword">new</span> CompactAlgorithm(<span class="hljs-keyword">new</span> File( parent+ <span class="hljs-string">&quot;/&quot;</span>,f.getName()+<span class="hljs-string">&quot;.zip&quot;</span>)).zipFiles(f);<br> <br><span class="hljs-comment">//关闭流</span><br>inputStream.close();<br> <br> <br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转换成功&quot;</span>+pages.size()+<span class="hljs-string">&quot;页&quot;</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>pdf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aspose-words java word 转换 服务器乱码解决</title>
    <link href="/blog/2021/01/16/aspose-words-java-word%E8%BD%AC%E6%8D%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/"/>
    <url>/blog/2021/01/16/aspose-words-java-word%E8%BD%AC%E6%8D%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>在本机测试是好的 但是到服务器就乱码 想到pdf是一种为打印设计的文档格式，可能跟字体相关。而且转出来的pdf中文都是空心方框，不是单纯的乱码，很有可能是缺少字体渲染不出来造成的。 服务器上用fc-list命令查看字体，果然没有中文字体 接下来将本机Windows的字体上传到CentOS服务器上。 具体操作： 也可以直接使用我的字体 经测试没问题 有的系统版本的原因 也会导致乱码 链接: <a href="https://pan.baidu.com/s/1Fj6pqfNDi__sdBJthdFCFg">https://pan.baidu.com/s/1Fj6pqfNDi__sdBJthdFCFg</a> 提取码: k35v 将Windows上字体文件 C:\Windows\Fonts目录，复制到CentOS的/usr/share/fonts目录 重启服务器</p><p>如果你转换的文档中有 公式系列的话 那么还需要再导入一种公式字体 这里已经准备好啦 链接: <a href="https://pan.baidu.com/s/1c8WYZMcqVeRHc23vVe3xrQ">https://pan.baidu.com/s/1c8WYZMcqVeRHc23vVe3xrQ</a> 提取码: c329<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190809-100929@2x_1565316592563.png" alt="WX20190809-100929@2x">同样需要重启服务器</p><p><strong>已知问题 着重号无法转换 官网也为给出解决方案</strong><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6_1565316729182.jpg" alt="未命名文件"></p><h1 id="aspose-words-word转图片"><a href="#aspose-words-word转图片" class="headerlink" title="aspose-words word转图片"></a>aspose-words word转图片</h1><p>这里所用到的jar包 和这里所用的的一样 <a href="https://bk.cuixiaoyan.xyz/archives/wordpdf">jar包下载 和谐文件</a> 将word转换为单张图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-comment">// 将word 转化为图片一张</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseFileToBase64_PNG</span><span class="hljs-params">(String wordfile)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br> <br><span class="hljs-comment">//文件流</span><br>InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(wordfile);<br><span class="hljs-comment">//文件 获取文件名字</span><br>File file = <span class="hljs-keyword">new</span> File(wordfile);<br>String name = file.getName();<br><span class="hljs-comment">//截取不带后缀名的字段</span><br>String fileName = name.substring(<span class="hljs-number">0</span>, name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br> <br><span class="hljs-comment">//文件上传路径</span><br>String parent = file.getParent();<br> <br>List&lt;BufferedImage&gt; bufferedImages = <span class="hljs-keyword">new</span> ArrayList&lt;BufferedImage&gt;();<br>BufferedImage image = <span class="hljs-keyword">null</span>;<br>bufferedImages = wordToImg(inputStream);<br>image = MergeImage.mergeImage(<span class="hljs-keyword">false</span>, bufferedImages);<br> <br><span class="hljs-keyword">boolean</span> png = ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-keyword">new</span> File(parent + <span class="hljs-string">&quot;/&quot;</span> + fileName + <span class="hljs-string">&quot;.png&quot;</span>));<span class="hljs-comment">// 写入流中</span><br> <br> <br><span class="hljs-keyword">if</span>(png == <span class="hljs-keyword">false</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转换失败&quot;</span>;<br>&#125;<br> <br><span class="hljs-comment">//关闭流</span><br>inputStream.close();<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转换成功&quot;</span>;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: word和txt文件转换图片</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;BufferedImage&gt; <span class="hljs-title">wordToImg</span><span class="hljs-params">(InputStream inputStream)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">if</span> (!isWordLicense()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br> <br><span class="hljs-keyword">try</span> &#123;<br> <br>Document doc = <span class="hljs-keyword">new</span> Document(inputStream);<br>ImageSaveOptions options = <span class="hljs-keyword">new</span> ImageSaveOptions(SaveFormat.PNG);<br>options.setPrettyFormat(<span class="hljs-keyword">true</span>);<br>options.setUseAntiAliasing(<span class="hljs-keyword">true</span>);<br>options.setUseHighQualityRendering(<span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">int</span> pageCount = doc.getPageCount();<br> <br>List&lt;BufferedImage&gt; imageList = <span class="hljs-keyword">new</span> ArrayList&lt;BufferedImage&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++) &#123;<br>OutputStream output = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>options.setPageIndex(i);<br> <br>doc.save(output, options);<br>ImageInputStream imageInputStream = ImageIO.createImageInputStream(parse(output));<br>imageList.add(ImageIO.read(imageInputStream));<br>&#125;<br><span class="hljs-keyword">return</span> imageList;<br> <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">throw</span> e;<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 验证aspose.word组件是否授权：无授权的文件有水印和试用标记</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWordLicense</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// InputStream inputStream = new</span><br><span class="hljs-comment">// FileInputStream(&quot;D:\\Workspaces\\TestFilters\\lib\\license.xml&quot;);</span><br><span class="hljs-comment">// 避免文件遗漏</span><br>String licensexml = <span class="hljs-string">&quot;&lt;License&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;Data&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;Products&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;Product&gt;Aspose.Total for Java&lt;/Product&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;Product&gt;Aspose.Words for Java&lt;/Product&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;/Products&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;EditionType&gt;Enterprise&lt;/EditionType&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;SubscriptionExpiry&gt;20991231&lt;/SubscriptionExpiry&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;LicenseExpiry&gt;20991231&lt;/LicenseExpiry&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;SerialNumber&gt;23dcc79f-44ec-4a23-be3a-03c1632404e9&lt;/SerialNumber&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;/Data&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;Signature&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU=\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;/Signature&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;/License&gt;&quot;</span>;<br>InputStream inputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(licensexml.getBytes());<br>com.aspose.words.License license = <span class="hljs-keyword">new</span> com.aspose.words.License();<br>license.setLicense(inputStream);<br>result = <span class="hljs-keyword">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br> <br><span class="hljs-comment">// outputStream转inputStream</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteArrayInputStream <span class="hljs-title">parse</span><span class="hljs-params">(OutputStream out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>baos = (ByteArrayOutputStream) out;<br>ByteArrayInputStream swapStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(baos.toByteArray());<br><span class="hljs-keyword">return</span> swapStream;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>新建一个工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> util;<br> <br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: transformation</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 多张图片合成</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: cuixy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2019-07-26 17:10</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeImage</span> </span>&#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 合并任数量的图片成一张图片</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isHorizontal</span><br><span class="hljs-comment">     *            true代表水平合并，fasle代表垂直合并</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> imgs</span><br><span class="hljs-comment">     *            待合并的图片数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BufferedImage <span class="hljs-title">mergeImage</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isHorizontal, List&lt;BufferedImage&gt; imgs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 生成新图片</span><br>        BufferedImage destImage = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 计算新图片的长和高</span><br>        <span class="hljs-keyword">int</span> allw = <span class="hljs-number">0</span>, allh = <span class="hljs-number">0</span>, allwMax = <span class="hljs-number">0</span>, allhMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 获取总长、总宽、最长、最宽</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; imgs.size(); i++) &#123;<br>            BufferedImage img = imgs.get(i);<br>            allw += img.getWidth();<br> <br>            <span class="hljs-keyword">if</span> (imgs.size() != i + <span class="hljs-number">1</span>) &#123;<br>                allh += img.getHeight() + <span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allh += img.getHeight();<br>            &#125;<br> <br>            <span class="hljs-keyword">if</span> (img.getWidth() &gt; allwMax) &#123;<br>                allwMax = img.getWidth();<br>            &#125;<br> <br>            <span class="hljs-keyword">if</span> (img.getHeight() &gt; allhMax) &#123;<br>                allhMax = img.getHeight();<br>            &#125;<br>        &#125;<br> <br>        <span class="hljs-comment">// 创建新图片</span><br>        <span class="hljs-keyword">if</span> (isHorizontal) &#123;<br>            destImage = <span class="hljs-keyword">new</span> BufferedImage(allw, allhMax, BufferedImage.TYPE_INT_RGB);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            destImage = <span class="hljs-keyword">new</span> BufferedImage(allwMax, allh, BufferedImage.TYPE_INT_RGB);<br>        &#125;<br> <br>        <span class="hljs-comment">// 注释，分隔线从灰色变成纯黑</span><br>        <span class="hljs-comment">// Graphics2D g2 = (Graphics2D) destImage.getGraphics();</span><br>        <span class="hljs-comment">// g2.setBackground(Color.LIGHT_GRAY);</span><br>        <span class="hljs-comment">// g2.clearRect(0, 0, allw, allh);</span><br>        <span class="hljs-comment">// g2.setPaint(Color.RED);</span><br> <br>        <span class="hljs-comment">// 合并所有子图片到新图片</span><br>        <span class="hljs-keyword">int</span> wx = <span class="hljs-number">0</span>, wy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; imgs.size(); i++) &#123;<br>            BufferedImage img = imgs.get(i);<br>            <span class="hljs-keyword">int</span> w1 = img.getWidth();<br>            <span class="hljs-keyword">int</span> h1 = img.getHeight();<br>            <span class="hljs-comment">// 从图片中读取RGB</span><br>            <span class="hljs-keyword">int</span>[] ImageArrayOne = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[w1 * h1];<br>            ImageArrayOne = img.getRGB(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w1, h1, ImageArrayOne, <span class="hljs-number">0</span>, w1); <span class="hljs-comment">// 逐行扫描图像中各个像素的RGB到数组中</span><br>            <span class="hljs-keyword">if</span> (isHorizontal) &#123; <span class="hljs-comment">// 水平方向合并</span><br>                destImage.setRGB(wx, <span class="hljs-number">0</span>, w1, h1, ImageArrayOne, <span class="hljs-number">0</span>, w1); <span class="hljs-comment">// 设置上半部分或左半部分的RGB</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 垂直方向合并</span><br>                destImage.setRGB(<span class="hljs-number">0</span>, wy, w1, h1, ImageArrayOne, <span class="hljs-number">0</span>, w1); <span class="hljs-comment">// 设置上半部分或左半部分的RGB</span><br>            &#125;<br> <br>            wx += w1;<br>            wy += h1 + <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> destImage;<br>    &#125;<br> <br> <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>将word转换为单页 每页为一张图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * word 转每页pdf</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wordfile</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseFileToBase64_PNG1</span><span class="hljs-params">(String wordfile)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br> <br><span class="hljs-keyword">if</span> (!isWordLicense()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br> <br><span class="hljs-comment">// 声明一个</span><br>InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(wordfile);<br> <br> <br> <br><span class="hljs-comment">//文件 获取文件名字</span><br>File file = <span class="hljs-keyword">new</span> File(wordfile);<br>String name = file.getName();<br><span class="hljs-comment">//截取不带后缀名的字段</span><br>String fileName = name.substring(<span class="hljs-number">0</span>, name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><span class="hljs-comment">//文件上传路径</span><br>String parent = file.getParent();<br> <br><span class="hljs-comment">//创建同名文件夹</span><br><span class="hljs-keyword">new</span> File(parent+<span class="hljs-string">&quot;/&quot;</span>+ fileName).mkdir();<br> <br>List&lt;BufferedImage&gt; bufferedImages = wordToImg1(inputStream);<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bufferedImages.size(); i++)&#123;<br>ImageIO.write(bufferedImages.get(i), <span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-keyword">new</span> File(parent +<span class="hljs-string">&quot;/&quot;</span>+ fileName +<span class="hljs-string">&quot;/&quot;</span>+ <span class="hljs-string">&quot;第&quot;</span>+ i +<span class="hljs-string">&quot;页&quot;</span> + fileName + <span class="hljs-string">&quot;.png&quot;</span>));<br>&#125;<br> <br> <br><br> <br><span class="hljs-comment">//关闭流</span><br>inputStream.close();<br> <br> <br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转换成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="图片转换为base64-前台预览"><a href="#图片转换为base64-前台预览" class="headerlink" title="图片转换为base64 前台预览"></a>图片转换为base64 前台预览</h1><p>业务需求 word转换成在线预览 结合<a href="https://bk.cuixiaoyan.xyz/archives/zhuantupian">这里是word转图片</a> 也可以直接转换为在线预览</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">parseFileToBase64_PNG1</span><span class="hljs-params">(InputStream inputStream, <span class="hljs-keyword">int</span> pageNum)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-comment">// String png_base64 = &quot;&quot;;</span><br>List&lt;BufferedImage&gt; bufferedImages = <span class="hljs-keyword">new</span> ArrayList&lt;BufferedImage&gt;();<br>BufferedImage image = <span class="hljs-keyword">null</span>;<br>ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<span class="hljs-comment">// io流</span><br>bufferedImages = wordToImg1(inputStream, pageNum);<br>image = mergeImage(<span class="hljs-keyword">false</span>, bufferedImages);<br>ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, baos);<span class="hljs-comment">// 写入流中</span><br> <br><span class="hljs-keyword">byte</span>[] bytes = baos.toByteArray();<span class="hljs-comment">// 转换成字节</span><br>BASE64Encoder encoder = <span class="hljs-keyword">new</span> BASE64Encoder();<br>String png_base64 = encoder.encodeBuffer(bytes).trim();<span class="hljs-comment">// 转换成base64串</span><br>png_base64 = png_base64.replaceAll(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replaceAll(<span class="hljs-string">&quot;\r&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 删除</span><br><br><span class="hljs-keyword">return</span> png_base64;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>aspose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aspose-words java word 转pdf</title>
    <link href="/blog/2021/01/15/aspose-words-java-word%E8%BD%ACpdf/"/>
    <url>/blog/2021/01/15/aspose-words-java-word%E8%BD%ACpdf/</url>
    
    <content type="html"><![CDATA[<p>和谐版jar包 加激活 去除水印 转换从此无限制 就算是在服务器上也不需要安装其他工具 目前最好 使用 方便快捷 jar包下载地址 链接: <a href="https://pan.baidu.com/s/1tlbueAQq5bxPNgncS7GgoA">https://pan.baidu.com/s/1tlbueAQq5bxPNgncS7GgoA</a> 提取码: p35p</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * word to pdf</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> inPath  word 全路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outPath 生成的pdf 全路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> an</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">docPdf</span><span class="hljs-params">(String inPath, String outPath)</span>   </span>&#123;<br> <br><span class="hljs-keyword">if</span> (!isWordLicense()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br> <br><span class="hljs-keyword">try</span> &#123;<br>String path = outPath.substring(<span class="hljs-number">0</span>, outPath.lastIndexOf(File.separator));<br>File file = <span class="hljs-keyword">null</span>;<br>file = <span class="hljs-keyword">new</span> File(path);<br><span class="hljs-keyword">if</span> (!file.exists()) &#123;<span class="hljs-comment">//创建文件夹</span><br>file.mkdirs();<br>&#125;<br>file = <span class="hljs-keyword">new</span> File(outPath);<span class="hljs-comment">// 新建一个空白pdf文档</span><br>FileOutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>Document doc = <span class="hljs-keyword">new</span> Document(inPath); <span class="hljs-comment">// Address是将要被转化的word文档</span><br>doc.save(os, SaveFormat.PDF);<span class="hljs-comment">// 全面支持DOC, DOCX, OOXML, RTF HTML, OpenDocument, PDF,</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">// EPUB, XPS, SWF 相互转换</span><br><span class="hljs-keyword">return</span> outPath;<br>&#125;<br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 验证aspose.word组件是否授权：无授权的文件有水印和试用标记</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWordLicense</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// InputStream inputStream = new</span><br><span class="hljs-comment">// FileInputStream(&quot;D:\\Workspaces\\TestFilters\\lib\\license.xml&quot;);</span><br><span class="hljs-comment">// 避免文件遗漏</span><br>String licensexml = <span class="hljs-string">&quot;&lt;License&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;Data&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;Products&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;Product&gt;Aspose.Total for Java&lt;/Product&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;Product&gt;Aspose.Words for Java&lt;/Product&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;/Products&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;EditionType&gt;Enterprise&lt;/EditionType&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;SubscriptionExpiry&gt;20991231&lt;/SubscriptionExpiry&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;LicenseExpiry&gt;20991231&lt;/LicenseExpiry&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;SerialNumber&gt;23dcc79f-44ec-4a23-be3a-03c1632404e9&lt;/SerialNumber&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;/Data&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;Signature&gt;\n&quot;</span><br>+ <span class="hljs-string">&quot;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU=\n&quot;</span><br>+ <span class="hljs-string">&quot;&lt;/Signature&gt;\n&quot;</span> + <span class="hljs-string">&quot;&lt;/License&gt;&quot;</span>;<br>InputStream inputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(licensexml.getBytes());<br>com.aspose.words.License license = <span class="hljs-keyword">new</span> com.aspose.words.License();<br>license.setLicense(inputStream);<br>result = <span class="hljs-keyword">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br> <br><span class="hljs-comment">// outputStream转inputStream</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteArrayInputStream <span class="hljs-title">parse</span><span class="hljs-params">(OutputStream out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>baos = (ByteArrayOutputStream) out;<br>ByteArrayInputStream swapStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(baos.toByteArray());<br><span class="hljs-keyword">return</span> swapStream;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>aspose</tag>
      
      <tag>word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将数字金额转为大写中文金额</title>
    <link href="/blog/2021/01/13/%E5%B0%86%E6%95%B0%E5%AD%97%E9%87%91%E9%A2%9D%E8%BD%AC%E4%B8%BA%E5%A4%A7%E5%86%99%E4%B8%AD%E6%96%87%E9%87%91%E9%A2%9D/"/>
    <url>/blog/2021/01/13/%E5%B0%86%E6%95%B0%E5%AD%97%E9%87%91%E9%A2%9D%E8%BD%AC%E4%B8%BA%E5%A4%A7%E5%86%99%E4%B8%AD%E6%96%87%E9%87%91%E9%A2%9D/</url>
    
    <content type="html"><![CDATA[<p>输入数字金额参数，运行程序得到其对应的大写中文金额；例如：输入— 12.56，输出— 12.56:壹拾贰元伍角陆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *<span class="hljs-doctag">@Title</span>: ConvertUpMoney </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:  将数字金额转为大写汉字金额</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2019年6月18日 下午10:52:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConvertUpMoney</span> </span>&#123;<br><br><span class="hljs-comment">//大写数字</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NUMBERS = &#123;<span class="hljs-string">&quot;零&quot;</span>,<span class="hljs-string">&quot;壹&quot;</span>,<span class="hljs-string">&quot;贰&quot;</span>,<span class="hljs-string">&quot;叁&quot;</span>,<span class="hljs-string">&quot;肆&quot;</span>,<span class="hljs-string">&quot;伍&quot;</span>,<span class="hljs-string">&quot;陆&quot;</span>,<span class="hljs-string">&quot;柒&quot;</span>,<span class="hljs-string">&quot;捌&quot;</span>,<span class="hljs-string">&quot;玖&quot;</span>&#125;;<br><span class="hljs-comment">// 整数部分的单位</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] IUNIT = &#123;<span class="hljs-string">&quot;元&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;仟&quot;</span>,<span class="hljs-string">&quot;万&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;仟&quot;</span>,<span class="hljs-string">&quot;亿&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;仟&quot;</span>,<span class="hljs-string">&quot;万&quot;</span>,<span class="hljs-string">&quot;拾&quot;</span>,<span class="hljs-string">&quot;佰&quot;</span>,<span class="hljs-string">&quot;仟&quot;</span>&#125;;<br>    <span class="hljs-comment">//小数部分的单位</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] DUNIT = &#123;<span class="hljs-string">&quot;角&quot;</span>,<span class="hljs-string">&quot;分&quot;</span>,<span class="hljs-string">&quot;厘&quot;</span>&#125;;<br><br><span class="hljs-comment">//转成中文的大写金额</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toChinese</span><span class="hljs-params">(String str)</span> </span>&#123;<br><span class="hljs-comment">//判断输入的金额字符串是否符合要求</span><br><span class="hljs-keyword">if</span> (StringUtils.isBlank(str) || !str.matches(<span class="hljs-string">&quot;(-)?[\\d]*(.)?[\\d]*&quot;</span>)) &#123;<br>System.out.println(<span class="hljs-string">&quot;抱歉，请输入数字！&quot;</span>);<br><span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;0&quot;</span>.equals(str) || <span class="hljs-string">&quot;0.00&quot;</span>.equals(str) || <span class="hljs-string">&quot;0.0&quot;</span>.equals(str)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;零元&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//判断是否存在负号&quot;-&quot;</span><br><span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">if</span>(str.startsWith(<span class="hljs-string">&quot;-&quot;</span>))&#123;<br>flag = <span class="hljs-keyword">true</span>;<br>str = str.replaceAll(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br>str = str.replaceAll(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//去掉&quot;,&quot;</span><br>String integerStr;<span class="hljs-comment">//整数部分数字</span><br>String decimalStr;<span class="hljs-comment">//小数部分数字</span><br><br><br><span class="hljs-comment">//初始化：分离整数部分和小数部分</span><br><span class="hljs-keyword">if</span>(str.indexOf(<span class="hljs-string">&quot;.&quot;</span>)&gt;<span class="hljs-number">0</span>) &#123;<br>integerStr = str.substring(<span class="hljs-number">0</span>,str.indexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>decimalStr = str.substring(str.indexOf(<span class="hljs-string">&quot;.&quot;</span>)+<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.indexOf(<span class="hljs-string">&quot;.&quot;</span>)==<span class="hljs-number">0</span>) &#123;<br>integerStr = <span class="hljs-string">&quot;&quot;</span>;<br>decimalStr = str.substring(<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>integerStr = str;<br>decimalStr = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//beyond超出计算能力，直接返回</span><br><span class="hljs-keyword">if</span>(integerStr.length()&gt;IUNIT.length) &#123;<br>System.out.println(str+<span class="hljs-string">&quot;：超出计算能力&quot;</span>);<br><span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-keyword">int</span>[] integers = toIntArray(integerStr);<span class="hljs-comment">//整数部分数字</span><br><span class="hljs-comment">//判断整数部分是否存在输入012的情况</span><br><span class="hljs-keyword">if</span> (integers.length&gt;<span class="hljs-number">1</span> &amp;&amp; integers[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;抱歉，请输入数字！&quot;</span>);<br><span class="hljs-keyword">if</span> (flag) &#123;<br>str = <span class="hljs-string">&quot;-&quot;</span>+str;<br>&#125;<br><span class="hljs-keyword">return</span> str;<br>&#125;<br><span class="hljs-keyword">boolean</span> isWan = isWan5(integerStr);<span class="hljs-comment">//设置万单位</span><br><span class="hljs-keyword">int</span>[] decimals = toIntArray(decimalStr);<span class="hljs-comment">//小数部分数字</span><br>String result = getChineseInteger(integers,isWan)+getChineseDecimal(decimals);<span class="hljs-comment">//返回最终的大写金额</span><br><span class="hljs-keyword">if</span>(flag)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;负&quot;</span>+result;<span class="hljs-comment">//如果是负数，加上&quot;负&quot;</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//将字符串转为int数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] toIntArray(String number) &#123;<br><span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[number.length()];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;number.length();i++) &#123;<br>array[i] = Integer.parseInt(number.substring(i,i+<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-comment">//将整数部分转为大写的金额</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getChineseInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] integers,<span class="hljs-keyword">boolean</span> isWan)</span> </span>&#123;<br>StringBuffer chineseInteger = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">int</span> length = integers.length;<br><span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span> &amp;&amp; integers[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++) &#123;<br>String key = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(integers[i] == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span>((length - i) == <span class="hljs-number">13</span>)<span class="hljs-comment">//万（亿）</span><br>key = IUNIT[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((length - i) == <span class="hljs-number">9</span>) &#123;<span class="hljs-comment">//亿</span><br>key = IUNIT[<span class="hljs-number">8</span>];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((length - i) == <span class="hljs-number">5</span> &amp;&amp; isWan) &#123;<span class="hljs-comment">//万</span><br>key = IUNIT[<span class="hljs-number">4</span>];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((length - i) == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//元</span><br>key = IUNIT[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">if</span>((length - i)&gt;<span class="hljs-number">1</span> &amp;&amp; integers[i+<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>) &#123;<br>key += NUMBERS[<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br>chineseInteger.append(integers[i]==<span class="hljs-number">0</span>?key:(NUMBERS[integers[i]]+IUNIT[length - i -<span class="hljs-number">1</span>]));<br>&#125;<br><span class="hljs-keyword">return</span> chineseInteger.toString();<br>&#125;<br><span class="hljs-comment">//将小数部分转为大写的金额</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getChineseDecimal</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] decimals)</span> </span>&#123;<br>StringBuffer chineseDecimal = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;decimals.length;i++) &#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>chineseDecimal.append(decimals[i]==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;&quot;</span>:(NUMBERS[decimals[i]]+DUNIT[i]));<br>&#125;<br><span class="hljs-keyword">return</span> chineseDecimal.toString();<br>&#125;<br><span class="hljs-comment">//判断当前整数部分是否已经是达到【万】</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWan5</span><span class="hljs-params">(String integerStr)</span> </span>&#123;<br><span class="hljs-keyword">int</span> length = integerStr.length();<br><span class="hljs-keyword">if</span>(length &gt; <span class="hljs-number">4</span>) &#123;<br>String subInteger = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(length &gt; <span class="hljs-number">8</span>) &#123;<br>subInteger = integerStr.substring(length- <span class="hljs-number">8</span>,length -<span class="hljs-number">4</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>subInteger = integerStr.substring(<span class="hljs-number">0</span>,length - <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-keyword">return</span> Integer.parseInt(subInteger) &gt; <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String number = <span class="hljs-string">&quot;12.56&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;1234567890563886.123&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;1600&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;156,0&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;-156,0&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;0.12&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;0.0&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;01.12&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;0125&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;-0125&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>number = <span class="hljs-string">&quot;sdw5655&quot;</span>;<br>System.out.println(number+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(number));<br><br>System.out.println(<span class="hljs-keyword">null</span>+<span class="hljs-string">&quot;: &quot;</span>+ConvertUpMoney.toChinese(<span class="hljs-keyword">null</span>));<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java常用工具类3</title>
    <link href="/blog/2021/01/13/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB3/"/>
    <url>/blog/2021/01/13/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB3/</url>
    
    <content type="html"><![CDATA[<p>在Java中，工具类定义了一组公共方法，这篇文章将介绍Java中使用最频繁及最通用的Java工具类。以下工具类、方法按使用流行度排名，参考数据来源于Github上随机选取的5万个开源项目源码。</p><p>一. org.apache.commons.io.IOUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在<span class="hljs-keyword">finally</span>块<br>toString：转换IO流、 Uri、 <span class="hljs-keyword">byte</span>[]为String<br>copy：IO流数据复制，从输入流写到输出流中，最大支持2GB<br>toByteArray：从输入流、URI获取<span class="hljs-keyword">byte</span>[]<br>write：把字节. 字符等写入输出流<br>toInputStream：把字符转换为输入流<br>readLines：从输入流中读取多行数据，返回List&lt;String&gt;<br>copyLarge：同copy，支持2GB以上数据的复制<br>lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败<br></code></pre></td></tr></table></figure><p>二. org.apache.commons.io.FileUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">deleteDirectory：删除文件夹<br>readFileToString：以字符形式读取文件内容<br>deleteQueitly：删除文件或文件夹且不会抛出异常<br>copyFile：复制文件<br>writeStringToFile：把字符写到目标文件，如果文件不存在，则创建<br>forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级<br>write：把字符写到指定文件中<br>listFiles：列举某个目录下的文件(根据过滤器)<br>copyDirectory：复制文件夹<br>forceDelete：强制删除文件<br></code></pre></td></tr></table></figure><p>三. org.apache.commons.lang.StringUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">isBlank：字符串是否为空 (trim后判断)<br>isEmpty：字符串是否为空 (不trim并判断)<br>equals：字符串是否相等<br>join：合并数组为单一字符串，可传分隔符<br>split：分割字符串<br>EMPTY：返回空字符串<br>trimToNull：trim后为空字符串则转换为<span class="hljs-keyword">null</span><br>replace：替换字符串<br></code></pre></td></tr></table></figure><p>四. org.apache.http.util.EntityUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">toString：把Entity转换为字符串<br>consume：确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉<br>toByteArray：把Entity转换为字节流<br>consumeQuietly：和consume一样，但不抛异常<br>getContentCharset：获取内容的编码<br></code></pre></td></tr></table></figure><p>五. org.apache.commons.lang3.StringUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">isBlank：字符串是否为空 (trim后判断)<br>isEmpty：字符串是否为空 (不trim并判断)<br>equals：字符串是否相等<br>join：合并数组为单一字符串，可传分隔符<br>split：分割字符串<br>EMPTY：返回空字符串<br>replace：替换字符串<br>capitalize：首字符大写<br></code></pre></td></tr></table></figure><p>六. org.apache.commons.io.FilenameUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">getExtension：返回文件后缀名<br>getBaseName：返回文件名，不包含后缀名<br>getName：返回文件全名<br>concat：按命令行风格组合文件路径(详见方法注释)<br>removeExtension：删除后缀名<br>normalize：使路径正常化<br>wildcardMatch：匹配通配符<br>seperatorToUnix：路径分隔符改成unix系统格式的，即/<br>getFullPath：获取文件路径，不包括文件名<br>isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个<br></code></pre></td></tr></table></figure><p>七. org.springframework.util.StringUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">hasText：检查字符串中是否包含文本<br>hasLength：检测字符串是否长度大于<span class="hljs-number">0</span><br>isEmpty：检测字符串是否为空（若传入为对象，则判断对象是否为<span class="hljs-keyword">null</span>）<br>commaDelimitedStringToArray：逗号分隔的String转换为数组<br>collectionToDelimitedString：把集合转为CSV格式字符串<br>replace 替换字符串<br><span class="hljs-number">7.</span> delimitedListToStringArray：相当于split<br>uncapitalize：首字母小写<br>collectionToDelimitedCommaString：把集合转为CSV格式字符串<br>tokenizeToStringArray：和split基本一样，但能自动去掉空白的单词<br></code></pre></td></tr></table></figure><p>八. org.apache.commons.lang.ArrayUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">contains：是否包含某字符串<br>addAll：添加整个数组<br>clone：克隆一个数组<br>isEmpty：是否空数组<br>add：向数组添加元素<br>subarray：截取数组<br>indexOf：查找某个元素的下标<br>isEquals：比较数组是否相等<br>toObject：基础类型数据数组转换为对应的Object数组<br></code></pre></td></tr></table></figure><p>九. org.apache.commons.lang.StringEscapeUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">参考十五：org.apache.commons.lang3.StringEscapeUtils<br></code></pre></td></tr></table></figure><p>十. org.apache.http.client.utils.URLEncodedUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">format：格式化参数，返回一个HTTP POST或者HTTP PUT可用application/x-www-form-urlencoded字符串<br>parse：把String或者URI等转换为List&lt;NameValuePair&gt;<br></code></pre></td></tr></table></figure><p>十一. org.apache.commons.codec.digest.DigestUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">md5Hex：MD5加密，返回<span class="hljs-number">32</span>位字符串<br>sha1Hex：SHA-<span class="hljs-number">1</span>加密<br>sha256Hex：SHA-<span class="hljs-number">256</span>加密<br>sha512Hex：SHA-<span class="hljs-number">512</span>加密<br>md5：MD5加密，返回<span class="hljs-number">16</span>位字符串<br></code></pre></td></tr></table></figure><p>十二. org.apache.commons.collections.CollectionUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">isEmpty：是否为空<br>select：根据条件筛选集合元素<br>transform：根据指定方法处理集合元素，类似List的map()<br>filter：过滤元素，雷瑟List的filter()<br>find：基本和select一样<br>collect：和transform 差不多一样，但是返回新数组<br>forAllDo：调用每个元素的指定方法<br>isEqualCollection：判断两个集合是否一致<br></code></pre></td></tr></table></figure><p>十三. org.apache.commons.lang3.ArrayUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">contains：是否包含某个字符串<br>addAll：添加整个数组<br>clone：克隆一个数组<br>isEmpty：是否空数组<br>add：向数组添加元素<br>subarray：截取数组<br>indexOf：查找某个元素的下标<br>isEquals：比较数组是否相等<br>toObject：基础类型数据数组转换为对应的Object数组<br></code></pre></td></tr></table></figure><p>十四. org.apache.commons.beanutils.PropertyUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">getProperty：获取对象属性值<br>setProperty：设置对象属性值<br>getPropertyDiscriptor：获取属性描述器<br>isReadable：检查属性是否可访问<br>copyProperties：复制属性值，从一个对象到另一个对象<br>getPropertyDiscriptors：获取所有属性描述器<br>isWriteable：检查属性是否可写<br>getPropertyType：获取对象属性类型<br></code></pre></td></tr></table></figure><p>十五. org.apache.commons.lang3.StringEscapeUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">unescapeHtml4：转义html<br>escapeHtml4：反转义html<br>escapeXml：转义xml<br>unescapeXml：反转义xml<br>escapeJava：转义unicode编码<br>escapeEcmaScript：转义EcmaScript字符<br>unescapeJava：反转义unicode编码<br>escapeJson：转义json字符<br>escapeXml10：转义Xml10<br>这个现在已经废弃了，建议使用commons-text包里面的方法。<br></code></pre></td></tr></table></figure><p>十六. org.apache.commons.beanutils.BeanUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">copyPeoperties：复制属性值，从一个对象到另一个对象<br>getProperty：获取对象属性值<br>setProperty：设置对象属性值<br>populate：根据Map给属性复制<br>copyPeoperty：复制单个值，从一个对象到另一个对象<br>cloneBean：克隆bean实例<br></code></pre></td></tr></table></figure><p>现在你只要了解了以上16种最流行的工具类方法，你就不必要再自己写工具类了，不必重复造轮子。大部分工具类方法通过其名字就能明白其用途，如果不清楚的，可以看下别人是怎么用的，或者去网上查询其用法。</p><p>另外，工具类，根据阿里开发手册，包名如果要使用util不能带s，工具类命名为 XxxUtils</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java常用工具类2</title>
    <link href="/blog/2021/01/13/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB2/"/>
    <url>/blog/2021/01/13/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB2/</url>
    
    <content type="html"><![CDATA[<p>一、当相同元素为String时 方法一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * List去重</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title">removeDuplicate</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<br>    LinkedHashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;(list.size());<br>    set.addAll(list);<br>    list.clear();<br>    list.addAll(set);<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list= list.stream().distinct().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>二、当相同元素为对象时 方法一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意Comparator.comparing要根据参数的类型进行选择</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;GroupVO&gt; <span class="hljs-title">removeDuplicateGroupVO</span><span class="hljs-params">(List&lt;GroupVO&gt; groupVOS)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> groupVOS.stream().collect(<br>            Collectors.collectingAndThen(<br>                    Collectors.toCollection(<br>                            () -&gt; <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(GroupVO::getId))<br>                    ), ArrayList::<span class="hljs-keyword">new</span><br>            )<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Person&gt; <span class="hljs-title">removeDupliById</span><span class="hljs-params">(List&lt;Person&gt; persons)</span> </span>&#123;<br>      Set&lt;Person&gt; personSet = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((o1, o2) -&gt; o1.getId().compareTo(o2.getId()));<br>      personSet.addAll(persons);<br> <br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(personSet);<br>  &#125;<br></code></pre></td></tr></table></figure><p>方法三</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">distinctByKey</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, Object&gt; keyExtractor)</span> </span>&#123;<br>      Map&lt;Object, Boolean&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>      <span class="hljs-keyword">return</span> t -&gt; map.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="hljs-keyword">null</span>;<br>  &#125;<br> <br><span class="hljs-comment">// remove duplicate</span><br>persons.stream().filter(distinctByKey(p -&gt; p.getId())).forEach(p -&gt; System.out.println(p));<br></code></pre></td></tr></table></figure><p>方法一：简单粗暴，直接使用copy()，如果目标存在，先使用delete()删除，再复制；</p><p>方法二：使用输入输出流。（代码注释部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> eg2;<br> <br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-comment">/******************</span><br><span class="hljs-comment"> * 文件的复制</span><br><span class="hljs-comment"> *******************/</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2_3</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入指定文件夹路径：&quot;</span>);<br>        String oldpath = sc.next();<br>        System.out.println(<span class="hljs-string">&quot;请输入目标文件夹路径：&quot;</span>);<br>        String newpath = sc.next();<br>        System.out.println(<span class="hljs-string">&quot;请输入要复制的文件名：&quot;</span>);<br>        String filename = sc.next();<br>        copy(filename, oldpath, newpath);<br>        System.out.println(<span class="hljs-string">&quot;复制完成！&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String filename, String oldpath, String newpath)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        File oldpaths = <span class="hljs-keyword">new</span> File(oldpath + <span class="hljs-string">&quot;/&quot;</span> + filename);<br>        File newpaths = <span class="hljs-keyword">new</span> File(newpath + <span class="hljs-string">&quot;/&quot;</span> + filename);<br>        <span class="hljs-keyword">if</span> (!newpaths.exists()) &#123;<br>            Files.copy(oldpaths.toPath(), newpaths.toPath());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newpaths.delete();<br>            Files.copy(oldpaths.toPath(), newpaths.toPath());<br>        &#125;<br> <br>        <span class="hljs-comment">// String newfile = &quot;&quot;;</span><br>        <span class="hljs-comment">// newfile += newpaths;</span><br>        <span class="hljs-comment">// FileInputStream in = new FileInputStream(oldpaths);</span><br>        <span class="hljs-comment">// File file = new File(newfile);</span><br>        <span class="hljs-comment">// if (!file.exists()) &#123;</span><br>        <span class="hljs-comment">// file.createNewFile();</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// FileOutputStream out = new FileOutputStream(newpaths);</span><br>        <span class="hljs-comment">// byte[] buffer = new byte[1024];</span><br>        <span class="hljs-comment">// int c;</span><br>        <span class="hljs-comment">// while ((c = in.read(buffer)) != -1) &#123;</span><br>        <span class="hljs-comment">// for (int i = 0; i &lt; c; i++) &#123;</span><br>        <span class="hljs-comment">// out.write(buffer[i]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// in.close();</span><br>        <span class="hljs-comment">// out.close();</span><br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="java实现文件压缩，文件夹压缩，以及文件和文件夹的混合压缩"><a href="#java实现文件压缩，文件夹压缩，以及文件和文件夹的混合压缩" class="headerlink" title="java实现文件压缩，文件夹压缩，以及文件和文件夹的混合压缩"></a>java实现文件压缩，文件夹压缩，以及文件和文件夹的混合压缩</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> util;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: transformation</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: cuixy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2019-07-26 14:30</span><br><span class="hljs-comment"> **/</span><br> <br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.zip.ZipEntry;<br><span class="hljs-keyword">import</span> java.util.zip.ZipOutputStream;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 压缩算法类</span><br><span class="hljs-comment"> * 实现文件压缩，文件夹压缩，以及文件和文件夹的混合压缩</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ljheee</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompactAlgorithm</span> </span>&#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成的结果文件--输出的压缩文件</span><br><span class="hljs-comment">     */</span><br>    File targetFile;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CompactAlgorithm</span><span class="hljs-params">()</span> </span>&#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CompactAlgorithm</span><span class="hljs-params">(File target)</span> </span>&#123;<br>        targetFile = target;<br>        <span class="hljs-keyword">if</span> (targetFile.exists())<br>            targetFile.delete();<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 压缩文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> srcfile</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipFiles</span><span class="hljs-params">(File srcfile)</span> </span>&#123;<br> <br>        ZipOutputStream out = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            out = <span class="hljs-keyword">new</span> ZipOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(targetFile));<br> <br>            <span class="hljs-keyword">if</span>(srcfile.isFile())&#123;<br>                zipFile(srcfile, out, <span class="hljs-string">&quot;&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                File[] list = srcfile.listFiles();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) &#123;<br>                    compress(list[i], out, <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>            &#125;<br> <br>            System.out.println(<span class="hljs-string">&quot;压缩完毕&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>)<br>                    out.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 压缩文件夹里的文件</span><br><span class="hljs-comment">     * 起初不知道是文件还是文件夹--- 统一调用该方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> basedir</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compress</span><span class="hljs-params">(File file, ZipOutputStream out, String basedir)</span> </span>&#123;<br>        <span class="hljs-comment">/* 判断是目录还是文件 */</span><br>        <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>            <span class="hljs-keyword">this</span>.zipDirectory(file, out, basedir);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.zipFile(file, out, basedir);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 压缩单个文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> srcfile</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipFile</span><span class="hljs-params">(File srcfile, ZipOutputStream out, String basedir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!srcfile.exists())<br>            <span class="hljs-keyword">return</span>;<br> <br>        <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        FileInputStream in = <span class="hljs-keyword">null</span>;<br> <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> len;<br>            in = <span class="hljs-keyword">new</span> FileInputStream(srcfile);<br>            out.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(basedir + srcfile.getName()));<br> <br>            <span class="hljs-keyword">while</span> ((len = in.read(buf)) &gt; <span class="hljs-number">0</span>) &#123;<br>                out.write(buf, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>)<br>                    out.closeEntry();<br>                <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>)<br>                    in.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 压缩文件夹</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dir</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> basedir</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipDirectory</span><span class="hljs-params">(File dir, ZipOutputStream out, String basedir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!dir.exists())<br>            <span class="hljs-keyword">return</span>;<br> <br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) &#123;<br>            <span class="hljs-comment">/* 递归 */</span><br>            compress(files[i], out, basedir + dir.getName() + <span class="hljs-string">&quot;/&quot;</span>);<br>        &#125;<br>    &#125;<br> <br> <br> <br>&#125;<br> <br></code></pre></td></tr></table></figure><p>运行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//压缩测试</span><br>File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/Users/cuixiaoyan/Downloads/浏览器下载&quot;</span>);<br><span class="hljs-keyword">new</span> CompactAlgorithm(<span class="hljs-keyword">new</span> File( <span class="hljs-string">&quot;/Users/cuixiaoyan/Downloads/&quot;</span>,f.getName()+<span class="hljs-string">&quot;.zip&quot;</span>)).zipFiles(f);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中实现List自定义排序</title>
    <link href="/blog/2021/01/11/Java%E4%B8%AD%E5%AE%9E%E7%8E%B0List%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2021/01/11/Java%E4%B8%AD%E5%AE%9E%E7%8E%B0List%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.whty.entity;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.whty.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">import</span> com.whty.entity.User;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-number">20</span>));<br>list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;spark&quot;</span>, <span class="hljs-number">19</span>));<br>list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;hive&quot;</span>, <span class="hljs-number">21</span>));<br><br><span class="hljs-keyword">for</span>(User user :list) &#123;<br>System.out.println(<span class="hljs-string">&quot;排序前：&quot;</span> + user.toString());<br>&#125;<br><span class="hljs-comment">//实现排序</span><br>Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;User&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User u1, User u2)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(u1.getAge() &gt; u2.getAge()) &#123;<br><span class="hljs-comment">//return -1:即为正序排序</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (u1.getAge() == u2.getAge()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//return 1: 即为倒序排序</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;);<br><br><span class="hljs-keyword">for</span>(User user :list) &#123;<br>System.out.println(<span class="hljs-string">&quot;排序后：&quot;</span> + user.toString());<br>&#125;<br>&#125;<br>&#125;<br> <br> <br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">排序前：User [id=<span class="hljs-number">1</span>, name=java, age=<span class="hljs-number">20</span>]<br>排序前：User [id=<span class="hljs-number">2</span>, name=spark, age=<span class="hljs-number">19</span>]<br>排序前：User [id=<span class="hljs-number">3</span>, name=hive, age=<span class="hljs-number">21</span>]<br>排序后：User [id=<span class="hljs-number">3</span>, name=hive, age=<span class="hljs-number">21</span>]<br>排序后：User [id=<span class="hljs-number">1</span>, name=java, age=<span class="hljs-number">20</span>]<br>排序后：User [id=<span class="hljs-number">2</span>, name=spark, age=<span class="hljs-number">19</span>]<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java常用工具类</title>
    <link href="/blog/2021/01/11/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/blog/2021/01/11/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>java中，StringUtils类中的一些常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isBlank</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//判断某字符串是否为空或长度为0或由空白符(whitespace)构成</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">isBlank</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">true</span><br>StringUtils.isBlank(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isBlank(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isBlank(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isBlank(<span class="hljs-string">&quot;\t \n \f \r&quot;</span>) = <span class="hljs-keyword">true</span> <span class="hljs-comment">//对于制表符、换行符、换页符和回车符StringUtils.isBlank()均识为空白符</span><br>StringUtils.isBlank(<span class="hljs-string">&quot;\b&quot;</span>) = <span class="hljs-keyword">false</span> <span class="hljs-comment">//&quot;\b&quot;为单词边界符</span><br>StringUtils.isBlank(<span class="hljs-string">&quot;bob&quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isBlank(<span class="hljs-string">&quot; bob &quot;</span>) = <span class="hljs-keyword">false</span><br> <br> <br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNotBlank</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成，等于!isBlank(String str)</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">isNotBlank</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">false</span><br>StringUtils.isNotBlank(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isNotBlank(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isNotBlank(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isNotBlank(<span class="hljs-string">&quot;\t \n \f \r&quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isNotBlank(<span class="hljs-string">&quot;\b&quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isNotBlank(<span class="hljs-string">&quot;bob&quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isNotBlank(<span class="hljs-string">&quot; bob &quot;</span>) = <span class="hljs-keyword">true</span><br> <br> <br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//判断某字符串是否为空，为空的标准是str==null或str.length()==0</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">true</span><br>StringUtils.isEmpty(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isEmpty(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">false</span> <span class="hljs-comment">//注意在StringUtils中空格作非空处理</span><br>StringUtils.isEmpty(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isEmpty(<span class="hljs-string">&quot;bob&quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isEmpty(<span class="hljs-string">&quot; bob &quot;</span>) = <span class="hljs-keyword">false</span><br> <br> <br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//判断某字符串是否非空，等于!isEmpty(String str)</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">isNotEmpty</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">false</span><br>StringUtils.isNotEmpty(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-keyword">false</span><br>StringUtils.isNotEmpty(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isNotEmpty(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isNotEmpty(<span class="hljs-string">&quot;bob&quot;</span>) = <span class="hljs-keyword">true</span><br>StringUtils.isNotEmpty(<span class="hljs-string">&quot; bob &quot;</span>) = <span class="hljs-keyword">true</span><br> <br> <br><span class="hljs-function">String <span class="hljs-title">trim</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//去掉字符串两端的控制符(control characters, char &lt;= 32),如果输入为null则返回null</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">trim</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">null</span><br>StringUtils.trim(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.trim(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.trim(<span class="hljs-string">&quot; \b \t \n \f \r &quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.trim(<span class="hljs-string">&quot; \n\tss \b&quot;</span>) = <span class="hljs-string">&quot;ss&quot;</span><br>StringUtils.trim(<span class="hljs-string">&quot; d d dd &quot;</span>) = <span class="hljs-string">&quot;d d dd&quot;</span><br>StringUtils.trim(<span class="hljs-string">&quot;dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br>StringUtils.trim(<span class="hljs-string">&quot; dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br> <br> <br><span class="hljs-function">String <span class="hljs-title">trimToNull</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//去掉字符串两端的控制符(control characters, char &lt;= 32),如果变为null或&quot;&quot;，则返回null</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">trimToNull</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">null</span><br>StringUtils.trimToNull(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-keyword">null</span><br>StringUtils.trimToNull(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">null</span><br>StringUtils.trimToNull(<span class="hljs-string">&quot; \b \t \n \f \r &quot;</span>) = <span class="hljs-keyword">null</span><br>StringUtils.trimToNull(<span class="hljs-string">&quot; \n\tss \b&quot;</span>) = <span class="hljs-string">&quot;ss&quot;</span><br>StringUtils.trimToNull(<span class="hljs-string">&quot; d d dd &quot;</span>) = <span class="hljs-string">&quot;d d dd&quot;</span><br>StringUtils.trimToNull(<span class="hljs-string">&quot;dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br>StringUtils.trimToNull(<span class="hljs-string">&quot; dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br> <br> <br><span class="hljs-function">String <span class="hljs-title">trimToEmpty</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//去掉字符串两端的控制符(control characters, char &lt;= 32),如果变为null或&quot;&quot;，则返回&quot;&quot;</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">trimToEmpty</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-string">&quot;&quot;</span><br>StringUtils.trimToEmpty(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.trimToEmpty(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.trimToEmpty(<span class="hljs-string">&quot; \b \t \n \f \r &quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.trimToEmpty(<span class="hljs-string">&quot; \n\tss \b&quot;</span>) = <span class="hljs-string">&quot;ss&quot;</span><br>StringUtils.trimToEmpty(<span class="hljs-string">&quot; d d dd &quot;</span>) = <span class="hljs-string">&quot;d d dd&quot;</span><br>StringUtils.trimToEmpty(<span class="hljs-string">&quot;dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br>StringUtils.trimToEmpty(<span class="hljs-string">&quot; dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br> <br> <br><span class="hljs-function">String <span class="hljs-title">strip</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//去掉字符串两端的空白符(whitespace)，如果输入为null则返回null(注意和trim()的区别)：</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">strip</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">null</span><br>StringUtils.strip(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.strip(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.strip(<span class="hljs-string">&quot; \b \t \n \f \r &quot;</span>) = <span class="hljs-string">&quot;\b&quot;</span><br>StringUtils.strip(<span class="hljs-string">&quot; \n\tss \b&quot;</span>) = <span class="hljs-string">&quot;ss \b&quot;</span><br>StringUtils.strip(<span class="hljs-string">&quot; d d dd &quot;</span>) = <span class="hljs-string">&quot;d d dd&quot;</span><br>StringUtils.strip(<span class="hljs-string">&quot;dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br>StringUtils.strip(<span class="hljs-string">&quot; dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br> <br> <br><span class="hljs-function">String <span class="hljs-title">stripToNull</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//去掉字符串两端的空白符(whitespace)，如果变为null或&quot;&quot;，则返回null(注意和trimToNull()的区别)：</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">stripToNull</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-keyword">null</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-keyword">null</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-keyword">null</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; \b \t \n \f \r &quot;</span>) = <span class="hljs-string">&quot;\b&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; \n\tss \b&quot;</span>) = <span class="hljs-string">&quot;ss \b&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; d d dd &quot;</span>) = <span class="hljs-string">&quot;d d dd&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot;dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br> <br> <br><span class="hljs-function">String <span class="hljs-title">stripToEmpty</span><span class="hljs-params">(String str)</span></span><br><span class="hljs-function"><span class="hljs-comment">//去掉字符串两端的空白符(whitespace)，如果变为null或&quot;&quot;，则返回&quot;&quot;(注意和trimToEmpty()的区别)：</span></span><br><span class="hljs-function">StringUtils.<span class="hljs-title">stripToNull</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span> </span>= <span class="hljs-string">&quot;&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot;&quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; &quot;</span>) = <span class="hljs-string">&quot;&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; \b \t \n \f \r &quot;</span>) = <span class="hljs-string">&quot;\b&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; \n\tss \b&quot;</span>) = <span class="hljs-string">&quot;ss \b&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; d d dd &quot;</span>) = <span class="hljs-string">&quot;d d dd&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot;dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br>StringUtils.stripToNull(<span class="hljs-string">&quot; dd &quot;</span>) = <span class="hljs-string">&quot;dd&quot;</span><br> <br></code></pre></td></tr></table></figure><p>java中我们会常用一些判断如IP、电子邮箱、电话号码的是不是合法，那么我们怎么来判断呢，答案就是利用正则表达式来判断了，废话不多说，下面就是上代码。</p><p>1:判断是否是正确的IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 用正则表达式进行判断</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIPAddressByRegex</span><span class="hljs-params">(String str)</span> </span>&#123;<br>            String regex = <span class="hljs-string">&quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;</span>;<br>            <span class="hljs-comment">// 判断ip地址是否与正则表达式匹配</span><br>            <span class="hljs-keyword">if</span> (str.matches(regex)) &#123;<br>                String[] arr = str.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                    <span class="hljs-keyword">int</span> temp = Integer.parseInt(arr[i]);<br>                    <span class="hljs-comment">//如果某个数字不是0到255之间的数 就返回false</span><br>                    <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> || temp &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>2:判断是否是正确的邮箱地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*正则表达式验证邮箱</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmail</span><span class="hljs-params">(String email)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (email == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(email)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            String regex = <span class="hljs-string">&quot;\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*&quot;</span>;<br>           <span class="hljs-keyword">return</span> email.matches(regex);<br>  &#125;<br></code></pre></td></tr></table></figure><p>3:判断是否是手机号码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*正则表达式验证手机</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">orPhoneNumber</span><span class="hljs-params">(String phoneNumber)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (phoneNumber == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(phoneNumber))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           String regex = <span class="hljs-string">&quot;^1[3|4|5|8][0-9]\\d&#123;8&#125;$&quot;</span>;<br>           <span class="hljs-keyword">return</span> phoneNumber.matches(regex);<br>    &#125;<br></code></pre></td></tr></table></figure><p>代码如下 收藏备用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.GregorianCalendar;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工具类，实现阴阳历互转</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> luohao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LunarCalendar</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 支持转换的最小农历年份</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_YEAR = <span class="hljs-number">1900</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 支持转换的最大农历年份</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_YEAR = <span class="hljs-number">2099</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 公历每月前的天数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] DAYS_BEFORE_MONTH = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">59</span>, <span class="hljs-number">90</span>, <span class="hljs-number">120</span>, <span class="hljs-number">151</span>, <span class="hljs-number">181</span>, <span class="hljs-number">212</span>, <span class="hljs-number">243</span>, <span class="hljs-number">273</span>, <span class="hljs-number">304</span>, <span class="hljs-number">334</span>, <span class="hljs-number">365</span>&#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来表示1900年到2099年间农历年份的相关信息，共24位bit的16进制表示，其中：</span><br><span class="hljs-comment">     * 1. 前4位表示该年闰哪个月；</span><br><span class="hljs-comment">     * 2. 5-17位表示农历年份13个月的大小月分布，0表示小，1表示大；</span><br><span class="hljs-comment">     * 3. 最后7位表示农历年首（正月初一）对应的公历日期。</span><br><span class="hljs-comment">     * 以2014年的数据0x955ABF为例说明：</span><br><span class="hljs-comment">     *                  1001 0101 0101 1010 1011 1111</span><br><span class="hljs-comment">     *                闰九月                                  农历正月初一对应公历1月31号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] LUNAR_INFO = &#123;<br>            <span class="hljs-comment">/*1900*/</span><br>            <span class="hljs-number">0x84B6BF</span>,<br>            <span class="hljs-comment">/*1901-1910*/</span><br>            <span class="hljs-number">0x04AE53</span>, <span class="hljs-number">0x0A5748</span>, <span class="hljs-number">0x5526BD</span>, <span class="hljs-number">0x0D2650</span>, <span class="hljs-number">0x0D9544</span>, <span class="hljs-number">0x46AAB9</span>, <span class="hljs-number">0x056A4D</span>, <span class="hljs-number">0x09AD42</span>, <span class="hljs-number">0x24AEB6</span>, <span class="hljs-number">0x04AE4A</span>,<br>            <span class="hljs-comment">/*1911-1920*/</span><br>            <span class="hljs-number">0x6A4DBE</span>, <span class="hljs-number">0x0A4D52</span>, <span class="hljs-number">0x0D2546</span>, <span class="hljs-number">0x5D52BA</span>, <span class="hljs-number">0x0B544E</span>, <span class="hljs-number">0x0D6A43</span>, <span class="hljs-number">0x296D37</span>, <span class="hljs-number">0x095B4B</span>, <span class="hljs-number">0x749BC1</span>, <span class="hljs-number">0x049754</span>,<br>            <span class="hljs-comment">/*1921-1930*/</span><br>            <span class="hljs-number">0x0A4B48</span>, <span class="hljs-number">0x5B25BC</span>, <span class="hljs-number">0x06A550</span>, <span class="hljs-number">0x06D445</span>, <span class="hljs-number">0x4ADAB8</span>, <span class="hljs-number">0x02B64D</span>, <span class="hljs-number">0x095742</span>, <span class="hljs-number">0x2497B7</span>, <span class="hljs-number">0x04974A</span>, <span class="hljs-number">0x664B3E</span>,<br>            <span class="hljs-comment">/*1931-1940*/</span><br>            <span class="hljs-number">0x0D4A51</span>, <span class="hljs-number">0x0EA546</span>, <span class="hljs-number">0x56D4BA</span>, <span class="hljs-number">0x05AD4E</span>, <span class="hljs-number">0x02B644</span>, <span class="hljs-number">0x393738</span>, <span class="hljs-number">0x092E4B</span>, <span class="hljs-number">0x7C96BF</span>, <span class="hljs-number">0x0C9553</span>, <span class="hljs-number">0x0D4A48</span>,<br>            <span class="hljs-comment">/*1941-1950*/</span><br>            <span class="hljs-number">0x6DA53B</span>, <span class="hljs-number">0x0B554F</span>, <span class="hljs-number">0x056A45</span>, <span class="hljs-number">0x4AADB9</span>, <span class="hljs-number">0x025D4D</span>, <span class="hljs-number">0x092D42</span>, <span class="hljs-number">0x2C95B6</span>, <span class="hljs-number">0x0A954A</span>, <span class="hljs-number">0x7B4ABD</span>, <span class="hljs-number">0x06CA51</span>,<br>            <span class="hljs-comment">/*1951-1960*/</span><br>            <span class="hljs-number">0x0B5546</span>, <span class="hljs-number">0x555ABB</span>, <span class="hljs-number">0x04DA4E</span>, <span class="hljs-number">0x0A5B43</span>, <span class="hljs-number">0x352BB8</span>, <span class="hljs-number">0x052B4C</span>, <span class="hljs-number">0x8A953F</span>, <span class="hljs-number">0x0E9552</span>, <span class="hljs-number">0x06AA48</span>, <span class="hljs-number">0x6AD53C</span>,<br>            <span class="hljs-comment">/*1961-1970*/</span><br>            <span class="hljs-number">0x0AB54F</span>, <span class="hljs-number">0x04B645</span>, <span class="hljs-number">0x4A5739</span>, <span class="hljs-number">0x0A574D</span>, <span class="hljs-number">0x052642</span>, <span class="hljs-number">0x3E9335</span>, <span class="hljs-number">0x0D9549</span>, <span class="hljs-number">0x75AABE</span>, <span class="hljs-number">0x056A51</span>, <span class="hljs-number">0x096D46</span>,<br>            <span class="hljs-comment">/*1971-1980*/</span><br>            <span class="hljs-number">0x54AEBB</span>, <span class="hljs-number">0x04AD4F</span>, <span class="hljs-number">0x0A4D43</span>, <span class="hljs-number">0x4D26B7</span>, <span class="hljs-number">0x0D254B</span>, <span class="hljs-number">0x8D52BF</span>, <span class="hljs-number">0x0B5452</span>, <span class="hljs-number">0x0B6A47</span>, <span class="hljs-number">0x696D3C</span>, <span class="hljs-number">0x095B50</span>,<br>            <span class="hljs-comment">/*1981-1990*/</span><br>            <span class="hljs-number">0x049B45</span>, <span class="hljs-number">0x4A4BB9</span>, <span class="hljs-number">0x0A4B4D</span>, <span class="hljs-number">0xAB25C2</span>, <span class="hljs-number">0x06A554</span>, <span class="hljs-number">0x06D449</span>, <span class="hljs-number">0x6ADA3D</span>, <span class="hljs-number">0x0AB651</span>, <span class="hljs-number">0x095746</span>, <span class="hljs-number">0x5497BB</span>,<br>            <span class="hljs-comment">/*1991-2000*/</span><br>            <span class="hljs-number">0x04974F</span>, <span class="hljs-number">0x064B44</span>, <span class="hljs-number">0x36A537</span>, <span class="hljs-number">0x0EA54A</span>, <span class="hljs-number">0x86B2BF</span>, <span class="hljs-number">0x05AC53</span>, <span class="hljs-number">0x0AB647</span>, <span class="hljs-number">0x5936BC</span>, <span class="hljs-number">0x092E50</span>, <span class="hljs-number">0x0C9645</span>,<br>            <span class="hljs-comment">/*2001-2010*/</span><br>            <span class="hljs-number">0x4D4AB8</span>, <span class="hljs-number">0x0D4A4C</span>, <span class="hljs-number">0x0DA541</span>, <span class="hljs-number">0x25AAB6</span>, <span class="hljs-number">0x056A49</span>, <span class="hljs-number">0x7AADBD</span>, <span class="hljs-number">0x025D52</span>, <span class="hljs-number">0x092D47</span>, <span class="hljs-number">0x5C95BA</span>, <span class="hljs-number">0x0A954E</span>,<br>            <span class="hljs-comment">/*2011-2020*/</span><br>            <span class="hljs-number">0x0B4A43</span>, <span class="hljs-number">0x4B5537</span>, <span class="hljs-number">0x0AD54A</span>, <span class="hljs-number">0x955ABF</span>, <span class="hljs-number">0x04BA53</span>, <span class="hljs-number">0x0A5B48</span>, <span class="hljs-number">0x652BBC</span>, <span class="hljs-number">0x052B50</span>, <span class="hljs-number">0x0A9345</span>, <span class="hljs-number">0x474AB9</span>,<br>            <span class="hljs-comment">/*2021-2030*/</span><br>            <span class="hljs-number">0x06AA4C</span>, <span class="hljs-number">0x0AD541</span>, <span class="hljs-number">0x24DAB6</span>, <span class="hljs-number">0x04B64A</span>, <span class="hljs-number">0x6a573D</span>, <span class="hljs-number">0x0A4E51</span>, <span class="hljs-number">0x0D2646</span>, <span class="hljs-number">0x5E933A</span>, <span class="hljs-number">0x0D534D</span>, <span class="hljs-number">0x05AA43</span>,<br>            <span class="hljs-comment">/*2031-2040*/</span><br>            <span class="hljs-number">0x36B537</span>, <span class="hljs-number">0x096D4B</span>, <span class="hljs-number">0xB4AEBF</span>, <span class="hljs-number">0x04AD53</span>, <span class="hljs-number">0x0A4D48</span>, <span class="hljs-number">0x6D25BC</span>, <span class="hljs-number">0x0D254F</span>, <span class="hljs-number">0x0D5244</span>, <span class="hljs-number">0x5DAA38</span>, <span class="hljs-number">0x0B5A4C</span>,<br>            <span class="hljs-comment">/*2041-2050*/</span><br>            <span class="hljs-number">0x056D41</span>, <span class="hljs-number">0x24ADB6</span>, <span class="hljs-number">0x049B4A</span>, <span class="hljs-number">0x7A4BBE</span>, <span class="hljs-number">0x0A4B51</span>, <span class="hljs-number">0x0AA546</span>, <span class="hljs-number">0x5B52BA</span>, <span class="hljs-number">0x06D24E</span>, <span class="hljs-number">0x0ADA42</span>, <span class="hljs-number">0x355B37</span>,<br>            <span class="hljs-comment">/*2051-2060*/</span><br>            <span class="hljs-number">0x09374B</span>, <span class="hljs-number">0x8497C1</span>, <span class="hljs-number">0x049753</span>, <span class="hljs-number">0x064B48</span>, <span class="hljs-number">0x66A53C</span>, <span class="hljs-number">0x0EA54F</span>, <span class="hljs-number">0x06AA44</span>, <span class="hljs-number">0x4AB638</span>, <span class="hljs-number">0x0AAE4C</span>, <span class="hljs-number">0x092E42</span>,<br>            <span class="hljs-comment">/*2061-2070*/</span><br>            <span class="hljs-number">0x3C9735</span>, <span class="hljs-number">0x0C9649</span>, <span class="hljs-number">0x7D4ABD</span>, <span class="hljs-number">0x0D4A51</span>, <span class="hljs-number">0x0DA545</span>, <span class="hljs-number">0x55AABA</span>, <span class="hljs-number">0x056A4E</span>, <span class="hljs-number">0x0A6D43</span>, <span class="hljs-number">0x452EB7</span>, <span class="hljs-number">0x052D4B</span>,<br>            <span class="hljs-comment">/*2071-2080*/</span><br>            <span class="hljs-number">0x8A95BF</span>, <span class="hljs-number">0x0A9553</span>, <span class="hljs-number">0x0B4A47</span>, <span class="hljs-number">0x6B553B</span>, <span class="hljs-number">0x0AD54F</span>, <span class="hljs-number">0x055A45</span>, <span class="hljs-number">0x4A5D38</span>, <span class="hljs-number">0x0A5B4C</span>, <span class="hljs-number">0x052B42</span>, <span class="hljs-number">0x3A93B6</span>,<br>            <span class="hljs-comment">/*2081-2090*/</span><br>            <span class="hljs-number">0x069349</span>, <span class="hljs-number">0x7729BD</span>, <span class="hljs-number">0x06AA51</span>, <span class="hljs-number">0x0AD546</span>, <span class="hljs-number">0x54DABA</span>, <span class="hljs-number">0x04B64E</span>, <span class="hljs-number">0x0A5743</span>, <span class="hljs-number">0x452738</span>, <span class="hljs-number">0x0D264A</span>, <span class="hljs-number">0x8E933E</span>,<br>            <span class="hljs-comment">/*2091-2099*/</span><br>            <span class="hljs-number">0x0D5252</span>, <span class="hljs-number">0x0DAA47</span>, <span class="hljs-number">0x66B53B</span>, <span class="hljs-number">0x056D4F</span>, <span class="hljs-number">0x04AE45</span>, <span class="hljs-number">0x4A4EB9</span>, <span class="hljs-number">0x0A4D4C</span>, <span class="hljs-number">0x0D1541</span>, <span class="hljs-number">0x2D92B5</span><br>    &#125;;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将农历日期转换为公历日期</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> year                               农历年份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> month                              农历月</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> monthDay                   农历日</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isLeapMonth        该月是否是闰月</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回农历日期对应的公历日期，year0, month1, day2.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] lunarToSolar(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> monthDay, <span class="hljs-keyword">boolean</span> isLeapMonth) &#123;<br> <br>        <span class="hljs-keyword">int</span> dayOffset;<br> <br>        <span class="hljs-keyword">int</span> leapMonth;<br> <br>        <span class="hljs-keyword">int</span> i;<br> <br>        <span class="hljs-keyword">if</span> (year &lt; MIN_YEAR || year &gt; MAX_YEAR || month &lt; <span class="hljs-number">1</span> || month &gt; <span class="hljs-number">12</span><br>                || monthDay &lt; <span class="hljs-number">1</span> || monthDay &gt; <span class="hljs-number">30</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    <span class="hljs-string">&quot;Illegal lunar date, must be like that:\n\t&quot;</span> +<br>                            <span class="hljs-string">&quot;year : 1900~2099\n\t&quot;</span> +<br>                            <span class="hljs-string">&quot;month : 1~12\n\t&quot;</span> +<br>                            <span class="hljs-string">&quot;day : 1~30&quot;</span>);<br>        &#125;<br>        dayOffset = (LUNAR_INFO[year - MIN_YEAR] &amp; <span class="hljs-number">0x001F</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (((LUNAR_INFO[year - MIN_YEAR] &amp; <span class="hljs-number">0x0060</span>) &gt;&gt; <span class="hljs-number">5</span>) == <span class="hljs-number">2</span>) &#123;<br>            dayOffset += <span class="hljs-number">31</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; month; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((LUNAR_INFO[year - MIN_YEAR] &amp; (<span class="hljs-number">0x80000</span> &gt;&gt; (i - <span class="hljs-number">1</span>))) == <span class="hljs-number">0</span>) &#123;<br>                dayOffset += <span class="hljs-number">29</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dayOffset += <span class="hljs-number">30</span>;<br>            &#125;<br>        &#125;<br>        dayOffset += monthDay;<br> <br>        leapMonth = (LUNAR_INFO[year - MIN_YEAR] &amp; <span class="hljs-number">0xf00000</span>) &gt;&gt; <span class="hljs-number">20</span>;<br> <br>        <span class="hljs-comment">// 这一年有闰月</span><br> <br>        <span class="hljs-keyword">if</span> (leapMonth != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (month &gt; leapMonth || (month == leapMonth &amp;&amp; isLeapMonth)) &#123;<br> <br>                <span class="hljs-keyword">if</span> ((LUNAR_INFO[year - MIN_YEAR] &amp; (<span class="hljs-number">0x80000</span> &gt;&gt; (month - <span class="hljs-number">1</span>))) == <span class="hljs-number">0</span>) &#123;<br>                    dayOffset += <span class="hljs-number">29</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dayOffset += <span class="hljs-number">30</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (dayOffset &gt; <span class="hljs-number">366</span> || (year % <span class="hljs-number">4</span> != <span class="hljs-number">0</span> &amp;&amp; dayOffset &gt; <span class="hljs-number">365</span>)) &#123;<br>            year += <span class="hljs-number">1</span>;<br> <br>            <span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">1</span>) &#123;<br>                dayOffset -= <span class="hljs-number">366</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dayOffset -= <span class="hljs-number">365</span>;<br>            &#125;<br>        &#125;<br> <br>        <span class="hljs-keyword">int</span>[] solarInfo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> iPos = DAYS_BEFORE_MONTH[i];<br> <br>            <span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">2</span>) &#123;<br> <br>                iPos += <span class="hljs-number">1</span>;<br>            &#125;<br> <br>            <span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; i == <span class="hljs-number">2</span> &amp;&amp; iPos + <span class="hljs-number">1</span> == dayOffset) &#123;<br> <br>                solarInfo[<span class="hljs-number">1</span>] = i;<br> <br>                solarInfo[<span class="hljs-number">2</span>] = dayOffset - <span class="hljs-number">31</span>;<br> <br>                <span class="hljs-keyword">break</span>;<br> <br>            &#125;<br>            <span class="hljs-keyword">if</span> (iPos &gt;= dayOffset) &#123;<br>                solarInfo[<span class="hljs-number">1</span>] = i;<br>                iPos = DAYS_BEFORE_MONTH[i - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">2</span>) &#123;<br>                    iPos += <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dayOffset &gt; iPos) &#123;<br>                    solarInfo[<span class="hljs-number">2</span>] = dayOffset - iPos;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dayOffset == iPos) &#123;<br>                    <span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; i == <span class="hljs-number">2</span>) &#123;<br>                        solarInfo[<span class="hljs-number">2</span>] = DAYS_BEFORE_MONTH[i] - DAYS_BEFORE_MONTH[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        solarInfo[<span class="hljs-number">2</span>] = DAYS_BEFORE_MONTH[i] - DAYS_BEFORE_MONTH[i - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    solarInfo[<span class="hljs-number">2</span>] = dayOffset;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        solarInfo[<span class="hljs-number">0</span>] = year;<br>        <span class="hljs-keyword">return</span> solarInfo;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将公历日期转换为农历日期，且标识是否是闰月</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> year</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> month</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> monthDay</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回公历日期对应的农历日期，year0，month1，day2，leap3</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] solarToLunar(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> monthDay) &#123;<br>        <span class="hljs-keyword">int</span>[] lunarDate = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br>        Date baseDate = <span class="hljs-keyword">new</span> GregorianCalendar(<span class="hljs-number">1900</span>, <span class="hljs-number">0</span>, <span class="hljs-number">31</span>).getTime();<br>        Date objDate = <span class="hljs-keyword">new</span> GregorianCalendar(year, month - <span class="hljs-number">1</span>, monthDay).getTime();<br>        <span class="hljs-keyword">int</span> offset = (<span class="hljs-keyword">int</span>) ((objDate.getTime() - baseDate.getTime()) / <span class="hljs-number">86400000L</span>);<br>        <span class="hljs-comment">// 用offset减去每农历年的天数计算当天是农历第几天</span><br>        <span class="hljs-comment">// iYear最终结果是农历的年份, offset是当年的第几天</span><br>        <span class="hljs-keyword">int</span> iYear, daysOfYear = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (iYear = MIN_YEAR; iYear &lt;= MAX_YEAR &amp;&amp; offset &gt; <span class="hljs-number">0</span>; iYear++) &#123;<br>            daysOfYear = daysInLunarYear(iYear);<br>            offset -= daysOfYear;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>            offset += daysOfYear;<br>            iYear--;<br>        &#125;<br>        <span class="hljs-comment">// 农历年份</span><br>        lunarDate[<span class="hljs-number">0</span>] = iYear;<br>        <span class="hljs-keyword">int</span> leapMonth = leapMonth(iYear);<br>        <span class="hljs-comment">// 闰哪个月,1-12</span><br>        <span class="hljs-keyword">boolean</span> isLeap = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 用当年的天数offset,逐个减去每月（农历）的天数，求出当天是本月的第几天</span><br>        <span class="hljs-keyword">int</span> iMonth, daysOfMonth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (iMonth = <span class="hljs-number">1</span>; iMonth &lt;= <span class="hljs-number">13</span> &amp;&amp; offset &gt; <span class="hljs-number">0</span>; iMonth++) &#123;<br>            daysOfMonth = daysInLunarMonth(iYear, iMonth);<br>            offset -= daysOfMonth;<br>        &#125;<br>        <span class="hljs-comment">// 当前月超过闰月，要校正</span><br>        <span class="hljs-keyword">if</span> (leapMonth != <span class="hljs-number">0</span> &amp;&amp; iMonth &gt; leapMonth) &#123;<br>            --iMonth;<br>            <span class="hljs-keyword">if</span> (iMonth == leapMonth) &#123;<br>                isLeap = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// offset小于0时，也要校正</span><br>        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>            offset += daysOfMonth;<br>            --iMonth;<br>        &#125;<br>        lunarDate[<span class="hljs-number">1</span>] = iMonth;<br>        lunarDate[<span class="hljs-number">2</span>] = offset + <span class="hljs-number">1</span>;<br>        lunarDate[<span class="hljs-number">3</span>] = isLeap ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> lunarDate;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 传回农历year年month月的总天数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> year   要计算的年份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> month        要计算的月</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 传回天数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">daysInMonth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> daysInMonth(year, month, <span class="hljs-keyword">false</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 传回农历year年month月的总天数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> year   要计算的年份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> month        要计算的月</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> leap   当月是否是闰月</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 传回天数，如果闰月是错误的，返回0.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">daysInMonth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">boolean</span> leap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> leapMonth = leapMonth(year);<br>        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果本年有闰月且month大于闰月时，需要校正</span><br>        <span class="hljs-keyword">if</span> (leapMonth != <span class="hljs-number">0</span> &amp;&amp; month &gt; leapMonth) &#123;<br>            offset = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不考虑闰月</span><br>        <span class="hljs-keyword">if</span> (!leap) &#123;<br>            <span class="hljs-keyword">return</span> daysInLunarMonth(year, month + offset);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 传入的闰月是正确的月份</span><br>            <span class="hljs-keyword">if</span> (leapMonth != <span class="hljs-number">0</span> &amp;&amp; leapMonth == month) &#123;<br>                <span class="hljs-keyword">return</span> daysInLunarMonth(year, month + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 传回农历 year年的总天数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> year 将要计算的年份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回传入年份的总天数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">daysInLunarYear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i, sum = <span class="hljs-number">348</span>;<br>        <span class="hljs-keyword">if</span> (leapMonth(year) != <span class="hljs-number">0</span>) &#123;<br>            sum = <span class="hljs-number">377</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> monthInfo = LUNAR_INFO[year - MIN_YEAR] &amp; <span class="hljs-number">0x0FFF80</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0x80000</span>; i &gt; <span class="hljs-number">0x7</span>; i &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((monthInfo &amp; i) != <span class="hljs-number">0</span>) &#123;<br>                sum += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 传回农历 year年month月的总天数，总共有13个月包括闰月</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> year  将要计算的年份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> month 将要计算的月份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 传回农历 year年month月的总天数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">daysInLunarMonth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((LUNAR_INFO[year - MIN_YEAR] &amp; (<span class="hljs-number">0x100000</span> &gt;&gt; month)) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">29</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 传回农历 year年闰哪个月 1-12 , 没闰传回 0</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> year 将要计算的年份</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 传回农历 year年闰哪个月1-12, 没闰传回 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leapMonth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((LUNAR_INFO[year - MIN_YEAR] &amp; <span class="hljs-number">0xF00000</span>)) &gt;&gt; <span class="hljs-number">20</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Arrays.toString(solarToLunar(<span class="hljs-number">2019</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)));<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>在做项目的时候遇到一个业务需要对图片进行旋转，于是找到一个工具类，亲测有效；在此与大家共享，需要用时可以直接用哈！ 一、旋转工具类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> zh.test.utils;<br> <br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 图片旋转工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RotateImage</span> </span>&#123;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对图片进行旋转</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> src   被旋转图片</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> angel 旋转角度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 旋转后的图片</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BufferedImage <span class="hljs-title">Rotate</span><span class="hljs-params">(Image src, <span class="hljs-keyword">int</span> angel)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> src_width = src.getWidth(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">int</span> src_height = src.getHeight(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 计算旋转后图片的尺寸</span><br>        Rectangle rect_des = CalcRotatedSize(<span class="hljs-keyword">new</span> Rectangle(<span class="hljs-keyword">new</span> Dimension(<br>                src_width, src_height)), angel);<br>        BufferedImage res = <span class="hljs-keyword">null</span>;<br>        res = <span class="hljs-keyword">new</span> BufferedImage(rect_des.width, rect_des.height,<br>                BufferedImage.TYPE_INT_RGB);<br>        Graphics2D g2 = res.createGraphics();<br>        <span class="hljs-comment">// 进行转换</span><br>        g2.translate((rect_des.width - src_width) / <span class="hljs-number">2</span>,<br>                (rect_des.height - src_height) / <span class="hljs-number">2</span>);<br>        g2.rotate(Math.toRadians(angel), src_width / <span class="hljs-number">2</span>, src_height / <span class="hljs-number">2</span>);<br> <br>        g2.drawImage(src, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算旋转后的图片</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> src   被旋转的图片</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> angel 旋转角度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 旋转后的图片</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Rectangle <span class="hljs-title">CalcRotatedSize</span><span class="hljs-params">(Rectangle src, <span class="hljs-keyword">int</span> angel)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果旋转的角度大于90度做相应的转换</span><br>        <span class="hljs-keyword">if</span> (angel &gt;= <span class="hljs-number">90</span>) &#123;<br>            <span class="hljs-keyword">if</span> (angel / <span class="hljs-number">90</span> % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">int</span> temp = src.height;<br>                src.height = src.width;<br>                src.width = temp;<br>            &#125;<br>            angel = angel % <span class="hljs-number">90</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">double</span> r = Math.sqrt(src.height * src.height + src.width * src.width) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">double</span> len = <span class="hljs-number">2</span> * Math.sin(Math.toRadians(angel) / <span class="hljs-number">2</span>) * r;<br>        <span class="hljs-keyword">double</span> angel_alpha = (Math.PI - Math.toRadians(angel)) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">double</span> angel_dalta_width = Math.atan((<span class="hljs-keyword">double</span>) src.height / src.width);<br>        <span class="hljs-keyword">double</span> angel_dalta_height = Math.atan((<span class="hljs-keyword">double</span>) src.width / src.height);<br> <br>        <span class="hljs-keyword">int</span> len_dalta_width = (<span class="hljs-keyword">int</span>) (len * Math.cos(Math.PI - angel_alpha<br>                - angel_dalta_width));<br>        <span class="hljs-keyword">int</span> len_dalta_height = (<span class="hljs-keyword">int</span>) (len * Math.cos(Math.PI - angel_alpha<br>                - angel_dalta_height));<br>        <span class="hljs-keyword">int</span> des_width = src.width + len_dalta_width * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> des_height = src.height + len_dalta_height * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-keyword">new</span> Dimension(des_width, des_height));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二、调用工具类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> zh.test.controller;<br> <br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><span class="hljs-keyword">import</span> zh.test.utils.RotateImage;<br> <br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.File;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试图片旋转</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br> <br>    <span class="hljs-meta">@RequestMapping(method = RequestMethod.POST)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testImgRotate</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        BufferedImage src = ImageIO.read(multipartFile.getInputStream());<br>        <span class="hljs-comment">//顺时针旋转90度</span><br>        BufferedImage des1 = RotateImage.Rotate(src, <span class="hljs-number">90</span>);<br>        ImageIO.write(des1, <span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;e:/90.jpg&quot;</span>));<br>        <span class="hljs-comment">//顺时针旋转180度</span><br>        BufferedImage des2 = RotateImage.Rotate(src, <span class="hljs-number">180</span>);<br>        ImageIO.write(des2, <span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;c:/180.jpg&quot;</span>));<br>        <span class="hljs-comment">//顺时针旋转270度</span><br>        BufferedImage des3 = RotateImage.Rotate(src, <span class="hljs-number">270</span>);<br>        ImageIO.write(des3, <span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;c:/270.jpg&quot;</span>));<br> <br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea取消警告</title>
    <link href="/blog/2021/01/11/idea%E5%8F%96%E6%B6%88%E8%AD%A6%E5%91%8A/"/>
    <url>/blog/2021/01/11/idea%E5%8F%96%E6%B6%88%E8%AD%A6%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>右边那五颜六色的一堆东西 是警告 如果是报错还是会提醒的哦<br>打开设置 搜索 inspections<br><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/BC0B365A-0200-45E5-B6E9-0DD5A2E557DA_1564123100369.png" alt="BC0B365A-0200-45E5-B6E9-0DD5A2E557DA"></p><h1 id="java判断中文汉字工具类"><a href="#java判断中文汉字工具类" class="headerlink" title="java判断中文汉字工具类"></a>java判断中文汉字工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wlkj.util;<br><br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">import</span> net.sourceforge.pinyin4j.PinyinHelper;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChineseUtil</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断中文字符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isChinese</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123;<br>    Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);<br>    <span class="hljs-keyword">if</span>(ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS ||<br>       ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS ||<br>       ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A ||<br>       ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B ||<br>       ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION ||<br>       ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS ||<br>       ub == Character.UnicodeBlock.GENERAL_PUNCTUATION)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 包含中文字符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsChinese</span><span class="hljs-params">(String str)</span></span>&#123;<br>    <span class="hljs-keyword">char</span>[] ch = str.toCharArray();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : ch)&#123;<br>        <span class="hljs-keyword">if</span>(isChinese(c))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 是否中文（非标点符号）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isChineseWord</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br><span class="hljs-keyword">char</span>[] ch = &#123;c&#125;;<br>Pattern pattern = Pattern.compile(<span class="hljs-string">&quot;([\u4E00-\uFA29]|[\uE7C7-\uE7F3])&quot;</span>);<br>Matcher matcher = pattern.matcher(<span class="hljs-keyword">new</span> String(ch));<br><span class="hljs-keyword">return</span> matcher.find();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 包含汉字（非标点符号）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsChineseWords</span><span class="hljs-params">(String name)</span> </span>&#123;<br>Pattern pattern = Pattern.compile(<span class="hljs-string">&quot;^.*([\u4E00-\uFA29]|[\uE7C7-\uE7F3])+.*$&quot;</span>);<br>Matcher matcher = pattern.matcher(name);<br><span class="hljs-keyword">return</span> matcher.find();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换成拼音字母缩写</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> abbr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toPinyinAbbr</span><span class="hljs-params">(String str)</span></span>&#123;<br>String abbr = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : str.toCharArray())&#123;<br><span class="hljs-keyword">if</span>(ChineseUtil.isChineseWord(c))&#123;<br>abbr += PinyinHelper.toHanyuPinyinStringArray(c)[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase();<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> abbr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(isChinese(<span class="hljs-string">&#x27;め&#x27;</span>));<span class="hljs-comment">// false</span><br>System.out.println(isChineseWord(<span class="hljs-string">&#x27;我&#x27;</span>));<span class="hljs-comment">// true</span><br>System.out.println(containsChinese(<span class="hljs-string">&quot;a我b&quot;</span>));<span class="hljs-comment">// true</span><br>System.out.println(containsChineseWords(<span class="hljs-string">&quot;a，b&quot;</span>)); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql系统知识梳理</title>
    <link href="/blog/2021/01/10/Mysql%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/blog/2021/01/10/Mysql%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>1 数据库分类</p><p>　　MySQL Oracle redis</p><p>2 MySQL 存储引擎有哪些</p><p>　　ENGINE=InnoDB 提供事务安全表，支持外键。</p><p>　　MyISAM</p><p>　　Memory数据存入内存中，如果内存出现异常或事重启关机，所有数据都会消失</p><p>3 事务</p><p>　　概念：逻辑上的一组sql语句，组成这组操作的sql语句，要么成功，要么失败。</p><p>3.1 事务四大特性ACID</p><p>　　原子性(Atomicity)：事务是一个不可分割的单位，事务中的sql语句，要么全都发生，要么都不发生。</p><p>　　一致性(Consistency)：事务发生前后，数据的完整性必须保持一致。</p><p>　　隔离性(Isolation)：当并发访问数据库的时候，一个正在执行的事务在执行完前，对于其他的会话是不可见的，多个并发的事务之间的数据库相互隔离。</p><p>　　持久性(Durability)：一个事务一旦被提交，数据库中的数据改变就是持久性的。如果出了错误也不能撤销。</p><p>3.2 事务隔离级别</p><p>　　对于同时运行的几个事务，当这些事务同时访问数据库时，如果不采取隔离措施就会导致各种并发问题。由此引出隔离级别的概念，总有4个，由低到高，可逐步解决脏读，不可重复读，幻读等问题。</p><p>　　Default spring：默认隔离级别，使用数据库默认的事务隔离级别</p><p>　　read_uncommitied：读未提交，一个会话可以读取其他事务未提交的更新结果，一旦这个事务被回滚了，导致这个会话的结果不正确了。</p><p>　　read_commited：读已提交，一个会话只能读取其他事务已经提交的更新结果，否则，等待。但是其他会话可以修改这个事务中被读取的记录，而不必等待事务结束。导致了，一个事务中两个相同的读取操作，其结果可能不同。</p><p>　　repeatable_read：重复读取，在数据读取出来后加锁，直到这个事务执行结束。</p><p>　　serlalizable：串行化，不管多少事务，只有执行完一个事务的所有子事务后，才可以执行另外一个事务里的所有子事务。</p><p>3.3 数据库设置的隔离级别read_commited</p><p>　　可以避免脏读，且具有较好的并发性能，可能出现的问题场景，可以使用悲观锁或乐观锁控制。</p><p>4 悲观锁和乐观锁，以及使用场景</p><p>　　悲观排他后，不能修改数据，即在数据被操作的时候，锁定数据不被访问。</p><p>　　乐观排他后，可以修改数据，即假设数据一般情况下不会造成冲突。</p><p>5 如何实现分页</p><p>　　使用sql语句关键字limit</p><p>6 数据库三大范式</p><p>1NF：对属性的原子性约束，要求属性具有原子性，不可再分解。</p><p>2NF：对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性。</p><p>3NF：对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</p><p>7 Mysql有哪些索引：fulltext、hash、btree、rtree</p><p>8 什么时候该建立索引</p><p>　　1）表的主键、外键必须有索引</p><p>　　2）数据量超过300的表应该有索引</p><p>　　3）经常与其他表进行连接的表，在连接字段上应该建立索引</p><p>　　4）经常出现在where子句中的字段，特别是大表的字段，应该建立索引</p><p>9 sql关键字执行顺序：select-&gt;from-&gt;where-&gt;group by-&gt;having-&gt;order by</p><p>10 explain包含哪些列</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7Nginx的SSl证书安装</title>
    <link href="/blog/2021/01/10/Centos7Nginx%E7%9A%84SSl%E8%AF%81%E4%B9%A6%E5%AE%89%E8%A3%85/"/>
    <url>/blog/2021/01/10/Centos7Nginx%E7%9A%84SSl%E8%AF%81%E4%B9%A6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>注意路径</p><p>可见，nginx缺少SSL模块支持。这是因为我当年建站的时候根本没用到SSL啊，所以以前编译nginx的时候使用了不带SSL支持的默认编译参数。 为了让nginx添加SSL模块，只能重新编译它。但是，如何在现有nginx的基础上，添加一个支持SSL的编译参数呢？首先要找回原来编译nginx时的编译参数，然后再加上支持SSL的编译参数。如果不这样做，那么编译出来的nginx可能就会有问题（某些旧的编译参数被去掉了，使得nginx不能支持某些功能）。 所以先查看旧的nginx的编译参数：nginx -V 大写V 输出的信息中，最重要的一句是： configure arguments: –prefix=/usr/local/nginx 可见，当时我编译nginx的时候，只是指定了一个安装路径，没有其他特殊的编译参数。那么现在事情就好办了：回到nginx的源码目录下，加上SSL支持参数重新编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">./configure --prefix=/usr/local/nginx --with-http_ssl_module<br>make<br></code></pre></td></tr></table></figure><p>注意，此时千万不能手快直接 make install！因为我原来的nginx还有一堆的配置文件，不能被覆盖。我们应该只覆盖编译出来的nginx可执行程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">cp /usr/local/nginx/sbin/nginx ~/<br>cp objs/nginx /usr/local/nginx/sbin/<br></code></pre></td></tr></table></figure><p>其中，objs/nginx 是新编译出来的nginx可执行程序。 覆盖之后，再尝试重新启动nginx，就没有问题了。</p><p>接下来安装证书<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190724-133740@2x_1563946759206.png" alt="WX20190724-133740@2x">一个证书 针对一个域名<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190724-133807@2x_1563946759366.png" alt="WX20190724-133807@2x">进入nginx 目录下创建一个 mkdir cert 将两个文件上传到这个目录下 建议将文件重命名为 zhzq.pem 和 zhzq.key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">编辑 vim nginx.conf<br> <br>server &#123;<br>    listen <span class="hljs-number">80</span>;<br>    listen <span class="hljs-number">443</span> ssl;<br>    server_name ; 你的域名<br>    ssl off;<br>    ssl_certificate ../cert/zhzq.pem;<br>    ssl_certificate_key ../cert/zhzq.key;<br>    ssl_session_timeout 5m;<br>    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;<br>    ssl_protocols TLSv1 TLSv1<span class="hljs-number">.1</span> TLSv1<span class="hljs-number">.2</span>;<br>    ssl_prefer_server_ciphers on;<br>  <br>&#125;<br> <br></code></pre></td></tr></table></figure><p>重新载入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">../sbin/nginx -s reload<br># 如果上面的命令不起作用，也可以重启<br>../sbin/nginx -s stop<br>../sbin/nginx<br></code></pre></td></tr></table></figure><p>https 443 开放对应的端口 访问就可以了</p>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java将PDF转为Word、图片、SVG、XPS、Html、PDF。</title>
    <link href="/blog/2021/01/10/java%E5%B0%86PDF%E8%BD%AC%E4%B8%BAWord%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81SVG%E3%80%81XPS%E3%80%81Html%E3%80%81PDF%E3%80%82/"/>
    <url>/blog/2021/01/10/java%E5%B0%86PDF%E8%BD%AC%E4%B8%BAWord%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81SVG%E3%80%81XPS%E3%80%81Html%E3%80%81PDF%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>本文将介绍通过Java编程来实现PDF文档转换的方法。包括：</p><ol><li><p>PDF转为Word</p></li><li><p>PDF转为图片</p></li><li><p>PDF转为Html</p></li><li><p>PDF转为SVG</p><p>4.1 将PDF每一页转为单个的SVG</p><p>4.2 将一个包含多页的PDF文档转为一个SVG</p></li><li><p>PDF转为XPS</p></li><li><p>PDF转为PDF/A</p></li></ol><p>使用工具：Free Spire.PDF for Java（免费版）</p><p>Jar文件获取及导入：</p><p>方法1：通过官网下载<a href="https://www.e-iceblue.cn/Downloads/Free-Spire-PDF-JAVA.html">下载jar包</a>。下载后，解压文件，并将lib文件夹下的Spire.Pdf.jar文件导入Java程序。</p><p>方法2：可通过maven仓库安装导入。参考<a href="https://www.e-iceblue.cn/licensing/install-spirepdf-for-java-from-maven-repository.html">导入方法</a></p><h2 id="PDF-转Word"><a href="#PDF-转Word" class="headerlink" title="PDF 转Word"></a>PDF 转Word</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PdfDocument pdf = <span class="hljs-keyword">new</span> PdfDocument(<span class="hljs-string">&quot;test.pdf&quot;</span>);<br>pdf.saveToFile(<span class="hljs-string">&quot;ToWord.docx&quot;</span>,FileFormat.DOCX);<br></code></pre></td></tr></table></figure><h2 id="PDF转图片"><a href="#PDF转图片" class="headerlink" title="PDF转图片"></a>PDF转图片</h2><p>支持的图片格式包括Jpeg, Jpg, Png, Bmp, Tiff, Gif, EMF等。这里以保存为Png格式为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.spire.pdf.*;<br> <br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFtoimage</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br> <br>PdfDocument pdf = <span class="hljs-keyword">new</span> PdfDocument(<span class="hljs-string">&quot;test.pdf&quot;</span>);<br>BufferedImage image;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; pdf.getPages().getCount();i++)&#123;<br>    image = pdf.saveAsImage(i);<br>    File file = <span class="hljs-keyword">new</span> File( String.format(<span class="hljs-string">&quot;ToImage-img-%d.png&quot;</span>, i));<br>    ImageIO.write(image, <span class="hljs-string">&quot;PNG&quot;</span>, file);<br>&#125;<br>pdf.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PDF转Html"><a href="#PDF转Html" class="headerlink" title="PDF转Html"></a>PDF转Html</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PdfDocument pdf = <span class="hljs-keyword">new</span> PdfDocument(<span class="hljs-string">&quot;test.pdf&quot;</span>);<br>pdf.saveToFile(<span class="hljs-string">&quot;ToHTML.html&quot;</span>, FileFormat.HTML);<br></code></pre></td></tr></table></figure><h2 id="PDF转SVG"><a href="#PDF转SVG" class="headerlink" title="PDF转SVG"></a>PDF转SVG</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转为单个svg</span><br>PdfDocument pdf = <span class="hljs-keyword">new</span> PdfDocument(<span class="hljs-string">&quot;test.pdf&quot;</span>);<br>pdf.saveToFile(<span class="hljs-string">&quot;ToSVG.svg&quot;</span>, FileFormat.SVG);<br><span class="hljs-comment">//多页pdf转为一个svg</span><br>PdfDocument pdf = <span class="hljs-keyword">new</span> PdfDocument(<span class="hljs-string">&quot;sampe.pdf&quot;</span>);<br>pdf.getConvertOptions().setOutputToOneSvg(<span class="hljs-keyword">true</span>);<br>pdf.saveToFile(<span class="hljs-string">&quot;ToOneSvg.svg&quot;</span>,FileFormat.SVG);<br></code></pre></td></tr></table></figure><h2 id="PDF-转XPS"><a href="#PDF-转XPS" class="headerlink" title="PDF 转XPS"></a>PDF 转XPS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PdfDocument pdf = <span class="hljs-keyword">new</span> PdfDocument(<span class="hljs-string">&quot;test.pdf&quot;</span>);<br>pdf.saveToFile(<span class="hljs-string">&quot;ToXPS.xps&quot;</span>, FileFormat.XPS);<br></code></pre></td></tr></table></figure><h2 id="PDF转PDF-A"><a href="#PDF转PDF-A" class="headerlink" title="PDF转PDF/A"></a>PDF转PDF/A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.spire.pdf.*;<br><span class="hljs-keyword">import</span> com.spire.pdf.graphics.PdfMargins;<br><span class="hljs-keyword">import</span> java.awt.geom.Dimension2D;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDFtoPDFA</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span></span>&#123;<br>        <span class="hljs-comment">//加载测试文档</span><br>        PdfDocument pdf = <span class="hljs-keyword">new</span> PdfDocument();<br>        pdf.loadFromFile(<span class="hljs-string">&quot;test.pdf&quot;</span>);<br> <br>        <span class="hljs-comment">//转换为Pdf_A_1_B格式</span><br>        PdfNewDocument newDoc = <span class="hljs-keyword">new</span> PdfNewDocument();<br>        newDoc.setConformance(PdfConformanceLevel.Pdf_A_1_B);<br>        PdfPageBase page;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt; pdf.getPages().getCount();i++) &#123;<br>            page = pdf.getPages().get(i);<br>            Dimension2D size = page.getSize();<br>            PdfPageBase p = newDoc.getPages().add(size, <span class="hljs-keyword">new</span> PdfMargins(<span class="hljs-number">0</span>));<br>            page.createTemplate().draw(p, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br> <br>        <span class="hljs-comment">//保存结果文件</span><br>        newDoc.save(<span class="hljs-string">&quot;ToPDFA.pdf&quot;</span>);<br>        newDoc.close();<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://bk.cuixiaoyan.xyz/archives/PDF#pdf-%E8%BD%ACword">PDF 转Word</a><a href="https://bk.cuixiaoyan.xyz/archives/PDF#pdf%E8%BD%AC%E5%9B%BE%E7%89%87">PDF转图片</a><a href="https://bk.cuixiaoyan.xyz/archives/PDF#pdf%E8%BD%AChtml">PDF转Html</a><a href="https://bk.cuixiaoyan.xyz/archives/PDF#pdf%E8%BD%ACsvg">PDF转SVG</a><a href="https://bk.cuixiaoyan.xyz/archives/PDF#pdf-%E8%BD%ACxps">PDF 转XPS</a><a href="https://bk.cuixiaoyan.xyz/archives/PDF#pdf%E8%BD%ACpdfa">PDF转PDF/A</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决IntellijIDEA部署JavaWeb项目404问题</title>
    <link href="/blog/2021/01/10/%E8%A7%A3%E5%86%B3IntellijIDEA%E9%83%A8%E7%BD%B2JavaWeb%E9%A1%B9%E7%9B%AE404%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2021/01/10/%E8%A7%A3%E5%86%B3IntellijIDEA%E9%83%A8%E7%BD%B2JavaWeb%E9%A1%B9%E7%9B%AE404%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>首先你要保证 你和同事的版本保持一致 jdk 和 tomcat 重中之重 检查一下Project Structure的配置，首先是project：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2_1563416756399.png" alt="2">Modules-Sources如下图：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/3_1563416756457.png" alt="3">Modules-Paths中没什么需要特别修改的地方。 Modules-Dependencis如下图： 不用勾选<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/4_1563416756561.png" alt="4">Liraires如下图所示：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/5_1563416756527.png" alt="5">Facets如下，路径一定不要配错，不如一定404，如下图： 尤其是从eclipse 导入尤其注意<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/6_1563416756587.png" alt="6">最后就是Artifacts:<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/7_1563416756592.png" alt="7">项目到这就配置完了，有些路径一定要结合自己的项目来配置。</p><p>接下来配置tomcat：<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/8_1563416765804.png" alt="8">不加就是/目录<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/9_1563416765774.png" alt="9"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Postman的基础功能</title>
    <link href="/blog/2021/01/10/Postman%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/"/>
    <url>/blog/2021/01/10/Postman%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>前后端分离 接口调试工具<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/20180523232921542_1563331603653.png" alt="20180523232921542"></p><p>1.表单提交<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190717-104908@2x_1563331761801.png" alt="WX20190717-104908@2x"></p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190717-104757@2x_1563331703420.png" alt="WX20190717-104757@2x">2.json提交 下图中，当我们选择JSON(application/json) 是会自动帮我们设置 headers 为 application/json<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/2018052400054291_1563331856704.png" alt="2018052400054291"></p><h2 id="下面就是很多系统会需要登陆之后-才能模拟效果"><a href="#下面就是很多系统会需要登陆之后-才能模拟效果" class="headerlink" title="下面就是很多系统会需要登陆之后 才能模拟效果"></a>下面就是很多系统会需要登陆之后 才能模拟效果</h2><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190717-105157@2x_1563331933756.png" alt="WX20190717-105157@2x"></p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js实现下雪特效</title>
    <link href="/blog/2021/01/06/js%E5%AE%9E%E7%8E%B0%E4%B8%8B%E9%9B%AA%E7%89%B9%E6%95%88/"/>
    <url>/blog/2021/01/06/js%E5%AE%9E%E7%8E%B0%E4%B8%8B%E9%9B%AA%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p>直接上代码 放到你的script 标签中 具体效果参考博客页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>)</span>&#123;<br>$.fn.snow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>)</span>&#123;<br><span class="hljs-keyword">var</span> $flake = $(<span class="hljs-string">&#x27;&lt;div id=&quot;snowbox&quot; /&gt;&#x27;</span>).css(&#123;<span class="hljs-string">&#x27;position&#x27;</span>: <span class="hljs-string">&#x27;absolute&#x27;</span>,<span class="hljs-string">&#x27;z-index&#x27;</span>:<span class="hljs-string">&#x27;9999&#x27;</span>, <span class="hljs-string">&#x27;top&#x27;</span>: <span class="hljs-string">&#x27;-50px&#x27;</span>&#125;).html(<span class="hljs-string">&#x27;&amp;#10052;&#x27;</span>),<br>documentHeight = $(<span class="hljs-built_in">document</span>).height(),<br>documentWidth= $(<span class="hljs-built_in">document</span>).width(),<br>defaults = &#123;<br>minSize: <span class="hljs-number">10</span>,<br>maxSize: <span class="hljs-number">20</span>,<br>newOn: <span class="hljs-number">1000</span>,<br>flakeColor: <span class="hljs-string">&quot;#AFDAEF&quot;</span> <span class="hljs-comment">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span><br>&#125;,<br>options= $.extend(&#123;&#125;, defaults, options);<br><span class="hljs-keyword">var</span> interval= <span class="hljs-built_in">setInterval</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> startPositionLeft = <span class="hljs-built_in">Math</span>.random() * documentWidth - <span class="hljs-number">100</span>,<br>startOpacity = <span class="hljs-number">0.5</span> + <span class="hljs-built_in">Math</span>.random(),<br>sizeFlake = options.minSize + <span class="hljs-built_in">Math</span>.random() * options.maxSize,<br>endPositionTop = documentHeight - <span class="hljs-number">200</span>,<br>endPositionLeft = startPositionLeft - <span class="hljs-number">500</span> + <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">500</span>,<br>durationFall = documentHeight * <span class="hljs-number">10</span> + <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5000</span>;<br>$flake.clone().appendTo(<span class="hljs-string">&#x27;body&#x27;</span>).css(&#123;<br>left: startPositionLeft,<br>opacity: startOpacity,<br><span class="hljs-string">&#x27;font-size&#x27;</span>: sizeFlake,<br>color: options.flakeColor<br>&#125;).animate(&#123;<br>top: endPositionTop,<br>left: endPositionLeft,<br>opacity: <span class="hljs-number">0.2</span><br>&#125;,durationFall,<span class="hljs-string">&#x27;linear&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-built_in">this</span>).remove()<br>&#125;);<br>&#125;, options.newOn);<br>    &#125;;<br>&#125;)(jQuery);<br>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    $.fn.snow(&#123; <br>    minSize: <span class="hljs-number">5</span>, <span class="hljs-comment">/* 定义雪花最小尺寸 */</span><br>    maxSize: <span class="hljs-number">30</span>,<span class="hljs-comment">/* 定义雪花最大尺寸 */</span><br>    newOn: <span class="hljs-number">300</span>  <span class="hljs-comment">/* 定义密集程度，数字越小越密集 */</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7安装redis</title>
    <link href="/blog/2021/01/06/Centos7%E5%AE%89%E8%A3%85redis/"/>
    <url>/blog/2021/01/06/Centos7%E5%AE%89%E8%A3%85redis/</url>
    
    <content type="html"><![CDATA[<p>在CentOS和Red Hat系统中，首先添加EPEL仓库，然后更新yum源：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo yum install epel-<span class="hljs-keyword">release</span><br>sudo yum <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>然后安装Redis数据库：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum -y <span class="hljs-keyword">install</span> redis<br></code></pre></td></tr></table></figure><p>安装好后启动Redis服务即可：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> redis<br></code></pre></td></tr></table></figure><p>这里同样可以使用redis-cli进入Redis命令行模式操作。</p><p>另外，为了可以使Redis能被远程连接，需要修改配置文件，路径为/etc/redis.conf</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>redis.conf<br></code></pre></td></tr></table></figure><p>需要修改的地方： 直接搜索 requirepass</p><p>首先，注释这一行： 另外，推荐给Redis设置密码，取消注释这一行：</p><p>#requirepass foobared</p><p>foobared即当前密码，可以自行修改为 这里我设置成root</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#bind 127.0.0.1</span><br> <br><span class="hljs-attribute">requirepass</span> root <br></code></pre></td></tr></table></figure><p>然后重启Redis服务，使用的命令如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl restart redis</span><br></code></pre></td></tr></table></figure><p>ps: 其他命令</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss">systemctl start redis.service <span class="hljs-meta">#启动redis服务器</span><br> <br>systemctl <span class="hljs-keyword">stop</span> redis.service <span class="hljs-meta">#停止redis服务器</span><br> <br>systemctl restart redis.service <span class="hljs-meta">#重新启动redis服务器</span><br> <br>systemctl status redis.service <span class="hljs-meta">#获取redis服务器的运行状态</span><br> <br>systemctl <span class="hljs-keyword">enable</span> redis.service <span class="hljs-meta">#开机启动redis服务器</span><br> <br>systemctl <span class="hljs-keyword">disable</span> redis.service <span class="hljs-meta">#开机禁用redis服务器</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7安装Nginx</title>
    <link href="/blog/2021/01/06/Centos7%E5%AE%89%E8%A3%85Nginx/"/>
    <url>/blog/2021/01/06/Centos7%E5%AE%89%E8%A3%85Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx-是C语言开发的-所以要安装gcc编译器。"><a href="#Nginx-是C语言开发的-所以要安装gcc编译器。" class="headerlink" title="Nginx 是C语言开发的,所以要安装gcc编译器。"></a>Nginx 是C语言开发的,所以要安装gcc编译器。</h1><ol><li>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</li></ol><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">yum</span> <span class="hljs-comment">install</span> <span class="hljs-literal">-</span><span class="hljs-comment">y</span> <span class="hljs-comment">gcc</span><span class="hljs-literal">-</span><span class="hljs-comment">c</span>++<br></code></pre></td></tr></table></figure><ol><li>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y pcre pcre-devel<br></code></pre></td></tr></table></figure><p>3.zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">yum install -y <span class="hljs-literal">zlib</span> <span class="hljs-literal">zlib</span>-devel<br></code></pre></td></tr></table></figure><p>4.OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y openssl openssl-devel<br></code></pre></td></tr></table></figure><p>下载nginx 到一个自己创建到文件夹中 随意</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载 wget https:<span class="hljs-regexp">//</span>nginx.org<span class="hljs-regexp">/download/</span>nginx-<span class="hljs-number">1.13</span>.<span class="hljs-number">0</span>.tar.gz<br>解压 tar -zxvf nginx-<span class="hljs-number">1.10</span>.<span class="hljs-number">1</span>.tar.gz<br>进入 cd nginx-<span class="hljs-number">1.10</span>.<span class="hljs-number">1</span><br>配置 ./configure<br>编译 make<br>安装 make install<br>一次完成也可以 .<span class="hljs-regexp">/configure --prefix=/</span>opt<span class="hljs-regexp">/software/</span>nginx &amp;&amp; make install<br>配置环境变量：（注意是sbin不是bin） <br>echo <span class="hljs-string">&#x27;export PATH=$PATH:/opt/software/nginx/sbin&#x27;</span> &gt; <span class="hljs-regexp">/etc/</span>profile.d/nginx.sh<br></code></pre></td></tr></table></figure><p>环境变量生效 source /etc/profile 查看安装路径 whereis nginx</p><p>前提进入安装路径里面 sbin 目录下 cd /opt/software/nginx/sbin/ 启动 ./nginx 查看进程 ps aux|grep nginx 重启 先停止再启动（推荐）：</p><p>./nginx -s quit ./nginx</p><p>有很多时候只改配置 不用重启了就 当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，即可将配置信息在 nginx 中生效，如下：</p><p>./nginx -s reload</p><p>默认端口为80 不用加 直接外部IP 访问 就能访问到页面</p>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7安装mysql5.7</title>
    <link href="/blog/2021/01/05/Centos7%E5%AE%89%E8%A3%85mysql/"/>
    <url>/blog/2021/01/05/Centos7%E5%AE%89%E8%A3%85mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="先检查系统是否装有mysql"><a href="#先检查系统是否装有mysql" class="headerlink" title="先检查系统是否装有mysql"></a>先检查系统是否装有mysql</h2><p>rpm -qa | grep mysql 这里执行安装命令是无效的，因为centos-7默认是Mariadb，所以执行以下命令只是更新Mariadb数据库 yum install mysql 删除 yum remove mysql</p><h2 id="下载mysql的repo源"><a href="#下载mysql的repo源" class="headerlink" title="下载mysql的repo源"></a>下载mysql的repo源</h2><p>wget <a href="http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm">http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</a></p><h2 id="安装mysql-community-release-el7-5-noarch-rpm包"><a href="#安装mysql-community-release-el7-5-noarch-rpm包" class="headerlink" title="安装mysql-community-release-el7-5.noarch.rpm包"></a>安装mysql-community-release-el7-5.noarch.rpm包</h2><p>sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm</p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>sudo yum install mysql-server</p><h3 id="这里可能会报错-请注意"><a href="#这里可能会报错-请注意" class="headerlink" title="这里可能会报错 请注意"></a>这里可能会报错 请注意</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>Package: mysql-community-libs<span class="hljs-string">-5</span>.6.35<span class="hljs-string">-2</span>.el7.x86_64 (mysql56-community)<br>           Requires: libc.so.6(GLIBC_2.17)(64bit)<br><span class="hljs-keyword">Error: </span>Package: mysql-community-server<span class="hljs-string">-5</span>.6.35<span class="hljs-string">-2</span>.el7.x86_64 (mysql56-community)<br>           Requires: libc.so.6(GLIBC_2.17)(64bit)<br><span class="hljs-keyword">Error: </span>Package: mysql-community-server<span class="hljs-string">-5</span>.6.35<span class="hljs-string">-2</span>.el7.x86_64 (mysql56-community)<br>           Requires: systemd<br><span class="hljs-keyword">Error: </span>Package: mysql-community-server<span class="hljs-string">-5</span>.6.35<span class="hljs-string">-2</span>.el7.x86_64 (mysql56-community)<br>           Requires: libstdc++.so.6(GLIBCXX_3.4.15)(64bit)<br><span class="hljs-keyword">Error: </span>Package: mysql-community-client<span class="hljs-string">-5</span>.6.35<span class="hljs-string">-2</span>.el7.x86_64 (mysql56-community)<br>           Requires: libc.so.6(GLIBC_2.17)(64bit)<br> You could try using --skip-broken to work around the problem<br> You could try running: rpm -Va --nofiles --nodigest<br> <br></code></pre></td></tr></table></figure><h3 id="解决方法如下："><a href="#解决方法如下：" class="headerlink" title="解决方法如下："></a>解决方法如下：</h3><p>yum install glibc.i686 yum list libstdc++*</p><p>然后登陆 没有密码直接回车跳过 mysql -u root -p</p><h3 id="登录时有可能报这样的错：ERROR-2002-HY000-Can’t-connect-to-local-MySQL-server-through-socket-‘-var-lib-mysql-mysql-sock’-2-，原因是-var-lib-mysql的访问权限问题。下面的命令把-var-lib-mysql的拥有者改为当前用户："><a href="#登录时有可能报这样的错：ERROR-2002-HY000-Can’t-connect-to-local-MySQL-server-through-socket-‘-var-lib-mysql-mysql-sock’-2-，原因是-var-lib-mysql的访问权限问题。下面的命令把-var-lib-mysql的拥有者改为当前用户：" class="headerlink" title="登录时有可能报这样的错：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户："></a>登录时有可能报这样的错：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：</h3><p>sudo chown -R openscanner:openscanner /var/lib/mysql</p><p>重启mysql service mysqld restart</p><p>这里密码设置的为root</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mysql &gt; use mysql;<br>mysql &gt; update user set password=password(<span class="hljs-string">&#x27;root&#x27;</span>) where user=<span class="hljs-string">&#x27;root&#x27;</span>;<br>mysql &gt; <span class="hljs-keyword">exit</span>;<br> <br></code></pre></td></tr></table></figure><p>再重启 登陆mysql 加上远程访问权限 为root添加远程连接的能力。链接密码为 “root”（不包括双引号）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> root@&quot;%&quot; IDENTIFIED <span class="hljs-keyword">BY</span> &quot;root&quot;;　　<br></code></pre></td></tr></table></figure><h1 id="最后最后-非常重要-查询不区分大小写表名"><a href="#最后最后-非常重要-查询不区分大小写表名" class="headerlink" title="最后最后 非常重要 查询不区分大小写表名"></a>最后最后 非常重要 查询不区分大小写表名</h1><p>vim /etc/my.cnf 在[mysqld]节点下，加入一行： lower_case_table_names=1<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190710-151220@2x_1562742772778.png" alt="WX20190710-151220@2x">重启数据库 连接工具测试连接<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/5E7E7FBB-4F4B-4C82-83E0-F98203469C7A_1562742912107.png" alt="5E7E7FBB-4F4B-4C82-83E0-F98203469C7A"></p>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7安装tomcat9</title>
    <link href="/blog/2021/01/05/Centos7%E5%AE%89%E8%A3%85tomcat9/"/>
    <url>/blog/2021/01/05/Centos7%E5%AE%89%E8%A3%85tomcat9/</url>
    
    <content type="html"><![CDATA[<h2 id="首先检查是否安装好jdk-和配置好运行环境-还有就是名字和路径"><a href="#首先检查是否安装好jdk-和配置好运行环境-还有就是名字和路径" class="headerlink" title="首先检查是否安装好jdk 和配置好运行环境 还有就是名字和路径"></a>首先检查是否安装好jdk 和配置好运行环境 还有就是名字和路径</h2><p>输入命令：Java -version，如果显示JDK版本号，则证明已经安装了JDK。</p><p>输入命令：echo $JAVA_HOME，如果显示路径，则证明配置了环境变量。</p><p>如果没有参考 <a href="http://47.100.236.144:888/archives/centos7-jdk">安装jdk</a> tomcat 下载地址 [tomcat9]( <a href="https://pan.baidu.com/s/171M_rXvsyKNI5jAY8nwd1Q">https://pan.baidu.com/s/171M_rXvsyKNI5jAY8nwd1Q</a> 提取码: 3r8q )</p><ol><li>cd /usr/local/ 进入此目录下面 创建 mkdir tomcat</li><li>进入tomcat 文件夹下面 将云盘安装包放入 解压</li><li>tar -zxvf apache-tomcat-9.0.21.tar.gz</li><li>再进入 cd apache-tomcat-9.0.21/bin/startup.sh 启动tomcat</li><li>启动 /usr/local/tomcat/apache-tomcat-9.0.21/bin/startup.sh</li><li>关闭 /usr/local/tomcat/apache-tomcat-9.0.21/bin/shutdown.sh</li><li>重启 建议 ps -ef | grep tomcat 查询 tomcat 占用的pid</li><li>kill -9 pid 再启动</li><li>ip 加端口能访问到 就成功了</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7安装jdk</title>
    <link href="/blog/2021/01/05/Centos7%E5%AE%89%E8%A3%85jdk/"/>
    <url>/blog/2021/01/05/Centos7%E5%AE%89%E8%A3%85jdk/</url>
    
    <content type="html"><![CDATA[<p>请注意版本和文件名 是否一致 按照你的地址来!</p><ol><li>先进入 cd /usr/local/</li><li>创建一个放jdk的文件夹 mkdir java</li><li>进入 cd java</li><li>通过工具 finalshell 直接把安装包放到Java文件夹下</li><li>tar -zxv -f jdk-8u211-linux-x64.tar.gz 解压出来 [jdk 下载地址](链接: <a href="https://pan.baidu.com/s/1KjBBvHRxj4QHWkAnsIQGbQ">https://pan.baidu.com/s/1KjBBvHRxj4QHWkAnsIQGbQ</a> 提取码: n1bp 复制这段内容后打开百度网盘手机App，操作更方便哦)</li></ol><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/1562571285905_1562571317802.jpg" alt="1562571285905"></p><h2 id="上面步骤已经安装完成了-下面配置环境变量"><a href="#上面步骤已经安装完成了-下面配置环境变量" class="headerlink" title="上面步骤已经安装完成了 下面配置环境变量"></a>上面步骤已经安装完成了 下面配置环境变量</h2><p>vim /etc/profile 打开之后按键盘【i】键进入编辑模式，将下面的内容复制到底部：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">JAVA_HOME=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_211<br>PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br>CLASSPATH=<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/jre/</span>lib<span class="hljs-regexp">/ext:$JAVA_HOME/</span>lib/tools.jar<br>export PATH JAVA_HOME CLASSPATH<br> <br></code></pre></td></tr></table></figure><p>配置完成后，最重要的一步就是使文件立即生效。命令如下： source /etc/profile</p><h2 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h2><p>java -version echo $JAVA_HOME<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190708-154036@2x_1562571647150.png" alt="WX20190708-154036@2x">说明安装成功，环境变量也配置成功！</p>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器</title>
    <link href="/blog/2021/01/05/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/blog/2021/01/05/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>24岁以下自动获取学生身份 所以入手一年用来部署自己的博客和项目 经过比较几个大厂的vps 推荐阿里云 <a href="https://promotion.aliyun.com/ntms/act/campus2018.html">购买地址</a></p><p>这里我买的是第二款<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190707-140757@2x_1562479700993.png" alt="WX20190707-140757@2x">购买完成之后在控制台 查看自己的ECS 云服务器<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190707-141000@2x_1562479814153.png" alt="WX20190707-141000@2x">在网络与安全中 安全组 配置 下面还需要添加安全组 用来后面在外部访问各种端口 这里我比较懒 就直接将全部端口开放 当然这是不太安全的<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190707-141206@2x_1562480012754.png" alt="WX20190707-141206@2x"></p><p>再回到实例 加入安全组<img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/WX20190707-141549@2x_1562480182400.png" alt="WX20190707-141549@2x"></p><p>最后用远程连接工具连接上之后 就开始云服务之旅啦</p>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis经典9种设计模式</title>
    <link href="/blog/2021/01/04/Mybatis%E7%BB%8F%E5%85%B89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/01/04/Mybatis%E7%BB%8F%E5%85%B89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。</p><h2 id="Mybatis至少遇到了以下的设计模式的使用"><a href="#Mybatis至少遇到了以下的设计模式的使用" class="headerlink" title="Mybatis至少遇到了以下的设计模式的使用"></a>Mybatis至少遇到了以下的设计模式的使用</h2><h2 id="1、Builder模式"><a href="#1、Builder模式" class="headerlink" title="1、Builder模式"></a>1、Builder模式</h2><p>例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder。</p><h2 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h2><p>例如SqlSessionFactory、ObjectFactory、MapperProxyFactory。</p><h2 id="3、单例模式"><a href="#3、单例模式" class="headerlink" title="3、单例模式"></a>3、单例模式</h2><p>例如ErrorContext和LogFactory。</p><h2 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h2><p>Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果。</p><h2 id="5、组合模式"><a href="#5、组合模式" class="headerlink" title="5、组合模式"></a>5、组合模式</h2><p>例如SqlNode和各个子类ChooseSqlNode等。</p><h2 id="6、模板方法模式"><a href="#6、模板方法模式" class="headerlink" title="6、模板方法模式"></a>6、模板方法模式</h2><p>例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler。</p><h2 id="7、适配器模式"><a href="#7、适配器模式" class="headerlink" title="7、适配器模式"></a>7、适配器模式</h2><p>例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现。</p><h2 id="8、装饰者模式"><a href="#8、装饰者模式" class="headerlink" title="8、装饰者模式"></a>8、装饰者模式</h2><p>例如Cache包中的cache.decorators子包中等各个装饰者的实现。</p><h2 id="9、迭代器模式"><a href="#9、迭代器模式" class="headerlink" title="9、迭代器模式"></a>9、迭代器模式</h2><p>例如迭代器模式PropertyTokenizer。</p><p><strong>接下来挨个模式进行解读，先介绍模式自身的知识，然后解读在Mybatis中怎样应用了该模式。</strong></p><h2 id="一、Builder模式"><a href="#一、Builder模式" class="headerlink" title="一、Builder模式"></a>一、Builder模式</h2><p>Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p><p>其中XMLConfigBuilder在构建Configuration对象时，也会调用XMLMapperBuilder用于读取*Mapper文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。</p><p>在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。</p><p><strong>对于builder的具体类，方法都大都用build*开头，比如SqlSessionFactoryBuilder为例，它包含以下方法：</strong></p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>即根据不同的输入参数来构建SqlSessionFactory这个工厂对象。</p><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><p>在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。</p><p><strong>在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level,<br><span class="hljs-keyword">boolean</span> autoCommit) &#123;<br>Transaction tx = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">final</span> Environment environment = configuration.getEnvironment();<br><span class="hljs-keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);<br>tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);<br><span class="hljs-keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>closeTransaction(tx); <span class="hljs-comment">// may have fetched a connection so lets call</span><br><span class="hljs-comment">// close()</span><br><span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">&quot;Error opening session.  Cause: &quot;</span> + e, e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>ErrorContext.instance().reset();<br>&#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象，然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。</p><p>在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。</p><p><strong>而对于LogFactory，它的实现代码：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFactory</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Constructor&lt;? <span class="hljs-keyword">extends</span> Log&gt; logConstructor;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">LogFactory</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">// disable construction</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Log <span class="hljs-function"><span class="hljs-title">getLog</span>(<span class="hljs-params">Class&lt;?&gt; aClass</span>)</span> &#123;<br><span class="hljs-keyword">return</span> getLog(aClass.getName());<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>这里有个特别的地方，是Log变量的的类型是Constructor&lt;? extends Log&gt;，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。</p><h2 id="三、单例模式"><a href="#三、单例模式" class="headerlink" title="三、单例模式"></a>三、单例模式</h2><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>在Mybatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而LogFactory则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p><strong>ErrorContext的单例实现代码：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ErrorContext</span> &#123;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">ErrorContext</span>&gt; LOCAL</span> = <span class="hljs-keyword">new</span> ThreadLocal&lt;ErrorContext&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ErrorContext</span>(<span class="hljs-params"></span>)</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ErrorContext <span class="hljs-title">instance</span>(<span class="hljs-params"></span>)</span> &#123;<br>ErrorContext context = LOCAL.<span class="hljs-keyword">get</span>();<br><span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>context = <span class="hljs-keyword">new</span> ErrorContext();<br>LOCAL.<span class="hljs-keyword">set</span>(context);<br>&#125;<br><span class="hljs-keyword">return</span> context;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。</p><p>只是这里有个有趣的地方是，LOCAL的静态实例变量使用了ThreadLocal修饰，也就是说它属于每个线程各自的数据，而在instance()方法中，先获取本线程的该实例，如果没有就创建该线程独有的ErrorContext。</p><h2 id="四、代理模式"><a href="#四、代理模式" class="headerlink" title="四、代理模式"></a>四、代理模式</h2><p>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。</p><p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p><p><strong>代理模式包含如下角色：</strong></p><h3 id="1-Subject"><a href="#1-Subject" class="headerlink" title="1.Subject:"></a>1.Subject:</h3><p>抽象主题角色</p><h3 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2.Proxy:"></a>2.Proxy:</h3><p>代理主题角色</p><h3 id="3-RealSubject"><a href="#3-RealSubject" class="headerlink" title="3.RealSubject:"></a>3.RealSubject:</h3><p>真实主题角色</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务； 当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author </span>Lasse Voss</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperProxyFactory</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br><span class="hljs-keyword">private</span> final Class&lt;T&gt; mapperInterface;<br><span class="hljs-keyword">private</span> final <span class="hljs-built_in">Map</span>&lt;Method, MapperMethod&gt; methodCache = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">MapperProxyFactory</span>(<span class="hljs-params">Class&lt;T&gt; mapperInterface</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>&#125;<br><br><span class="hljs-keyword">public</span> Class&lt;T&gt; <span class="hljs-function"><span class="hljs-title">getMapperInterface</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> mapperInterface;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">Map</span>&lt;Method, MapperMethod&gt; <span class="hljs-function"><span class="hljs-title">getMethodCache</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> methodCache;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br><span class="hljs-keyword">protected</span> T <span class="hljs-function"><span class="hljs-title">newInstance</span>(<span class="hljs-params">MapperProxy&lt;T&gt; mapperProxy</span>)</span> &#123;<br><span class="hljs-keyword">return</span> (T) <span class="hljs-built_in">Proxy</span>.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> Class[] &#123; mapperInterface &#125;,<br>mapperProxy);<br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-function"><span class="hljs-title">newInstance</span>(<span class="hljs-params">SqlSession sqlSession</span>)</span> &#123;<br>final MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);<br><span class="hljs-keyword">return</span> newInstance(mapperProxy);<br>&#125;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>在这里，先通过T newInstance(SqlSession sqlSession)方法会得到一个MapperProxy对象，然后调用T newInstance(MapperProxymapperProxy)生成代理对象然后返回。</p><p><strong>而查看MapperProxy的代码，可以看到如下内容：</strong></p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperProxy</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span>, <span class="hljs-title">Serializable</span> &#123;</span><br><br>@Override<br><span class="hljs-keyword">public</span> Object invoke(Object proxy, <span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">method</span>, <span class="hljs-title">Object</span>[] <span class="hljs-title">args</span>) <span class="hljs-title">throws</span> <span class="hljs-title">Throwable</span> &#123;</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;<br><span class="hljs-keyword">return</span> method.invoke(this, args);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDefaultMethod(<span class="hljs-function"><span class="hljs-keyword">method</span>)) &#123;</span><br><span class="hljs-keyword">return</span> invokeDefaultMethod(proxy, <span class="hljs-function"><span class="hljs-keyword">method</span>, <span class="hljs-title">args</span>);</span><br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br><span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(t);<br>&#125;<br><span class="hljs-keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(<span class="hljs-function"><span class="hljs-keyword">method</span>);</span><br><span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>非常典型的，该MapperProxy类实现了InvocationHandler接口，并且实现了该接口的invoke方法。</p><p>通过这种方式，我们只需要编写Mapper.java接口类，当真正执行一个Mapper接口的时候，就会转发给MapperProxy.invoke方法，而该方法则会调用后续的sqlSession.cud&gt;executor.execute&gt;prepareStatement等一系列方法，完成SQL的执行和返回。</p><h2 id="五、组合模式"><a href="#五、组合模式" class="headerlink" title="五、组合模式"></a>五、组合模式</h2><p>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fce4762c12a74809aacc0143f05a2ce7~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p><strong>Mybatis支持动态SQL的强大功能，比如下面的这个SQL：</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;org.format.dynamicproxy.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="xml">    UPDATE users</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="xml">            name = #</span><span class="hljs-template-variable">&#123;name&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="xml">            , age = #</span><span class="hljs-template-variable">&#123;age&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;birthday != null and birthday != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="xml">            , birthday = #</span><span class="hljs-template-variable">&#123;birthday&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></span><br><span class="xml">    where id = $</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><br><span class="xml">复制代码</span><br></code></pre></td></tr></table></figure><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；</p><p>在DynamicSqlSource.getBoundSql方法里，调用了rootSqlNode.apply(context)方法，apply方法是所有的动态节点都实现的接口：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">SqlNode</span> &#123;<br><span class="hljs-built_in">bool</span>ean apply(DynamicContext context);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>对于实现该SqlSource接口的所有节点，就是整个组合模式树的各个节点：</strong></p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public boolean apply(DynamicContext context) &#123;<br>GenericTokenParser parser = create<span class="hljs-constructor">Parser(<span class="hljs-params">new</span> BindingTokenParser(<span class="hljs-params">context</span>, <span class="hljs-params">injectionFilter</span>)</span>);<br>context.append<span class="hljs-constructor">Sql(<span class="hljs-params">parser</span>.<span class="hljs-params">parse</span>(<span class="hljs-params">text</span>)</span>);<br>return <span class="hljs-literal">true</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>但是对于IfSqlNode，就需要先做判断，如果判断通过，仍然会调用子元素的SqlNode，即contents.apply方法，实现递归的解析。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">DynamicContext context</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;<br>contents.apply(context);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="六、模板方法模式"><a href="#六、模板方法模式" class="headerlink" title="六、模板方法模式"></a>六、模板方法模式</h2><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p><p>模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p><p>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，Executor包含以下结构：</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>其中的BaseExecutor就采用了模板方法模式，它实现了大部分的SQL执行逻辑，然后把以下几个方法交给子类定制化完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doUpdate</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> List&lt;BatchResult&gt; <span class="hljs-title">doFlushStatements</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isRollback)</span> <span class="hljs-keyword">throws</span> SQLException</span>;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds,</span></span><br><span class="hljs-function"><span class="hljs-params">ResultHandler resultHandler, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>该模板方法类有几个子类的具体实现，使用了不同的策略：</strong></p><h3 id="1-简单SimpleExecutor"><a href="#1-简单SimpleExecutor" class="headerlink" title="1.简单SimpleExecutor"></a>1.简单SimpleExecutor</h3><p>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（可以是Statement或PrepareStatement对象）</p><h3 id="2-重用ReuseExecutor"><a href="#2-重用ReuseExecutor" class="headerlink" title="2.重用ReuseExecutor"></a>2.重用ReuseExecutor</h3><p>执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。（可以是Statement或PrepareStatement对象）</p><h3 id="3-批量BatchExecutor"><a href="#3-批量BatchExecutor" class="headerlink" title="3.批量BatchExecutor"></a>3.批量BatchExecutor</h3><p>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</p><p><strong>比如在SimpleExecutor中这样实现update方法：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doUpdate</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>Statement stmt = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>Configuration configuration = ms.getConfiguration();<br>StatementHandler <span class="hljs-keyword">handler</span> = configuration.newStatementHandler(<span class="hljs-keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="hljs-keyword">null</span>,<br><span class="hljs-keyword">null</span>);<br>stmt = prepareStatement(<span class="hljs-keyword">handler</span>, ms.getStatementLog());<br><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">handler</span>.<span class="hljs-title">update</span><span class="hljs-params">(stmt)</span></span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>closeStatement(stmt);<br>&#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="七、适配器模式"><a href="#七、适配器模式" class="headerlink" title="七、适配器模式"></a>七、适配器模式</h2><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6f7fcb8510047b0bc2e09172782ef02~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p><strong>在Mybatsi的logging包中，有一个Log接口：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Clinton Begin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> interface Log &#123;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDebugEnabled</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTraceEnabled</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, Throwable e)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trace</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">warn</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span></span>;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4df50a29785f432996b49e42d807ac60~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>比如对于Log4jImpl的实现来说，该实现持有了org.apache.log4j.Logger的实例，然后所有的日志方法，均委托该实例来实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log4jImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">Log</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-built_in">String</span> FQCN = Log4jImpl.class.getName();<br><br><span class="hljs-keyword">private</span> Logger log;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Log4jImpl</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> clazz</span>)</span> &#123;<br>log = Logger.getLogger(clazz);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isDebugEnabled</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> log.isDebugEnabled();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isTraceEnabled</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> log.isTraceEnabled();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s, Throwable e</span>)</span> &#123;<br>log.log(FQCN, Level.ERROR, s, e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>log.log(FQCN, Level.ERROR, s, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">debug</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>log.log(FQCN, Level.DEBUG, s, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">trace</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>log.log(FQCN, Level.TRACE, s, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">warn</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>log.log(FQCN, Level.WARN, s, <span class="hljs-literal">null</span>);<br>&#125;<br><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="八、装饰者模式"><a href="#八、装饰者模式" class="headerlink" title="八、装饰者模式"></a>八、装饰者模式</h2><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46cf5d22d32b4882b35d19fdce820371~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>在mybatis中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）永久缓存实现，然后通过一系列的装饰器来对PerpetualCache永久缓存进行缓存策略等方便的控制。如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb8621391df348aab88431138a1d2d30~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p><strong>用于装饰PerpetualCache的标准装饰器共有8个（全部在org.apache.ibatis.cache.decorators包中）：</strong></p><h3 id="1-FifoCache："><a href="#1-FifoCache：" class="headerlink" title="1.FifoCache："></a>1.FifoCache：</h3><p>先进先出算法，缓存回收策略</p><h3 id="2-LoggingCache："><a href="#2-LoggingCache：" class="headerlink" title="2.LoggingCache："></a>2.LoggingCache：</h3><p>输出缓存命中的日志信息</p><h3 id="3-LruCache："><a href="#3-LruCache：" class="headerlink" title="3.LruCache："></a>3.LruCache：</h3><p>最近最少使用算法，缓存回收策略</p><h3 id="4-ScheduledCache："><a href="#4-ScheduledCache：" class="headerlink" title="4.ScheduledCache："></a>4.ScheduledCache：</h3><p>调度缓存，负责定时清空缓存</p><h3 id="5-SerializedCache："><a href="#5-SerializedCache：" class="headerlink" title="5.SerializedCache："></a>5.SerializedCache：</h3><p>缓存序列化和反序列化存储</p><h3 id="6-SoftCache："><a href="#6-SoftCache：" class="headerlink" title="6.SoftCache："></a>6.SoftCache：</h3><p>基于软引用实现的缓存管理策略</p><h3 id="7-SynchronizedCache："><a href="#7-SynchronizedCache：" class="headerlink" title="7.SynchronizedCache："></a>7.SynchronizedCache：</h3><p>同步的缓存装饰器，用于防止多线程并发访问</p><h3 id="8-WeakCache："><a href="#8-WeakCache：" class="headerlink" title="8.WeakCache："></a>8.WeakCache：</h3><p><strong>基于弱引用实现的缓存管理策略</strong></p><p>另外，还有一个特殊的装饰器TransactionalCache：事务性的缓存</p><p>正如大多数持久层框架一样，mybatis缓存同样分为一级缓存和二级缓存</p><h3 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h3><p>又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中（BaseExecutor），而执行器又在SqlSession（DefaultSqlSession）中，所以一级缓存的生命周期与SqlSession是相同的。</p><h3 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2.二级缓存"></a>2.二级缓存</h3><p>又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在Configuration核心配置对象中。</p><h3 id="3-二级缓存对象"><a href="#3-二级缓存对象" class="headerlink" title="3.二级缓存对象"></a>3.二级缓存对象</h3><p>默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis会根据配置自动追加一系列装饰器。</p><p><strong>Cache对象之间的引用顺序为：</strong></p><p>SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p><h2 id="九、迭代器模式"><a href="#九、迭代器模式" class="headerlink" title="九、迭代器模式"></a>九、迭代器模式</h2><p>迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1308f1e7c444af9ae7e66110668ccac~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>Java的Iterator就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式：</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>比如Mybatis的PropertyTokenizer是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了Iterator接口，在使用时经常被用到的是Iterator接口中的hasNext这个函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyTokenizer</span> <span class="hljs-title">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">PropertyTokenizer</span>&gt; </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> indexedName;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> index;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> children;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">PropertyTokenizer</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> fullname</span>)</span> &#123;<br>int delim = fullname.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br><span class="hljs-keyword">if</span> (delim &gt; -<span class="hljs-number">1</span>) &#123;<br>name = fullname.substring(<span class="hljs-number">0</span>, delim);<br>children = fullname.substring(delim + <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>name = fullname;<br>children = <span class="hljs-literal">null</span>;<br>&#125;<br>indexedName = name;<br>delim = name.indexOf(<span class="hljs-string">&#x27;[&#x27;</span>);<br><span class="hljs-keyword">if</span> (delim &gt; -<span class="hljs-number">1</span>) &#123;<br>index = name.substring(delim + <span class="hljs-number">1</span>, name.length() - <span class="hljs-number">1</span>);<br>name = name.substring(<span class="hljs-number">0</span>, delim);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getIndex</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> index;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getIndexedName</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> indexedName;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getChildren</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> children;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">hasNext</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> children != <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PropertyTokenizer <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PropertyTokenizer(children);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<br><span class="hljs-string">&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;</span>);<br>&#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>可以看到，这个类传入一个字符串到构造函数，然后提供了iterator方法对解析后的子串进行遍历，是一个很常用的方法类。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单点登录（SSO）</title>
    <link href="/blog/2021/01/01/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88SSO%EF%BC%89/"/>
    <url>/blog/2021/01/01/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88SSO%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>单点登录又称之为Single Sign On，简称SSO，单点登录可以通过基于用户会话的共享，他分文两种，先来看第一种，那就是他的原理是分布式会话来实现。</p><p>比如说现在有个一级域名为 <a href="http://www.imooc.com/">www.imooc.com</a> ，是教育类网站，但是慕课网有其他的产品线，可以通过构建二级域名提供服务给用户访问，比如： music.imooc.com ， blog.imooc.com 等等，分别为慕课音乐以及慕课博客等，用户只需要在其中一个站点登录，那么其他站点也会随之而登录。</p><p>也就是说，用户自始至终只在某一个网站下登录后，那么他所产生的会话，就共享给了其他的网站，实现了单点网站登录后，同时间接登录了其他的网站，那么这个其实就是单点登录，他们的会话是共享的，都是同一个用户会话。</p><h2 id="Cookie-Redis-实现-SSO"><a href="#Cookie-Redis-实现-SSO" class="headerlink" title="Cookie + Redis 实现 SSO"></a>Cookie + Redis 实现 SSO</h2><p>那么之前我们所实现的分布式会话后端是基于redis的，如此会话可以流窜在后端的任意系统，都能获取到缓存中的用户数据信息，前端通过使用cookie，可以保证在同域名的一级二级下获取，那么这样一来，cookie中的信息userid和token是可以在发送请求的时候携带上的，这样从前端请求后端后是可以获取拿到的，这样一来，其实用户在某一端登录注册以后，其实cookie和redis中都会带有用户信息，只要用户不退出，那么就能在任意一个站点实现登录了。</p><p>那么这个原理主要也是cookie和网站的依赖关系，顶级域名 <a href="http://www.imooc.com/">www.imooc.com</a> 和 *.imooc.com的cookie值是可以共享的，可以被携带至后端的，比如设置为 .imooc.com，.t.mukewang.com，如此是OK的。<br> 二级域名自己的独立cookie是不能共享的，不能被其他二级域名获取，比如：music.imooc.com的cookie是不能被mtv.imooc.com共享，两者互不影响，要共享必须设置为.imooc.com。</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/00e2afe7458740a8bec8c2326e3ab6b1~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h2 id="顶级域名不同怎么办"><a href="#顶级域名不同怎么办" class="headerlink" title="顶级域名不同怎么办?"></a>顶级域名不同怎么办?</h2><p>上一节单点登录是基于相同顶级域名做的，那么如果顶级域名都不一样，咋办？比如 <a href="http://www.imooc.com/">www.imooc.com</a> 要和<a href="http://www.mukewang.com/">www.mukewang.com</a> 的会话实现共享，这个时候又该如何？！如下图，这个时候的cookie由于顶级域名不同，就不能实现cookie跨域了，每个站点各自请求到服务端，cookie无法同步。比如，<a href="http://www.imooc.com/">www.imooc.com</a> 下的用户发起请求后会有cookie，但是他又访问了<a href="http://www.abc.com/">www.abc.com</a> ，由于cookie无法携带，所以会要你二次登录。<br> 那么遇到顶级域名不同却又要实现单点登录该如何实现呢？我们来参考下面一张图： <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/668be1732242402a8a8f83534b883774~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>如上图所示，多个系统之间的登录会通过一个独立的登录系统去做验证，它就相当于是一个中介公司，整合了所有人，你要看房经过中介允许拿钥匙就行，实现了统一的登录。那么这个就称之为CAS系统，CAS全称为Central Authentication Service即中央认证服务，是一个单点登录的解决方案，可以用于不同顶级域名之间的单点登录。</p><p>过程解析 <img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/fe338ecce616416d868e91c8058ce0e1~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>用户首次登录时流程如下：</p><p>1)、用户浏览器访问系统A需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。</p><p>2)、系统A发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，没有，进行登录。</p><p>3)、认证中心呈现登录页面，用户登录，登录成功后，认证中心重定向请求到系统A，并附上认证通过令牌，此时认证中心同时生成了全局票据。</p><p>4)、此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统A与认证中心通信，验证令牌有效,证明用户已登录。</p><p>5)、系统A将受限资源返给用户</p><p>已登录用户首次访问应用群中系统B时：</p><p>1)、浏览器访问另一应用B需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。</p><p>2)、系统B发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，获取全局票据，可以获得，认证中心发现已经登录。</p><p>3)、认证中心发放临时票据(令牌)，并携带该令牌重定向到系统B。</p><p>4)、此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统B与认证中心通信，验证令牌有效,证明用户已登录。</p><p>5)、系统B将受限资源返回给客户端。</p><p>全局票据的意义就是判断用户是否已经在认证中心登陆过。<br> 临时票据的意义是签发给用户一个登陆的认证。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSOController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisOperator redisOperator;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_USER_TOKEN = <span class="hljs-string">&quot;redis_user_token&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_USER_TICKET = <span class="hljs-string">&quot;redis_user_ticket&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REDIS_TMP_TICKET = <span class="hljs-string">&quot;redis_tmp_ticket&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String COOKIE_USER_TICKET = <span class="hljs-string">&quot;cookie_user_ticket&quot;</span>;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String returnUrl,</span></span><br><span class="hljs-function"><span class="hljs-params">                        Model model,</span></span><br><span class="hljs-function"><span class="hljs-params">                        HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                        HttpServletResponse response)</span> </span>&#123;<br><br>        model.addAttribute(<span class="hljs-string">&quot;returnUrl&quot;</span>, returnUrl);<br><br>        <span class="hljs-comment">// 1. 获取userTicket门票，如果cookie中能够获取到，证明用户登录过，此时签发一个一次性的临时票据并且回跳</span><br>        String userTicket = getCookie(request, COOKIE_USER_TICKET);<br><br>        <span class="hljs-keyword">boolean</span> isVerified = verifyUserTicket(userTicket);<br>        <span class="hljs-keyword">if</span> (isVerified) &#123;<br>            String tmpTicket = createTmpTicket();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:&quot;</span> + returnUrl + <span class="hljs-string">&quot;?tmpTicket=&quot;</span> + tmpTicket;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 用户从未登录过，第一次进入则跳转到CAS的统一登录页面</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验CAS全局用户门票</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userTicket</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyUserTicket</span><span class="hljs-params">(String userTicket)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 0. 验证CAS门票不能为空</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(userTicket)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1. 验证CAS门票是否有效</span><br>        String userId = redisOperator.get(REDIS_USER_TICKET + <span class="hljs-string">&quot;:&quot;</span> + userTicket);<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(userId)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 验证门票对应的user会话是否存在</span><br>        String userRedis = redisOperator.get(REDIS_USER_TOKEN + <span class="hljs-string">&quot;:&quot;</span> + userId);<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(userRedis)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * CAS的统一登录接口</span><br><span class="hljs-comment">     *      目的：</span><br><span class="hljs-comment">     *          1. 登录后创建用户的全局会话                 -&gt;  uniqueToken</span><br><span class="hljs-comment">     *          2. 创建用户全局门票，用以表示在CAS端是否登录  -&gt;  userTicket</span><br><span class="hljs-comment">     *          3. 创建用户的临时票据，用于回跳回传          -&gt;  tmpTicket</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/doLogin&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doLogin</span><span class="hljs-params">(String username,</span></span><br><span class="hljs-function"><span class="hljs-params">                          String password,</span></span><br><span class="hljs-function"><span class="hljs-params">                          String returnUrl,</span></span><br><span class="hljs-function"><span class="hljs-params">                          Model model,</span></span><br><span class="hljs-function"><span class="hljs-params">                          HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                          HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        model.addAttribute(<span class="hljs-string">&quot;returnUrl&quot;</span>, returnUrl);<br><br>        <span class="hljs-comment">// 0. 判断用户名和密码必须不为空</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(username) ||<br>                StringUtils.isBlank(password)) &#123;<br>            model.addAttribute(<span class="hljs-string">&quot;errmsg&quot;</span>, <span class="hljs-string">&quot;用户名或密码不能为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1. 实现登录</span><br>        Users userResult = userService.queryUserForLogin(username,<br>                MD5Utils.getMD5Str(password));<br>        <span class="hljs-keyword">if</span> (userResult == <span class="hljs-keyword">null</span>) &#123;<br>            model.addAttribute(<span class="hljs-string">&quot;errmsg&quot;</span>, <span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 实现用户的redis会话</span><br>        String uniqueToken = UUID.randomUUID().toString().trim();<br>        UsersVO usersVO = <span class="hljs-keyword">new</span> UsersVO();<br>        BeanUtils.copyProperties(userResult, usersVO);<br>        usersVO.setUserUniqueToken(uniqueToken);<br>        redisOperator.set(REDIS_USER_TOKEN + <span class="hljs-string">&quot;:&quot;</span> + userResult.getId(),<br>                JsonUtils.objectToJson(usersVO));<br><br>        <span class="hljs-comment">// 3. 生成ticket门票，全局门票，代表用户在CAS端登录过</span><br>        String userTicket = UUID.randomUUID().toString().trim();<br><br>        <span class="hljs-comment">// 3.1 用户全局门票需要放入CAS端的cookie中</span><br>        setCookie(COOKIE_USER_TICKET, userTicket, response);<br><br>        <span class="hljs-comment">// 4. userTicket关联用户id，并且放入到redis中，代表这个用户有门票了，可以在各个景区游玩</span><br>        redisOperator.set(REDIS_USER_TICKET + <span class="hljs-string">&quot;:&quot;</span> + userTicket, userResult.getId());<br><br>        <span class="hljs-comment">// 5. 生成临时票据，回跳到调用端网站，是由CAS端所签发的一个一次性的临时ticket</span><br>        String tmpTicket = createTmpTicket();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * userTicket: 用于表示用户在CAS端的一个登录状态：已经登录</span><br><span class="hljs-comment">         * tmpTicket: 用于颁发给用户进行一次性的验证的票据，有时效性</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 举例：</span><br><span class="hljs-comment">         *      我们去动物园玩耍，大门口买了一张统一的门票，这个就是CAS系统的全局门票和用户全局会话。</span><br><span class="hljs-comment">         *      动物园里有一些小的景点，需要凭你的门票去领取一次性的票据，有了这张票据以后就能去一些小的景点游玩了。</span><br><span class="hljs-comment">         *      这样的一个个的小景点其实就是我们这里所对应的一个个的站点。</span><br><span class="hljs-comment">         *      当我们使用完毕这张临时票据以后，就需要销毁。</span><br><span class="hljs-comment">         */</span><br><br><span class="hljs-comment">//        return &quot;login&quot;;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:&quot;</span> + returnUrl + <span class="hljs-string">&quot;?tmpTicket=&quot;</span> + tmpTicket;<br>    &#125;<br><br><br>    <span class="hljs-meta">@PostMapping(&quot;/verifyTmpTicket&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMOOCJSONResult <span class="hljs-title">verifyTmpTicket</span><span class="hljs-params">(String tmpTicket,</span></span><br><span class="hljs-function"><span class="hljs-params">                                           HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                                           HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">// 使用一次性临时票据来验证用户是否登录，如果登录过，把用户会话信息返回给站点</span><br>        <span class="hljs-comment">// 使用完毕后，需要销毁临时票据</span><br>        String tmpTicketValue = redisOperator.get(REDIS_TMP_TICKET + <span class="hljs-string">&quot;:&quot;</span> + tmpTicket);<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(tmpTicketValue)) &#123;<br>            <span class="hljs-keyword">return</span> IMOOCJSONResult.errorUserTicket(<span class="hljs-string">&quot;用户票据异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 0. 如果临时票据OK，则需要销毁，并且拿到CAS端cookie中的全局userTicket，以此再获取用户会话</span><br>        <span class="hljs-keyword">if</span> (!tmpTicketValue.equals(MD5Utils.getMD5Str(tmpTicket))) &#123;<br>            <span class="hljs-keyword">return</span> IMOOCJSONResult.errorUserTicket(<span class="hljs-string">&quot;用户票据异常&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 销毁临时票据</span><br>            redisOperator.del(REDIS_TMP_TICKET + <span class="hljs-string">&quot;:&quot;</span> + tmpTicket);<br>        &#125;<br><br>        <span class="hljs-comment">// 1. 验证并且获取用户的userTicket</span><br>        String userTicket = getCookie(request, COOKIE_USER_TICKET);<br>        String userId = redisOperator.get(REDIS_USER_TICKET + <span class="hljs-string">&quot;:&quot;</span> + userTicket);<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(userId)) &#123;<br>            <span class="hljs-keyword">return</span> IMOOCJSONResult.errorUserTicket(<span class="hljs-string">&quot;用户票据异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 验证门票对应的user会话是否存在</span><br>        String userRedis = redisOperator.get(REDIS_USER_TOKEN + <span class="hljs-string">&quot;:&quot;</span> + userId);<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(userRedis)) &#123;<br>            <span class="hljs-keyword">return</span> IMOOCJSONResult.errorUserTicket(<span class="hljs-string">&quot;用户票据异常&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 验证成功，返回OK，携带用户会话</span><br>        <span class="hljs-keyword">return</span> IMOOCJSONResult.ok(JsonUtils.jsonToPojo(userRedis, UsersVO.class));<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/logout&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IMOOCJSONResult <span class="hljs-title">logout</span><span class="hljs-params">(String userId,</span></span><br><span class="hljs-function"><span class="hljs-params">                                  HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                                  HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">// 0. 获取CAS中的用户门票</span><br>        String userTicket = getCookie(request, COOKIE_USER_TICKET);<br><br>        <span class="hljs-comment">// 1. 清除userTicket票据，redis/cookie</span><br>        deleteCookie(COOKIE_USER_TICKET, response);<br>        redisOperator.del(REDIS_USER_TICKET + <span class="hljs-string">&quot;:&quot;</span> + userTicket);<br><br>        <span class="hljs-comment">// 2. 清除用户全局会话（分布式会话）</span><br>        redisOperator.del(REDIS_USER_TOKEN + <span class="hljs-string">&quot;:&quot;</span> + userId);<br><br>        <span class="hljs-keyword">return</span> IMOOCJSONResult.ok();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建临时票据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">createTmpTicket</span><span class="hljs-params">()</span> </span>&#123;<br>        String tmpTicket = UUID.randomUUID().toString().trim();<br>        <span class="hljs-keyword">try</span> &#123;<br>            redisOperator.set(REDIS_TMP_TICKET + <span class="hljs-string">&quot;:&quot;</span> + tmpTicket,<br>                    MD5Utils.getMD5Str(tmpTicket), <span class="hljs-number">600</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmpTicket;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCookie</span><span class="hljs-params">(String key,</span></span><br><span class="hljs-function"><span class="hljs-params">                           String val,</span></span><br><span class="hljs-function"><span class="hljs-params">                           HttpServletResponse response)</span> </span>&#123;<br><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(key, val);<br>        cookie.setDomain(<span class="hljs-string">&quot;sso.com&quot;</span>);<br>        cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>        response.addCookie(cookie);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteCookie</span><span class="hljs-params">(String key,</span></span><br><span class="hljs-function"><span class="hljs-params">                              HttpServletResponse response)</span> </span>&#123;<br><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(key, <span class="hljs-keyword">null</span>);<br>        cookie.setDomain(<span class="hljs-string">&quot;sso.com&quot;</span>);<br>        cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>        cookie.setMaxAge(-<span class="hljs-number">1</span>);<br>        response.addCookie(cookie);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getCookie</span><span class="hljs-params">(HttpServletRequest request, String key)</span> </span>&#123;<br><br>        Cookie[] cookieList = request.getCookies();<br>        <span class="hljs-keyword">if</span> (cookieList == <span class="hljs-keyword">null</span> || StringUtils.isBlank(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        String cookieValue = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; cookieList.length; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (cookieList[i].getName().equals(key)) &#123;<br>                cookieValue = cookieList[i].getValue();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cookieValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>单点登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>业务和技术</title>
    <link href="/blog/2020/12/28/%E4%B8%9A%E5%8A%A1%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    <url>/blog/2020/12/28/%E4%B8%9A%E5%8A%A1%E5%92%8C%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p> 身处业务的我们，技术上如何自拔？</p><p>文章目录概述自我回顾业务与技术的困扰带着问题思考什么是技术和业务业务技术技术和业务的关系业务与为解决业务而衍生的业务对待业务的态度因你在团队的角色不同而不同从所谓的业务代码中跳出如何轻松、漂亮的搞定业务……</p><p>看了网上的学习方法，也综合了一下他人的意见，总结下来，想来自我学习以及自我提升的方式，大抵就是如下三种了</p><ol><li> 从文字视图中学习</li><li> 向身边的人学习</li><li> 向自己学习</li></ol><p>其中向自己学习最为靠谱。</p><p>而向自己学习最有效的方法，就是自省。</p><p>“曾子曰: 吾日三省吾身，为人谋而不忠乎? 与朋友交而不信乎? 传不习乎?”</p><p>“古人诚不我欺”。总结，是自省反馈出来的一种结果。写这篇文章，希望不只是自己能够学到东西，进行成长，也希望能将自己的思考和经验传播出来，与大家共勉。</p><p>从年初到年末，从一个技术人员 仅 3 人的小手游公司到了如今开发团队近 200 人的中大型公司。</p><p>下面从工作和个人成长两个方面进行入手，剖析一下自己。</p><p>工作上，从一个人埋头干活，到主导跨 4，5 个小部门共同协作的技术经理以及现在作为一个小组的 leader，作为员工，如何在业务中继续成长下去以及如何在公司体现出自己的不可替代性（技术和业务上的），也让公司看到你的潜力（你的成长能为公司为团队带来的收益）；作为小组 leader，如何更好的带好自己的小组（这点在后面并没有讲到，明年见）；</p><p>另外，自己技术上的成长。也许我扯一大堆的技术名词，并不是很直观，简单粗暴的讲，就是从一个日流量不到万级的游戏到如今日流量亿级的项目以及其他大大小小高流量项目的开发。</p><p>稍微从技术层面说就是 Java 的单体 SpringBoot 项目发展到基于 Dubbo、SpringBoot 的，使用到分布式事务，分布式锁，分布式数据分片，负载、限流、熔断、降级、链路追踪、elasticsearch、消息队列、缓存 redis、自动化部署、apollo、Sentinel 等一大堆名词和技术搭建的高并发高可用服务化项目；</p><p>凭我这浅薄的知识，至少目前不可能用自己理解的概念来把上面列到的一些知识点的原理来进行讲解，自己对其也只是懂个大概，更不想误人子弟，仅仅讲点自己也似懂非懂的概念。自己目前对其理解的，就是很多开发所处的，调用接口使用的这个层次。原理知识，以后会慢慢道来。余生漫漫，请君勿急。</p><p>篇幅有限，开始想着能写很多，但是思考下来，关于技术和业务就能写一大篇的文字。</p><p>相信很多开发经常会被业务代码所困扰，绝大多数都是有梦想的程序猿，大家都有着一个想使用代码改变世界的梦，当初我选择软件工程这个专业，原因之一就是我觉得我哥使用代码开发一个网站出来是一件牛逼哄哄的事情。</p><p>现在倒是觉得，比如开发一个 GitHub 开源项目的 star 几千上万才是牛逼哄哄的事情了。</p><p>在工作中，天天写业务代码，自己如何在技术上进步？大家是不是也经常心生疑惑，我以前也困扰过（自己的老大在总结中点醒了我，对技术有追求，但是并没有很好的结合业务。自己也好好进行了反省，搜集了很多资料，也询问了另外的大佬，如何更好的处理业务和技术），现在倒是觉得贴合业务更加能够提升打磨自己的技术以及增加自己在公司的不可替代性。</p><p>看到有文章这样比喻业务与技术，写业务代码学习的技术就像游戏中升级打怪一样，开始打小怪，经验值很高，越到后面经验值越少，打小怪已经不能提升经验值了。这个时候就需要打一些更高级的怪，刷一些有挑战的副本了，没看到哪个游戏只要一直打小怪就能升到顶级的。 成为技术大牛的路也是类似的，你要不断的提升自己的水平，然后面临更大的挑战，通过应对这些挑战从而使自己水平更上一级，然后如此往复，最终达到技术大牛甚至业界大牛的境界，写业务代码只是这个打怪升级路上的一个挑战而已。业务代码都写不好的程序员肯定无法成为技术大牛，但只把业务代码写好的程序员也还不能成为技术大牛。对应自己所处的角色，更好的挖掘出自己的潜力与提升实力，创造出更多的价值。</p><p>再说一个现实中的问题，工作都是基于业务来驱动的，国内基本所有公司（抛开研究不讲，广义上来说，所有的技术都是为业务服务的）都是业务来驱动的。 阿里的中间件团队，也是业务驱动而成立的团队（为了解决阿里内部复杂的业务场景、飞速的业务增长、高并发的大促洪峰、层出不穷的稳定性问题而成立的团队），只是做的事情比我们的高大上（高分布式 RPC 服务框架、高可靠分布式消息中间件、分布式数据层、海量数据存储、实时计算、系统性能优化、架构高可用等），后面会介绍到因业务需要而衍生高深技术。</p><h2 id="带着问题思考"><a href="#带着问题思考" class="headerlink" title="带着问题思考"></a>带着问题思考</h2><p>作为开发人员，如何面对 “CRUD，天天写业务代码” 这个事情，可以思考下面的几个问题</p><ol><li> 什么是技术和业务</li><li> 业务和技术的关系</li><li> 业务与为解决业务而衍生的业务</li><li> 对待业务的态度因你在团队的角色不同而不同</li><li> 如何从所谓的业务代码中学习深入</li></ol><h3 id="什么是技术和业务"><a href="#什么是技术和业务" class="headerlink" title="什么是技术和业务"></a>什么是技术和业务</h3><p>接下来就从业务和技术来入手进行分析了。</p><p>回归到这两个词的定义。</p><p>维基百科是这么解释的：</p><h4 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h4><p><strong>业务是指某种有目的的工作或工作项目。</strong> 考虑到企业已经成为现代社会最常见的活动主体，故可为业务作现实定义，即企业运用科学方法和生产工艺生产出可交付用户使用的产品与服务，并以此为企业带来利益的行为。</p><p>不只是为企业，能为人类本身带来利益的需求，都可以称之为业务。</p><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p><strong>技术可以指人类对机器、硬件或人造器皿的运用，但它也可以包含更广的架构，如系统、组织方法学和技巧</strong></p><p>它是知识进化的主体，由社会形塑或形塑社会。如电脑等新技术的增生使人们相信技术是社会进化的决定性力量，换句话说，它是驱动改变的自发性动力。</p><p>通过人为创造条件，让指定的事件能够按照人类的意愿发生，这就是技术。</p><p>比如取火，最早人类只能靠打雷等自然现象产生火。</p><p>取火其实就是一个业务目标，要解决的是人类自己的问题，这就是业务，实际就是人类的利益。这个时候人类并没有生火的技术，只能靠不断的加木材，保持火不熄灭。</p><p>后来人们发现了钻木取火：只要用一个干的木棍，在另一个干木表面快速的转动，就可以生火。这个办法让人类可以自行创造火源，就产生了钻木取火的技术。</p><p>但是双手快速转动木棍钻木取火，并不是所有人都能够做得到的，需要很多力量和速度，对人的要求太高。为了解决快速转动的问题，就有人采用弓弦来提升木棍转动的速度。</p><p>业务目标是为了取火，钻木取火这个技术的出现解决了这个问题。</p><p>钻木取火的效率不高，影响了业务（取火）的效率，就有了进一步改进的动机，改进转动木棍的方式，产生了弓弦转动木棍的技术。</p><p>再用比较现代化的业务来进行说明一下</p><p>比如取款就是一种业务，ATM 机内运转的软件，要解决的业务就是取款。（取款是为了交易，当初交易不方便，于是便有了移动支付，聚合支付等等） 比如买火车票也是业务，12306 这个网站就是为解决买车票的业务服务的。（春运买票不易，于是出现了抢票软件，加速软件等等）</p><p>实现软件 / 网站功能的系统，架构，框架等便是技术（而技术本身又可能是建立在其他技术之上的）。</p><p>从上面的定义以及例子中，可以知道，业务是具有强目的性的，比如说我的业务就是为了取款，而 12306 网站的业务就是为了解决买车票的业务服务，是为某个具体特定的问题而生的；但是业务就具有弱目的性，普遍性和通用性，比如前面实现取款的技术框架，可能在 12306 中的框架还能复用等等。</p><p>技术存在演变，也是为了更方便的服务于业务本身。</p><h3 id="技术和业务的关系"><a href="#技术和业务的关系" class="headerlink" title="技术和业务的关系"></a>技术和业务的关系</h3><p>接下来以取火为例吧。</p><p>前面说到最开始是通过雷电获取火源，接下来是火石、钻木取火，然后渐渐演变到弓弦加速转动木棍取火，随着科技的发展，渐渐的生成火源便成为了一种业务，并且可以出售带来另外的利益，这个时候，生成火柴、打火机便是业务。而其中业务中使用的剧烈氧化还原反应、汽油制作、物理化学知识、工业制作等便是技术。</p><p>简单的可以得出如下几个结论</p><ol><li> 技术是为了解决业务的问题而产生的，没有了业务，技术就没有了存在的前提</li><li> 有了更好的技术，效率更差的技术，就会慢慢的被淘汰，消失，一切都遵从人类的利益诉求 – 也就是业务</li></ol><p>有人会问，不用钻木取火了，但是弓弦加速转动木棍还可以用啊？ 没错，因为弓弦转动木棍这个技术，不是来生火的，是用来加速木棍转动的，所解决的问题不一样（引出了后面因解决业务而衍生出来的业务）。但是多种不同的技术，合理结合起来，会更好更有效率的解决业务问题。</p><p>所以技术与技术之间，有如下的两种关系：</p><ol><li> 在解决同一个业务问题的前提下，更高效，更低成本的技术，会淘汰低效，高成本的技术。这是人类利益诉求所决定的。</li><li> 一般刚开始解决根本问题的技术（钻木取火）的效率是比较低的，只是把不可能变成了可能（从这一点上来说，技术才是业务的 促成者）。然后就会有提高效率的需求出现，要求改进这个技术。这个技术的低效率部分就会被其他人（或者技术发明人自己）加以改进，这部分就会形成新的技术。</li></ol><p>当更好的技术发生的时候，必定会形成一个切分，新技术会通过某种方式和原有的技术连接在一起形成一个整体，让这个新的技术可以和原有技术共同工作，使得原有的技术可以用更高的效率解决问题。因为要解决的主要业务（生火）并没有发生改变，分拆所形成的是一个树状的结构。</p><p>这个时候其实已经产生了架构。也就是说，一般是先有技术，才会有架构。这些其他技术（弓弦拉动木棍、氧化还原反应生火等），是从直接解决问题的初始主要技术中分拆出来形成的，并通过树状结构和主要技术（钻木取火）组合在一起。在解决主要问题（生火）之后，再开始逐渐的分拆为更为细粒度的技术（弓弦转木棍）</p><p>而这个细粒度的技术（弓弦转动木棍）往往不会和业务的主要目标（生火）发生直接的关系。不同的技术，通过树状结构，组合在一起，形成了一个完整的架构解决方案，共同完成业务的目标。这就是技术，业务和架构之间的关系。（分析火柴与打火机原理生成火源类似）</p><p>很多人把这个过程称为架构的进化，我更愿意把这个过程称为技术的进步所导致的新的架构分拆，因为这个过程内在的动力，更多的是来自技术对解决业务问题的解决。</p><p>我们回到开发者身上来看，写业务代码多一些，还是所谓的技术代码多一些，没有高下之分，只有个人取向和组织分工的不同。</p><h3 id="业务与为解决业务而衍生的业务"><a href="#业务与为解决业务而衍生的业务" class="headerlink" title="业务与为解决业务而衍生的业务"></a>业务与为解决业务而衍生的业务</h3><p>打开淘宝首页，随便浏览一个商品详情页面。</p><p>是不是有人会第一眼觉得商品封面，优惠券等相关信息的代码是没有什么技术含量的，因为那些是业务代码。</p><p>是不是觉得写商品页面的框架，分布式架构，分布式缓存，JMQ，Redis 或者说是 等技术才是有技术含量的。</p><p>但实际上，所谓的业务代码和技术代码，它们的区别，仅仅是和业务的距离远近不同而已：业务代码离业务更近，技术代码离业务稍远。它们最终都是指向业务实现的。</p><p>而且，可以考虑换一种视角来看业务，就会发现，其实每一层代码，都服务于它的上一层代码，上一层代码，就是它的业务！</p><p>![](data:;base64,&lt;?xml version=)” alt=”img” data-src=”<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/901f02baa8e24b23abc9cf09be674f41~tplv-k3u1fbpfcp-zoom-1.image&quot;">https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/901f02baa8e24b23abc9cf09be674f41~tplv-k3u1fbpfcp-zoom-1.image&quot;</a> data-width=”800” data-height=”600” /&gt;</p><p>比如详情页架构的第 2 层 “对外提供 API” 中的“商品介绍” ，它的服务对象，就是前端页面，要解决的业务，就是“响应前端页面的查询，提供商品介绍”</p><p>而第 2 层底部的前端数据集群（JIMDB），它的服务对象，就是商品介绍，要解决的业务，就是 “存储商品或代理商品介绍信息”。</p><p>简单说，每一层技术实现，都服务于上一层，都以上一层的需求为业务。 从这个角度讲，现实中的业务在被虚拟化的过程中，会在技术实现层面引发分层，产生中间性、对用户不可见的新业务。</p><p>但是为什么很多开发者又觉得所做的技术实现越接近现实业务越没技术含量呢？</p><p>这是因为，你越接近用户业务：</p><ol><li> 细节越多，繁琐度越高，越不容易做好，越容易因为一点小瑕疵而被否定，让人觉得自己的劳动没价值</li><li> 现实性越强，变化几率越高，越容易来回修改代码，越让人觉得自己的掌控感低下</li><li> 实现的代码可迁移性越差，劳动成果被复用的概率越低</li></ol><p>而当你远离用户业务时：</p><ol><li> 你用到的技术，多数都是被高度抽象过的、用来解决从用户业务衍生出的技术性业务的，它们比具体的用户业务稳定，它们的适用面更广，也更容易被迁移到其它的业务领域</li><li> 你的劳动成果因为具有抽象属性，被复用的概率会更高，你会更愿意打磨它，会更有成就感</li><li> 你受到压力，经过距离用户近的几层同事的传递，得到了衰减，没那么大</li><li> 你打交道的对象，多数时候是内部同事、是技术人群，更容易达成一致</li></ol><h3 id="对待业务的态度因你在团队的角色不同而不同"><a href="#对待业务的态度因你在团队的角色不同而不同" class="headerlink" title="对待业务的态度因你在团队的角色不同而不同"></a>对待业务的态度因你在团队的角色不同而不同</h3><p>你对业务的态度，会因你在团队中承担的角色不同而不同。这是由开发团队的组织结构和职责分工导致的。</p><p>下面是 “团队结构、能力与职责” 图：</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/7e6220e13c624ca3852ac1cad0528ec2~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在一个开发团队中，架构师这个角色，会负责业务拆分和软件架构的工作，并且领导团队来实现满足业务的软件。</p><ul><li>  注 1 ：有的研发团队里有业务架构师和软件架构师两种角色，业务拆分由业务架构师或业务分析师完成。</li><li>  注 2 ：软件架构师和业务架构师这两个角色也可能由没有架构师头衔的研发经理兼任。 架构师一定是要以业务为导向的，要搞懂业务的。所以，在架构师这个阶段，在团队管理者这个阶段，业务的重要性，往往是高于技术的，在他们的眼中，业务统领技术，技术是用来实现业务的。</li></ul><p>当团队完成业务架构和软件架构之后，就会选择不同的开发者来负责不同功能模块的实现。</p><p>负责不同功能模块实现的开发者，必须能够理解业务，并且要熟悉某个技术栈，能够进行模块设计和任务拆分，我称这样的开发者为 “熟练开发者”。</p><p>熟练开发者会承接由架构师分派的子业务，负责模块设计和拆分，把拆分后的小任务，交给普通程序员来完成。</p><p>当你是一个熟练开发者时，业务和技术几乎同等重要，因为：</p><p>你不理解业务，就很难将子业务模块映射到软件实现上，也很难做进一步的业务拆分。</p><p>你不具备完整的技术栈和相应的知识体系，就很难找到合适的技术来实现业务，也很难做软件模块的拆分。</p><p>熟练开发者完成了子业务和软件模块的拆分，会形成一系列的叶子型任务，并把它们分派给具备特定专项技术能力的普通程序员。</p><p>普通程序员要做的事情比较简单，就是接受别人分派的任务，实现特定的业务细节。</p><p>注意当你是一个普通程序员的时候，团队要求你具备一定的专项技术能力，能够完成任务即可，你的角色，就拿把螺丝刀拧螺丝，拧好螺丝就 Ok 。</p><p>这个时候，你内心是痛苦的，对不停地写业务代码是拒绝的，因为你要再找工作时，别的组织看重你的专项技术能力甚于业务能力（他们有人做业务拆分，你过去了能拧螺丝即可），而你在现有组织中，却因为深陷业务代码的编写而无法持续淬炼你的技能能力。</p><p>而开发中普通程序员是占比最大的，所以经常能看到文章或者有人提问纠结写业务代码这件事！</p><p>那么，该如何才能解脱呢？</p><h3 id="从所谓的业务代码中跳出"><a href="#从所谓的业务代码中跳出" class="headerlink" title="从所谓的业务代码中跳出"></a>从所谓的业务代码中跳出</h3><p>首先，很遗憾的告诉各位，这不是一蹴而就的，是一个技术深度和业务层次积累的过程，这需要时间。</p><p>作为一名技术人员，一方面要认识到技术只是用来解决特定问题的工具，所以一定要从问题出发，提出解决方案，而不能一味的追求技术的完美。</p><p>另一方面，也要认识到技术本身也可能成为一项业务，只要它足够通用，能够给其他人、组织提供有价值的解决方案。</p><p>但是，公司业务代码太多，总是 “沉迷业务无法自拔”，如何更好的提升自己，让自己发光发亮，能够提供更多有价值的东西。</p><p>也看到很多文章说的是，需要自己挤出时间出来进行学习，也就是在工作之余进行提升，自己认真的想一想，在业务上真的是无法提升自己吗？ 当我们轻松、漂亮的搞定业务后，能不能再从下面的方面入手进行思考呢。 例如</p><ul><li>  熟悉业务相关的更多业务和代码，不管业务是不是你负责的，不管代码是不是你写的；这样的好处太多，不列举，有兴趣的可以搜索</li><li>  这个业务有没有优化的点；</li><li>  重复代码太多，是不是可以考虑使用设计模式进行优化</li><li>  系统中业务是不是庞大，能不能进行解耦成几个服务或者模块</li><li>  开源框架中的一些功能正好能够用到，可不可以引进</li><li>  代码中性能有没有需要优化的地方</li><li>  在高并发情况下，有没有潜在 Bug</li><li>  能不能使用缓存，减少数据库压力，增加访问性能</li><li>  思考一下这个系统的架构，该系统使用了些什么技术，我还有哪些不知道的</li><li>  系统为什么使用这个技术，为什么使用这种架构</li><li>  下次类似的业务，我能不能抽出相关代码，进行复用，或者直接开发成服务，暴露出来</li><li>  … …</li></ul><p>很多普通程序员天天抱怨老写业务代码没长进，可手上的任务却总是敷衍了事，完成得凑凑合合，甚至还出现频现线上 Bug，那是很难摆重复简单业务任务的泥沼的。</p><h4 id="如何轻松、漂亮的搞定业务"><a href="#如何轻松、漂亮的搞定业务" class="headerlink" title="如何轻松、漂亮的搞定业务"></a>如何轻松、漂亮的搞定业务</h4><p>可以从这四方面进行入手：</p><ol><li> 在深度（研究领域中非常具有代表性的某几个框架的原理链）和广度（开源的框架这么多，至少要认识吧）两个方面提升技术能力（如果当下任务繁重，就利用业余时间练习）</li><li> 把自己的做的事情放在全局理解，提升业务理解能力</li><li> 培养好的工作习惯，比如计划、回顾、总结等</li><li> 做好汇报和展示，让领导知道你的能力</li></ol><p>当你慢慢做了上面 4 点之后，每次拿到任务，都能轻松又漂亮地搞定，超出领导的预期，还有未发挥完的火力，那团队就一定会给你复杂一点的任务。</p><p>如果你还能轻松、漂亮地搞定并且还有余力，那团队就会给你复杂度再高一些的任务。</p><p>往复循环，你就可以跳出最简单的业务代码编写，做越来越重要的事情，你的不可替代性也变得越来越强。</p>]]></content>
    
    
    <categories>
      
      <category>感悟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署到gitee</title>
    <link href="/blog/2020/12/27/hexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee/"/>
    <url>/blog/2020/12/27/hexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee/</url>
    
    <content type="html"><![CDATA[<p>因为服务器和域名，即将到期，所以准备关闭自建博客，将博客迁移到码云上，用免费的域名和存储。</p><p>首先选择哪个git平台，我尝试了使用github pages，但很难受，我只能在FAN QIANG状态下正常访问，而且速度偏慢，改了hosts也没啥用，而且文章数如果多了起来，更新网站的速度更是慢得不行，所以还是选择国内的一些git平台比较好，比如码云(gitee)，Coding等。</p><p>然后是博客系统的选择，我首先尝试的是Gridea，界面可以，挺好看的，但就是只支持github pages和coding pages，还有个人服务器搭建。github pages不用说，速度慢，我失败了无数次。coding我也试了很多次，实在是找不出问题所在(基本都是连不上的问题，没法解决)。如果想尝试的小伙伴可以去官网看看<a href="https://links.jianshu.com/go?to=https://gridea.dev/">https://gridea.dev/</a>，上面有搭建方法。</p><p>这里我使用的是hexo+gitee。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>首先要下载<a href="https://links.jianshu.com/go?to=http://nodejs.cn/">Node.js</a>，然后安装<a href="https://links.jianshu.com/go?to=https://git-scm.com/downloads">Git</a>，接着注册<a href="https://links.jianshu.com/go?to=https://gitee.com/">码云</a>，最后安装Hexo，Hexo安装命令行(cmd 或 gitbash):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>速度慢可以先改一下安装源:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">npm config <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/image-20201227123923753.png" alt="image-20201227123923753"></p><p>如果遇到上面的情况，就需要进行如下操作，一般在mac才会遇到这种。</p><p>1、vim ~/.bash_profile 编辑文件。</p><p>2、在最后追加下面三行代码。</p><p>alias ll=‘ls -alF’</p><p>alias la=‘ls -A’</p><p>alias l=‘ls -CF’</p><p>3、刷新配置文件，source ~/.bash_profile 。</p><p>后面如果还遇到，直接刷新配置文件即可，和maven在mac所遇到的问题一样，还未找到解决方案。</p><p>在想要存放博客的目录里右键打开控制台，然后输入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>接着生成静态页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo g<br></code></pre></td></tr></table></figure><p>然后启动本地服务，查看界面是否生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo s<br></code></pre></td></tr></table></figure><p>将<code>http://localhost:4000</code>复制到浏览器查看，默认主题为<code>landscape</code>。(在下面的每次配置中，对根目录的<code>_config.yml</code>修改后都要重新执行<code>hexo g</code>，同时可以不断刷新本地服务查看效果)</p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>这里我选的这一款主题，当然也可以去官网选择，配置方法都差不多。<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a>  这里我用的第二种部署方式。</p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>创建一个新的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;测试&#x27;新增文章&quot;</span><br></code></pre></td></tr></table></figure><p>编写就自己用本地编辑器，打开即可。</p><h1 id="配置码云"><a href="#配置码云" class="headerlink" title="配置码云"></a>配置码云</h1><p>打开根目录 _config.yml</p><p>1、修改语言，language: zh-CN。</p><p>2、修改部署到码云的访问地址，</p><p><img src="https://gitee.com/cuixiaoyan/uPic/raw/master/uPic/image-20201227125538853.png" alt="image-20201227125538853"></p><p>url: <a href="https://gitee.com/cuixiaoyan/blog/">https://gitee.com/cuixiaoyan/blog/</a><br>root: /blog/</p><p>3、码云仓库地址，</p><p>deploy:<br>  type: git<br>  repo: <a href="https://gitee.com/cuixiaoyan/blog.git">https://gitee.com/cuixiaoyan/blog.git</a><br>  branch: master</p><p>4、提交步骤。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">clean</span><br>hexo g<br>hexo d<br>然后刷新上方，gitee pages 才行，注意，仓库的地址，和文章的路径是不同的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
